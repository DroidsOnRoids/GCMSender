/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Alamofire.swift:
       |    1|// Alamofire.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: - URLStringConvertible
       |   26|
       |   27|/**
       |   28|    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
       |   29|    construct URL requests.
       |   30|*/
       |   31|public protocol URLStringConvertible {
       |   32|    /**
       |   33|        A URL that conforms to RFC 2396.
       |   34|
       |   35|        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
       |   36|
       |   37|        See https://tools.ietf.org/html/rfc2396
       |   38|        See https://tools.ietf.org/html/rfc1738
       |   39|        See https://tools.ietf.org/html/rfc1808
       |   40|    */
       |   41|    var URLString: String { get }
       |   42|}
       |   43|
       |   44|extension String: URLStringConvertible {
      1|   45|    public var URLString: String {
      1|   46|        return self
      1|   47|    }
       |   48|}
       |   49|
       |   50|extension NSURL: URLStringConvertible {
      0|   51|    public var URLString: String {
      0|   52|        return absoluteString
      0|   53|    }
       |   54|}
       |   55|
       |   56|extension NSURLComponents: URLStringConvertible {
      0|   57|    public var URLString: String {
      0|   58|        return URL!.URLString
      0|   59|    }
       |   60|}
       |   61|
       |   62|extension NSURLRequest: URLStringConvertible {
      0|   63|    public var URLString: String {
      0|   64|        return URL!.URLString
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - URLRequestConvertible
       |   69|
       |   70|/**
       |   71|    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
       |   72|*/
       |   73|public protocol URLRequestConvertible {
       |   74|    /// The URL request.
       |   75|    var URLRequest: NSMutableURLRequest { get }
       |   76|}
       |   77|
       |   78|extension NSURLRequest: URLRequestConvertible {
      2|   79|    public var URLRequest: NSMutableURLRequest {
      2|   80|        return self.mutableCopy() as! NSMutableURLRequest
      2|   81|    }
       |   82|}
       |   83|
       |   84|// MARK: - Convenience
       |   85|
       |   86|func URLRequest(
       |   87|    method: Method,
       |   88|    _ URLString: URLStringConvertible,
       |   89|    headers: [String: String]? = nil)
       |   90|    -> NSMutableURLRequest
      1|   91|{
      1|   92|    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
      1|   93|    mutableURLRequest.HTTPMethod = method.rawValue
      1|   94|
      1|   95|    if let headers = headers {
      2|   96|        for (headerField, headerValue) in headers {
      2|   97|            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
      2|   98|        }
      1|   99|    }
      1|  100|
      1|  101|    return mutableURLRequest
      1|  102|}
       |  103|
       |  104|// MARK: - Request Methods
       |  105|
       |  106|/**
       |  107|    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
       |  108|    parameter encoding.
       |  109|
       |  110|    - parameter method:     The HTTP method.
       |  111|    - parameter URLString:  The URL string.
       |  112|    - parameter parameters: The parameters. `nil` by default.
       |  113|    - parameter encoding:   The parameter encoding. `.URL` by default.
       |  114|    - parameter headers:    The HTTP headers. `nil` by default.
       |  115|
       |  116|    - returns: The created request.
       |  117|*/
       |  118|public func request(
       |  119|    method: Method,
       |  120|    _ URLString: URLStringConvertible,
       |  121|    parameters: [String: AnyObject]? = nil,
       |  122|    encoding: ParameterEncoding = .URL,
       |  123|    headers: [String: String]? = nil)
       |  124|    -> Request
      1|  125|{
      1|  126|    return Manager.sharedInstance.request(
      1|  127|        method,
      1|  128|        URLString,
      1|  129|        parameters: parameters,
      1|  130|        encoding: encoding,
      1|  131|        headers: headers
      1|  132|    )
      1|  133|}
       |  134|
       |  135|/**
       |  136|    Creates a request using the shared manager instance for the specified URL request.
       |  137|
       |  138|    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  139|
       |  140|    - parameter URLRequest: The URL request
       |  141|
       |  142|    - returns: The created request.
       |  143|*/
      0|  144|public func request(URLRequest: URLRequestConvertible) -> Request {
      0|  145|    return Manager.sharedInstance.request(URLRequest.URLRequest)
      0|  146|}
       |  147|
       |  148|// MARK: - Upload Methods
       |  149|
       |  150|// MARK: File
       |  151|
       |  152|/**
       |  153|    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
       |  154|
       |  155|    - parameter method:    The HTTP method.
       |  156|    - parameter URLString: The URL string.
       |  157|    - parameter headers:   The HTTP headers. `nil` by default.
       |  158|    - parameter file:      The file to upload.
       |  159|
       |  160|    - returns: The created upload request.
       |  161|*/
       |  162|public func upload(
       |  163|    method: Method,
       |  164|    _ URLString: URLStringConvertible,
       |  165|    headers: [String: String]? = nil,
       |  166|    file: NSURL)
       |  167|    -> Request
      0|  168|{
      0|  169|    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
      0|  170|}
       |  171|
       |  172|/**
       |  173|    Creates an upload request using the shared manager instance for the specified URL request and file.
       |  174|
       |  175|    - parameter URLRequest: The URL request.
       |  176|    - parameter file:       The file to upload.
       |  177|
       |  178|    - returns: The created upload request.
       |  179|*/
      0|  180|public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|  181|    return Manager.sharedInstance.upload(URLRequest, file: file)
      0|  182|}
       |  183|
       |  184|// MARK: Data
       |  185|
       |  186|/**
       |  187|    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
       |  188|
       |  189|    - parameter method:    The HTTP method.
       |  190|    - parameter URLString: The URL string.
       |  191|    - parameter headers:   The HTTP headers. `nil` by default.
       |  192|    - parameter data:      The data to upload.
       |  193|
       |  194|    - returns: The created upload request.
       |  195|*/
       |  196|public func upload(
       |  197|    method: Method,
       |  198|    _ URLString: URLStringConvertible,
       |  199|    headers: [String: String]? = nil,
       |  200|    data: NSData)
       |  201|    -> Request
      0|  202|{
      0|  203|    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
      0|  204|}
       |  205|
       |  206|/**
       |  207|    Creates an upload request using the shared manager instance for the specified URL request and data.
       |  208|
       |  209|    - parameter URLRequest: The URL request.
       |  210|    - parameter data:       The data to upload.
       |  211|
       |  212|    - returns: The created upload request.
       |  213|*/
      0|  214|public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  215|    return Manager.sharedInstance.upload(URLRequest, data: data)
      0|  216|}
       |  217|
       |  218|// MARK: Stream
       |  219|
       |  220|/**
       |  221|    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
       |  222|
       |  223|    - parameter method:    The HTTP method.
       |  224|    - parameter URLString: The URL string.
       |  225|    - parameter headers:   The HTTP headers. `nil` by default.
       |  226|    - parameter stream:    The stream to upload.
       |  227|
       |  228|    - returns: The created upload request.
       |  229|*/
       |  230|public func upload(
       |  231|    method: Method,
       |  232|    _ URLString: URLStringConvertible,
       |  233|    headers: [String: String]? = nil,
       |  234|    stream: NSInputStream)
       |  235|    -> Request
      0|  236|{
      0|  237|    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
      0|  238|}
       |  239|
       |  240|/**
       |  241|    Creates an upload request using the shared manager instance for the specified URL request and stream.
       |  242|
       |  243|    - parameter URLRequest: The URL request.
       |  244|    - parameter stream:     The stream to upload.
       |  245|
       |  246|    - returns: The created upload request.
       |  247|*/
      0|  248|public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  249|    return Manager.sharedInstance.upload(URLRequest, stream: stream)
      0|  250|}
       |  251|
       |  252|// MARK: MultipartFormData
       |  253|
       |  254|/**
       |  255|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  256|
       |  257|    - parameter method:                  The HTTP method.
       |  258|    - parameter URLString:               The URL string.
       |  259|    - parameter headers:                 The HTTP headers. `nil` by default.
       |  260|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  261|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  262|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  263|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  264|*/
       |  265|public func upload(
       |  266|    method: Method,
       |  267|    _ URLString: URLStringConvertible,
       |  268|    headers: [String: String]? = nil,
       |  269|    multipartFormData: MultipartFormData -> Void,
       |  270|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  271|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  272|{
      0|  273|    return Manager.sharedInstance.upload(
      0|  274|        method,
      0|  275|        URLString,
      0|  276|        headers: headers,
      0|  277|        multipartFormData: multipartFormData,
      0|  278|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  279|        encodingCompletion: encodingCompletion
      0|  280|    )
      0|  281|}
       |  282|
       |  283|/**
       |  284|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  285|
       |  286|    - parameter URLRequest:              The URL request.
       |  287|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  288|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  289|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  290|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  291|*/
       |  292|public func upload(
       |  293|    URLRequest: URLRequestConvertible,
       |  294|    multipartFormData: MultipartFormData -> Void,
       |  295|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  296|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  297|{
      0|  298|    return Manager.sharedInstance.upload(
      0|  299|        URLRequest,
      0|  300|        multipartFormData: multipartFormData,
      0|  301|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  302|        encodingCompletion: encodingCompletion
      0|  303|    )
      0|  304|}
       |  305|
       |  306|// MARK: - Download Methods
       |  307|
       |  308|// MARK: URL Request
       |  309|
       |  310|/**
       |  311|    Creates a download request using the shared manager instance for the specified method and URL string.
       |  312|
       |  313|    - parameter method:      The HTTP method.
       |  314|    - parameter URLString:   The URL string.
       |  315|    - parameter parameters:  The parameters. `nil` by default.
       |  316|    - parameter encoding:    The parameter encoding. `.URL` by default.
       |  317|    - parameter headers:     The HTTP headers. `nil` by default.
       |  318|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  319|
       |  320|    - returns: The created download request.
       |  321|*/
       |  322|public func download(
       |  323|    method: Method,
       |  324|    _ URLString: URLStringConvertible,
       |  325|    parameters: [String: AnyObject]? = nil,
       |  326|    encoding: ParameterEncoding = .URL,
       |  327|    headers: [String: String]? = nil,
       |  328|    destination: Request.DownloadFileDestination)
       |  329|    -> Request
      0|  330|{
      0|  331|    return Manager.sharedInstance.download(
      0|  332|        method,
      0|  333|        URLString,
      0|  334|        parameters: parameters,
      0|  335|        encoding: encoding,
      0|  336|        headers: headers,
      0|  337|        destination: destination
      0|  338|    )
      0|  339|}
       |  340|
       |  341|/**
       |  342|    Creates a download request using the shared manager instance for the specified URL request.
       |  343|
       |  344|    - parameter URLRequest:  The URL request.
       |  345|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  346|
       |  347|    - returns: The created download request.
       |  348|*/
      0|  349|public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  350|    return Manager.sharedInstance.download(URLRequest, destination: destination)
      0|  351|}
       |  352|
       |  353|// MARK: Resume Data
       |  354|
       |  355|/**
       |  356|    Creates a request using the shared manager instance for downloading from the resume data produced from a 
       |  357|    previous request cancellation.
       |  358|
       |  359|    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
       |  360|                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
       |  361|                             information.
       |  362|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  363|
       |  364|    - returns: The created download request.
       |  365|*/
      0|  366|public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  367|    return Manager.sharedInstance.download(data, destination: destination)
      0|  368|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Download.swift:
       |    1|// Download.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Downloadable {
       |   27|        case Request(NSURLRequest)
       |   28|        case ResumeData(NSData)
       |   29|    }
       |   30|
      0|   31|    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
      0|   32|        var downloadTask: NSURLSessionDownloadTask!
      0|   33|
      0|   34|        switch downloadable {
      0|   35|        case .Request(let request):
      0|   36|            dispatch_sync(queue) {
      0|   37|                downloadTask = self.session.downloadTaskWithRequest(request)
      0|   38|            }
      0|   39|        case .ResumeData(let resumeData):
      0|   40|            dispatch_sync(queue) {
      0|   41|                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
      0|   42|            }
      0|   43|        }
      0|   44|
      0|   45|        let request = Request(session: session, task: downloadTask)
      0|   46|
      0|   47|        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
      0|   48|            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
      0|   49|                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
      0|   50|            }
      0|   51|        }
      0|   52|
      0|   53|        delegate[request.delegate.task] = request.delegate
      0|   54|
      0|   55|        if startRequestsImmediately {
      0|   56|            request.resume()
      0|   57|        }
      0|   58|
      0|   59|        return request
      0|   60|    }
       |   61|
       |   62|    // MARK: Request
       |   63|
       |   64|    /**
       |   65|        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
       |   66|        and destination.
       |   67|
       |   68|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   69|
       |   70|        - parameter method:      The HTTP method.
       |   71|        - parameter URLString:   The URL string.
       |   72|        - parameter parameters:  The parameters. `nil` by default.
       |   73|        - parameter encoding:    The parameter encoding. `.URL` by default.
       |   74|        - parameter headers:     The HTTP headers. `nil` by default.
       |   75|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |   76|
       |   77|        - returns: The created download request.
       |   78|    */
       |   79|    public func download(
       |   80|        method: Method,
       |   81|        _ URLString: URLStringConvertible,
       |   82|        parameters: [String: AnyObject]? = nil,
       |   83|        encoding: ParameterEncoding = .URL,
       |   84|        headers: [String: String]? = nil,
       |   85|        destination: Request.DownloadFileDestination)
       |   86|        -> Request
      0|   87|    {
      0|   88|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|   89|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      0|   90|
      0|   91|        return download(encodedURLRequest, destination: destination)
      0|   92|    }
       |   93|
       |   94|    /**
       |   95|        Creates a request for downloading from the specified URL request.
       |   96|
       |   97|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   98|
       |   99|        - parameter URLRequest:  The URL request
       |  100|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  101|
       |  102|        - returns: The created download request.
       |  103|    */
      0|  104|    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  105|        return download(.Request(URLRequest.URLRequest), destination: destination)
      0|  106|    }
       |  107|
       |  108|    // MARK: Resume Data
       |  109|
       |  110|    /**
       |  111|        Creates a request for downloading from the resume data produced from a previous request cancellation.
       |  112|
       |  113|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  114|
       |  115|        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
       |  116|                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
       |  117|                                 additional information.
       |  118|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  119|
       |  120|        - returns: The created download request.
       |  121|    */
      0|  122|    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  123|        return download(.ResumeData(resumeData), destination: destination)
      0|  124|    }
       |  125|}
       |  126|
       |  127|// MARK: -
       |  128|
       |  129|extension Request {
       |  130|    /**
       |  131|        A closure executed once a request has successfully completed in order to determine where to move the temporary 
       |  132|        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
       |  133|        response, and returns a single argument: the file URL where the temporary file should be moved.
       |  134|    */
       |  135|    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
       |  136|
       |  137|    /**
       |  138|        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
       |  139|        file URL in the first available directory with the specified search path directory and search path domain mask.
       |  140|
       |  141|        - parameter directory: The search path directory. `.DocumentDirectory` by default.
       |  142|        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
       |  143|
       |  144|        - returns: A download file destination closure.
       |  145|    */
       |  146|    public class func suggestedDownloadDestination(
       |  147|        directory directory: NSSearchPathDirectory = .DocumentDirectory,
       |  148|        domain: NSSearchPathDomainMask = .UserDomainMask)
       |  149|        -> DownloadFileDestination
      0|  150|    {
      0|  151|        return { temporaryURL, response -> NSURL in
      0|  152|            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
      0|  153|
      0|  154|            if !directoryURLs.isEmpty {
      0|  155|                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
      0|  156|            }
      0|  157|
      0|  158|            return temporaryURL
      0|  159|        }
      0|  160|    }
       |  161|
       |  162|    /// The resume data of the underlying download task if available after a failure.
      0|  163|    public var resumeData: NSData? {
      0|  164|        var data: NSData?
      0|  165|
      0|  166|        if let delegate = delegate as? DownloadTaskDelegate {
      0|  167|            data = delegate.resumeData
      0|  168|        }
      0|  169|
      0|  170|        return data
      0|  171|    }
       |  172|
       |  173|    // MARK: - DownloadTaskDelegate
       |  174|
       |  175|    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
      0|  176|        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
       |  177|        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
       |  178|
       |  179|        var resumeData: NSData?
      0|  180|        override var data: NSData? { return resumeData }
       |  181|
       |  182|        // MARK: - NSURLSessionDownloadDelegate
       |  183|
       |  184|        // MARK: Override Closures
       |  185|
       |  186|        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
       |  187|        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  188|        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  189|
       |  190|        // MARK: Delegate Methods
       |  191|
       |  192|        func URLSession(
       |  193|            session: NSURLSession,
       |  194|            downloadTask: NSURLSessionDownloadTask,
       |  195|            didFinishDownloadingToURL location: NSURL)
      0|  196|        {
      0|  197|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  198|                do {
      0|  199|                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  200|                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
      0|  201|                } catch {
      0|  202|                    self.error = error as NSError
      0|  203|                }
      0|  204|            }
      0|  205|        }
       |  206|
       |  207|        func URLSession(
       |  208|            session: NSURLSession,
       |  209|            downloadTask: NSURLSessionDownloadTask,
       |  210|            didWriteData bytesWritten: Int64,
       |  211|            totalBytesWritten: Int64,
       |  212|            totalBytesExpectedToWrite: Int64)
      0|  213|        {
      0|  214|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  215|                downloadTaskDidWriteData(
      0|  216|                    session,
      0|  217|                    downloadTask,
      0|  218|                    bytesWritten,
      0|  219|                    totalBytesWritten, 
      0|  220|                    totalBytesExpectedToWrite
      0|  221|                )
      0|  222|            } else {
      0|  223|                progress.totalUnitCount = totalBytesExpectedToWrite
      0|  224|                progress.completedUnitCount = totalBytesWritten
      0|  225|
      0|  226|                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  227|            }
      0|  228|        }
       |  229|
       |  230|        func URLSession(
       |  231|            session: NSURLSession,
       |  232|            downloadTask: NSURLSessionDownloadTask,
       |  233|            didResumeAtOffset fileOffset: Int64,
       |  234|            expectedTotalBytes: Int64)
      0|  235|        {
      0|  236|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  237|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  238|            } else {
      0|  239|                progress.totalUnitCount = expectedTotalBytes
      0|  240|                progress.completedUnitCount = fileOffset
      0|  241|            }
      0|  242|        }
       |  243|    }
       |  244|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Error.swift:
       |    1|// Error.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
       |   26|public struct Error {
       |   27|    /// The domain used for creating all Alamofire errors.
       |   28|    public static let Domain = "com.alamofire.error"
       |   29|
       |   30|    /// The custom error codes generated by Alamofire.
       |   31|    public enum Code: Int {
       |   32|        case InputStreamReadFailed           = -6000
       |   33|        case OutputStreamWriteFailed         = -6001
       |   34|        case ContentTypeValidationFailed     = -6002
       |   35|        case StatusCodeValidationFailed      = -6003
       |   36|        case DataSerializationFailed         = -6004
       |   37|        case StringSerializationFailed       = -6005
       |   38|        case JSONSerializationFailed         = -6006
       |   39|        case PropertyListSerializationFailed = -6007
       |   40|    }
       |   41|
       |   42|    /**
       |   43|        Creates an `NSError` with the given error code and failure reason.
       |   44|
       |   45|        - parameter code:          The error code.
       |   46|        - parameter failureReason: The failure reason.
       |   47|
       |   48|        - returns: An `NSError` with the given error code and failure reason.
       |   49|    */
      0|   50|    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
      0|   51|        return errorWithCode(code.rawValue, failureReason: failureReason)
      0|   52|    }
       |   53|
       |   54|    /**
       |   55|        Creates an `NSError` with the given error code and failure reason.
       |   56|
       |   57|        - parameter code:          The error code.
       |   58|        - parameter failureReason: The failure reason.
       |   59|
       |   60|        - returns: An `NSError` with the given error code and failure reason.
       |   61|    */
      0|   62|    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
      0|   63|        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
      0|   64|        return NSError(domain: Domain, code: code, userInfo: userInfo)
      0|   65|    }
       |   66|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Manager.swift:
       |    1|// Manager.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
       |   27|*/
       |   28|public class Manager {
       |   29|
       |   30|    // MARK: - Properties
       |   31|
       |   32|    /**
       |   33|        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
       |   34|        for any ad hoc requests.
       |   35|    */
       |   36|    public static let sharedInstance: Manager = {
       |   37|        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
       |   38|        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
       |   39|
       |   40|        return Manager(configuration: configuration)
       |   41|    }()
       |   42|
       |   43|    /**
       |   44|        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
       |   45|    */
       |   46|    public static let defaultHTTPHeaders: [String: String] = {
       |   47|        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
       |   48|        let acceptEncoding: String = "gzip;q=1.0,compress;q=0.5"
       |   49|
       |   50|        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
       |   51|        let acceptLanguage: String = {
       |   52|            var components: [String] = []
       |   53|            for (index, languageCode) in (NSLocale.preferredLanguages() as [String]).enumerate() {
       |   54|                let q = 1.0 - (Double(index) * 0.1)
       |   55|                components.append("\(languageCode);q=\(q)")
       |   56|                if q <= 0.5 {
       |   57|                    break
       |   58|                }
       |   59|            }
       |   60|
       |   61|            return components.joinWithSeparator(",")
       |   62|        }()
       |   63|
       |   64|        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
       |   65|        let userAgent: String = {
       |   66|            if let info = NSBundle.mainBundle().infoDictionary {
       |   67|                let executable: AnyObject = info[kCFBundleExecutableKey as String] ?? "Unknown"
       |   68|                let bundle: AnyObject = info[kCFBundleIdentifierKey as String] ?? "Unknown"
       |   69|                let version: AnyObject = info[kCFBundleVersionKey as String] ?? "Unknown"
       |   70|                let os: AnyObject = NSProcessInfo.processInfo().operatingSystemVersionString ?? "Unknown"
       |   71|
       |   72|                var mutableUserAgent = NSMutableString(string: "\(executable)/\(bundle) (\(version); OS \(os))") as CFMutableString
       |   73|                let transform = NSString(string: "Any-Latin; Latin-ASCII; [:^ASCII:] Remove") as CFString
       |   74|
       |   75|                if CFStringTransform(mutableUserAgent, UnsafeMutablePointer<CFRange>(nil), transform, false) {
       |   76|                    return mutableUserAgent as String
       |   77|                }
       |   78|            }
       |   79|
       |   80|            return "Alamofire"
       |   81|        }()
       |   82|
       |   83|        return [
       |   84|            "Accept-Encoding": acceptEncoding,
       |   85|            "Accept-Language": acceptLanguage,
       |   86|            "User-Agent": userAgent
       |   87|        ]
       |   88|    }()
       |   89|
       |   90|    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
       |   91|
       |   92|    /// The underlying session.
       |   93|    public let session: NSURLSession
       |   94|
       |   95|    /// The session delegate handling all the task and session delegate callbacks.
       |   96|    public let delegate: SessionDelegate
       |   97|
       |   98|    /// Whether to start requests immediately after being constructed. `true` by default.
       |   99|    public var startRequestsImmediately: Bool = true
       |  100|
       |  101|    /**
       |  102|        The background completion handler closure provided by the UIApplicationDelegate 
       |  103|        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
       |  104|        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
       |  105|        will automatically call the handler.
       |  106|    
       |  107|        If you need to handle your own events before the handler is called, then you need to override the 
       |  108|        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
       |  109|    
       |  110|        `nil` by default.
       |  111|    */
       |  112|    public var backgroundCompletionHandler: (() -> Void)?
       |  113|
       |  114|    // MARK: - Lifecycle
       |  115|
       |  116|    /**
       |  117|        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
       |  118|
       |  119|        - parameter configuration:            The configuration used to construct the managed session. 
       |  120|                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
       |  121|        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
       |  122|                                              default.
       |  123|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
       |  124|                                              challenges. `nil` by default.
       |  125|
       |  126|        - returns: The new `Manager` instance.
       |  127|    */
       |  128|    public init(
       |  129|        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
       |  130|        delegate: SessionDelegate = SessionDelegate(),
       |  131|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      1|  132|    {
      1|  133|        self.delegate = delegate
      1|  134|        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
      1|  135|
      1|  136|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      1|  137|    }
       |  138|
       |  139|    /**
       |  140|        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
       |  141|
       |  142|        - parameter session:                  The URL session.
       |  143|        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
       |  144|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
       |  145|                                              challenges. `nil` by default.
       |  146|
       |  147|        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
       |  148|    */
       |  149|    public init?(
       |  150|        session: NSURLSession,
       |  151|        delegate: SessionDelegate,
       |  152|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      0|  153|    {
      0|  154|        self.delegate = delegate
      0|  155|        self.session = session
      0|  156|
      0|  157|        guard delegate === session.delegate else { return nil }
      0|  158|
      0|  159|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      0|  160|    }
       |  161|
      1|  162|    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
      1|  163|        session.serverTrustPolicyManager = serverTrustPolicyManager
      1|  164|
      0|  165|        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
      0|  166|            guard let strongSelf = self else { return }
      0|  167|            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
      0|  168|        }
      1|  169|    }
       |  170|
      0|  171|    deinit {
      0|  172|        session.invalidateAndCancel()
      0|  173|    }
       |  174|
       |  175|    // MARK: - Request
       |  176|
       |  177|    /**
       |  178|        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
       |  179|
       |  180|        - parameter method:     The HTTP method.
       |  181|        - parameter URLString:  The URL string.
       |  182|        - parameter parameters: The parameters. `nil` by default.
       |  183|        - parameter encoding:   The parameter encoding. `.URL` by default.
       |  184|        - parameter headers:    The HTTP headers. `nil` by default.
       |  185|
       |  186|        - returns: The created request.
       |  187|    */
       |  188|    public func request(
       |  189|        method: Method,
       |  190|        _ URLString: URLStringConvertible,
       |  191|        parameters: [String: AnyObject]? = nil,
       |  192|        encoding: ParameterEncoding = .URL,
       |  193|        headers: [String: String]? = nil)
       |  194|        -> Request
      1|  195|    {
      1|  196|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      1|  197|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      1|  198|        return request(encodedURLRequest)
      1|  199|    }
       |  200|
       |  201|    /**
       |  202|        Creates a request for the specified URL request.
       |  203|
       |  204|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  205|
       |  206|        - parameter URLRequest: The URL request
       |  207|
       |  208|        - returns: The created request.
       |  209|    */
      1|  210|    public func request(URLRequest: URLRequestConvertible) -> Request {
      1|  211|        var dataTask: NSURLSessionDataTask!
      1|  212|        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
      1|  213|
      1|  214|        let request = Request(session: session, task: dataTask)
      1|  215|        delegate[request.delegate.task] = request.delegate
      1|  216|
      1|  217|        if startRequestsImmediately {
      1|  218|            request.resume()
      1|  219|        }
      1|  220|
      1|  221|        return request
      1|  222|    }
      1|  223|
      1|  224|    // MARK: - SessionDelegate
      1|  225|
       |  226|    /**
       |  227|        Responsible for handling all delegate callbacks for the underlying session.
       |  228|    */
       |  229|    public final class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
       |  230|        private var subdelegates: [Int: Request.TaskDelegate] = [:]
       |  231|        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
       |  232|
       |  233|        subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
       |  234|            get {
       |  235|                var subdelegate: Request.TaskDelegate?
       |  236|                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
      4|  237|
      4|  238|                return subdelegate
      4|  239|            }
      4|  240|
      4|  241|            set {
      4|  242|                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
      4|  243|            }
      4|  244|        }
       |  245|
      2|  246|        /**
      2|  247|            Initializes the `SessionDelegate` instance.
      2|  248|
      2|  249|            - returns: The new `SessionDelegate` instance.
      2|  250|        */
       |  251|        public override init() {
       |  252|            super.init()
       |  253|        }
       |  254|
       |  255|        // MARK: - NSURLSessionDelegate
       |  256|
       |  257|        // MARK: Override Closures
      1|  258|
      1|  259|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
      1|  260|        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
       |  261|
       |  262|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
       |  263|        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  264|
       |  265|        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
       |  266|        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
       |  267|
       |  268|        // MARK: Delegate Methods
       |  269|
       |  270|        /**
       |  271|            Tells the delegate that the session has been invalidated.
       |  272|
       |  273|            - parameter session: The session object that was invalidated.
       |  274|            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
       |  275|        */
       |  276|        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
       |  277|            sessionDidBecomeInvalidWithError?(session, error)
       |  278|        }
       |  279|
       |  280|        /**
       |  281|            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
       |  282|
      0|  283|            - parameter session:           The session containing the task that requested authentication.
      0|  284|            - parameter challenge:         An object that contains the request for authentication.
      0|  285|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  286|        */
       |  287|        public func URLSession(
       |  288|            session: NSURLSession,
       |  289|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  290|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
       |  291|        {
       |  292|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
       |  293|            var credential: NSURLCredential?
       |  294|
       |  295|            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
       |  296|                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
       |  297|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      0|  298|                let host = challenge.protectionSpace.host
      0|  299|
      0|  300|                if let
      0|  301|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      0|  302|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  303|                {
      0|  304|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  305|                        disposition = .UseCredential
      0|  306|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  307|                    } else {
      0|  308|                        disposition = .CancelAuthenticationChallenge
      0|  309|                    }
      0|  310|                }
      0|  311|            }
      0|  312|
      0|  313|            completionHandler(disposition, credential)
      0|  314|        }
      0|  315|
      0|  316|        /**
      0|  317|            Tells the delegate that all messages enqueued for a session have been delivered.
      0|  318|
      0|  319|            - parameter session: The session that no longer has any outstanding requests.
      0|  320|        */
      0|  321|        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
       |  322|            sessionDidFinishEventsForBackgroundURLSession?(session)
       |  323|        }
       |  324|
       |  325|        // MARK: - NSURLSessionTaskDelegate
       |  326|
       |  327|        // MARK: Override Closures
      0|  328|
      0|  329|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
      0|  330|        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  331|
       |  332|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
       |  333|        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  334|
       |  335|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
       |  336|        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream!)?
       |  337|
       |  338|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
       |  339|        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  340|
       |  341|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
       |  342|        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  343|
       |  344|        // MARK: Delegate Methods
       |  345|
       |  346|        /**
       |  347|            Tells the delegate that the remote server requested an HTTP redirect.
       |  348|
       |  349|            - parameter session:           The session containing the task whose request resulted in a redirect.
       |  350|            - parameter task:              The task whose request resulted in a redirect.
       |  351|            - parameter response:          An object containing the server’s response to the original request.
       |  352|            - parameter request:           A URL request object filled out with the new location.
       |  353|            - parameter completionHandler: A closure that your handler should call with either the value of the request 
       |  354|                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
       |  355|                                           return the body of the redirect response.
       |  356|        */
       |  357|        public func URLSession(
       |  358|            session: NSURLSession,
       |  359|            task: NSURLSessionTask,
       |  360|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  361|            newRequest request: NSURLRequest,
       |  362|            completionHandler: ((NSURLRequest?) -> Void))
       |  363|        {
       |  364|            var redirectRequest: NSURLRequest? = request
       |  365|
       |  366|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
       |  367|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
       |  368|            }
       |  369|
      0|  370|            completionHandler(redirectRequest)
      0|  371|        }
      0|  372|
      0|  373|        /**
      0|  374|            Requests credentials from the delegate in response to an authentication request from the remote server.
      0|  375|
      0|  376|            - parameter session:           The session containing the task whose request requires authentication.
      0|  377|            - parameter task:              The task whose request requires authentication.
      0|  378|            - parameter challenge:         An object that contains the request for authentication.
       |  379|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  380|        */
       |  381|        public func URLSession(
       |  382|            session: NSURLSession,
       |  383|            task: NSURLSessionTask,
       |  384|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  385|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
       |  386|        {
       |  387|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
       |  388|                completionHandler(taskDidReceiveChallenge(session, task, challenge))
       |  389|            } else if let delegate = self[task] {
       |  390|                delegate.URLSession(
       |  391|                    session,
       |  392|                    task: task,
      1|  393|                    didReceiveChallenge: challenge,
      0|  394|                    completionHandler: completionHandler
      0|  395|                )
      1|  396|            } else {
      1|  397|                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
      1|  398|            }
      1|  399|        }
      1|  400|
      1|  401|        /**
      1|  402|            Tells the delegate when a task requires a new request body stream to send to the remote server.
      0|  403|
      0|  404|            - parameter session:           The session containing the task that needs a new body stream.
      0|  405|            - parameter task:              The task that needs a new body stream.
      1|  406|            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
       |  407|        */
       |  408|        public func URLSession(
       |  409|            session: NSURLSession,
       |  410|            task: NSURLSessionTask,
       |  411|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
       |  412|        {
       |  413|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
       |  414|                completionHandler(taskNeedNewBodyStream(session, task))
       |  415|            } else if let delegate = self[task] {
       |  416|                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
       |  417|            }
       |  418|        }
      0|  419|
      0|  420|        /**
      0|  421|            Periodically informs the delegate of the progress of sending body content to the server.
      0|  422|
      0|  423|            - parameter session:                  The session containing the data task.
      0|  424|            - parameter task:                     The data task.
      0|  425|            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
       |  426|            - parameter totalBytesSent:           The total number of bytes sent so far.
       |  427|            - parameter totalBytesExpectedToSend: The expected length of the body data.
       |  428|        */
       |  429|        public func URLSession(
       |  430|            session: NSURLSession,
       |  431|            task: NSURLSessionTask,
       |  432|            didSendBodyData bytesSent: Int64,
       |  433|            totalBytesSent: Int64,
       |  434|            totalBytesExpectedToSend: Int64)
       |  435|        {
       |  436|            if let taskDidSendBodyData = taskDidSendBodyData {
       |  437|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
       |  438|            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
       |  439|                delegate.URLSession(
       |  440|                    session,
       |  441|                    task: task,
      1|  442|                    didSendBodyData: bytesSent,
      0|  443|                    totalBytesSent: totalBytesSent,
      0|  444|                    totalBytesExpectedToSend: totalBytesExpectedToSend
      0|  445|                )
      0|  446|            }
      0|  447|        }
      0|  448|
      0|  449|        /**
      0|  450|            Tells the delegate that the task finished transferring data.
      0|  451|
      0|  452|            - parameter session: The session containing the task whose request finished transferring data.
      0|  453|            - parameter task:    The task whose request finished transferring data.
      1|  454|            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
       |  455|        */
       |  456|        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
       |  457|            if let taskDidComplete = taskDidComplete {
       |  458|                taskDidComplete(session, task, error)
       |  459|            } else if let delegate = self[task] {
       |  460|                delegate.URLSession(session, task: task, didCompleteWithError: error)
       |  461|            }
       |  462|
      1|  463|            self[task] = nil
      0|  464|        }
      0|  465|
      1|  466|        // MARK: - NSURLSessionDataDelegate
      1|  467|
      1|  468|        // MARK: Override Closures
      1|  469|
      1|  470|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
      1|  471|        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  472|
       |  473|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
       |  474|        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  475|
       |  476|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
       |  477|        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  478|
       |  479|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
       |  480|        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse!)?
       |  481|
       |  482|        // MARK: Delegate Methods
       |  483|
       |  484|        /**
       |  485|            Tells the delegate that the data task received the initial reply (headers) from the server.
       |  486|
       |  487|            - parameter session:           The session containing the data task that received an initial reply.
       |  488|            - parameter dataTask:          The data task that received an initial reply.
       |  489|            - parameter response:          A URL response object populated with headers.
       |  490|            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
       |  491|                                           constant to indicate whether the transfer should continue as a data task or 
       |  492|                                           should become a download task.
       |  493|        */
       |  494|        public func URLSession(
       |  495|            session: NSURLSession,
       |  496|            dataTask: NSURLSessionDataTask,
       |  497|            didReceiveResponse response: NSURLResponse,
       |  498|            completionHandler: ((NSURLSessionResponseDisposition) -> Void))
       |  499|        {
       |  500|            var disposition: NSURLSessionResponseDisposition = .Allow
       |  501|
       |  502|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
       |  503|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
       |  504|            }
       |  505|
      0|  506|            completionHandler(disposition)
      0|  507|        }
      0|  508|
      0|  509|        /**
      0|  510|            Tells the delegate that the data task was changed to a download task.
      0|  511|
      0|  512|            - parameter session:      The session containing the task that was replaced by a download task.
      0|  513|            - parameter dataTask:     The data task that was replaced by a download task.
      0|  514|            - parameter downloadTask: The new download task that replaced the data task.
       |  515|        */
       |  516|        public func URLSession(
       |  517|            session: NSURLSession,
       |  518|            dataTask: NSURLSessionDataTask,
       |  519|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
       |  520|        {
       |  521|            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
       |  522|                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
       |  523|            } else {
       |  524|                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
       |  525|                self[downloadTask] = downloadDelegate
       |  526|            }
      0|  527|        }
      0|  528|
      0|  529|        /**
      0|  530|            Tells the delegate that the data task has received some of the expected data.
      0|  531|
      0|  532|            - parameter session:  The session containing the data task that provided data.
      0|  533|            - parameter dataTask: The data task that provided data.
      0|  534|            - parameter data:     A data object containing the transferred data.
       |  535|        */
       |  536|        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
       |  537|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
       |  538|                dataTaskDidReceiveData(session, dataTask, data)
       |  539|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
       |  540|                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
       |  541|            }
       |  542|        }
      1|  543|
      0|  544|        /**
      0|  545|            Asks the delegate whether the data (or upload) task should store the response in the cache.
      1|  546|
      1|  547|            - parameter session:           The session containing the data (or upload) task.
      1|  548|            - parameter dataTask:          The data (or upload) task.
      1|  549|            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
       |  550|                                           caching policy and the values of certain received headers, such as the Pragma 
       |  551|                                           and Cache-Control headers.
       |  552|            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
       |  553|                                           response, a modified version of that response, or NULL to prevent caching the 
       |  554|                                           response. If your delegate implements this method, it must call this completion 
       |  555|                                           handler; otherwise, your app leaks memory.
       |  556|        */
       |  557|        public func URLSession(
       |  558|            session: NSURLSession,
       |  559|            dataTask: NSURLSessionDataTask,
       |  560|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  561|            completionHandler: ((NSCachedURLResponse?) -> Void))
       |  562|        {
       |  563|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
       |  564|                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
       |  565|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
       |  566|                delegate.URLSession(
       |  567|                    session,
       |  568|                    dataTask: dataTask,
      0|  569|                    willCacheResponse: proposedResponse,
      0|  570|                    completionHandler: completionHandler
      0|  571|                )
      0|  572|            } else {
      0|  573|                completionHandler(proposedResponse)
      0|  574|            }
      0|  575|        }
      0|  576|
      0|  577|        // MARK: - NSURLSessionDownloadDelegate
      0|  578|
      0|  579|        // MARK: Override Closures
      0|  580|
      0|  581|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
      0|  582|        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
       |  583|
       |  584|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
       |  585|        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  586|
       |  587|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
       |  588|        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  589|
       |  590|        // MARK: Delegate Methods
       |  591|
       |  592|        /**
       |  593|            Tells the delegate that a download task has finished downloading.
       |  594|
       |  595|            - parameter session:      The session containing the download task that finished.
       |  596|            - parameter downloadTask: The download task that finished.
       |  597|            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
       |  598|                                      open the file for reading or move it to a permanent location in your app’s sandbox 
       |  599|                                      container directory before returning from this delegate method.
       |  600|        */
       |  601|        public func URLSession(
       |  602|            session: NSURLSession,
       |  603|            downloadTask: NSURLSessionDownloadTask,
       |  604|            didFinishDownloadingToURL location: NSURL)
       |  605|        {
       |  606|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
       |  607|                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
       |  608|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  609|                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
       |  610|            }
       |  611|        }
      0|  612|
      0|  613|        /**
      0|  614|            Periodically informs the delegate about the download’s progress.
      0|  615|
      0|  616|            - parameter session:                   The session containing the download task.
      0|  617|            - parameter downloadTask:              The download task.
      0|  618|            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
       |  619|                                                   method was called.
       |  620|            - parameter totalBytesWritten:         The total number of bytes transferred so far.
       |  621|            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
       |  622|                                                   header. If this header was not provided, the value is 
       |  623|                                                   `NSURLSessionTransferSizeUnknown`.
       |  624|        */
       |  625|        public func URLSession(
       |  626|            session: NSURLSession,
       |  627|            downloadTask: NSURLSessionDownloadTask,
       |  628|            didWriteData bytesWritten: Int64,
       |  629|            totalBytesWritten: Int64,
       |  630|            totalBytesExpectedToWrite: Int64)
       |  631|        {
       |  632|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
       |  633|                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
       |  634|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  635|                delegate.URLSession(
       |  636|                    session,
       |  637|                    downloadTask: downloadTask,
      0|  638|                    didWriteData: bytesWritten,
      0|  639|                    totalBytesWritten: totalBytesWritten,
      0|  640|                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
      0|  641|                )
      0|  642|            }
      0|  643|        }
      0|  644|
      0|  645|        /**
      0|  646|            Tells the delegate that the download task has resumed downloading.
      0|  647|
      0|  648|            - parameter session:            The session containing the download task that finished.
      0|  649|            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
      0|  650|            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
       |  651|                                            existing content, then this value is zero. Otherwise, this value is an 
       |  652|                                            integer representing the number of bytes on disk that do not need to be 
       |  653|                                            retrieved again.
       |  654|            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
       |  655|                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
       |  656|        */
       |  657|        public func URLSession(
       |  658|            session: NSURLSession,
       |  659|            downloadTask: NSURLSessionDownloadTask,
       |  660|            didResumeAtOffset fileOffset: Int64,
       |  661|            expectedTotalBytes: Int64)
       |  662|        {
       |  663|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
       |  664|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
       |  665|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  666|                delegate.URLSession(
       |  667|                    session,
       |  668|                    downloadTask: downloadTask,
      0|  669|                    didResumeAtOffset: fileOffset,
      0|  670|                    expectedTotalBytes: expectedTotalBytes
      0|  671|                )
      0|  672|            }
      0|  673|        }
      0|  674|
      0|  675|        // MARK: - NSURLSessionStreamDelegate
      0|  676|
      0|  677|        var _streamTaskReadClosed: Any?
      0|  678|        var _streamTaskWriteClosed: Any?
      0|  679|        var _streamTaskBetterRouteDiscovered: Any?
      0|  680|        var _streamTaskDidBecomeInputStream: Any?
       |  681|
       |  682|        // MARK: - NSObject
       |  683|
       |  684|        public override func respondsToSelector(selector: Selector) -> Bool {
       |  685|            switch selector {
       |  686|            case "URLSession:didBecomeInvalidWithError:":
       |  687|                return sessionDidBecomeInvalidWithError != nil
       |  688|            case "URLSession:didReceiveChallenge:completionHandler:":
       |  689|                return sessionDidReceiveChallenge != nil
       |  690|            case "URLSessionDidFinishEventsForBackgroundURLSession:":
     11|  691|                return sessionDidFinishEventsForBackgroundURLSession != nil
     11|  692|            case "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:":
      0|  693|                return taskWillPerformHTTPRedirection != nil
      0|  694|            case "URLSession:dataTask:didReceiveResponse:completionHandler:":
      1|  695|                return dataTaskDidReceiveResponse != nil
      1|  696|            default:
      0|  697|                return self.dynamicType.instancesRespondToSelector(selector)
      0|  698|            }
      0|  699|        }
      0|  700|    }
      1|  701|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/MultipartFormData.swift:
       |    1|// MultipartFormData.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if os(iOS) || os(watchOS) || os(tvOS)
       |   26|import MobileCoreServices
       |   27|#elseif os(OSX)
       |   28|import CoreServices
       |   29|#endif
       |   30|
       |   31|/**
       |   32|    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
       |   33|    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
       |   34|    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
       |   35|    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
       |   36|    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
       |   37|
       |   38|    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
       |   39|    and the w3 form documentation.
       |   40|
       |   41|    - https://www.ietf.org/rfc/rfc2388.txt
       |   42|    - https://www.ietf.org/rfc/rfc2045.txt
       |   43|    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
       |   44|*/
       |   45|public class MultipartFormData {
       |   46|
       |   47|    // MARK: - Helper Types
       |   48|
       |   49|    struct EncodingCharacters {
       |   50|        static let CRLF = "\r\n"
       |   51|    }
       |   52|
       |   53|    struct BoundaryGenerator {
       |   54|        enum BoundaryType {
       |   55|            case Initial, Encapsulated, Final
       |   56|        }
       |   57|
      0|   58|        static func randomBoundary() -> String {
      0|   59|            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
      0|   60|        }
       |   61|
      0|   62|        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
      0|   63|            let boundaryText: String
      0|   64|
      0|   65|            switch boundaryType {
      0|   66|            case .Initial:
      0|   67|                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
      0|   68|            case .Encapsulated:
      0|   69|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
      0|   70|            case .Final:
      0|   71|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
      0|   72|            }
      0|   73|
      0|   74|            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|   75|        }
       |   76|    }
       |   77|
       |   78|    class BodyPart {
       |   79|        let headers: [String: String]
       |   80|        let bodyStream: NSInputStream
       |   81|        let bodyContentLength: UInt64
       |   82|        var hasInitialBoundary = false
       |   83|        var hasFinalBoundary = false
       |   84|
      0|   85|        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
      0|   86|            self.headers = headers
      0|   87|            self.bodyStream = bodyStream
      0|   88|            self.bodyContentLength = bodyContentLength
      0|   89|        }
       |   90|    }
       |   91|
       |   92|    // MARK: - Properties
       |   93|
       |   94|    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
      0|   95|    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
       |   96|
       |   97|    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
      0|   98|    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
       |   99|
       |  100|    /// The boundary used to separate the body parts in the encoded form data.
       |  101|    public let boundary: String
       |  102|
       |  103|    private var bodyParts: [BodyPart]
       |  104|    private var bodyPartError: NSError?
       |  105|    private let streamBufferSize: Int
       |  106|
       |  107|    // MARK: - Lifecycle
       |  108|
       |  109|    /**
       |  110|        Creates a multipart form data object.
       |  111|
       |  112|        - returns: The multipart form data object.
       |  113|    */
      0|  114|    public init() {
      0|  115|        self.boundary = BoundaryGenerator.randomBoundary()
      0|  116|        self.bodyParts = []
      0|  117|
      0|  118|        /**
      0|  119|         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
      0|  120|         *  information, please refer to the following article:
      0|  121|         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
      0|  122|         */
      0|  123|
      0|  124|        self.streamBufferSize = 1024
      0|  125|    }
       |  126|
       |  127|    // MARK: - Body Parts
       |  128|
       |  129|    /**
       |  130|        Creates a body part from the data and appends it to the multipart form data object.
       |  131|
       |  132|        The body part data will be encoded using the following format:
       |  133|
       |  134|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  135|        - Encoded data
       |  136|        - Multipart form boundary
       |  137|
       |  138|        - parameter data: The data to encode into the multipart form data.
       |  139|        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
       |  140|    */
      0|  141|    public func appendBodyPart(data data: NSData, name: String) {
      0|  142|        let headers = contentHeaders(name: name)
      0|  143|        let stream = NSInputStream(data: data)
      0|  144|        let length = UInt64(data.length)
      0|  145|
      0|  146|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  147|    }
       |  148|
       |  149|    /**
       |  150|        Creates a body part from the data and appends it to the multipart form data object.
       |  151|
       |  152|        The body part data will be encoded using the following format:
       |  153|
       |  154|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  155|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  156|        - Encoded data
       |  157|        - Multipart form boundary
       |  158|
       |  159|        - parameter data:     The data to encode into the multipart form data.
       |  160|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  161|        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
       |  162|    */
      0|  163|    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
      0|  164|        let headers = contentHeaders(name: name, mimeType: mimeType)
      0|  165|        let stream = NSInputStream(data: data)
      0|  166|        let length = UInt64(data.length)
      0|  167|
      0|  168|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  169|    }
       |  170|
       |  171|    /**
       |  172|        Creates a body part from the data and appends it to the multipart form data object.
       |  173|
       |  174|        The body part data will be encoded using the following format:
       |  175|
       |  176|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  177|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  178|        - Encoded file data
       |  179|        - Multipart form boundary
       |  180|
       |  181|        - parameter data:     The data to encode into the multipart form data.
       |  182|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  183|        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
       |  184|        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
       |  185|    */
      0|  186|    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
      0|  187|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  188|        let stream = NSInputStream(data: data)
      0|  189|        let length = UInt64(data.length)
      0|  190|
      0|  191|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Creates a body part from the file and appends it to the multipart form data object.
       |  196|
       |  197|        The body part data will be encoded using the following format:
       |  198|
       |  199|        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
       |  200|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  201|        - Encoded file data
       |  202|        - Multipart form boundary
       |  203|
       |  204|        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
       |  205|        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
       |  206|        system associated MIME type.
       |  207|
       |  208|        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
       |  209|        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  210|    */
      0|  211|    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
      0|  212|        if let
      0|  213|            fileName = fileURL.lastPathComponent,
      0|  214|            pathExtension = fileURL.pathExtension
      0|  215|        {
      0|  216|            let mimeType = mimeTypeForPathExtension(pathExtension)
      0|  217|            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
      0|  218|        } else {
      0|  219|            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
      0|  220|            setBodyPartError(Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason))
      0|  221|        }
      0|  222|    }
       |  223|
       |  224|    /**
       |  225|        Creates a body part from the file and appends it to the multipart form data object.
       |  226|
       |  227|        The body part data will be encoded using the following format:
       |  228|
       |  229|        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
       |  230|        - Content-Type: #{mimeType} (HTTP Header)
       |  231|        - Encoded file data
       |  232|        - Multipart form boundary
       |  233|
       |  234|        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
       |  235|        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  236|        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
       |  237|        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
       |  238|    */
      0|  239|    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
      0|  240|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  241|
      0|  242|        //============================================================
      0|  243|        //                 Check 1 - is file URL?
      0|  244|        //============================================================
      0|  245|
      0|  246|        guard fileURL.fileURL else {
      0|  247|            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
      0|  248|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  249|            setBodyPartError(error)
      0|  250|            return
      0|  251|        }
      0|  252|
      0|  253|        //============================================================
      0|  254|        //              Check 2 - is file URL reachable?
      0|  255|        //============================================================
      0|  256|
      0|  257|        var isReachable = true
      0|  258|
      0|  259|        if #available(OSX 10.10, *) {
      0|  260|            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
      0|  261|        }
      0|  262|
      0|  263|        guard isReachable else {
      0|  264|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
      0|  265|            setBodyPartError(error)
      0|  266|            return
      0|  267|        }
      0|  268|
      0|  269|        //============================================================
      0|  270|        //            Check 3 - is file URL a directory?
      0|  271|        //============================================================
      0|  272|
      0|  273|        var isDirectory: ObjCBool = false
      0|  274|
      0|  275|        guard let
      0|  276|            path = fileURL.path
      0|  277|            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
      0|  278|        {
      0|  279|            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
      0|  280|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  281|            setBodyPartError(error)
      0|  282|            return
      0|  283|        }
      0|  284|
      0|  285|        //============================================================
      0|  286|        //          Check 4 - can the file size be extracted?
      0|  287|        //============================================================
      0|  288|
      0|  289|        var bodyContentLength: UInt64?
      0|  290|
      0|  291|        do {
      0|  292|            if let
      0|  293|                path = fileURL.path,
      0|  294|                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
      0|  295|            {
      0|  296|                bodyContentLength = fileSize.unsignedLongLongValue
      0|  297|            }
      0|  298|        } catch {
      0|  299|            // No-op
      0|  300|        }
      0|  301|
      0|  302|        guard let length = bodyContentLength else {
      0|  303|            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
      0|  304|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  305|            setBodyPartError(error)
      0|  306|            return
      0|  307|        }
      0|  308|
      0|  309|        //============================================================
      0|  310|        //       Check 5 - can a stream be created from file URL?
      0|  311|        //============================================================
      0|  312|
      0|  313|        guard let stream = NSInputStream(URL: fileURL) else {
      0|  314|            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
      0|  315|            let error = Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  316|            setBodyPartError(error)
      0|  317|            return
      0|  318|        }
      0|  319|
      0|  320|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  321|    }
       |  322|
       |  323|    /**
       |  324|        Creates a body part from the stream and appends it to the multipart form data object.
       |  325|
       |  326|        The body part data will be encoded using the following format:
       |  327|
       |  328|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  329|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  330|        - Encoded stream data
       |  331|        - Multipart form boundary
       |  332|
       |  333|        - parameter stream:   The input stream to encode in the multipart form data.
       |  334|        - parameter length:   The content length of the stream.
       |  335|        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
       |  336|        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
       |  337|        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
       |  338|    */
       |  339|    public func appendBodyPart(
       |  340|        stream stream: NSInputStream,
       |  341|        length: UInt64,
       |  342|        name: String,
       |  343|        fileName: String,
       |  344|        mimeType: String)
      0|  345|    {
      0|  346|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  347|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  348|    }
       |  349|
       |  350|    /**
       |  351|        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
       |  352|
       |  353|        The body part data will be encoded using the following format:
       |  354|
       |  355|        - HTTP headers
       |  356|        - Encoded stream data
       |  357|        - Multipart form boundary
       |  358|
       |  359|        - parameter stream:  The input stream to encode in the multipart form data.
       |  360|        - parameter length:  The content length of the stream.
       |  361|        - parameter headers: The HTTP headers for the body part.
       |  362|    */
      0|  363|    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
      0|  364|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
      0|  365|        bodyParts.append(bodyPart)
      0|  366|    }
       |  367|
       |  368|    // MARK: - Data Encoding
       |  369|
       |  370|    /**
       |  371|        Encodes all the appended body parts into a single `NSData` object.
       |  372|
       |  373|        It is important to note that this method will load all the appended body parts into memory all at the same 
       |  374|        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
       |  375|        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
       |  376|
       |  377|        - throws: An `NSError` if encoding encounters an error.
       |  378|
       |  379|        - returns: The encoded `NSData` if encoding is successful.
       |  380|    */
      0|  381|    public func encode() throws -> NSData {
      0|  382|        if let bodyPartError = bodyPartError {
      0|  383|            throw bodyPartError
      0|  384|        }
      0|  385|
      0|  386|        let encoded = NSMutableData()
      0|  387|
      0|  388|        bodyParts.first?.hasInitialBoundary = true
      0|  389|        bodyParts.last?.hasFinalBoundary = true
      0|  390|
      0|  391|        for bodyPart in bodyParts {
      0|  392|            let encodedData = try encodeBodyPart(bodyPart)
      0|  393|            encoded.appendData(encodedData)
      0|  394|        }
      0|  395|
      0|  396|        return encoded
      0|  397|    }
       |  398|
       |  399|    /**
       |  400|        Writes the appended body parts into the given file URL.
       |  401|
       |  402|        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
       |  403|        this approach is very memory efficient and should be used for large body part data.
       |  404|
       |  405|        - parameter fileURL: The file URL to write the multipart form data into.
       |  406|
       |  407|        - throws: An `NSError` if encoding encounters an error.
       |  408|    */
      0|  409|    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
      0|  410|        if let bodyPartError = bodyPartError {
      0|  411|            throw bodyPartError
      0|  412|        }
      0|  413|
      0|  414|        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
      0|  415|            let failureReason = "A file already exists at the given file URL: \(fileURL)"
      0|  416|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  417|        } else if !fileURL.fileURL {
      0|  418|            let failureReason = "The URL does not point to a valid file: \(fileURL)"
      0|  419|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  420|        }
      0|  421|
      0|  422|        let outputStream: NSOutputStream
      0|  423|
      0|  424|        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
      0|  425|            outputStream = possibleOutputStream
      0|  426|        } else {
      0|  427|            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
      0|  428|            throw Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  429|        }
      0|  430|
      0|  431|        outputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  432|        outputStream.open()
      0|  433|
      0|  434|        self.bodyParts.first?.hasInitialBoundary = true
      0|  435|        self.bodyParts.last?.hasFinalBoundary = true
      0|  436|
      0|  437|        for bodyPart in self.bodyParts {
      0|  438|            try writeBodyPart(bodyPart, toOutputStream: outputStream)
      0|  439|        }
      0|  440|
      0|  441|        outputStream.close()
      0|  442|        outputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  443|    }
       |  444|
       |  445|    // MARK: - Private - Body Part Encoding
       |  446|
      0|  447|    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  448|        let encoded = NSMutableData()
      0|  449|
      0|  450|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  451|        encoded.appendData(initialData)
      0|  452|
      0|  453|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  454|        encoded.appendData(headerData)
      0|  455|
      0|  456|        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
      0|  457|        encoded.appendData(bodyStreamData)
      0|  458|
      0|  459|        if bodyPart.hasFinalBoundary {
      0|  460|            encoded.appendData(finalBoundaryData())
      0|  461|        }
      0|  462|
      0|  463|        return encoded
      0|  464|    }
       |  465|
      0|  466|    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
      0|  467|        var headerText = ""
      0|  468|
      0|  469|        for (key, value) in bodyPart.headers {
      0|  470|            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
      0|  471|        }
      0|  472|        headerText += EncodingCharacters.CRLF
      0|  473|
      0|  474|        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|  475|    }
       |  476|
      0|  477|    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  478|        let inputStream = bodyPart.bodyStream
      0|  479|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  480|        inputStream.open()
      0|  481|
      0|  482|        var error: NSError?
      0|  483|        let encoded = NSMutableData()
      0|  484|
      0|  485|        while inputStream.hasBytesAvailable {
      0|  486|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  487|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  488|
      0|  489|            if inputStream.streamError != nil {
      0|  490|                error = inputStream.streamError
      0|  491|                break
      0|  492|            }
      0|  493|
      0|  494|            if bytesRead > 0 {
      0|  495|                encoded.appendBytes(buffer, length: bytesRead)
      0|  496|            } else if bytesRead < 0 {
      0|  497|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  498|                error = Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  499|                break
      0|  500|            } else {
      0|  501|                break
      0|  502|            }
      0|  503|        }
      0|  504|
      0|  505|        inputStream.close()
      0|  506|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  507|
      0|  508|        if let error = error {
      0|  509|            throw error
      0|  510|        }
      0|  511|
      0|  512|        return encoded
      0|  513|    }
       |  514|
       |  515|    // MARK: - Private - Writing Body Part to Output Stream
       |  516|
      0|  517|    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  518|        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  519|        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  520|        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  521|        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  522|    }
       |  523|
       |  524|    private func writeInitialBoundaryDataForBodyPart(
       |  525|        bodyPart: BodyPart,
       |  526|        toOutputStream outputStream: NSOutputStream)
       |  527|        throws
      0|  528|    {
      0|  529|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  530|        return try writeData(initialData, toOutputStream: outputStream)
      0|  531|    }
       |  532|
      0|  533|    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  534|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  535|        return try writeData(headerData, toOutputStream: outputStream)
      0|  536|    }
       |  537|
      0|  538|    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  539|        let inputStream = bodyPart.bodyStream
      0|  540|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  541|        inputStream.open()
      0|  542|
      0|  543|        while inputStream.hasBytesAvailable {
      0|  544|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  545|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  546|
      0|  547|            if let streamError = inputStream.streamError {
      0|  548|                throw streamError
      0|  549|            }
      0|  550|
      0|  551|            if bytesRead > 0 {
      0|  552|                if buffer.count != bytesRead {
      0|  553|                    buffer = Array(buffer[0..<bytesRead])
      0|  554|                }
      0|  555|
      0|  556|                try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  557|            } else if bytesRead < 0 {
      0|  558|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  559|                throw Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  560|            } else {
      0|  561|                break
      0|  562|            }
      0|  563|        }
      0|  564|
      0|  565|        inputStream.close()
      0|  566|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  567|    }
       |  568|
       |  569|    private func writeFinalBoundaryDataForBodyPart(
       |  570|        bodyPart: BodyPart,
       |  571|        toOutputStream outputStream: NSOutputStream)
       |  572|        throws
      0|  573|    {
      0|  574|        if bodyPart.hasFinalBoundary {
      0|  575|            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
      0|  576|        }
      0|  577|    }
       |  578|
       |  579|    // MARK: - Private - Writing Buffered Data to Output Stream
       |  580|
      0|  581|    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
      0|  582|        var buffer = [UInt8](count: data.length, repeatedValue: 0)
      0|  583|        data.getBytes(&buffer, length: data.length)
      0|  584|
      0|  585|        return try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  586|    }
       |  587|
      0|  588|    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
      0|  589|        var bytesToWrite = buffer.count
      0|  590|
      0|  591|        while bytesToWrite > 0 {
      0|  592|            if outputStream.hasSpaceAvailable {
      0|  593|                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
      0|  594|
      0|  595|                if let streamError = outputStream.streamError {
      0|  596|                    throw streamError
      0|  597|                }
      0|  598|
      0|  599|                if bytesWritten < 0 {
      0|  600|                    let failureReason = "Failed to write to output stream: \(outputStream)"
      0|  601|                    throw Error.errorWithCode(.OutputStreamWriteFailed, failureReason: failureReason)
      0|  602|                }
      0|  603|
      0|  604|                bytesToWrite -= bytesWritten
      0|  605|
      0|  606|                if bytesToWrite > 0 {
      0|  607|                    buffer = Array(buffer[bytesWritten..<buffer.count])
      0|  608|                }
      0|  609|            } else if let streamError = outputStream.streamError {
      0|  610|                throw streamError
      0|  611|            }
      0|  612|        }
      0|  613|    }
       |  614|
       |  615|    // MARK: - Private - Mime Type
       |  616|
      0|  617|    private func mimeTypeForPathExtension(pathExtension: String) -> String {
      0|  618|        if let
      0|  619|            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
      0|  620|            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
      0|  621|        {
      0|  622|            return contentType as String
      0|  623|        }
      0|  624|
      0|  625|        return "application/octet-stream"
      0|  626|    }
       |  627|
       |  628|    // MARK: - Private - Content Headers
       |  629|
      0|  630|    private func contentHeaders(name name: String) -> [String: String] {
      0|  631|        return ["Content-Disposition": "form-data; name=\"\(name)\""]
      0|  632|    }
       |  633|
      0|  634|    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
      0|  635|        return [
      0|  636|            "Content-Disposition": "form-data; name=\"\(name)\"",
      0|  637|            "Content-Type": "\(mimeType)"
      0|  638|        ]
      0|  639|    }
       |  640|
      0|  641|    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
      0|  642|        return [
      0|  643|            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
      0|  644|            "Content-Type": "\(mimeType)"
      0|  645|        ]
      0|  646|    }
       |  647|
       |  648|    // MARK: - Private - Boundary Encoding
       |  649|
      0|  650|    private func initialBoundaryData() -> NSData {
      0|  651|        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
      0|  652|    }
       |  653|
      0|  654|    private func encapsulatedBoundaryData() -> NSData {
      0|  655|        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
      0|  656|    }
       |  657|
      0|  658|    private func finalBoundaryData() -> NSData {
      0|  659|        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
      0|  660|    }
       |  661|
       |  662|    // MARK: - Private - Errors
       |  663|
      0|  664|    private func setBodyPartError(error: NSError) {
      0|  665|        if bodyPartError == nil {
      0|  666|            bodyPartError = error
      0|  667|        }
      0|  668|    }
       |  669|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ParameterEncoding.swift:
       |    1|// ParameterEncoding.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    HTTP method definitions.
       |   27|
       |   28|    See https://tools.ietf.org/html/rfc7231#section-4.3
       |   29|*/
       |   30|public enum Method: String {
       |   31|    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
       |   32|}
       |   33|
       |   34|// MARK: ParameterEncoding
       |   35|
       |   36|/**
       |   37|    Used to specify the way in which a set of parameters are applied to a URL request.
       |   38|
       |   39|    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
       |   40|                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
       |   41|                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
       |   42|                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
       |   43|                         for how to encode collection types, the convention of appending `[]` to the key for array
       |   44|                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
       |   45|                         dictionary values (`foo[bar]=baz`).
       |   46|
       |   47|    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
       |   48|                         implementation as the `.URL` case, but always applies the encoded result to the URL.
       |   49|
       |   50|    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
       |   51|                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
       |   52|                         set to `application/json`.
       |   53|
       |   54|    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
       |   55|                         according to the associated format and write options values, which is set as the body of the
       |   56|                         request. The `Content-Type` HTTP header field of an encoded request is set to
       |   57|                         `application/x-plist`.
       |   58|
       |   59|    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
       |   60|                         parameters.
       |   61|*/
       |   62|public enum ParameterEncoding {
       |   63|    case URL
       |   64|    case URLEncodedInURL
       |   65|    case JSON
       |   66|    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
       |   67|    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
       |   68|
       |   69|    /**
       |   70|        Creates a URL request by encoding parameters and applying them onto an existing request.
       |   71|
       |   72|        - parameter URLRequest: The request to have parameters applied
       |   73|        - parameter parameters: The parameters to apply
       |   74|
       |   75|        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
       |   76|                   if any.
       |   77|    */
       |   78|    public func encode(
       |   79|        URLRequest: URLRequestConvertible,
       |   80|        parameters: [String: AnyObject]?)
       |   81|        -> (NSMutableURLRequest, NSError?)
      1|   82|    {
      1|   83|        var mutableURLRequest = URLRequest.URLRequest
      1|   84|
      0|   85|        guard let parameters = parameters where !parameters.isEmpty else {
      0|   86|            return (mutableURLRequest, nil)
      0|   87|        }
      1|   88|
      1|   89|        var encodingError: NSError? = nil
      1|   90|
      1|   91|        switch self {
      0|   92|        case .URL, .URLEncodedInURL:
      0|   93|            func query(parameters: [String: AnyObject]) -> String {
      0|   94|                var components: [(String, String)] = []
      0|   95|
      0|   96|                for key in parameters.keys.sort(<) {
      0|   97|                    let value = parameters[key]!
      0|   98|                    components += queryComponents(key, value)
      0|   99|                }
      0|  100|
      0|  101|                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
      0|  102|            }
      0|  103|
      0|  104|            func encodesParametersInURL(method: Method) -> Bool {
      0|  105|                switch self {
      0|  106|                case .URLEncodedInURL:
      0|  107|                    return true
      0|  108|                default:
      0|  109|                    break
      0|  110|                }
      0|  111|
      0|  112|                switch method {
      0|  113|                case .GET, .HEAD, .DELETE:
      0|  114|                    return true
      0|  115|                default:
      0|  116|                    return false
      0|  117|                }
      0|  118|            }
      0|  119|
      0|  120|            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
      0|  121|                if let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false) {
      0|  122|                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
      0|  123|                    URLComponents.percentEncodedQuery = percentEncodedQuery
      0|  124|                    mutableURLRequest.URL = URLComponents.URL
      0|  125|                }
      0|  126|            } else {
      0|  127|                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
      0|  128|                    mutableURLRequest.setValue(
      0|  129|                        "application/x-www-form-urlencoded; charset=utf-8",
      0|  130|                        forHTTPHeaderField: "Content-Type"
      0|  131|                    )
      0|  132|                }
      0|  133|
      0|  134|                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
      0|  135|                    NSUTF8StringEncoding,
      0|  136|                    allowLossyConversion: false
      0|  137|                )
      0|  138|            }
      1|  139|        case .JSON:
      1|  140|            do {
      1|  141|                let options = NSJSONWritingOptions()
      1|  142|                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
      1|  143|
      1|  144|                mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
      1|  145|                mutableURLRequest.HTTPBody = data
      0|  146|            } catch {
      0|  147|                encodingError = error as NSError
      0|  148|            }
      0|  149|        case .PropertyList(let format, let options):
      0|  150|            do {
      0|  151|                let data = try NSPropertyListSerialization.dataWithPropertyList(
      0|  152|                    parameters,
      0|  153|                    format: format,
      0|  154|                    options: options
      0|  155|                )
      0|  156|                mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
      0|  157|                mutableURLRequest.HTTPBody = data
      0|  158|            } catch {
      0|  159|                encodingError = error as NSError
      0|  160|            }
      0|  161|        case .Custom(let closure):
      0|  162|            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
      1|  163|        }
      1|  164|
      1|  165|        return (mutableURLRequest, encodingError)
      1|  166|    }
       |  167|
       |  168|    /**
       |  169|        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
       |  170|
       |  171|        - parameter key:   The key of the query component.
       |  172|        - parameter value: The value of the query component.
       |  173|
       |  174|        - returns: The percent-escaped, URL encoded query string components.
       |  175|    */
      0|  176|    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
      0|  177|        var components: [(String, String)] = []
      0|  178|
      0|  179|        if let dictionary = value as? [String: AnyObject] {
      0|  180|            for (nestedKey, value) in dictionary {
      0|  181|                components += queryComponents("\(key)[\(nestedKey)]", value)
      0|  182|            }
      0|  183|        } else if let array = value as? [AnyObject] {
      0|  184|            for value in array {
      0|  185|                components += queryComponents("\(key)[]", value)
      0|  186|            }
      0|  187|        } else {
      0|  188|            components.append((escape(key), escape("\(value)")))
      0|  189|        }
      0|  190|
      0|  191|        return components
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Returns a percent-escaped string following RFC 3986 for a query string key or value.
       |  196|
       |  197|        RFC 3986 states that the following characters are "reserved" characters.
       |  198|
       |  199|        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
       |  200|        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
       |  201|
       |  202|        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
       |  203|        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
       |  204|        should be percent-escaped in the query string.
       |  205|
       |  206|        - parameter string: The string to be percent-escaped.
       |  207|
       |  208|        - returns: The percent-escaped string.
       |  209|    */
      0|  210|    public func escape(string: String) -> String {
      0|  211|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
      0|  212|        let subDelimitersToEncode = "!$&'()*+,;="
      0|  213|
      0|  214|        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
      0|  215|        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
      0|  216|
      0|  217|        var escaped = ""
      0|  218|
      0|  219|        //==========================================================================================================
      0|  220|        //
      0|  221|        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
      0|  222|        //  hundred Chinense characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
      0|  223|        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
      0|  224|        //  info, please refer to:
      0|  225|        //
      0|  226|        //      - https://github.com/Alamofire/Alamofire/issues/206
      0|  227|        //
      0|  228|        //==========================================================================================================
      0|  229|
      0|  230|        if #available(iOS 8.3, OSX 10.10, *) {
      0|  231|            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
      0|  232|        } else {
      0|  233|            let batchSize = 50
      0|  234|            var index = string.startIndex
      0|  235|
      0|  236|            while index != string.endIndex {
      0|  237|                let startIndex = index
      0|  238|                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
      0|  239|                let range = Range(start: startIndex, end: endIndex)
      0|  240|
      0|  241|                let substring = string.substringWithRange(range)
      0|  242|
      0|  243|                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
      0|  244|
      0|  245|                index = endIndex
      0|  246|            }
      0|  247|        }
      0|  248|
      0|  249|        return escaped
      0|  250|    }
       |  251|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Request.swift:
       |    1|// Request.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for sending a request and receiving the response and associated data from the server, as well as 
       |   27|    managing its underlying `NSURLSessionTask`.
       |   28|*/
       |   29|public class Request {
       |   30|
       |   31|    // MARK: - Properties
       |   32|
       |   33|    /// The delegate for the underlying task.
       |   34|    public let delegate: TaskDelegate
       |   35|
       |   36|    /// The underlying task.
      5|   37|    public var task: NSURLSessionTask { return delegate.task }
       |   38|
       |   39|    /// The session belonging to the underlying task.
       |   40|    public let session: NSURLSession
       |   41|
       |   42|    /// The request sent or to be sent to the server.
      2|   43|    public var request: NSURLRequest? { return task.originalRequest }
       |   44|
       |   45|    /// The response received from the server, if any.
      2|   46|    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
       |   47|
       |   48|    /// The progress of the request lifecycle.
      0|   49|    public var progress: NSProgress { return delegate.progress }
       |   50|
       |   51|    // MARK: - Lifecycle
       |   52|
      1|   53|    init(session: NSURLSession, task: NSURLSessionTask) {
      1|   54|        self.session = session
      1|   55|
      1|   56|        switch task {
      0|   57|        case is NSURLSessionUploadTask:
      0|   58|            self.delegate = UploadTaskDelegate(task: task)
      1|   59|        case is NSURLSessionDataTask:
      1|   60|            self.delegate = DataTaskDelegate(task: task)
      0|   61|        case is NSURLSessionDownloadTask:
      0|   62|            self.delegate = DownloadTaskDelegate(task: task)
      0|   63|        default:
      0|   64|            self.delegate = TaskDelegate(task: task)
      1|   65|        }
      1|   66|    }
       |   67|
       |   68|    // MARK: - Authentication
       |   69|
       |   70|    /**
       |   71|        Associates an HTTP Basic credential with the request.
       |   72|
       |   73|        - parameter user:        The user.
       |   74|        - parameter password:    The password.
       |   75|        - parameter persistence: The URL credential persistence. `.ForSession` by default.
       |   76|
       |   77|        - returns: The request.
       |   78|    */
       |   79|    public func authenticate(
       |   80|        user user: String,
       |   81|        password: String,
       |   82|        persistence: NSURLCredentialPersistence = .ForSession)
       |   83|        -> Self
      0|   84|    {
      0|   85|        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
      0|   86|
      0|   87|        return authenticate(usingCredential: credential)
      0|   88|    }
       |   89|
       |   90|    /**
       |   91|        Associates a specified credential with the request.
       |   92|
       |   93|        - parameter credential: The credential.
       |   94|
       |   95|        - returns: The request.
       |   96|    */
      0|   97|    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
      0|   98|        delegate.credential = credential
      0|   99|
      0|  100|        return self
      0|  101|    }
       |  102|
       |  103|    // MARK: - Progress
       |  104|
       |  105|    /**
       |  106|        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
       |  107|        from the server.
       |  108|
       |  109|        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
       |  110|          to write.
       |  111|        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
       |  112|          expected to read.
       |  113|
       |  114|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  115|
       |  116|        - returns: The request.
       |  117|    */
      0|  118|    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
      0|  119|        if let uploadDelegate = delegate as? UploadTaskDelegate {
      0|  120|            uploadDelegate.uploadProgress = closure
      0|  121|        } else if let dataDelegate = delegate as? DataTaskDelegate {
      0|  122|            dataDelegate.dataProgress = closure
      0|  123|        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
      0|  124|            downloadDelegate.downloadProgress = closure
      0|  125|        }
      0|  126|
      0|  127|        return self
      0|  128|    }
       |  129|
       |  130|    /**
       |  131|        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
       |  132|
       |  133|        This closure returns the bytes most recently received from the server, not including data from previous calls. 
       |  134|        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
       |  135|        also important to note that the `response` closure will be called with nil `responseData`.
       |  136|
       |  137|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  138|
       |  139|        - returns: The request.
       |  140|    */
      0|  141|    public func stream(closure: (NSData -> Void)? = nil) -> Self {
      0|  142|        if let dataDelegate = delegate as? DataTaskDelegate {
      0|  143|            dataDelegate.dataStream = closure
      0|  144|        }
      0|  145|
      0|  146|        return self
      0|  147|    }
       |  148|
       |  149|    // MARK: - State
       |  150|
       |  151|    /**
       |  152|        Suspends the request.
       |  153|    */
      0|  154|    public func suspend() {
      0|  155|        task.suspend()
      0|  156|    }
       |  157|
       |  158|    /**
       |  159|        Resumes the request.
       |  160|    */
      1|  161|    public func resume() {
      1|  162|        task.resume()
      1|  163|    }
       |  164|
       |  165|    /**
       |  166|        Cancels the request.
       |  167|    */
      0|  168|    public func cancel() {
      0|  169|        if let
      0|  170|            downloadDelegate = delegate as? DownloadTaskDelegate,
      0|  171|            downloadTask = downloadDelegate.downloadTask
      0|  172|        {
      0|  173|            downloadTask.cancelByProducingResumeData { data in
      0|  174|                downloadDelegate.resumeData = data
      0|  175|            }
      0|  176|        } else {
      0|  177|            task.cancel()
      0|  178|        }
      0|  179|    }
       |  180|
       |  181|    // MARK: - TaskDelegate
       |  182|
       |  183|    /**
       |  184|        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
       |  185|        executing all operations attached to the serial operation queue upon task completion.
       |  186|    */
       |  187|    public class TaskDelegate: NSObject {
       |  188|
       |  189|        /// The serial operation queue used to execute all operations after the task completes.
       |  190|        public let queue: NSOperationQueue
       |  191|
       |  192|        let task: NSURLSessionTask
       |  193|        let progress: NSProgress
       |  194|
      0|  195|        var data: NSData? { return nil }
       |  196|        var error: NSError?
       |  197|
       |  198|        var credential: NSURLCredential?
       |  199|
      1|  200|        init(task: NSURLSessionTask) {
      1|  201|            self.task = task
      1|  202|            self.progress = NSProgress(totalUnitCount: 0)
      1|  203|            self.queue = {
      1|  204|                let operationQueue = NSOperationQueue()
      1|  205|                operationQueue.maxConcurrentOperationCount = 1
      1|  206|                operationQueue.suspended = true
      1|  207|
      1|  208|                if #available(OSX 10.10, *) {
      1|  209|                    operationQueue.qualityOfService = NSQualityOfService.Utility
      1|  210|                }
      1|  211|
      1|  212|                return operationQueue
      1|  213|            }()
      1|  214|        }
       |  215|
      0|  216|        deinit {
      0|  217|            queue.cancelAllOperations()
      0|  218|            queue.suspended = false
      0|  219|        }
       |  220|
       |  221|        // MARK: - NSURLSessionTaskDelegate
       |  222|
       |  223|        // MARK: Override Closures
       |  224|
       |  225|        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  226|        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  227|        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
       |  228|        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  229|
       |  230|        // MARK: Delegate Methods
       |  231|
       |  232|        func URLSession(
       |  233|            session: NSURLSession,
       |  234|            task: NSURLSessionTask,
       |  235|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  236|            newRequest request: NSURLRequest,
       |  237|            completionHandler: ((NSURLRequest?) -> Void))
      0|  238|        {
      0|  239|            var redirectRequest: NSURLRequest? = request
      0|  240|
      0|  241|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  242|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  243|            }
      0|  244|
      0|  245|            completionHandler(redirectRequest)
      0|  246|        }
       |  247|
       |  248|        func URLSession(
       |  249|            session: NSURLSession,
       |  250|            task: NSURLSessionTask,
       |  251|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  252|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  253|        {
      1|  254|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      1|  255|            var credential: NSURLCredential?
      1|  256|
      0|  257|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  258|                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
      1|  259|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      1|  260|                let host = challenge.protectionSpace.host
      1|  261|
      1|  262|                if let
      1|  263|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      1|  264|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  265|                {
      0|  266|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  267|                        disposition = .UseCredential
      0|  268|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  269|                    } else {
      0|  270|                        disposition = .CancelAuthenticationChallenge
      0|  271|                    }
      0|  272|                }
      0|  273|            } else {
      0|  274|                if challenge.previousFailureCount > 0 {
      0|  275|                    disposition = .CancelAuthenticationChallenge
      0|  276|                } else {
      0|  277|                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
      0|  278|
      0|  279|                    if credential != nil {
      0|  280|                        disposition = .UseCredential
      0|  281|                    }
      0|  282|                }
      0|  283|            }
      1|  284|
      1|  285|            completionHandler(disposition, credential)
      1|  286|        }
       |  287|
       |  288|        func URLSession(
       |  289|            session: NSURLSession,
       |  290|            task: NSURLSessionTask,
       |  291|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  292|        {
      0|  293|            var bodyStream: NSInputStream?
      0|  294|
      0|  295|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  296|                bodyStream = taskNeedNewBodyStream(session, task)
      0|  297|            }
      0|  298|
      0|  299|            completionHandler(bodyStream)
      0|  300|        }
       |  301|
      1|  302|        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  303|            if let taskDidCompleteWithError = taskDidCompleteWithError {
      0|  304|                taskDidCompleteWithError(session, task, error)
      1|  305|            } else {
      0|  306|                if let error = error {
      0|  307|                    self.error = error
      0|  308|
      0|  309|                    if let
      0|  310|                        downloadDelegate = self as? DownloadTaskDelegate,
      0|  311|                        userInfo = error.userInfo as? [String: AnyObject],
      0|  312|                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
      0|  313|                    {
      0|  314|                        downloadDelegate.resumeData = resumeData
      0|  315|                    }
      0|  316|                }
      1|  317|
      1|  318|                queue.suspended = false
      1|  319|            }
      1|  320|        }
       |  321|    }
       |  322|
       |  323|    // MARK: - DataTaskDelegate
       |  324|
       |  325|    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
      0|  326|        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
       |  327|
       |  328|        private var totalBytesReceived: Int64 = 0
       |  329|        private var mutableData: NSMutableData
      2|  330|        override var data: NSData? {
      0|  331|            if dataStream != nil {
      0|  332|                return nil
      2|  333|            } else {
      2|  334|                return mutableData
      2|  335|            }
      0|  336|        }
       |  337|
       |  338|        private var expectedContentLength: Int64?
       |  339|        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
       |  340|        private var dataStream: ((data: NSData) -> Void)?
       |  341|
      1|  342|        override init(task: NSURLSessionTask) {
      1|  343|            mutableData = NSMutableData()
      1|  344|            super.init(task: task)
      1|  345|        }
       |  346|
       |  347|        // MARK: - NSURLSessionDataDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  352|        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  353|        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  354|        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
       |  355|
       |  356|        // MARK: Delegate Methods
       |  357|
       |  358|        func URLSession(
       |  359|            session: NSURLSession,
       |  360|            dataTask: NSURLSessionDataTask,
       |  361|            didReceiveResponse response: NSURLResponse,
       |  362|            completionHandler: (NSURLSessionResponseDisposition -> Void))
      0|  363|        {
      0|  364|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  365|
      0|  366|            expectedContentLength = response.expectedContentLength
      0|  367|
      0|  368|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  369|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  370|            }
      0|  371|
      0|  372|            completionHandler(disposition)
      0|  373|        }
       |  374|
       |  375|        func URLSession(
       |  376|            session: NSURLSession,
       |  377|            dataTask: NSURLSessionDataTask,
       |  378|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  379|        {
      0|  380|            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
      0|  381|        }
       |  382|
      1|  383|        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  384|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  385|                dataTaskDidReceiveData(session, dataTask, data)
      1|  386|            } else {
      0|  387|                if let dataStream = dataStream {
      0|  388|                    dataStream(data: data)
      1|  389|                } else {
      1|  390|                    mutableData.appendData(data)
      1|  391|                }
      1|  392|
      1|  393|                totalBytesReceived += data.length
      0|  394|                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
      1|  395|
      1|  396|                progress.totalUnitCount = totalBytesExpected
      1|  397|                progress.completedUnitCount = totalBytesReceived
      1|  398|
      1|  399|                dataProgress?(
      1|  400|                    bytesReceived: Int64(data.length),
      1|  401|                    totalBytesReceived: totalBytesReceived,
      1|  402|                    totalBytesExpectedToReceive: totalBytesExpected
      1|  403|                )
      1|  404|            }
      1|  405|        }
       |  406|
       |  407|        func URLSession(
       |  408|            session: NSURLSession,
       |  409|            dataTask: NSURLSessionDataTask,
       |  410|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  411|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  412|        {
      0|  413|            var cachedResponse: NSCachedURLResponse? = proposedResponse
      0|  414|
      0|  415|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  416|                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
      0|  417|            }
      0|  418|
      0|  419|            completionHandler(cachedResponse)
      0|  420|        }
       |  421|    }
       |  422|}
       |  423|
       |  424|// MARK: - CustomStringConvertible
       |  425|
       |  426|extension Request: CustomStringConvertible {
       |  427|
       |  428|    /**
       |  429|        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
       |  430|        well as the response status code if a response has been received.
       |  431|    */
      0|  432|    public var description: String {
      0|  433|        var components: [String] = []
      0|  434|
      0|  435|        if let HTTPMethod = request?.HTTPMethod {
      0|  436|            components.append(HTTPMethod)
      0|  437|        }
      0|  438|
      0|  439|        if let URLString = request?.URL?.absoluteString {
      0|  440|            components.append(URLString)
      0|  441|        }
      0|  442|
      0|  443|        if let response = response {
      0|  444|            components.append("(\(response.statusCode))")
      0|  445|        }
      0|  446|
      0|  447|        return components.joinWithSeparator(" ")
      0|  448|    }
       |  449|}
       |  450|
       |  451|// MARK: - CustomDebugStringConvertible
       |  452|
       |  453|extension Request: CustomDebugStringConvertible {
      0|  454|    func cURLRepresentation() -> String {
      0|  455|        var components = ["$ curl -i"]
      0|  456|
      0|  457|        guard let request = self.request else {
      0|  458|            return "$ curl command could not be created"
      0|  459|        }
      0|  460|
      0|  461|        let URL = request.URL
      0|  462|
      0|  463|        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
      0|  464|            components.append("-X \(HTTPMethod)")
      0|  465|        }
      0|  466|
      0|  467|        if let credentialStorage = self.session.configuration.URLCredentialStorage {
      0|  468|            let protectionSpace = NSURLProtectionSpace(
      0|  469|                host: URL!.host!,
      0|  470|                port: URL!.port?.integerValue ?? 0,
      0|  471|                `protocol`: URL!.scheme,
      0|  472|                realm: URL!.host!,
      0|  473|                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
      0|  474|            )
      0|  475|
      0|  476|            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
      0|  477|                for credential in credentials {
      0|  478|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  479|                }
      0|  480|            } else {
      0|  481|                if let credential = delegate.credential {
      0|  482|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  483|                }
      0|  484|            }
      0|  485|        }
      0|  486|
      0|  487|        if session.configuration.HTTPShouldSetCookies {
      0|  488|            if let
      0|  489|                cookieStorage = session.configuration.HTTPCookieStorage,
      0|  490|                cookies = cookieStorage.cookiesForURL(URL!) where !cookies.isEmpty
      0|  491|            {
      0|  492|                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
      0|  493|                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
      0|  494|            }
      0|  495|        }
      0|  496|
      0|  497|        if let headerFields = request.allHTTPHeaderFields {
      0|  498|            for (field, value) in headerFields {
      0|  499|                switch field {
      0|  500|                case "Cookie":
      0|  501|                    continue
      0|  502|                default:
      0|  503|                    components.append("-H \"\(field): \(value)\"")
      0|  504|                }
      0|  505|            }
      0|  506|        }
      0|  507|
      0|  508|        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
      0|  509|            for (field, value) in additionalHeaders {
      0|  510|                switch field {
      0|  511|                case "Cookie":
      0|  512|                    continue
      0|  513|                default:
      0|  514|                    components.append("-H \"\(field): \(value)\"")
      0|  515|                }
      0|  516|            }
      0|  517|        }
      0|  518|
      0|  519|        if let
      0|  520|            HTTPBodyData = request.HTTPBody,
      0|  521|            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
      0|  522|        {
      0|  523|            let escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
      0|  524|            components.append("-d \"\(escapedBody)\"")
      0|  525|        }
      0|  526|
      0|  527|        components.append("\"\(URL!.absoluteString)\"")
      0|  528|
      0|  529|        return components.joinWithSeparator(" \\\n\t")
      0|  530|    }
       |  531|
       |  532|    /// The textual representation used when written to an output stream, in the form of a cURL command.
      0|  533|    public var debugDescription: String {
      0|  534|        return cURLRepresentation()
      0|  535|    }
       |  536|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Response.swift:
       |    1|// Response.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Used to store all response data returned from a completed `Request`.
       |   26|public struct Response<Value, Error: ErrorType> {
       |   27|    /// The URL request sent to the server.
       |   28|    public let request: NSURLRequest?
       |   29|
       |   30|    /// The server's response to the URL request.
       |   31|    public let response: NSHTTPURLResponse?
       |   32|
       |   33|    /// The data returned by the server.
       |   34|    public let data: NSData?
       |   35|
       |   36|    /// The result of response serialization.
       |   37|    public let result: Result<Value, Error>
       |   38|
       |   39|    /**
       |   40|        Initializes the `Response` instance with the specified URL request, URL response, server data and response
       |   41|        serialization result.
       |   42|    
       |   43|        - parameter request:  The URL request sent to the server.
       |   44|        - parameter response: The server's response to the URL request.
       |   45|        - parameter data:     The data returned by the server.
       |   46|        - parameter result:   The result of response serialization.
       |   47|    
       |   48|        - returns: the new `Response` instance.
       |   49|    */
      1|   50|    public init(request: NSURLRequest?, response: NSHTTPURLResponse?, data: NSData?, result: Result<Value, Error>) {
      1|   51|        self.request = request
      1|   52|        self.response = response
      1|   53|        self.data = data
      1|   54|        self.result = result
      1|   55|    }
       |   56|}
       |   57|
       |   58|// MARK: - CustomStringConvertible
       |   59|
       |   60|extension Response: CustomStringConvertible {
       |   61|    /// The textual representation used when written to an output stream, which includes whether the result was a
       |   62|    /// success or failure.
      0|   63|    public var description: String {
      0|   64|        return result.debugDescription
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - CustomDebugStringConvertible
       |   69|
       |   70|extension Response: CustomDebugStringConvertible {
       |   71|    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
       |   72|    /// response, the server data and the response serialization result.
      0|   73|    public var debugDescription: String {
      0|   74|        var output: [String] = []
      0|   75|
      0|   76|        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
      0|   77|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
      0|   78|        output.append("[Data]: \(data?.length ?? 0) bytes")
      0|   79|        output.append("[Result]: \(result.debugDescription)")
      0|   80|
      0|   81|        return output.joinWithSeparator("\n")
      0|   82|    }
       |   83|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ResponseSerialization.swift:
       |    1|// ResponseSerialization.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: ResponseSerializer
       |   26|
       |   27|/**
       |   28|    The type in which all response serializers must conform to in order to serialize a response.
       |   29|*/
       |   30|public protocol ResponseSerializerType {
       |   31|    /// The type of serialized object to be created by this `ResponseSerializerType`.
       |   32|    typealias SerializedObject
       |   33|
       |   34|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   35|    typealias ErrorObject: ErrorType
       |   36|
       |   37|    /**
       |   38|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   39|    */
       |   40|    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
       |   41|}
       |   42|
       |   43|// MARK: -
       |   44|
       |   45|/**
       |   46|    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
       |   47|*/
       |   48|public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
       |   49|    /// The type of serialized object to be created by this `ResponseSerializer`.
       |   50|    public typealias SerializedObject = Value
       |   51|
       |   52|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   53|    public typealias ErrorObject = Error
       |   54|
       |   55|    /**
       |   56|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   57|    */
       |   58|    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
       |   59|
       |   60|    /**
       |   61|        Initializes the `ResponseSerializer` instance with the given serialize response closure.
       |   62|
       |   63|        - parameter serializeResponse: The closure used to serialize the response.
       |   64|
       |   65|        - returns: The new generic response serializer instance.
       |   66|    */
      1|   67|    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
      1|   68|        self.serializeResponse = serializeResponse
      1|   69|    }
       |   70|}
       |   71|
       |   72|// MARK: - Default
       |   73|
       |   74|extension Request {
       |   75|
       |   76|    /**
       |   77|        Adds a handler to be called once the request has finished.
       |   78|
       |   79|        - parameter queue:             The queue on which the completion handler is dispatched.
       |   80|        - parameter completionHandler: The code to be executed once the request has finished.
       |   81|
       |   82|        - returns: The request.
       |   83|    */
       |   84|    public func response(
       |   85|        queue queue: dispatch_queue_t? = nil,
       |   86|        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
       |   87|        -> Self
      0|   88|    {
      0|   89|        delegate.queue.addOperationWithBlock {
      0|   90|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      0|   91|                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
      0|   92|            }
      0|   93|        }
      0|   94|
      0|   95|        return self
      0|   96|    }
       |   97|
       |   98|    /**
       |   99|        Adds a handler to be called once the request has finished.
       |  100|
       |  101|        - parameter queue:              The queue on which the completion handler is dispatched.
       |  102|        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
       |  103|                                        and data.
       |  104|        - parameter completionHandler:  The code to be executed once the request has finished.
       |  105|
       |  106|        - returns: The request.
       |  107|    */
       |  108|    public func response<T: ResponseSerializerType>(
       |  109|        queue queue: dispatch_queue_t? = nil,
       |  110|        responseSerializer: T,
       |  111|        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
       |  112|        -> Self
      1|  113|    {
      1|  114|        delegate.queue.addOperationWithBlock {
      1|  115|            let result = responseSerializer.serializeResponse(
      1|  116|                self.request,
      1|  117|                self.response,
      1|  118|                self.delegate.data,
      1|  119|                self.delegate.error
      1|  120|            )
      1|  121|
      1|  122|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      1|  123|                let response = Response<T.SerializedObject, T.ErrorObject>(
      1|  124|                    request: self.request,
      1|  125|                    response: self.response,
      1|  126|                    data: self.delegate.data,
      1|  127|                    result: result
      1|  128|                )
      1|  129|
      1|  130|                completionHandler(response)
      1|  131|            }
      1|  132|        }
      1|  133|
      1|  134|        return self
      1|  135|    }
       |  136|}
       |  137|
       |  138|// MARK: - Data
       |  139|
       |  140|extension Request {
       |  141|
       |  142|    /**
       |  143|        Creates a response serializer that returns the associated data as-is.
       |  144|
       |  145|        - returns: A data response serializer.
       |  146|    */
      0|  147|    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
      0|  148|        return ResponseSerializer { _, response, data, error in
      0|  149|            guard error == nil else { return .Failure(error!) }
      0|  150|
      0|  151|            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
      0|  152|
      0|  153|            guard let validData = data else {
      0|  154|                let failureReason = "Data could not be serialized. Input data was nil."
      0|  155|                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
      0|  156|                return .Failure(error)
      0|  157|            }
      0|  158|
      0|  159|            return .Success(validData)
      0|  160|        }
      0|  161|    }
       |  162|
       |  163|    /**
       |  164|        Adds a handler to be called once the request has finished.
       |  165|
       |  166|        - parameter completionHandler: The code to be executed once the request has finished.
       |  167|
       |  168|        - returns: The request.
       |  169|    */
      0|  170|    public func responseData(completionHandler: Response<NSData, NSError> -> Void) -> Self {
      0|  171|        return response(responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
      0|  172|    }
       |  173|}
       |  174|
       |  175|// MARK: - String
       |  176|
       |  177|extension Request {
       |  178|
       |  179|    /**
       |  180|        Creates a response serializer that returns a string initialized from the response data with the specified 
       |  181|        string encoding.
       |  182|
       |  183|        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
       |  184|                              response, falling back to the default HTTP default character set, ISO-8859-1.
       |  185|
       |  186|        - returns: A string response serializer.
       |  187|    */
       |  188|    public static func stringResponseSerializer(
       |  189|        var encoding encoding: NSStringEncoding? = nil)
       |  190|        -> ResponseSerializer<String, NSError>
      0|  191|    {
      0|  192|        return ResponseSerializer { _, response, data, error in
      0|  193|            guard error == nil else { return .Failure(error!) }
      0|  194|
      0|  195|            if let response = response where response.statusCode == 204 { return .Success("") }
      0|  196|
      0|  197|            guard let validData = data else {
      0|  198|                let failureReason = "String could not be serialized. Input data was nil."
      0|  199|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  200|                return .Failure(error)
      0|  201|            }
      0|  202|
      0|  203|            if let encodingName = response?.textEncodingName where encoding == nil {
      0|  204|                encoding = CFStringConvertEncodingToNSStringEncoding(
      0|  205|                    CFStringConvertIANACharSetNameToEncoding(encodingName)
      0|  206|                )
      0|  207|            }
      0|  208|
      0|  209|            let actualEncoding = encoding ?? NSISOLatin1StringEncoding
      0|  210|
      0|  211|            if let string = String(data: validData, encoding: actualEncoding) {
      0|  212|                return .Success(string)
      0|  213|            } else {
      0|  214|                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
      0|  215|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  216|                return .Failure(error)
      0|  217|            }
      0|  218|        }
      0|  219|    }
       |  220|
       |  221|    /**
       |  222|        Adds a handler to be called once the request has finished.
       |  223|
       |  224|        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
       |  225|                                       server response, falling back to the default HTTP default character set, 
       |  226|                                       ISO-8859-1.
       |  227|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  228|
       |  229|        - returns: The request.
       |  230|    */
       |  231|    public func responseString(
       |  232|        encoding encoding: NSStringEncoding? = nil,
       |  233|        completionHandler: Response<String, NSError> -> Void)
       |  234|        -> Self
      0|  235|    {
      0|  236|        return response(
      0|  237|            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
      0|  238|            completionHandler: completionHandler
      0|  239|        )
      0|  240|    }
       |  241|}
       |  242|
       |  243|// MARK: - JSON
       |  244|
       |  245|extension Request {
       |  246|
       |  247|    /**
       |  248|        Creates a response serializer that returns a JSON object constructed from the response data using 
       |  249|        `NSJSONSerialization` with the specified reading options.
       |  250|
       |  251|        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
       |  252|
       |  253|        - returns: A JSON object response serializer.
       |  254|    */
       |  255|    public static func JSONResponseSerializer(
       |  256|        options options: NSJSONReadingOptions = .AllowFragments)
       |  257|        -> ResponseSerializer<AnyObject, NSError>
      1|  258|    {
      1|  259|        return ResponseSerializer { _, response, data, error in
      0|  260|            guard error == nil else { return .Failure(error!) }
      1|  261|
      0|  262|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      1|  263|
      0|  264|            guard let validData = data where validData.length > 0 else {
      0|  265|                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
      0|  266|                let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
      0|  267|                return .Failure(error)
      0|  268|            }
      1|  269|
      1|  270|            do {
      1|  271|                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
      1|  272|                return .Success(JSON)
      1|  273|            } catch {
      1|  274|                return .Failure(error as NSError)
      1|  275|            }
      0|  276|        }
      1|  277|    }
       |  278|
       |  279|    /**
       |  280|        Adds a handler to be called once the request has finished.
       |  281|
       |  282|        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
       |  283|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  284|
       |  285|        - returns: The request.
       |  286|    */
       |  287|    public func responseJSON(
       |  288|        options options: NSJSONReadingOptions = .AllowFragments,
       |  289|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  290|        -> Self
      1|  291|    {
      1|  292|        return response(
      1|  293|            responseSerializer: Request.JSONResponseSerializer(options: options),
      1|  294|            completionHandler: completionHandler
      1|  295|        )
      1|  296|    }
       |  297|}
       |  298|
       |  299|// MARK: - Property List
       |  300|
       |  301|extension Request {
       |  302|
       |  303|    /**
       |  304|        Creates a response serializer that returns an object constructed from the response data using 
       |  305|        `NSPropertyListSerialization` with the specified reading options.
       |  306|
       |  307|        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
       |  308|
       |  309|        - returns: A property list object response serializer.
       |  310|    */
       |  311|    public static func propertyListResponseSerializer(
       |  312|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
       |  313|        -> ResponseSerializer<AnyObject, NSError>
      0|  314|    {
      0|  315|        return ResponseSerializer { _, response, data, error in
      0|  316|            guard error == nil else { return .Failure(error!) }
      0|  317|
      0|  318|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      0|  319|
      0|  320|            guard let validData = data where validData.length > 0 else {
      0|  321|                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
      0|  322|                let error = Error.errorWithCode(.PropertyListSerializationFailed, failureReason: failureReason)
      0|  323|                return .Failure(error)
      0|  324|            }
      0|  325|
      0|  326|            do {
      0|  327|                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
      0|  328|                return .Success(plist)
      0|  329|            } catch {
      0|  330|                return .Failure(error as NSError)
      0|  331|            }
      0|  332|        }
      0|  333|    }
       |  334|
       |  335|    /**
       |  336|        Adds a handler to be called once the request has finished.
       |  337|
       |  338|        - parameter options:           The property list reading options. `0` by default.
       |  339|        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
       |  340|                                       arguments: the URL request, the URL response, the server data and the result 
       |  341|                                       produced while creating the property list.
       |  342|
       |  343|        - returns: The request.
       |  344|    */
       |  345|    public func responsePropertyList(
       |  346|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
       |  347|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  348|        -> Self
      0|  349|    {
      0|  350|        return response(
      0|  351|            responseSerializer: Request.propertyListResponseSerializer(options: options),
      0|  352|            completionHandler: completionHandler
      0|  353|        )
      0|  354|    }
       |  355|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Result.swift:
       |    1|// Result.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Used to represent whether a request was successful or encountered an error.
       |   27|
       |   28|    - Success: The request and all post processing operations were successful resulting in the serialization of the 
       |   29|               provided associated value.
       |   30|    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
       |   31|               provided by the server as well as the error that caused the failure.
       |   32|*/
       |   33|public enum Result<Value, Error: ErrorType> {
       |   34|    case Success(Value)
       |   35|    case Failure(Error)
       |   36|
       |   37|    /// Returns `true` if the result is a success, `false` otherwise.
      0|   38|    public var isSuccess: Bool {
      0|   39|        switch self {
      0|   40|        case .Success:
      0|   41|            return true
      0|   42|        case .Failure:
      0|   43|            return false
      0|   44|        }
      0|   45|    }
       |   46|
       |   47|    /// Returns `true` if the result is a failure, `false` otherwise.
      0|   48|    public var isFailure: Bool {
      0|   49|        return !isSuccess
      0|   50|    }
       |   51|
       |   52|    /// Returns the associated value if the result is a success, `nil` otherwise.
      0|   53|    public var value: Value? {
      0|   54|        switch self {
      0|   55|        case .Success(let value):
      0|   56|            return value
      0|   57|        case .Failure:
      0|   58|            return nil
      0|   59|        }
      0|   60|    }
       |   61|
       |   62|    /// Returns the associated error value if the result is a failure, `nil` otherwise.
      0|   63|    public var error: Error? {
      0|   64|        switch self {
      0|   65|        case .Success:
      0|   66|            return nil
      0|   67|        case .Failure(let error):
      0|   68|            return error
      0|   69|        }
      0|   70|    }
       |   71|}
       |   72|
       |   73|// MARK: - CustomStringConvertible
       |   74|
       |   75|extension Result: CustomStringConvertible {
       |   76|    /// The textual representation used when written to an output stream, which includes whether the result was a 
       |   77|    /// success or failure.
      0|   78|    public var description: String {
      0|   79|        switch self {
      0|   80|        case .Success:
      0|   81|            return "SUCCESS"
      0|   82|        case .Failure:
      0|   83|            return "FAILURE"
      0|   84|        }
      0|   85|    }
       |   86|}
       |   87|
       |   88|// MARK: - CustomDebugStringConvertible
       |   89|
       |   90|extension Result: CustomDebugStringConvertible {
       |   91|    /// The debug textual representation used when written to an output stream, which includes whether the result was a
       |   92|    /// success or failure in addition to the value or error.
      1|   93|    public var debugDescription: String {
      1|   94|        switch self {
      0|   95|        case .Success(let value):
      0|   96|            return "SUCCESS: \(value)"
      1|   97|        case .Failure(let error):
      1|   98|            return "FAILURE: \(error)"
      1|   99|        }
      1|  100|    }
       |  101|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ServerTrustPolicy.swift:
       |    1|// ServerTrustPolicy.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
       |   26|public class ServerTrustPolicyManager {
       |   27|    /// The dictionary of policies mapped to a particular host.
       |   28|    public let policies: [String: ServerTrustPolicy]
       |   29|
       |   30|    /**
       |   31|        Initializes the `ServerTrustPolicyManager` instance with the given policies.
       |   32|
       |   33|        Since different servers and web services can have different leaf certificates, intermediate and even root 
       |   34|        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
       |   35|        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
       |   36|        pinning for host3 and disabling evaluation for host4.
       |   37|
       |   38|        - parameter policies: A dictionary of all policies mapped to a particular host.
       |   39|
       |   40|        - returns: The new `ServerTrustPolicyManager` instance.
       |   41|    */
      0|   42|    public init(policies: [String: ServerTrustPolicy]) {
      0|   43|        self.policies = policies
      0|   44|    }
       |   45|
       |   46|    /**
       |   47|        Returns the `ServerTrustPolicy` for the given host if applicable.
       |   48|
       |   49|        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
       |   50|        this method and implement more complex mapping implementations such as wildcards.
       |   51|
       |   52|        - parameter host: The host to use when searching for a matching policy.
       |   53|
       |   54|        - returns: The server trust policy for the given host if found.
       |   55|    */
      0|   56|    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
      0|   57|        return policies[host]
      0|   58|    }
       |   59|}
       |   60|
       |   61|// MARK: -
       |   62|
       |   63|extension NSURLSession {
       |   64|    private struct AssociatedKeys {
       |   65|        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
       |   66|    }
       |   67|
       |   68|    var serverTrustPolicyManager: ServerTrustPolicyManager? {
      1|   69|        get {
      1|   70|            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
      1|   71|        }
      1|   72|        set (manager) {
      1|   73|            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
      1|   74|        }
       |   75|    }
       |   76|}
       |   77|
       |   78|// MARK: - ServerTrustPolicy
       |   79|
       |   80|/**
       |   81|    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
       |   82|    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
       |   83|    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
       |   84|
       |   85|    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
       |   86|    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
       |   87|    to route all communication over an HTTPS connection with pinning enabled.
       |   88|
       |   89|    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
       |   90|                                validate the host provided by the challenge. Applications are encouraged to always 
       |   91|                                validate the host in production environments to guarantee the validity of the server's 
       |   92|                                certificate chain.
       |   93|
       |   94|    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
       |   95|                                considered valid if one of the pinned certificates match one of the server certificates. 
       |   96|                                By validating both the certificate chain and host, certificate pinning provides a very 
       |   97|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |   98|                                Applications are encouraged to always validate the host and require a valid certificate 
       |   99|                                chain in production environments.
       |  100|
       |  101|    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
       |  102|                                valid if one of the pinned public keys match one of the server certificate public keys. 
       |  103|                                By validating both the certificate chain and host, public key pinning provides a very 
       |  104|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |  105|                                Applications are encouraged to always validate the host and require a valid certificate 
       |  106|                                chain in production environments.
       |  107|
       |  108|    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
       |  109|
       |  110|    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
       |  111|*/
       |  112|public enum ServerTrustPolicy {
       |  113|    case PerformDefaultEvaluation(validateHost: Bool)
       |  114|    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
       |  115|    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
       |  116|    case DisableEvaluation
       |  117|    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
       |  118|
       |  119|    // MARK: - Bundle Location
       |  120|
       |  121|    /**
       |  122|        Returns all certificates within the given bundle with a `.cer` file extension.
       |  123|
       |  124|        - parameter bundle: The bundle to search for all `.cer` files.
       |  125|
       |  126|        - returns: All certificates within the given bundle.
       |  127|    */
      0|  128|    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
      0|  129|        var certificates: [SecCertificate] = []
      0|  130|
      0|  131|        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
      0|  132|            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
      0|  133|        }.flatten())
      0|  134|
      0|  135|        for path in paths {
      0|  136|            if let
      0|  137|                certificateData = NSData(contentsOfFile: path),
      0|  138|                certificate = SecCertificateCreateWithData(nil, certificateData)
      0|  139|            {
      0|  140|                certificates.append(certificate)
      0|  141|            }
       |  142|        }
       |  143|
       |  144|        return certificates
       |  145|    }
       |  146|
       |  147|    /**
       |  148|        Returns all public keys within the given bundle with a `.cer` file extension.
       |  149|
      0|  150|        - parameter bundle: The bundle to search for all `*.cer` files.
      0|  151|
      0|  152|        - returns: All public keys within the given bundle.
      0|  153|    */
      0|  154|    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
      0|  155|        var publicKeys: [SecKey] = []
      0|  156|
      0|  157|        for certificate in certificatesInBundle(bundle) {
      0|  158|            if let publicKey = publicKeyForCertificate(certificate) {
      0|  159|                publicKeys.append(publicKey)
      0|  160|            }
       |  161|        }
       |  162|
       |  163|        return publicKeys
       |  164|    }
       |  165|
       |  166|    // MARK: - Evaluation
       |  167|
       |  168|    /**
       |  169|        Evaluates whether the server trust is valid for the given host.
       |  170|
       |  171|        - parameter serverTrust: The server trust to evaluate.
      0|  172|        - parameter host:        The host of the challenge protection space.
      0|  173|
      0|  174|        - returns: Whether the server trust is valid.
      0|  175|    */
      0|  176|    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
      0|  177|        var serverTrustIsValid = false
      0|  178|
      0|  179|        switch self {
      0|  180|        case let .PerformDefaultEvaluation(validateHost):
      0|  181|            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  182|            SecTrustSetPolicies(serverTrust, [policy])
      0|  183|
      0|  184|            serverTrustIsValid = trustIsValid(serverTrust)
      0|  185|        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
      0|  186|            if validateCertificateChain {
      0|  187|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  188|                SecTrustSetPolicies(serverTrust, [policy])
      0|  189|
      0|  190|                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
      0|  191|                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
      0|  192|
      0|  193|                serverTrustIsValid = trustIsValid(serverTrust)
      0|  194|            } else {
      0|  195|                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
      0|  196|                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
      0|  197|
      0|  198|                outerLoop: for serverCertificateData in serverCertificatesDataArray {
      0|  199|                    for pinnedCertificateData in pinnedCertificatesDataArray {
      0|  200|                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
      0|  201|                            serverTrustIsValid = true
      0|  202|                            break outerLoop
      0|  203|                        }
      0|  204|                    }
      0|  205|                }
      0|  206|            }
      0|  207|        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
      0|  208|            var certificateChainEvaluationPassed = true
      0|  209|
      0|  210|            if validateCertificateChain {
      0|  211|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  212|                SecTrustSetPolicies(serverTrust, [policy])
      0|  213|
      0|  214|                certificateChainEvaluationPassed = trustIsValid(serverTrust)
      0|  215|            }
      0|  216|
      0|  217|            if certificateChainEvaluationPassed {
      0|  218|                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
      0|  219|                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
      0|  220|                        if serverPublicKey.isEqual(pinnedPublicKey) {
      0|  221|                            serverTrustIsValid = true
      0|  222|                            break outerLoop
      0|  223|                        }
      0|  224|                    }
      0|  225|                }
      0|  226|            }
      0|  227|        case .DisableEvaluation:
      0|  228|            serverTrustIsValid = true
      0|  229|        case let .CustomEvaluation(closure):
      0|  230|            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
      0|  231|        }
      0|  232|
      0|  233|        return serverTrustIsValid
      0|  234|    }
      0|  235|
      0|  236|    // MARK: - Private - Trust Validation
      0|  237|
       |  238|    private func trustIsValid(trust: SecTrust) -> Bool {
       |  239|        var isValid = false
       |  240|
      0|  241|        var result = SecTrustResultType(kSecTrustResultInvalid)
      0|  242|        let status = SecTrustEvaluate(trust, &result)
      0|  243|
      0|  244|        if status == errSecSuccess {
      0|  245|            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
      0|  246|            let proceed = SecTrustResultType(kSecTrustResultProceed)
      0|  247|
      0|  248|            isValid = result == unspecified || result == proceed
      0|  249|        }
      0|  250|
      0|  251|        return isValid
      0|  252|    }
      0|  253|
      0|  254|    // MARK: - Private - Certificate Data
      0|  255|
       |  256|    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
       |  257|        var certificates: [SecCertificate] = []
       |  258|
      0|  259|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  260|            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
      0|  261|                certificates.append(certificate)
      0|  262|            }
      0|  263|        }
      0|  264|
      0|  265|        return certificateDataForCertificates(certificates)
      0|  266|    }
      0|  267|
      0|  268|    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
      0|  269|        return certificates.map { SecCertificateCopyData($0) as NSData }
       |  270|    }
      0|  271|
      0|  272|    // MARK: - Private - Public Key Extraction
      0|  273|
       |  274|    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
       |  275|        var publicKeys: [SecKey] = []
       |  276|
      0|  277|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  278|            if let
      0|  279|                certificate = SecTrustGetCertificateAtIndex(trust, index),
      0|  280|                publicKey = publicKeyForCertificate(certificate)
      0|  281|            {
      0|  282|                publicKeys.append(publicKey)
      0|  283|            }
      0|  284|        }
      0|  285|
      0|  286|        return publicKeys
      0|  287|    }
      0|  288|
      0|  289|    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
      0|  290|        var publicKey: SecKey?
       |  291|
      0|  292|        let policy = SecPolicyCreateBasicX509()
      0|  293|        var trust: SecTrust?
      0|  294|        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
      0|  295|
      0|  296|        if let trust = trust where trustCreationStatus == errSecSuccess {
      0|  297|            publicKey = SecTrustCopyPublicKey(trust)
      0|  298|        }
      0|  299|
      0|  300|        return publicKey
      0|  301|    }
      0|  302|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Stream.swift:
       |    1|// Stream.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if !os(watchOS)
       |   26|
       |   27|@available(iOS 9.0, OSX 10.11, *)
       |   28|extension Manager {
       |   29|    private enum Streamable {
       |   30|        case Stream(String, Int)
       |   31|        case NetService(NSNetService)
       |   32|    }
       |   33|
      0|   34|    private func stream(streamable: Streamable) -> Request {
      0|   35|        var streamTask: NSURLSessionStreamTask!
      0|   36|
      0|   37|        switch streamable {
      0|   38|        case .Stream(let hostName, let port):
      0|   39|            dispatch_sync(queue) {
      0|   40|                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
      0|   41|            }
      0|   42|        case .NetService(let netService):
      0|   43|            dispatch_sync(queue) {
      0|   44|                streamTask = self.session.streamTaskWithNetService(netService)
      0|   45|            }
      0|   46|        }
      0|   47|
      0|   48|        let request = Request(session: session, task: streamTask)
      0|   49|
      0|   50|        delegate[request.delegate.task] = request.delegate
      0|   51|
      0|   52|        if startRequestsImmediately {
      0|   53|            request.resume()
      0|   54|        }
      0|   55|
      0|   56|        return request
      0|   57|    }
       |   58|
       |   59|    /**
       |   60|        Creates a request for bidirectional streaming with the given hostname and port.
       |   61|
       |   62|        - parameter hostName: The hostname of the server to connect to.
       |   63|        - parameter port:     The port of the server to connect to.
       |   64|
       |   65|        :returns: The created stream request.
       |   66|    */
      0|   67|    public func stream(hostName hostName: String, port: Int) -> Request {
      0|   68|        return stream(.Stream(hostName, port))
      0|   69|    }
       |   70|
       |   71|    /**
       |   72|        Creates a request for bidirectional streaming with the given `NSNetService`.
       |   73|
       |   74|        - parameter netService: The net service used to identify the endpoint.
       |   75|
       |   76|        - returns: The created stream request.
       |   77|    */
      0|   78|    public func stream(netService netService: NSNetService) -> Request {
      0|   79|        return stream(.NetService(netService))
      0|   80|    }
       |   81|}
       |   82|
       |   83|// MARK: -
       |   84|
       |   85|@available(iOS 9.0, OSX 10.11, *)
       |   86|extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
       |   87|
       |   88|    // MARK: Override Closures
       |   89|
       |   90|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
       |   91|    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|   92|        get {
      0|   93|            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|   94|        }
      0|   95|        set {
      0|   96|            _streamTaskReadClosed = newValue
      0|   97|        }
       |   98|    }
       |   99|
       |  100|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
       |  101|    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  102|        get {
      0|  103|            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  104|        }
      0|  105|        set {
      0|  106|            _streamTaskWriteClosed = newValue
      0|  107|        }
       |  108|    }
       |  109|
       |  110|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
       |  111|    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  112|        get {
      0|  113|            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  114|        }
      0|  115|        set {
      0|  116|            _streamTaskBetterRouteDiscovered = newValue
      0|  117|        }
       |  118|    }
       |  119|
       |  120|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
       |  121|    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
      0|  122|        get {
      0|  123|            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
      0|  124|        }
      0|  125|        set {
      0|  126|            _streamTaskDidBecomeInputStream = newValue
      0|  127|        }
       |  128|    }
       |  129|
       |  130|    // MARK: Delegate Methods
       |  131|
       |  132|    /**
       |  133|        Tells the delegate that the read side of the connection has been closed.
       |  134|
       |  135|        - parameter session:    The session.
       |  136|        - parameter streamTask: The stream task.
       |  137|    */
      0|  138|    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  139|        streamTaskReadClosed?(session, streamTask)
      0|  140|    }
       |  141|
       |  142|    /**
       |  143|        Tells the delegate that the write side of the connection has been closed.
       |  144|
       |  145|        - parameter session:    The session.
       |  146|        - parameter streamTask: The stream task.
       |  147|    */
      0|  148|    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  149|        streamTaskWriteClosed?(session, streamTask)
      0|  150|    }
       |  151|
       |  152|    /**
       |  153|        Tells the delegate that the system has determined that a better route to the host is available.
       |  154|
       |  155|        - parameter session:    The session.
       |  156|        - parameter streamTask: The stream task.
       |  157|    */
      0|  158|    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  159|        streamTaskBetterRouteDiscovered?(session, streamTask)
      0|  160|    }
       |  161|
       |  162|    /**
       |  163|        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
       |  164|
       |  165|        - parameter session:      The session.
       |  166|        - parameter streamTask:   The stream task.
       |  167|        - parameter inputStream:  The new input stream.
       |  168|        - parameter outputStream: The new output stream.
       |  169|    */
       |  170|    public func URLSession(
       |  171|        session: NSURLSession,
       |  172|        streamTask: NSURLSessionStreamTask,
       |  173|        didBecomeInputStream inputStream: NSInputStream,
       |  174|        outputStream: NSOutputStream)
      0|  175|    {
      0|  176|        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
      0|  177|    }
       |  178|}
       |  179|
       |  180|#endif

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Upload.swift:
       |    1|// Upload.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Uploadable {
       |   27|        case Data(NSURLRequest, NSData)
       |   28|        case File(NSURLRequest, NSURL)
       |   29|        case Stream(NSURLRequest, NSInputStream)
       |   30|    }
       |   31|
      0|   32|    private func upload(uploadable: Uploadable) -> Request {
      0|   33|        var uploadTask: NSURLSessionUploadTask!
      0|   34|        var HTTPBodyStream: NSInputStream?
      0|   35|
      0|   36|        switch uploadable {
      0|   37|        case .Data(let request, let data):
      0|   38|            dispatch_sync(queue) {
      0|   39|                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
      0|   40|            }
      0|   41|        case .File(let request, let fileURL):
      0|   42|            dispatch_sync(queue) {
      0|   43|                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
      0|   44|            }
      0|   45|        case .Stream(let request, let stream):
      0|   46|            dispatch_sync(queue) {
      0|   47|                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
      0|   48|            }
      0|   49|
      0|   50|            HTTPBodyStream = stream
      0|   51|        }
      0|   52|
      0|   53|        let request = Request(session: session, task: uploadTask)
      0|   54|
      0|   55|        if HTTPBodyStream != nil {
      0|   56|            request.delegate.taskNeedNewBodyStream = { _, _ in
      0|   57|                return HTTPBodyStream
      0|   58|            }
      0|   59|        }
      0|   60|
      0|   61|        delegate[request.delegate.task] = request.delegate
      0|   62|
      0|   63|        if startRequestsImmediately {
      0|   64|            request.resume()
      0|   65|        }
      0|   66|
      0|   67|        return request
      0|   68|    }
       |   69|
       |   70|    // MARK: File
       |   71|
       |   72|    /**
       |   73|        Creates a request for uploading a file to the specified URL request.
       |   74|
       |   75|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   76|
       |   77|        - parameter URLRequest: The URL request
       |   78|        - parameter file:       The file to upload
       |   79|
       |   80|        - returns: The created upload request.
       |   81|    */
      0|   82|    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|   83|        return upload(.File(URLRequest.URLRequest, file))
      0|   84|    }
       |   85|
       |   86|    /**
       |   87|        Creates a request for uploading a file to the specified URL request.
       |   88|
       |   89|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   90|
       |   91|        - parameter method:    The HTTP method.
       |   92|        - parameter URLString: The URL string.
       |   93|        - parameter headers:   The HTTP headers. `nil` by default.
       |   94|        - parameter file:      The file to upload
       |   95|
       |   96|        - returns: The created upload request.
       |   97|    */
       |   98|    public func upload(
       |   99|        method: Method,
       |  100|        _ URLString: URLStringConvertible,
       |  101|        headers: [String: String]? = nil,
       |  102|        file: NSURL)
       |  103|        -> Request
      0|  104|    {
      0|  105|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  106|        return upload(mutableURLRequest, file: file)
      0|  107|    }
       |  108|
       |  109|    // MARK: Data
       |  110|
       |  111|    /**
       |  112|        Creates a request for uploading data to the specified URL request.
       |  113|
       |  114|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  115|
       |  116|        - parameter URLRequest: The URL request.
       |  117|        - parameter data:       The data to upload.
       |  118|
       |  119|        - returns: The created upload request.
       |  120|    */
      0|  121|    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  122|        return upload(.Data(URLRequest.URLRequest, data))
      0|  123|    }
       |  124|
       |  125|    /**
       |  126|        Creates a request for uploading data to the specified URL request.
       |  127|
       |  128|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  129|
       |  130|        - parameter method:    The HTTP method.
       |  131|        - parameter URLString: The URL string.
       |  132|        - parameter headers:   The HTTP headers. `nil` by default.
       |  133|        - parameter data:      The data to upload
       |  134|
       |  135|        - returns: The created upload request.
       |  136|    */
       |  137|    public func upload(
       |  138|        method: Method,
       |  139|        _ URLString: URLStringConvertible,
       |  140|        headers: [String: String]? = nil,
       |  141|        data: NSData)
       |  142|        -> Request
      0|  143|    {
      0|  144|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  145|
      0|  146|        return upload(mutableURLRequest, data: data)
      0|  147|    }
       |  148|
       |  149|    // MARK: Stream
       |  150|
       |  151|    /**
       |  152|        Creates a request for uploading a stream to the specified URL request.
       |  153|
       |  154|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  155|
       |  156|        - parameter URLRequest: The URL request.
       |  157|        - parameter stream:     The stream to upload.
       |  158|
       |  159|        - returns: The created upload request.
       |  160|    */
      0|  161|    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  162|        return upload(.Stream(URLRequest.URLRequest, stream))
      0|  163|    }
       |  164|
       |  165|    /**
       |  166|        Creates a request for uploading a stream to the specified URL request.
       |  167|
       |  168|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  169|
       |  170|        - parameter method:    The HTTP method.
       |  171|        - parameter URLString: The URL string.
       |  172|        - parameter headers:   The HTTP headers. `nil` by default.
       |  173|        - parameter stream:    The stream to upload.
       |  174|
       |  175|        - returns: The created upload request.
       |  176|    */
       |  177|    public func upload(
       |  178|        method: Method,
       |  179|        _ URLString: URLStringConvertible,
       |  180|        headers: [String: String]? = nil,
       |  181|        stream: NSInputStream)
       |  182|        -> Request
      0|  183|    {
      0|  184|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  185|
      0|  186|        return upload(mutableURLRequest, stream: stream)
      0|  187|    }
       |  188|
       |  189|    // MARK: MultipartFormData
       |  190|
       |  191|    /// Default memory threshold used when encoding `MultipartFormData`.
       |  192|    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
       |  193|
       |  194|    /**
       |  195|        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
       |  196|        associated values.
       |  197|
       |  198|        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
       |  199|                   streaming information.
       |  200|        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
       |  201|                   error.
       |  202|    */
       |  203|    public enum MultipartFormDataEncodingResult {
       |  204|        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
       |  205|        case Failure(ErrorType)
       |  206|    }
       |  207|
       |  208|    /**
       |  209|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  210|
       |  211|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
       |  212|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
       |  213|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
       |  214|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
       |  215|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
       |  216|        used for larger payloads such as video content.
       |  217|
       |  218|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
       |  219|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  220|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
       |  221|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
       |  222|        technique was used.
       |  223|
       |  224|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  225|
       |  226|        - parameter method:                  The HTTP method.
       |  227|        - parameter URLString:               The URL string.
       |  228|        - parameter headers:                 The HTTP headers. `nil` by default.
       |  229|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  230|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  231|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  232|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  233|    */
       |  234|    public func upload(
       |  235|        method: Method,
       |  236|        _ URLString: URLStringConvertible,
       |  237|        headers: [String: String]? = nil,
       |  238|        multipartFormData: MultipartFormData -> Void,
       |  239|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  240|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  241|    {
      0|  242|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  243|
      0|  244|        return upload(
      0|  245|            mutableURLRequest,
      0|  246|            multipartFormData: multipartFormData,
      0|  247|            encodingMemoryThreshold: encodingMemoryThreshold,
      0|  248|            encodingCompletion: encodingCompletion
      0|  249|        )
      0|  250|    }
       |  251|
       |  252|    /**
       |  253|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  254|
       |  255|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
       |  256|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
       |  257|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
       |  258|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
       |  259|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
       |  260|        used for larger payloads such as video content.
       |  261|
       |  262|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
       |  263|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  264|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
       |  265|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
       |  266|        technique was used.
       |  267|
       |  268|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  269|
       |  270|        - parameter URLRequest:              The URL request.
       |  271|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  272|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  273|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  274|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  275|    */
       |  276|    public func upload(
       |  277|        URLRequest: URLRequestConvertible,
       |  278|        multipartFormData: MultipartFormData -> Void,
       |  279|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  280|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  281|    {
      0|  282|        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
      0|  283|            let formData = MultipartFormData()
      0|  284|            multipartFormData(formData)
      0|  285|
      0|  286|            let URLRequestWithContentType = URLRequest.URLRequest
      0|  287|            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
      0|  288|
      0|  289|            let isBackgroundSession = self.session.configuration.identifier != nil
      0|  290|
      0|  291|            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
      0|  292|                do {
      0|  293|                    let data = try formData.encode()
      0|  294|                    let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  295|                        request: self.upload(URLRequestWithContentType, data: data),
      0|  296|                        streamingFromDisk: false,
      0|  297|                        streamFileURL: nil
      0|  298|                    )
      0|  299|
      0|  300|                    dispatch_async(dispatch_get_main_queue()) {
      0|  301|                        encodingCompletion?(encodingResult)
      0|  302|                    }
      0|  303|                } catch {
      0|  304|                    dispatch_async(dispatch_get_main_queue()) {
      0|  305|                        encodingCompletion?(.Failure(error as NSError))
      0|  306|                    }
      0|  307|                }
      0|  308|            } else {
      0|  309|                let fileManager = NSFileManager.defaultManager()
      0|  310|                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
      0|  311|                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
      0|  312|                let fileName = NSUUID().UUIDString
      0|  313|                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
      0|  314|
      0|  315|                do {
      0|  316|                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
      0|  317|                    try formData.writeEncodedDataToDisk(fileURL)
      0|  318|
      0|  319|                    dispatch_async(dispatch_get_main_queue()) {
      0|  320|                        let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  321|                            request: self.upload(URLRequestWithContentType, file: fileURL),
      0|  322|                            streamingFromDisk: true,
      0|  323|                            streamFileURL: fileURL
      0|  324|                        )
      0|  325|                        encodingCompletion?(encodingResult)
      0|  326|                    }
      0|  327|                } catch {
      0|  328|                    dispatch_async(dispatch_get_main_queue()) {
      0|  329|                        encodingCompletion?(.Failure(error as NSError))
      0|  330|                    }
      0|  331|                }
      0|  332|            }
      0|  333|        }
      0|  334|    }
       |  335|}
       |  336|
       |  337|// MARK: -
       |  338|
       |  339|extension Request {
       |  340|
       |  341|    // MARK: - UploadTaskDelegate
       |  342|
       |  343|    class UploadTaskDelegate: DataTaskDelegate {
      0|  344|        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
       |  345|        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
       |  346|
       |  347|        // MARK: - NSURLSessionTaskDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  352|
       |  353|        // MARK: Delegate Methods
       |  354|
       |  355|        func URLSession(
       |  356|            session: NSURLSession,
       |  357|            task: NSURLSessionTask,
       |  358|            didSendBodyData bytesSent: Int64,
       |  359|            totalBytesSent: Int64,
       |  360|            totalBytesExpectedToSend: Int64)
      0|  361|        {
      0|  362|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  363|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  364|            } else {
      0|  365|                progress.totalUnitCount = totalBytesExpectedToSend
      0|  366|                progress.completedUnitCount = totalBytesSent
      0|  367|
      0|  368|                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  369|            }
      0|  370|        }
       |  371|    }
       |  372|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Validation.swift:
       |    1|// Validation.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Request {
       |   26|
       |   27|    /**
       |   28|        Used to represent whether validation was successful or encountered an error resulting in a failure.
       |   29|
       |   30|        - Success: The validation was successful.
       |   31|        - Failure: The validation failed encountering the provided error.
       |   32|    */
       |   33|    public enum ValidationResult {
       |   34|        case Success
       |   35|        case Failure(NSError)
       |   36|    }
       |   37|
       |   38|    /**
       |   39|        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
       |   40|        request was valid.
       |   41|    */
       |   42|    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
       |   43|
       |   44|    /**
       |   45|        Validates the request, using the specified closure.
       |   46|
       |   47|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   48|
       |   49|        - parameter validation: A closure to validate the request.
       |   50|
       |   51|        - returns: The request.
       |   52|    */
      0|   53|    public func validate(validation: Validation) -> Self {
      0|   54|        delegate.queue.addOperationWithBlock {
      0|   55|            if let
      0|   56|                response = self.response where self.delegate.error == nil,
      0|   57|                case let .Failure(error) = validation(self.request, response)
      0|   58|            {
      0|   59|                self.delegate.error = error
      0|   60|            }
      0|   61|        }
      0|   62|
      0|   63|        return self
      0|   64|    }
       |   65|
       |   66|    // MARK: - Status Code
       |   67|
       |   68|    /**
       |   69|        Validates that the response has a status code in the specified range.
       |   70|
       |   71|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   72|
       |   73|        - parameter range: The range of acceptable status codes.
       |   74|
       |   75|        - returns: The request.
       |   76|    */
      0|   77|    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
      0|   78|        return validate { _, response in
      0|   79|            if acceptableStatusCode.contains(response.statusCode) {
      0|   80|                return .Success
      0|   81|            } else {
      0|   82|                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
      0|   83|                return .Failure(Error.errorWithCode(.StatusCodeValidationFailed, failureReason: failureReason))
      0|   84|            }
      0|   85|        }
      0|   86|    }
       |   87|
       |   88|    // MARK: - Content-Type
       |   89|
       |   90|    private struct MIMEType {
       |   91|        let type: String
       |   92|        let subtype: String
       |   93|
      0|   94|        init?(_ string: String) {
      0|   95|            let components: [String] = {
      0|   96|                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
      0|   97|                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
      0|   98|                return split.componentsSeparatedByString("/")
      0|   99|            }()
      0|  100|
      0|  101|            if let
      0|  102|                type = components.first,
      0|  103|                subtype = components.last
      0|  104|            {
      0|  105|                self.type = type
      0|  106|                self.subtype = subtype
      0|  107|            } else {
      0|  108|                return nil
      0|  109|            }
      0|  110|        }
       |  111|
      0|  112|        func matches(MIME: MIMEType) -> Bool {
      0|  113|            switch (type, subtype) {
      0|  114|            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
      0|  115|                return true
      0|  116|            default:
      0|  117|                return false
      0|  118|            }
      0|  119|        }
       |  120|    }
       |  121|
       |  122|    /**
       |  123|        Validates that the response has a content type in the specified array.
       |  124|
       |  125|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  126|
       |  127|        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
       |  128|
       |  129|        - returns: The request.
       |  130|    */
      0|  131|    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
      0|  132|        return validate { _, response in
      0|  133|            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
      0|  134|
      0|  135|            if let
      0|  136|                responseContentType = response.MIMEType,
      0|  137|                responseMIMEType = MIMEType(responseContentType)
      0|  138|            {
      0|  139|                for contentType in acceptableContentTypes {
      0|  140|                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
      0|  141|                        return .Success
      0|  142|                    }
      0|  143|                }
      0|  144|            } else {
      0|  145|                for contentType in acceptableContentTypes {
      0|  146|                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
      0|  147|                        return .Success
      0|  148|                    }
      0|  149|                }
      0|  150|            }
      0|  151|
      0|  152|            let failureReason: String
      0|  153|
      0|  154|            if let responseContentType = response.MIMEType {
      0|  155|                failureReason = (
      0|  156|                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
      0|  157|                    "content types: \(acceptableContentTypes)"
      0|  158|                )
      0|  159|            } else {
      0|  160|                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
      0|  161|            }
      0|  162|
      0|  163|            return .Failure(Error.errorWithCode(.ContentTypeValidationFailed, failureReason: failureReason))
      0|  164|        }
      0|  165|    }
       |  166|
       |  167|    // MARK: - Automatic
       |  168|
       |  169|    /**
       |  170|        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
       |  171|        type matches any specified in the Accept HTTP header field.
       |  172|
       |  173|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  174|
       |  175|        - returns: The request.
       |  176|    */
      0|  177|    public func validate() -> Self {
      0|  178|        let acceptableStatusCodes: Range<Int> = 200..<300
      0|  179|        let acceptableContentTypes: [String] = {
      0|  180|            if let accept = request?.valueForHTTPHeaderField("Accept") {
      0|  181|                return accept.componentsSeparatedByString(",")
      0|  182|            }
      0|  183|
      0|  184|            return ["*/*"]
      0|  185|        }()
      0|  186|
      0|  187|        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
      0|  188|    }
       |  189|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Alamofire.swift:
       |    1|// Alamofire.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: - URLStringConvertible
       |   26|
       |   27|/**
       |   28|    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
       |   29|    construct URL requests.
       |   30|*/
       |   31|public protocol URLStringConvertible {
       |   32|    /**
       |   33|        A URL that conforms to RFC 2396.
       |   34|
       |   35|        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
       |   36|
       |   37|        See https://tools.ietf.org/html/rfc2396
       |   38|        See https://tools.ietf.org/html/rfc1738
       |   39|        See https://tools.ietf.org/html/rfc1808
       |   40|    */
       |   41|    var URLString: String { get }
       |   42|}
       |   43|
       |   44|extension String: URLStringConvertible {
      1|   45|    public var URLString: String {
      1|   46|        return self
      1|   47|    }
       |   48|}
       |   49|
       |   50|extension NSURL: URLStringConvertible {
      0|   51|    public var URLString: String {
      0|   52|        return absoluteString
      0|   53|    }
       |   54|}
       |   55|
       |   56|extension NSURLComponents: URLStringConvertible {
      0|   57|    public var URLString: String {
      0|   58|        return URL!.URLString
      0|   59|    }
       |   60|}
       |   61|
       |   62|extension NSURLRequest: URLStringConvertible {
      0|   63|    public var URLString: String {
      0|   64|        return URL!.URLString
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - URLRequestConvertible
       |   69|
       |   70|/**
       |   71|    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
       |   72|*/
       |   73|public protocol URLRequestConvertible {
       |   74|    /// The URL request.
       |   75|    var URLRequest: NSMutableURLRequest { get }
       |   76|}
       |   77|
       |   78|extension NSURLRequest: URLRequestConvertible {
      2|   79|    public var URLRequest: NSMutableURLRequest {
      2|   80|        return self.mutableCopy() as! NSMutableURLRequest
      2|   81|    }
       |   82|}
       |   83|
       |   84|// MARK: - Convenience
       |   85|
       |   86|func URLRequest(
       |   87|    method: Method,
       |   88|    _ URLString: URLStringConvertible,
       |   89|    headers: [String: String]? = nil)
       |   90|    -> NSMutableURLRequest
      1|   91|{
      1|   92|    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
      1|   93|    mutableURLRequest.HTTPMethod = method.rawValue
      1|   94|
      1|   95|    if let headers = headers {
      2|   96|        for (headerField, headerValue) in headers {
      2|   97|            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
      2|   98|        }
      1|   99|    }
      1|  100|
      1|  101|    return mutableURLRequest
      1|  102|}
       |  103|
       |  104|// MARK: - Request Methods
       |  105|
       |  106|/**
       |  107|    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
       |  108|    parameter encoding.
       |  109|
       |  110|    - parameter method:     The HTTP method.
       |  111|    - parameter URLString:  The URL string.
       |  112|    - parameter parameters: The parameters. `nil` by default.
       |  113|    - parameter encoding:   The parameter encoding. `.URL` by default.
       |  114|    - parameter headers:    The HTTP headers. `nil` by default.
       |  115|
       |  116|    - returns: The created request.
       |  117|*/
       |  118|public func request(
       |  119|    method: Method,
       |  120|    _ URLString: URLStringConvertible,
       |  121|    parameters: [String: AnyObject]? = nil,
       |  122|    encoding: ParameterEncoding = .URL,
       |  123|    headers: [String: String]? = nil)
       |  124|    -> Request
      1|  125|{
      1|  126|    return Manager.sharedInstance.request(
      1|  127|        method,
      1|  128|        URLString,
      1|  129|        parameters: parameters,
      1|  130|        encoding: encoding,
      1|  131|        headers: headers
      1|  132|    )
      1|  133|}
       |  134|
       |  135|/**
       |  136|    Creates a request using the shared manager instance for the specified URL request.
       |  137|
       |  138|    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  139|
       |  140|    - parameter URLRequest: The URL request
       |  141|
       |  142|    - returns: The created request.
       |  143|*/
      0|  144|public func request(URLRequest: URLRequestConvertible) -> Request {
      0|  145|    return Manager.sharedInstance.request(URLRequest.URLRequest)
      0|  146|}
       |  147|
       |  148|// MARK: - Upload Methods
       |  149|
       |  150|// MARK: File
       |  151|
       |  152|/**
       |  153|    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
       |  154|
       |  155|    - parameter method:    The HTTP method.
       |  156|    - parameter URLString: The URL string.
       |  157|    - parameter headers:   The HTTP headers. `nil` by default.
       |  158|    - parameter file:      The file to upload.
       |  159|
       |  160|    - returns: The created upload request.
       |  161|*/
       |  162|public func upload(
       |  163|    method: Method,
       |  164|    _ URLString: URLStringConvertible,
       |  165|    headers: [String: String]? = nil,
       |  166|    file: NSURL)
       |  167|    -> Request
      0|  168|{
      0|  169|    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
      0|  170|}
       |  171|
       |  172|/**
       |  173|    Creates an upload request using the shared manager instance for the specified URL request and file.
       |  174|
       |  175|    - parameter URLRequest: The URL request.
       |  176|    - parameter file:       The file to upload.
       |  177|
       |  178|    - returns: The created upload request.
       |  179|*/
      0|  180|public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|  181|    return Manager.sharedInstance.upload(URLRequest, file: file)
      0|  182|}
       |  183|
       |  184|// MARK: Data
       |  185|
       |  186|/**
       |  187|    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
       |  188|
       |  189|    - parameter method:    The HTTP method.
       |  190|    - parameter URLString: The URL string.
       |  191|    - parameter headers:   The HTTP headers. `nil` by default.
       |  192|    - parameter data:      The data to upload.
       |  193|
       |  194|    - returns: The created upload request.
       |  195|*/
       |  196|public func upload(
       |  197|    method: Method,
       |  198|    _ URLString: URLStringConvertible,
       |  199|    headers: [String: String]? = nil,
       |  200|    data: NSData)
       |  201|    -> Request
      0|  202|{
      0|  203|    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
      0|  204|}
       |  205|
       |  206|/**
       |  207|    Creates an upload request using the shared manager instance for the specified URL request and data.
       |  208|
       |  209|    - parameter URLRequest: The URL request.
       |  210|    - parameter data:       The data to upload.
       |  211|
       |  212|    - returns: The created upload request.
       |  213|*/
      0|  214|public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  215|    return Manager.sharedInstance.upload(URLRequest, data: data)
      0|  216|}
       |  217|
       |  218|// MARK: Stream
       |  219|
       |  220|/**
       |  221|    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
       |  222|
       |  223|    - parameter method:    The HTTP method.
       |  224|    - parameter URLString: The URL string.
       |  225|    - parameter headers:   The HTTP headers. `nil` by default.
       |  226|    - parameter stream:    The stream to upload.
       |  227|
       |  228|    - returns: The created upload request.
       |  229|*/
       |  230|public func upload(
       |  231|    method: Method,
       |  232|    _ URLString: URLStringConvertible,
       |  233|    headers: [String: String]? = nil,
       |  234|    stream: NSInputStream)
       |  235|    -> Request
      0|  236|{
      0|  237|    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
      0|  238|}
       |  239|
       |  240|/**
       |  241|    Creates an upload request using the shared manager instance for the specified URL request and stream.
       |  242|
       |  243|    - parameter URLRequest: The URL request.
       |  244|    - parameter stream:     The stream to upload.
       |  245|
       |  246|    - returns: The created upload request.
       |  247|*/
      0|  248|public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  249|    return Manager.sharedInstance.upload(URLRequest, stream: stream)
      0|  250|}
       |  251|
       |  252|// MARK: MultipartFormData
       |  253|
       |  254|/**
       |  255|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  256|
       |  257|    - parameter method:                  The HTTP method.
       |  258|    - parameter URLString:               The URL string.
       |  259|    - parameter headers:                 The HTTP headers. `nil` by default.
       |  260|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  261|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  262|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  263|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  264|*/
       |  265|public func upload(
       |  266|    method: Method,
       |  267|    _ URLString: URLStringConvertible,
       |  268|    headers: [String: String]? = nil,
       |  269|    multipartFormData: MultipartFormData -> Void,
       |  270|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  271|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  272|{
      0|  273|    return Manager.sharedInstance.upload(
      0|  274|        method,
      0|  275|        URLString,
      0|  276|        headers: headers,
      0|  277|        multipartFormData: multipartFormData,
      0|  278|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  279|        encodingCompletion: encodingCompletion
      0|  280|    )
      0|  281|}
       |  282|
       |  283|/**
       |  284|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  285|
       |  286|    - parameter URLRequest:              The URL request.
       |  287|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  288|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  289|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  290|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  291|*/
       |  292|public func upload(
       |  293|    URLRequest: URLRequestConvertible,
       |  294|    multipartFormData: MultipartFormData -> Void,
       |  295|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  296|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  297|{
      0|  298|    return Manager.sharedInstance.upload(
      0|  299|        URLRequest,
      0|  300|        multipartFormData: multipartFormData,
      0|  301|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  302|        encodingCompletion: encodingCompletion
      0|  303|    )
      0|  304|}
       |  305|
       |  306|// MARK: - Download Methods
       |  307|
       |  308|// MARK: URL Request
       |  309|
       |  310|/**
       |  311|    Creates a download request using the shared manager instance for the specified method and URL string.
       |  312|
       |  313|    - parameter method:      The HTTP method.
       |  314|    - parameter URLString:   The URL string.
       |  315|    - parameter parameters:  The parameters. `nil` by default.
       |  316|    - parameter encoding:    The parameter encoding. `.URL` by default.
       |  317|    - parameter headers:     The HTTP headers. `nil` by default.
       |  318|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  319|
       |  320|    - returns: The created download request.
       |  321|*/
       |  322|public func download(
       |  323|    method: Method,
       |  324|    _ URLString: URLStringConvertible,
       |  325|    parameters: [String: AnyObject]? = nil,
       |  326|    encoding: ParameterEncoding = .URL,
       |  327|    headers: [String: String]? = nil,
       |  328|    destination: Request.DownloadFileDestination)
       |  329|    -> Request
      0|  330|{
      0|  331|    return Manager.sharedInstance.download(
      0|  332|        method,
      0|  333|        URLString,
      0|  334|        parameters: parameters,
      0|  335|        encoding: encoding,
      0|  336|        headers: headers,
      0|  337|        destination: destination
      0|  338|    )
      0|  339|}
       |  340|
       |  341|/**
       |  342|    Creates a download request using the shared manager instance for the specified URL request.
       |  343|
       |  344|    - parameter URLRequest:  The URL request.
       |  345|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  346|
       |  347|    - returns: The created download request.
       |  348|*/
      0|  349|public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  350|    return Manager.sharedInstance.download(URLRequest, destination: destination)
      0|  351|}
       |  352|
       |  353|// MARK: Resume Data
       |  354|
       |  355|/**
       |  356|    Creates a request using the shared manager instance for downloading from the resume data produced from a 
       |  357|    previous request cancellation.
       |  358|
       |  359|    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
       |  360|                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
       |  361|                             information.
       |  362|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  363|
       |  364|    - returns: The created download request.
       |  365|*/
      0|  366|public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  367|    return Manager.sharedInstance.download(data, destination: destination)
      0|  368|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Download.swift:
       |    1|// Download.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Downloadable {
       |   27|        case Request(NSURLRequest)
       |   28|        case ResumeData(NSData)
       |   29|    }
       |   30|
      0|   31|    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
      0|   32|        var downloadTask: NSURLSessionDownloadTask!
      0|   33|
      0|   34|        switch downloadable {
      0|   35|        case .Request(let request):
      0|   36|            dispatch_sync(queue) {
      0|   37|                downloadTask = self.session.downloadTaskWithRequest(request)
      0|   38|            }
      0|   39|        case .ResumeData(let resumeData):
      0|   40|            dispatch_sync(queue) {
      0|   41|                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
      0|   42|            }
      0|   43|        }
      0|   44|
      0|   45|        let request = Request(session: session, task: downloadTask)
      0|   46|
      0|   47|        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
      0|   48|            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
      0|   49|                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
      0|   50|            }
      0|   51|        }
      0|   52|
      0|   53|        delegate[request.delegate.task] = request.delegate
      0|   54|
      0|   55|        if startRequestsImmediately {
      0|   56|            request.resume()
      0|   57|        }
      0|   58|
      0|   59|        return request
      0|   60|    }
       |   61|
       |   62|    // MARK: Request
       |   63|
       |   64|    /**
       |   65|        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
       |   66|        and destination.
       |   67|
       |   68|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   69|
       |   70|        - parameter method:      The HTTP method.
       |   71|        - parameter URLString:   The URL string.
       |   72|        - parameter parameters:  The parameters. `nil` by default.
       |   73|        - parameter encoding:    The parameter encoding. `.URL` by default.
       |   74|        - parameter headers:     The HTTP headers. `nil` by default.
       |   75|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |   76|
       |   77|        - returns: The created download request.
       |   78|    */
       |   79|    public func download(
       |   80|        method: Method,
       |   81|        _ URLString: URLStringConvertible,
       |   82|        parameters: [String: AnyObject]? = nil,
       |   83|        encoding: ParameterEncoding = .URL,
       |   84|        headers: [String: String]? = nil,
       |   85|        destination: Request.DownloadFileDestination)
       |   86|        -> Request
      0|   87|    {
      0|   88|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|   89|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      0|   90|
      0|   91|        return download(encodedURLRequest, destination: destination)
      0|   92|    }
       |   93|
       |   94|    /**
       |   95|        Creates a request for downloading from the specified URL request.
       |   96|
       |   97|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   98|
       |   99|        - parameter URLRequest:  The URL request
       |  100|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  101|
       |  102|        - returns: The created download request.
       |  103|    */
      0|  104|    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  105|        return download(.Request(URLRequest.URLRequest), destination: destination)
      0|  106|    }
       |  107|
       |  108|    // MARK: Resume Data
       |  109|
       |  110|    /**
       |  111|        Creates a request for downloading from the resume data produced from a previous request cancellation.
       |  112|
       |  113|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  114|
       |  115|        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
       |  116|                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
       |  117|                                 additional information.
       |  118|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  119|
       |  120|        - returns: The created download request.
       |  121|    */
      0|  122|    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  123|        return download(.ResumeData(resumeData), destination: destination)
      0|  124|    }
       |  125|}
       |  126|
       |  127|// MARK: -
       |  128|
       |  129|extension Request {
       |  130|    /**
       |  131|        A closure executed once a request has successfully completed in order to determine where to move the temporary 
       |  132|        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
       |  133|        response, and returns a single argument: the file URL where the temporary file should be moved.
       |  134|    */
       |  135|    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
       |  136|
       |  137|    /**
       |  138|        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
       |  139|        file URL in the first available directory with the specified search path directory and search path domain mask.
       |  140|
       |  141|        - parameter directory: The search path directory. `.DocumentDirectory` by default.
       |  142|        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
       |  143|
       |  144|        - returns: A download file destination closure.
       |  145|    */
       |  146|    public class func suggestedDownloadDestination(
       |  147|        directory directory: NSSearchPathDirectory = .DocumentDirectory,
       |  148|        domain: NSSearchPathDomainMask = .UserDomainMask)
       |  149|        -> DownloadFileDestination
      0|  150|    {
      0|  151|        return { temporaryURL, response -> NSURL in
      0|  152|            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
      0|  153|
      0|  154|            if !directoryURLs.isEmpty {
      0|  155|                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
      0|  156|            }
      0|  157|
      0|  158|            return temporaryURL
      0|  159|        }
      0|  160|    }
       |  161|
       |  162|    /// The resume data of the underlying download task if available after a failure.
      0|  163|    public var resumeData: NSData? {
      0|  164|        var data: NSData?
      0|  165|
      0|  166|        if let delegate = delegate as? DownloadTaskDelegate {
      0|  167|            data = delegate.resumeData
      0|  168|        }
      0|  169|
      0|  170|        return data
      0|  171|    }
       |  172|
       |  173|    // MARK: - DownloadTaskDelegate
       |  174|
       |  175|    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
      0|  176|        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
       |  177|        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
       |  178|
       |  179|        var resumeData: NSData?
      0|  180|        override var data: NSData? { return resumeData }
       |  181|
       |  182|        // MARK: - NSURLSessionDownloadDelegate
       |  183|
       |  184|        // MARK: Override Closures
       |  185|
       |  186|        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
       |  187|        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  188|        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  189|
       |  190|        // MARK: Delegate Methods
       |  191|
       |  192|        func URLSession(
       |  193|            session: NSURLSession,
       |  194|            downloadTask: NSURLSessionDownloadTask,
       |  195|            didFinishDownloadingToURL location: NSURL)
      0|  196|        {
      0|  197|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  198|                do {
      0|  199|                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  200|                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
      0|  201|                } catch {
      0|  202|                    self.error = error as NSError
      0|  203|                }
      0|  204|            }
      0|  205|        }
       |  206|
       |  207|        func URLSession(
       |  208|            session: NSURLSession,
       |  209|            downloadTask: NSURLSessionDownloadTask,
       |  210|            didWriteData bytesWritten: Int64,
       |  211|            totalBytesWritten: Int64,
       |  212|            totalBytesExpectedToWrite: Int64)
      0|  213|        {
      0|  214|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  215|                downloadTaskDidWriteData(
      0|  216|                    session,
      0|  217|                    downloadTask,
      0|  218|                    bytesWritten,
      0|  219|                    totalBytesWritten, 
      0|  220|                    totalBytesExpectedToWrite
      0|  221|                )
      0|  222|            } else {
      0|  223|                progress.totalUnitCount = totalBytesExpectedToWrite
      0|  224|                progress.completedUnitCount = totalBytesWritten
      0|  225|
      0|  226|                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  227|            }
      0|  228|        }
       |  229|
       |  230|        func URLSession(
       |  231|            session: NSURLSession,
       |  232|            downloadTask: NSURLSessionDownloadTask,
       |  233|            didResumeAtOffset fileOffset: Int64,
       |  234|            expectedTotalBytes: Int64)
      0|  235|        {
      0|  236|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  237|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  238|            } else {
      0|  239|                progress.totalUnitCount = expectedTotalBytes
      0|  240|                progress.completedUnitCount = fileOffset
      0|  241|            }
      0|  242|        }
       |  243|    }
       |  244|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Error.swift:
       |    1|// Error.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
       |   26|public struct Error {
       |   27|    /// The domain used for creating all Alamofire errors.
       |   28|    public static let Domain = "com.alamofire.error"
       |   29|
       |   30|    /// The custom error codes generated by Alamofire.
       |   31|    public enum Code: Int {
       |   32|        case InputStreamReadFailed           = -6000
       |   33|        case OutputStreamWriteFailed         = -6001
       |   34|        case ContentTypeValidationFailed     = -6002
       |   35|        case StatusCodeValidationFailed      = -6003
       |   36|        case DataSerializationFailed         = -6004
       |   37|        case StringSerializationFailed       = -6005
       |   38|        case JSONSerializationFailed         = -6006
       |   39|        case PropertyListSerializationFailed = -6007
       |   40|    }
       |   41|
       |   42|    /**
       |   43|        Creates an `NSError` with the given error code and failure reason.
       |   44|
       |   45|        - parameter code:          The error code.
       |   46|        - parameter failureReason: The failure reason.
       |   47|
       |   48|        - returns: An `NSError` with the given error code and failure reason.
       |   49|    */
      0|   50|    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
      0|   51|        return errorWithCode(code.rawValue, failureReason: failureReason)
      0|   52|    }
       |   53|
       |   54|    /**
       |   55|        Creates an `NSError` with the given error code and failure reason.
       |   56|
       |   57|        - parameter code:          The error code.
       |   58|        - parameter failureReason: The failure reason.
       |   59|
       |   60|        - returns: An `NSError` with the given error code and failure reason.
       |   61|    */
      0|   62|    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
      0|   63|        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
      0|   64|        return NSError(domain: Domain, code: code, userInfo: userInfo)
      0|   65|    }
       |   66|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Manager.swift:
       |    1|// Manager.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
       |   27|*/
       |   28|public class Manager {
       |   29|
       |   30|    // MARK: - Properties
       |   31|
       |   32|    /**
       |   33|        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
       |   34|        for any ad hoc requests.
       |   35|    */
       |   36|    public static let sharedInstance: Manager = {
       |   37|        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
       |   38|        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
       |   39|
       |   40|        return Manager(configuration: configuration)
       |   41|    }()
       |   42|
       |   43|    /**
       |   44|        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
       |   45|    */
       |   46|    public static let defaultHTTPHeaders: [String: String] = {
       |   47|        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
       |   48|        let acceptEncoding: String = "gzip;q=1.0,compress;q=0.5"
       |   49|
       |   50|        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
       |   51|        let acceptLanguage: String = {
       |   52|            var components: [String] = []
       |   53|            for (index, languageCode) in (NSLocale.preferredLanguages() as [String]).enumerate() {
       |   54|                let q = 1.0 - (Double(index) * 0.1)
       |   55|                components.append("\(languageCode);q=\(q)")
       |   56|                if q <= 0.5 {
       |   57|                    break
       |   58|                }
       |   59|            }
       |   60|
       |   61|            return components.joinWithSeparator(",")
       |   62|        }()
       |   63|
       |   64|        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
       |   65|        let userAgent: String = {
       |   66|            if let info = NSBundle.mainBundle().infoDictionary {
       |   67|                let executable: AnyObject = info[kCFBundleExecutableKey as String] ?? "Unknown"
       |   68|                let bundle: AnyObject = info[kCFBundleIdentifierKey as String] ?? "Unknown"
       |   69|                let version: AnyObject = info[kCFBundleVersionKey as String] ?? "Unknown"
       |   70|                let os: AnyObject = NSProcessInfo.processInfo().operatingSystemVersionString ?? "Unknown"
       |   71|
       |   72|                var mutableUserAgent = NSMutableString(string: "\(executable)/\(bundle) (\(version); OS \(os))") as CFMutableString
       |   73|                let transform = NSString(string: "Any-Latin; Latin-ASCII; [:^ASCII:] Remove") as CFString
       |   74|
       |   75|                if CFStringTransform(mutableUserAgent, UnsafeMutablePointer<CFRange>(nil), transform, false) {
       |   76|                    return mutableUserAgent as String
       |   77|                }
       |   78|            }
       |   79|
       |   80|            return "Alamofire"
       |   81|        }()
       |   82|
       |   83|        return [
       |   84|            "Accept-Encoding": acceptEncoding,
       |   85|            "Accept-Language": acceptLanguage,
       |   86|            "User-Agent": userAgent
       |   87|        ]
       |   88|    }()
       |   89|
       |   90|    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
       |   91|
       |   92|    /// The underlying session.
       |   93|    public let session: NSURLSession
       |   94|
       |   95|    /// The session delegate handling all the task and session delegate callbacks.
       |   96|    public let delegate: SessionDelegate
       |   97|
       |   98|    /// Whether to start requests immediately after being constructed. `true` by default.
       |   99|    public var startRequestsImmediately: Bool = true
       |  100|
       |  101|    /**
       |  102|        The background completion handler closure provided by the UIApplicationDelegate 
       |  103|        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
       |  104|        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
       |  105|        will automatically call the handler.
       |  106|    
       |  107|        If you need to handle your own events before the handler is called, then you need to override the 
       |  108|        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
       |  109|    
       |  110|        `nil` by default.
       |  111|    */
       |  112|    public var backgroundCompletionHandler: (() -> Void)?
       |  113|
       |  114|    // MARK: - Lifecycle
       |  115|
       |  116|    /**
       |  117|        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
       |  118|
       |  119|        - parameter configuration:            The configuration used to construct the managed session. 
       |  120|                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
       |  121|        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
       |  122|                                              default.
       |  123|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
       |  124|                                              challenges. `nil` by default.
       |  125|
       |  126|        - returns: The new `Manager` instance.
       |  127|    */
       |  128|    public init(
       |  129|        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
       |  130|        delegate: SessionDelegate = SessionDelegate(),
       |  131|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      1|  132|    {
      1|  133|        self.delegate = delegate
      1|  134|        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
      1|  135|
      1|  136|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      1|  137|    }
       |  138|
       |  139|    /**
       |  140|        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
       |  141|
       |  142|        - parameter session:                  The URL session.
       |  143|        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
       |  144|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
       |  145|                                              challenges. `nil` by default.
       |  146|
       |  147|        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
       |  148|    */
       |  149|    public init?(
       |  150|        session: NSURLSession,
       |  151|        delegate: SessionDelegate,
       |  152|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      0|  153|    {
      0|  154|        self.delegate = delegate
      0|  155|        self.session = session
      0|  156|
      0|  157|        guard delegate === session.delegate else { return nil }
      0|  158|
      0|  159|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      0|  160|    }
       |  161|
      1|  162|    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
      1|  163|        session.serverTrustPolicyManager = serverTrustPolicyManager
      1|  164|
      0|  165|        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
      0|  166|            guard let strongSelf = self else { return }
      0|  167|            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
      0|  168|        }
      1|  169|    }
       |  170|
      0|  171|    deinit {
      0|  172|        session.invalidateAndCancel()
      0|  173|    }
       |  174|
       |  175|    // MARK: - Request
       |  176|
       |  177|    /**
       |  178|        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
       |  179|
       |  180|        - parameter method:     The HTTP method.
       |  181|        - parameter URLString:  The URL string.
       |  182|        - parameter parameters: The parameters. `nil` by default.
       |  183|        - parameter encoding:   The parameter encoding. `.URL` by default.
       |  184|        - parameter headers:    The HTTP headers. `nil` by default.
       |  185|
       |  186|        - returns: The created request.
       |  187|    */
       |  188|    public func request(
       |  189|        method: Method,
       |  190|        _ URLString: URLStringConvertible,
       |  191|        parameters: [String: AnyObject]? = nil,
       |  192|        encoding: ParameterEncoding = .URL,
       |  193|        headers: [String: String]? = nil)
       |  194|        -> Request
      1|  195|    {
      1|  196|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      1|  197|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      1|  198|        return request(encodedURLRequest)
      1|  199|    }
       |  200|
       |  201|    /**
       |  202|        Creates a request for the specified URL request.
       |  203|
       |  204|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  205|
       |  206|        - parameter URLRequest: The URL request
       |  207|
       |  208|        - returns: The created request.
       |  209|    */
      1|  210|    public func request(URLRequest: URLRequestConvertible) -> Request {
      1|  211|        var dataTask: NSURLSessionDataTask!
      1|  212|        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
      1|  213|
      1|  214|        let request = Request(session: session, task: dataTask)
      1|  215|        delegate[request.delegate.task] = request.delegate
      1|  216|
      1|  217|        if startRequestsImmediately {
      1|  218|            request.resume()
      1|  219|        }
      1|  220|
      1|  221|        return request
      1|  222|    }
      1|  223|
      1|  224|    // MARK: - SessionDelegate
      1|  225|
       |  226|    /**
       |  227|        Responsible for handling all delegate callbacks for the underlying session.
       |  228|    */
       |  229|    public final class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
       |  230|        private var subdelegates: [Int: Request.TaskDelegate] = [:]
       |  231|        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
       |  232|
       |  233|        subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
       |  234|            get {
       |  235|                var subdelegate: Request.TaskDelegate?
       |  236|                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
      4|  237|
      4|  238|                return subdelegate
      4|  239|            }
      4|  240|
      4|  241|            set {
      4|  242|                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
      4|  243|            }
      4|  244|        }
       |  245|
      2|  246|        /**
      2|  247|            Initializes the `SessionDelegate` instance.
      2|  248|
      2|  249|            - returns: The new `SessionDelegate` instance.
      2|  250|        */
       |  251|        public override init() {
       |  252|            super.init()
       |  253|        }
       |  254|
       |  255|        // MARK: - NSURLSessionDelegate
       |  256|
       |  257|        // MARK: Override Closures
      1|  258|
      1|  259|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
      1|  260|        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
       |  261|
       |  262|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
       |  263|        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  264|
       |  265|        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
       |  266|        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
       |  267|
       |  268|        // MARK: Delegate Methods
       |  269|
       |  270|        /**
       |  271|            Tells the delegate that the session has been invalidated.
       |  272|
       |  273|            - parameter session: The session object that was invalidated.
       |  274|            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
       |  275|        */
       |  276|        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
       |  277|            sessionDidBecomeInvalidWithError?(session, error)
       |  278|        }
       |  279|
       |  280|        /**
       |  281|            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
       |  282|
      0|  283|            - parameter session:           The session containing the task that requested authentication.
      0|  284|            - parameter challenge:         An object that contains the request for authentication.
      0|  285|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  286|        */
       |  287|        public func URLSession(
       |  288|            session: NSURLSession,
       |  289|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  290|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
       |  291|        {
       |  292|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
       |  293|            var credential: NSURLCredential?
       |  294|
       |  295|            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
       |  296|                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
       |  297|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      0|  298|                let host = challenge.protectionSpace.host
      0|  299|
      0|  300|                if let
      0|  301|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      0|  302|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  303|                {
      0|  304|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  305|                        disposition = .UseCredential
      0|  306|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  307|                    } else {
      0|  308|                        disposition = .CancelAuthenticationChallenge
      0|  309|                    }
      0|  310|                }
      0|  311|            }
      0|  312|
      0|  313|            completionHandler(disposition, credential)
      0|  314|        }
      0|  315|
      0|  316|        /**
      0|  317|            Tells the delegate that all messages enqueued for a session have been delivered.
      0|  318|
      0|  319|            - parameter session: The session that no longer has any outstanding requests.
      0|  320|        */
      0|  321|        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
       |  322|            sessionDidFinishEventsForBackgroundURLSession?(session)
       |  323|        }
       |  324|
       |  325|        // MARK: - NSURLSessionTaskDelegate
       |  326|
       |  327|        // MARK: Override Closures
      0|  328|
      0|  329|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
      0|  330|        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  331|
       |  332|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
       |  333|        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  334|
       |  335|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
       |  336|        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream!)?
       |  337|
       |  338|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
       |  339|        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  340|
       |  341|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
       |  342|        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  343|
       |  344|        // MARK: Delegate Methods
       |  345|
       |  346|        /**
       |  347|            Tells the delegate that the remote server requested an HTTP redirect.
       |  348|
       |  349|            - parameter session:           The session containing the task whose request resulted in a redirect.
       |  350|            - parameter task:              The task whose request resulted in a redirect.
       |  351|            - parameter response:          An object containing the server’s response to the original request.
       |  352|            - parameter request:           A URL request object filled out with the new location.
       |  353|            - parameter completionHandler: A closure that your handler should call with either the value of the request 
       |  354|                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
       |  355|                                           return the body of the redirect response.
       |  356|        */
       |  357|        public func URLSession(
       |  358|            session: NSURLSession,
       |  359|            task: NSURLSessionTask,
       |  360|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  361|            newRequest request: NSURLRequest,
       |  362|            completionHandler: ((NSURLRequest?) -> Void))
       |  363|        {
       |  364|            var redirectRequest: NSURLRequest? = request
       |  365|
       |  366|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
       |  367|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
       |  368|            }
       |  369|
      0|  370|            completionHandler(redirectRequest)
      0|  371|        }
      0|  372|
      0|  373|        /**
      0|  374|            Requests credentials from the delegate in response to an authentication request from the remote server.
      0|  375|
      0|  376|            - parameter session:           The session containing the task whose request requires authentication.
      0|  377|            - parameter task:              The task whose request requires authentication.
      0|  378|            - parameter challenge:         An object that contains the request for authentication.
       |  379|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  380|        */
       |  381|        public func URLSession(
       |  382|            session: NSURLSession,
       |  383|            task: NSURLSessionTask,
       |  384|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  385|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
       |  386|        {
       |  387|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
       |  388|                completionHandler(taskDidReceiveChallenge(session, task, challenge))
       |  389|            } else if let delegate = self[task] {
       |  390|                delegate.URLSession(
       |  391|                    session,
       |  392|                    task: task,
      1|  393|                    didReceiveChallenge: challenge,
      0|  394|                    completionHandler: completionHandler
      0|  395|                )
      1|  396|            } else {
      1|  397|                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
      1|  398|            }
      1|  399|        }
      1|  400|
      1|  401|        /**
      1|  402|            Tells the delegate when a task requires a new request body stream to send to the remote server.
      0|  403|
      0|  404|            - parameter session:           The session containing the task that needs a new body stream.
      0|  405|            - parameter task:              The task that needs a new body stream.
      1|  406|            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
       |  407|        */
       |  408|        public func URLSession(
       |  409|            session: NSURLSession,
       |  410|            task: NSURLSessionTask,
       |  411|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
       |  412|        {
       |  413|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
       |  414|                completionHandler(taskNeedNewBodyStream(session, task))
       |  415|            } else if let delegate = self[task] {
       |  416|                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
       |  417|            }
       |  418|        }
      0|  419|
      0|  420|        /**
      0|  421|            Periodically informs the delegate of the progress of sending body content to the server.
      0|  422|
      0|  423|            - parameter session:                  The session containing the data task.
      0|  424|            - parameter task:                     The data task.
      0|  425|            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
       |  426|            - parameter totalBytesSent:           The total number of bytes sent so far.
       |  427|            - parameter totalBytesExpectedToSend: The expected length of the body data.
       |  428|        */
       |  429|        public func URLSession(
       |  430|            session: NSURLSession,
       |  431|            task: NSURLSessionTask,
       |  432|            didSendBodyData bytesSent: Int64,
       |  433|            totalBytesSent: Int64,
       |  434|            totalBytesExpectedToSend: Int64)
       |  435|        {
       |  436|            if let taskDidSendBodyData = taskDidSendBodyData {
       |  437|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
       |  438|            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
       |  439|                delegate.URLSession(
       |  440|                    session,
       |  441|                    task: task,
      1|  442|                    didSendBodyData: bytesSent,
      0|  443|                    totalBytesSent: totalBytesSent,
      0|  444|                    totalBytesExpectedToSend: totalBytesExpectedToSend
      0|  445|                )
      0|  446|            }
      0|  447|        }
      0|  448|
      0|  449|        /**
      0|  450|            Tells the delegate that the task finished transferring data.
      0|  451|
      0|  452|            - parameter session: The session containing the task whose request finished transferring data.
      0|  453|            - parameter task:    The task whose request finished transferring data.
      1|  454|            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
       |  455|        */
       |  456|        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
       |  457|            if let taskDidComplete = taskDidComplete {
       |  458|                taskDidComplete(session, task, error)
       |  459|            } else if let delegate = self[task] {
       |  460|                delegate.URLSession(session, task: task, didCompleteWithError: error)
       |  461|            }
       |  462|
      1|  463|            self[task] = nil
      0|  464|        }
      0|  465|
      1|  466|        // MARK: - NSURLSessionDataDelegate
      1|  467|
      1|  468|        // MARK: Override Closures
      1|  469|
      1|  470|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
      1|  471|        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  472|
       |  473|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
       |  474|        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  475|
       |  476|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
       |  477|        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  478|
       |  479|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
       |  480|        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse!)?
       |  481|
       |  482|        // MARK: Delegate Methods
       |  483|
       |  484|        /**
       |  485|            Tells the delegate that the data task received the initial reply (headers) from the server.
       |  486|
       |  487|            - parameter session:           The session containing the data task that received an initial reply.
       |  488|            - parameter dataTask:          The data task that received an initial reply.
       |  489|            - parameter response:          A URL response object populated with headers.
       |  490|            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
       |  491|                                           constant to indicate whether the transfer should continue as a data task or 
       |  492|                                           should become a download task.
       |  493|        */
       |  494|        public func URLSession(
       |  495|            session: NSURLSession,
       |  496|            dataTask: NSURLSessionDataTask,
       |  497|            didReceiveResponse response: NSURLResponse,
       |  498|            completionHandler: ((NSURLSessionResponseDisposition) -> Void))
       |  499|        {
       |  500|            var disposition: NSURLSessionResponseDisposition = .Allow
       |  501|
       |  502|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
       |  503|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
       |  504|            }
       |  505|
      0|  506|            completionHandler(disposition)
      0|  507|        }
      0|  508|
      0|  509|        /**
      0|  510|            Tells the delegate that the data task was changed to a download task.
      0|  511|
      0|  512|            - parameter session:      The session containing the task that was replaced by a download task.
      0|  513|            - parameter dataTask:     The data task that was replaced by a download task.
      0|  514|            - parameter downloadTask: The new download task that replaced the data task.
       |  515|        */
       |  516|        public func URLSession(
       |  517|            session: NSURLSession,
       |  518|            dataTask: NSURLSessionDataTask,
       |  519|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
       |  520|        {
       |  521|            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
       |  522|                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
       |  523|            } else {
       |  524|                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
       |  525|                self[downloadTask] = downloadDelegate
       |  526|            }
      0|  527|        }
      0|  528|
      0|  529|        /**
      0|  530|            Tells the delegate that the data task has received some of the expected data.
      0|  531|
      0|  532|            - parameter session:  The session containing the data task that provided data.
      0|  533|            - parameter dataTask: The data task that provided data.
      0|  534|            - parameter data:     A data object containing the transferred data.
       |  535|        */
       |  536|        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
       |  537|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
       |  538|                dataTaskDidReceiveData(session, dataTask, data)
       |  539|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
       |  540|                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
       |  541|            }
       |  542|        }
      1|  543|
      0|  544|        /**
      0|  545|            Asks the delegate whether the data (or upload) task should store the response in the cache.
      1|  546|
      1|  547|            - parameter session:           The session containing the data (or upload) task.
      1|  548|            - parameter dataTask:          The data (or upload) task.
      1|  549|            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
       |  550|                                           caching policy and the values of certain received headers, such as the Pragma 
       |  551|                                           and Cache-Control headers.
       |  552|            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
       |  553|                                           response, a modified version of that response, or NULL to prevent caching the 
       |  554|                                           response. If your delegate implements this method, it must call this completion 
       |  555|                                           handler; otherwise, your app leaks memory.
       |  556|        */
       |  557|        public func URLSession(
       |  558|            session: NSURLSession,
       |  559|            dataTask: NSURLSessionDataTask,
       |  560|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  561|            completionHandler: ((NSCachedURLResponse?) -> Void))
       |  562|        {
       |  563|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
       |  564|                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
       |  565|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
       |  566|                delegate.URLSession(
       |  567|                    session,
       |  568|                    dataTask: dataTask,
      0|  569|                    willCacheResponse: proposedResponse,
      0|  570|                    completionHandler: completionHandler
      0|  571|                )
      0|  572|            } else {
      0|  573|                completionHandler(proposedResponse)
      0|  574|            }
      0|  575|        }
      0|  576|
      0|  577|        // MARK: - NSURLSessionDownloadDelegate
      0|  578|
      0|  579|        // MARK: Override Closures
      0|  580|
      0|  581|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
      0|  582|        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
       |  583|
       |  584|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
       |  585|        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  586|
       |  587|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
       |  588|        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  589|
       |  590|        // MARK: Delegate Methods
       |  591|
       |  592|        /**
       |  593|            Tells the delegate that a download task has finished downloading.
       |  594|
       |  595|            - parameter session:      The session containing the download task that finished.
       |  596|            - parameter downloadTask: The download task that finished.
       |  597|            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
       |  598|                                      open the file for reading or move it to a permanent location in your app’s sandbox 
       |  599|                                      container directory before returning from this delegate method.
       |  600|        */
       |  601|        public func URLSession(
       |  602|            session: NSURLSession,
       |  603|            downloadTask: NSURLSessionDownloadTask,
       |  604|            didFinishDownloadingToURL location: NSURL)
       |  605|        {
       |  606|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
       |  607|                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
       |  608|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  609|                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
       |  610|            }
       |  611|        }
      0|  612|
      0|  613|        /**
      0|  614|            Periodically informs the delegate about the download’s progress.
      0|  615|
      0|  616|            - parameter session:                   The session containing the download task.
      0|  617|            - parameter downloadTask:              The download task.
      0|  618|            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
       |  619|                                                   method was called.
       |  620|            - parameter totalBytesWritten:         The total number of bytes transferred so far.
       |  621|            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
       |  622|                                                   header. If this header was not provided, the value is 
       |  623|                                                   `NSURLSessionTransferSizeUnknown`.
       |  624|        */
       |  625|        public func URLSession(
       |  626|            session: NSURLSession,
       |  627|            downloadTask: NSURLSessionDownloadTask,
       |  628|            didWriteData bytesWritten: Int64,
       |  629|            totalBytesWritten: Int64,
       |  630|            totalBytesExpectedToWrite: Int64)
       |  631|        {
       |  632|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
       |  633|                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
       |  634|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  635|                delegate.URLSession(
       |  636|                    session,
       |  637|                    downloadTask: downloadTask,
      0|  638|                    didWriteData: bytesWritten,
      0|  639|                    totalBytesWritten: totalBytesWritten,
      0|  640|                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
      0|  641|                )
      0|  642|            }
      0|  643|        }
      0|  644|
      0|  645|        /**
      0|  646|            Tells the delegate that the download task has resumed downloading.
      0|  647|
      0|  648|            - parameter session:            The session containing the download task that finished.
      0|  649|            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
      0|  650|            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
       |  651|                                            existing content, then this value is zero. Otherwise, this value is an 
       |  652|                                            integer representing the number of bytes on disk that do not need to be 
       |  653|                                            retrieved again.
       |  654|            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
       |  655|                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
       |  656|        */
       |  657|        public func URLSession(
       |  658|            session: NSURLSession,
       |  659|            downloadTask: NSURLSessionDownloadTask,
       |  660|            didResumeAtOffset fileOffset: Int64,
       |  661|            expectedTotalBytes: Int64)
       |  662|        {
       |  663|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
       |  664|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
       |  665|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  666|                delegate.URLSession(
       |  667|                    session,
       |  668|                    downloadTask: downloadTask,
      0|  669|                    didResumeAtOffset: fileOffset,
      0|  670|                    expectedTotalBytes: expectedTotalBytes
      0|  671|                )
      0|  672|            }
      0|  673|        }
      0|  674|
      0|  675|        // MARK: - NSURLSessionStreamDelegate
      0|  676|
      0|  677|        var _streamTaskReadClosed: Any?
      0|  678|        var _streamTaskWriteClosed: Any?
      0|  679|        var _streamTaskBetterRouteDiscovered: Any?
      0|  680|        var _streamTaskDidBecomeInputStream: Any?
       |  681|
       |  682|        // MARK: - NSObject
       |  683|
       |  684|        public override func respondsToSelector(selector: Selector) -> Bool {
       |  685|            switch selector {
       |  686|            case "URLSession:didBecomeInvalidWithError:":
       |  687|                return sessionDidBecomeInvalidWithError != nil
       |  688|            case "URLSession:didReceiveChallenge:completionHandler:":
       |  689|                return sessionDidReceiveChallenge != nil
       |  690|            case "URLSessionDidFinishEventsForBackgroundURLSession:":
     11|  691|                return sessionDidFinishEventsForBackgroundURLSession != nil
     11|  692|            case "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:":
      0|  693|                return taskWillPerformHTTPRedirection != nil
      0|  694|            case "URLSession:dataTask:didReceiveResponse:completionHandler:":
      1|  695|                return dataTaskDidReceiveResponse != nil
      1|  696|            default:
      0|  697|                return self.dynamicType.instancesRespondToSelector(selector)
      0|  698|            }
      0|  699|        }
      0|  700|    }
      1|  701|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/MultipartFormData.swift:
       |    1|// MultipartFormData.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if os(iOS) || os(watchOS) || os(tvOS)
       |   26|import MobileCoreServices
       |   27|#elseif os(OSX)
       |   28|import CoreServices
       |   29|#endif
       |   30|
       |   31|/**
       |   32|    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
       |   33|    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
       |   34|    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
       |   35|    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
       |   36|    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
       |   37|
       |   38|    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
       |   39|    and the w3 form documentation.
       |   40|
       |   41|    - https://www.ietf.org/rfc/rfc2388.txt
       |   42|    - https://www.ietf.org/rfc/rfc2045.txt
       |   43|    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
       |   44|*/
       |   45|public class MultipartFormData {
       |   46|
       |   47|    // MARK: - Helper Types
       |   48|
       |   49|    struct EncodingCharacters {
       |   50|        static let CRLF = "\r\n"
       |   51|    }
       |   52|
       |   53|    struct BoundaryGenerator {
       |   54|        enum BoundaryType {
       |   55|            case Initial, Encapsulated, Final
       |   56|        }
       |   57|
      0|   58|        static func randomBoundary() -> String {
      0|   59|            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
      0|   60|        }
       |   61|
      0|   62|        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
      0|   63|            let boundaryText: String
      0|   64|
      0|   65|            switch boundaryType {
      0|   66|            case .Initial:
      0|   67|                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
      0|   68|            case .Encapsulated:
      0|   69|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
      0|   70|            case .Final:
      0|   71|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
      0|   72|            }
      0|   73|
      0|   74|            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|   75|        }
       |   76|    }
       |   77|
       |   78|    class BodyPart {
       |   79|        let headers: [String: String]
       |   80|        let bodyStream: NSInputStream
       |   81|        let bodyContentLength: UInt64
       |   82|        var hasInitialBoundary = false
       |   83|        var hasFinalBoundary = false
       |   84|
      0|   85|        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
      0|   86|            self.headers = headers
      0|   87|            self.bodyStream = bodyStream
      0|   88|            self.bodyContentLength = bodyContentLength
      0|   89|        }
       |   90|    }
       |   91|
       |   92|    // MARK: - Properties
       |   93|
       |   94|    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
      0|   95|    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
       |   96|
       |   97|    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
      0|   98|    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
       |   99|
       |  100|    /// The boundary used to separate the body parts in the encoded form data.
       |  101|    public let boundary: String
       |  102|
       |  103|    private var bodyParts: [BodyPart]
       |  104|    private var bodyPartError: NSError?
       |  105|    private let streamBufferSize: Int
       |  106|
       |  107|    // MARK: - Lifecycle
       |  108|
       |  109|    /**
       |  110|        Creates a multipart form data object.
       |  111|
       |  112|        - returns: The multipart form data object.
       |  113|    */
      0|  114|    public init() {
      0|  115|        self.boundary = BoundaryGenerator.randomBoundary()
      0|  116|        self.bodyParts = []
      0|  117|
      0|  118|        /**
      0|  119|         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
      0|  120|         *  information, please refer to the following article:
      0|  121|         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
      0|  122|         */
      0|  123|
      0|  124|        self.streamBufferSize = 1024
      0|  125|    }
       |  126|
       |  127|    // MARK: - Body Parts
       |  128|
       |  129|    /**
       |  130|        Creates a body part from the data and appends it to the multipart form data object.
       |  131|
       |  132|        The body part data will be encoded using the following format:
       |  133|
       |  134|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  135|        - Encoded data
       |  136|        - Multipart form boundary
       |  137|
       |  138|        - parameter data: The data to encode into the multipart form data.
       |  139|        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
       |  140|    */
      0|  141|    public func appendBodyPart(data data: NSData, name: String) {
      0|  142|        let headers = contentHeaders(name: name)
      0|  143|        let stream = NSInputStream(data: data)
      0|  144|        let length = UInt64(data.length)
      0|  145|
      0|  146|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  147|    }
       |  148|
       |  149|    /**
       |  150|        Creates a body part from the data and appends it to the multipart form data object.
       |  151|
       |  152|        The body part data will be encoded using the following format:
       |  153|
       |  154|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  155|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  156|        - Encoded data
       |  157|        - Multipart form boundary
       |  158|
       |  159|        - parameter data:     The data to encode into the multipart form data.
       |  160|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  161|        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
       |  162|    */
      0|  163|    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
      0|  164|        let headers = contentHeaders(name: name, mimeType: mimeType)
      0|  165|        let stream = NSInputStream(data: data)
      0|  166|        let length = UInt64(data.length)
      0|  167|
      0|  168|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  169|    }
       |  170|
       |  171|    /**
       |  172|        Creates a body part from the data and appends it to the multipart form data object.
       |  173|
       |  174|        The body part data will be encoded using the following format:
       |  175|
       |  176|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  177|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  178|        - Encoded file data
       |  179|        - Multipart form boundary
       |  180|
       |  181|        - parameter data:     The data to encode into the multipart form data.
       |  182|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  183|        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
       |  184|        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
       |  185|    */
      0|  186|    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
      0|  187|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  188|        let stream = NSInputStream(data: data)
      0|  189|        let length = UInt64(data.length)
      0|  190|
      0|  191|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Creates a body part from the file and appends it to the multipart form data object.
       |  196|
       |  197|        The body part data will be encoded using the following format:
       |  198|
       |  199|        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
       |  200|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  201|        - Encoded file data
       |  202|        - Multipart form boundary
       |  203|
       |  204|        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
       |  205|        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
       |  206|        system associated MIME type.
       |  207|
       |  208|        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
       |  209|        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  210|    */
      0|  211|    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
      0|  212|        if let
      0|  213|            fileName = fileURL.lastPathComponent,
      0|  214|            pathExtension = fileURL.pathExtension
      0|  215|        {
      0|  216|            let mimeType = mimeTypeForPathExtension(pathExtension)
      0|  217|            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
      0|  218|        } else {
      0|  219|            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
      0|  220|            setBodyPartError(Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason))
      0|  221|        }
      0|  222|    }
       |  223|
       |  224|    /**
       |  225|        Creates a body part from the file and appends it to the multipart form data object.
       |  226|
       |  227|        The body part data will be encoded using the following format:
       |  228|
       |  229|        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
       |  230|        - Content-Type: #{mimeType} (HTTP Header)
       |  231|        - Encoded file data
       |  232|        - Multipart form boundary
       |  233|
       |  234|        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
       |  235|        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  236|        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
       |  237|        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
       |  238|    */
      0|  239|    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
      0|  240|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  241|
      0|  242|        //============================================================
      0|  243|        //                 Check 1 - is file URL?
      0|  244|        //============================================================
      0|  245|
      0|  246|        guard fileURL.fileURL else {
      0|  247|            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
      0|  248|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  249|            setBodyPartError(error)
      0|  250|            return
      0|  251|        }
      0|  252|
      0|  253|        //============================================================
      0|  254|        //              Check 2 - is file URL reachable?
      0|  255|        //============================================================
      0|  256|
      0|  257|        var isReachable = true
      0|  258|
      0|  259|        if #available(OSX 10.10, *) {
      0|  260|            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
      0|  261|        }
      0|  262|
      0|  263|        guard isReachable else {
      0|  264|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
      0|  265|            setBodyPartError(error)
      0|  266|            return
      0|  267|        }
      0|  268|
      0|  269|        //============================================================
      0|  270|        //            Check 3 - is file URL a directory?
      0|  271|        //============================================================
      0|  272|
      0|  273|        var isDirectory: ObjCBool = false
      0|  274|
      0|  275|        guard let
      0|  276|            path = fileURL.path
      0|  277|            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
      0|  278|        {
      0|  279|            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
      0|  280|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  281|            setBodyPartError(error)
      0|  282|            return
      0|  283|        }
      0|  284|
      0|  285|        //============================================================
      0|  286|        //          Check 4 - can the file size be extracted?
      0|  287|        //============================================================
      0|  288|
      0|  289|        var bodyContentLength: UInt64?
      0|  290|
      0|  291|        do {
      0|  292|            if let
      0|  293|                path = fileURL.path,
      0|  294|                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
      0|  295|            {
      0|  296|                bodyContentLength = fileSize.unsignedLongLongValue
      0|  297|            }
      0|  298|        } catch {
      0|  299|            // No-op
      0|  300|        }
      0|  301|
      0|  302|        guard let length = bodyContentLength else {
      0|  303|            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
      0|  304|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  305|            setBodyPartError(error)
      0|  306|            return
      0|  307|        }
      0|  308|
      0|  309|        //============================================================
      0|  310|        //       Check 5 - can a stream be created from file URL?
      0|  311|        //============================================================
      0|  312|
      0|  313|        guard let stream = NSInputStream(URL: fileURL) else {
      0|  314|            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
      0|  315|            let error = Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  316|            setBodyPartError(error)
      0|  317|            return
      0|  318|        }
      0|  319|
      0|  320|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  321|    }
       |  322|
       |  323|    /**
       |  324|        Creates a body part from the stream and appends it to the multipart form data object.
       |  325|
       |  326|        The body part data will be encoded using the following format:
       |  327|
       |  328|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  329|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  330|        - Encoded stream data
       |  331|        - Multipart form boundary
       |  332|
       |  333|        - parameter stream:   The input stream to encode in the multipart form data.
       |  334|        - parameter length:   The content length of the stream.
       |  335|        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
       |  336|        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
       |  337|        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
       |  338|    */
       |  339|    public func appendBodyPart(
       |  340|        stream stream: NSInputStream,
       |  341|        length: UInt64,
       |  342|        name: String,
       |  343|        fileName: String,
       |  344|        mimeType: String)
      0|  345|    {
      0|  346|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  347|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  348|    }
       |  349|
       |  350|    /**
       |  351|        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
       |  352|
       |  353|        The body part data will be encoded using the following format:
       |  354|
       |  355|        - HTTP headers
       |  356|        - Encoded stream data
       |  357|        - Multipart form boundary
       |  358|
       |  359|        - parameter stream:  The input stream to encode in the multipart form data.
       |  360|        - parameter length:  The content length of the stream.
       |  361|        - parameter headers: The HTTP headers for the body part.
       |  362|    */
      0|  363|    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
      0|  364|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
      0|  365|        bodyParts.append(bodyPart)
      0|  366|    }
       |  367|
       |  368|    // MARK: - Data Encoding
       |  369|
       |  370|    /**
       |  371|        Encodes all the appended body parts into a single `NSData` object.
       |  372|
       |  373|        It is important to note that this method will load all the appended body parts into memory all at the same 
       |  374|        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
       |  375|        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
       |  376|
       |  377|        - throws: An `NSError` if encoding encounters an error.
       |  378|
       |  379|        - returns: The encoded `NSData` if encoding is successful.
       |  380|    */
      0|  381|    public func encode() throws -> NSData {
      0|  382|        if let bodyPartError = bodyPartError {
      0|  383|            throw bodyPartError
      0|  384|        }
      0|  385|
      0|  386|        let encoded = NSMutableData()
      0|  387|
      0|  388|        bodyParts.first?.hasInitialBoundary = true
      0|  389|        bodyParts.last?.hasFinalBoundary = true
      0|  390|
      0|  391|        for bodyPart in bodyParts {
      0|  392|            let encodedData = try encodeBodyPart(bodyPart)
      0|  393|            encoded.appendData(encodedData)
      0|  394|        }
      0|  395|
      0|  396|        return encoded
      0|  397|    }
       |  398|
       |  399|    /**
       |  400|        Writes the appended body parts into the given file URL.
       |  401|
       |  402|        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
       |  403|        this approach is very memory efficient and should be used for large body part data.
       |  404|
       |  405|        - parameter fileURL: The file URL to write the multipart form data into.
       |  406|
       |  407|        - throws: An `NSError` if encoding encounters an error.
       |  408|    */
      0|  409|    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
      0|  410|        if let bodyPartError = bodyPartError {
      0|  411|            throw bodyPartError
      0|  412|        }
      0|  413|
      0|  414|        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
      0|  415|            let failureReason = "A file already exists at the given file URL: \(fileURL)"
      0|  416|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  417|        } else if !fileURL.fileURL {
      0|  418|            let failureReason = "The URL does not point to a valid file: \(fileURL)"
      0|  419|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  420|        }
      0|  421|
      0|  422|        let outputStream: NSOutputStream
      0|  423|
      0|  424|        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
      0|  425|            outputStream = possibleOutputStream
      0|  426|        } else {
      0|  427|            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
      0|  428|            throw Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  429|        }
      0|  430|
      0|  431|        outputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  432|        outputStream.open()
      0|  433|
      0|  434|        self.bodyParts.first?.hasInitialBoundary = true
      0|  435|        self.bodyParts.last?.hasFinalBoundary = true
      0|  436|
      0|  437|        for bodyPart in self.bodyParts {
      0|  438|            try writeBodyPart(bodyPart, toOutputStream: outputStream)
      0|  439|        }
      0|  440|
      0|  441|        outputStream.close()
      0|  442|        outputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  443|    }
       |  444|
       |  445|    // MARK: - Private - Body Part Encoding
       |  446|
      0|  447|    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  448|        let encoded = NSMutableData()
      0|  449|
      0|  450|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  451|        encoded.appendData(initialData)
      0|  452|
      0|  453|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  454|        encoded.appendData(headerData)
      0|  455|
      0|  456|        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
      0|  457|        encoded.appendData(bodyStreamData)
      0|  458|
      0|  459|        if bodyPart.hasFinalBoundary {
      0|  460|            encoded.appendData(finalBoundaryData())
      0|  461|        }
      0|  462|
      0|  463|        return encoded
      0|  464|    }
       |  465|
      0|  466|    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
      0|  467|        var headerText = ""
      0|  468|
      0|  469|        for (key, value) in bodyPart.headers {
      0|  470|            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
      0|  471|        }
      0|  472|        headerText += EncodingCharacters.CRLF
      0|  473|
      0|  474|        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|  475|    }
       |  476|
      0|  477|    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  478|        let inputStream = bodyPart.bodyStream
      0|  479|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  480|        inputStream.open()
      0|  481|
      0|  482|        var error: NSError?
      0|  483|        let encoded = NSMutableData()
      0|  484|
      0|  485|        while inputStream.hasBytesAvailable {
      0|  486|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  487|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  488|
      0|  489|            if inputStream.streamError != nil {
      0|  490|                error = inputStream.streamError
      0|  491|                break
      0|  492|            }
      0|  493|
      0|  494|            if bytesRead > 0 {
      0|  495|                encoded.appendBytes(buffer, length: bytesRead)
      0|  496|            } else if bytesRead < 0 {
      0|  497|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  498|                error = Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  499|                break
      0|  500|            } else {
      0|  501|                break
      0|  502|            }
      0|  503|        }
      0|  504|
      0|  505|        inputStream.close()
      0|  506|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  507|
      0|  508|        if let error = error {
      0|  509|            throw error
      0|  510|        }
      0|  511|
      0|  512|        return encoded
      0|  513|    }
       |  514|
       |  515|    // MARK: - Private - Writing Body Part to Output Stream
       |  516|
      0|  517|    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  518|        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  519|        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  520|        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  521|        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  522|    }
       |  523|
       |  524|    private func writeInitialBoundaryDataForBodyPart(
       |  525|        bodyPart: BodyPart,
       |  526|        toOutputStream outputStream: NSOutputStream)
       |  527|        throws
      0|  528|    {
      0|  529|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  530|        return try writeData(initialData, toOutputStream: outputStream)
      0|  531|    }
       |  532|
      0|  533|    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  534|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  535|        return try writeData(headerData, toOutputStream: outputStream)
      0|  536|    }
       |  537|
      0|  538|    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  539|        let inputStream = bodyPart.bodyStream
      0|  540|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  541|        inputStream.open()
      0|  542|
      0|  543|        while inputStream.hasBytesAvailable {
      0|  544|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  545|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  546|
      0|  547|            if let streamError = inputStream.streamError {
      0|  548|                throw streamError
      0|  549|            }
      0|  550|
      0|  551|            if bytesRead > 0 {
      0|  552|                if buffer.count != bytesRead {
      0|  553|                    buffer = Array(buffer[0..<bytesRead])
      0|  554|                }
      0|  555|
      0|  556|                try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  557|            } else if bytesRead < 0 {
      0|  558|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  559|                throw Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  560|            } else {
      0|  561|                break
      0|  562|            }
      0|  563|        }
      0|  564|
      0|  565|        inputStream.close()
      0|  566|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  567|    }
       |  568|
       |  569|    private func writeFinalBoundaryDataForBodyPart(
       |  570|        bodyPart: BodyPart,
       |  571|        toOutputStream outputStream: NSOutputStream)
       |  572|        throws
      0|  573|    {
      0|  574|        if bodyPart.hasFinalBoundary {
      0|  575|            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
      0|  576|        }
      0|  577|    }
       |  578|
       |  579|    // MARK: - Private - Writing Buffered Data to Output Stream
       |  580|
      0|  581|    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
      0|  582|        var buffer = [UInt8](count: data.length, repeatedValue: 0)
      0|  583|        data.getBytes(&buffer, length: data.length)
      0|  584|
      0|  585|        return try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  586|    }
       |  587|
      0|  588|    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
      0|  589|        var bytesToWrite = buffer.count
      0|  590|
      0|  591|        while bytesToWrite > 0 {
      0|  592|            if outputStream.hasSpaceAvailable {
      0|  593|                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
      0|  594|
      0|  595|                if let streamError = outputStream.streamError {
      0|  596|                    throw streamError
      0|  597|                }
      0|  598|
      0|  599|                if bytesWritten < 0 {
      0|  600|                    let failureReason = "Failed to write to output stream: \(outputStream)"
      0|  601|                    throw Error.errorWithCode(.OutputStreamWriteFailed, failureReason: failureReason)
      0|  602|                }
      0|  603|
      0|  604|                bytesToWrite -= bytesWritten
      0|  605|
      0|  606|                if bytesToWrite > 0 {
      0|  607|                    buffer = Array(buffer[bytesWritten..<buffer.count])
      0|  608|                }
      0|  609|            } else if let streamError = outputStream.streamError {
      0|  610|                throw streamError
      0|  611|            }
      0|  612|        }
      0|  613|    }
       |  614|
       |  615|    // MARK: - Private - Mime Type
       |  616|
      0|  617|    private func mimeTypeForPathExtension(pathExtension: String) -> String {
      0|  618|        if let
      0|  619|            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
      0|  620|            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
      0|  621|        {
      0|  622|            return contentType as String
      0|  623|        }
      0|  624|
      0|  625|        return "application/octet-stream"
      0|  626|    }
       |  627|
       |  628|    // MARK: - Private - Content Headers
       |  629|
      0|  630|    private func contentHeaders(name name: String) -> [String: String] {
      0|  631|        return ["Content-Disposition": "form-data; name=\"\(name)\""]
      0|  632|    }
       |  633|
      0|  634|    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
      0|  635|        return [
      0|  636|            "Content-Disposition": "form-data; name=\"\(name)\"",
      0|  637|            "Content-Type": "\(mimeType)"
      0|  638|        ]
      0|  639|    }
       |  640|
      0|  641|    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
      0|  642|        return [
      0|  643|            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
      0|  644|            "Content-Type": "\(mimeType)"
      0|  645|        ]
      0|  646|    }
       |  647|
       |  648|    // MARK: - Private - Boundary Encoding
       |  649|
      0|  650|    private func initialBoundaryData() -> NSData {
      0|  651|        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
      0|  652|    }
       |  653|
      0|  654|    private func encapsulatedBoundaryData() -> NSData {
      0|  655|        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
      0|  656|    }
       |  657|
      0|  658|    private func finalBoundaryData() -> NSData {
      0|  659|        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
      0|  660|    }
       |  661|
       |  662|    // MARK: - Private - Errors
       |  663|
      0|  664|    private func setBodyPartError(error: NSError) {
      0|  665|        if bodyPartError == nil {
      0|  666|            bodyPartError = error
      0|  667|        }
      0|  668|    }
       |  669|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ParameterEncoding.swift:
       |    1|// ParameterEncoding.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    HTTP method definitions.
       |   27|
       |   28|    See https://tools.ietf.org/html/rfc7231#section-4.3
       |   29|*/
       |   30|public enum Method: String {
       |   31|    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
       |   32|}
       |   33|
       |   34|// MARK: ParameterEncoding
       |   35|
       |   36|/**
       |   37|    Used to specify the way in which a set of parameters are applied to a URL request.
       |   38|
       |   39|    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
       |   40|                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
       |   41|                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
       |   42|                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
       |   43|                         for how to encode collection types, the convention of appending `[]` to the key for array
       |   44|                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
       |   45|                         dictionary values (`foo[bar]=baz`).
       |   46|
       |   47|    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
       |   48|                         implementation as the `.URL` case, but always applies the encoded result to the URL.
       |   49|
       |   50|    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
       |   51|                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
       |   52|                         set to `application/json`.
       |   53|
       |   54|    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
       |   55|                         according to the associated format and write options values, which is set as the body of the
       |   56|                         request. The `Content-Type` HTTP header field of an encoded request is set to
       |   57|                         `application/x-plist`.
       |   58|
       |   59|    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
       |   60|                         parameters.
       |   61|*/
       |   62|public enum ParameterEncoding {
       |   63|    case URL
       |   64|    case URLEncodedInURL
       |   65|    case JSON
       |   66|    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
       |   67|    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
       |   68|
       |   69|    /**
       |   70|        Creates a URL request by encoding parameters and applying them onto an existing request.
       |   71|
       |   72|        - parameter URLRequest: The request to have parameters applied
       |   73|        - parameter parameters: The parameters to apply
       |   74|
       |   75|        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
       |   76|                   if any.
       |   77|    */
       |   78|    public func encode(
       |   79|        URLRequest: URLRequestConvertible,
       |   80|        parameters: [String: AnyObject]?)
       |   81|        -> (NSMutableURLRequest, NSError?)
      1|   82|    {
      1|   83|        var mutableURLRequest = URLRequest.URLRequest
      1|   84|
      0|   85|        guard let parameters = parameters where !parameters.isEmpty else {
      0|   86|            return (mutableURLRequest, nil)
      0|   87|        }
      1|   88|
      1|   89|        var encodingError: NSError? = nil
      1|   90|
      1|   91|        switch self {
      0|   92|        case .URL, .URLEncodedInURL:
      0|   93|            func query(parameters: [String: AnyObject]) -> String {
      0|   94|                var components: [(String, String)] = []
      0|   95|
      0|   96|                for key in parameters.keys.sort(<) {
      0|   97|                    let value = parameters[key]!
      0|   98|                    components += queryComponents(key, value)
      0|   99|                }
      0|  100|
      0|  101|                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
      0|  102|            }
      0|  103|
      0|  104|            func encodesParametersInURL(method: Method) -> Bool {
      0|  105|                switch self {
      0|  106|                case .URLEncodedInURL:
      0|  107|                    return true
      0|  108|                default:
      0|  109|                    break
      0|  110|                }
      0|  111|
      0|  112|                switch method {
      0|  113|                case .GET, .HEAD, .DELETE:
      0|  114|                    return true
      0|  115|                default:
      0|  116|                    return false
      0|  117|                }
      0|  118|            }
      0|  119|
      0|  120|            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
      0|  121|                if let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false) {
      0|  122|                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
      0|  123|                    URLComponents.percentEncodedQuery = percentEncodedQuery
      0|  124|                    mutableURLRequest.URL = URLComponents.URL
      0|  125|                }
      0|  126|            } else {
      0|  127|                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
      0|  128|                    mutableURLRequest.setValue(
      0|  129|                        "application/x-www-form-urlencoded; charset=utf-8",
      0|  130|                        forHTTPHeaderField: "Content-Type"
      0|  131|                    )
      0|  132|                }
      0|  133|
      0|  134|                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
      0|  135|                    NSUTF8StringEncoding,
      0|  136|                    allowLossyConversion: false
      0|  137|                )
      0|  138|            }
      1|  139|        case .JSON:
      1|  140|            do {
      1|  141|                let options = NSJSONWritingOptions()
      1|  142|                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
      1|  143|
      1|  144|                mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
      1|  145|                mutableURLRequest.HTTPBody = data
      0|  146|            } catch {
      0|  147|                encodingError = error as NSError
      0|  148|            }
      0|  149|        case .PropertyList(let format, let options):
      0|  150|            do {
      0|  151|                let data = try NSPropertyListSerialization.dataWithPropertyList(
      0|  152|                    parameters,
      0|  153|                    format: format,
      0|  154|                    options: options
      0|  155|                )
      0|  156|                mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
      0|  157|                mutableURLRequest.HTTPBody = data
      0|  158|            } catch {
      0|  159|                encodingError = error as NSError
      0|  160|            }
      0|  161|        case .Custom(let closure):
      0|  162|            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
      1|  163|        }
      1|  164|
      1|  165|        return (mutableURLRequest, encodingError)
      1|  166|    }
       |  167|
       |  168|    /**
       |  169|        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
       |  170|
       |  171|        - parameter key:   The key of the query component.
       |  172|        - parameter value: The value of the query component.
       |  173|
       |  174|        - returns: The percent-escaped, URL encoded query string components.
       |  175|    */
      0|  176|    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
      0|  177|        var components: [(String, String)] = []
      0|  178|
      0|  179|        if let dictionary = value as? [String: AnyObject] {
      0|  180|            for (nestedKey, value) in dictionary {
      0|  181|                components += queryComponents("\(key)[\(nestedKey)]", value)
      0|  182|            }
      0|  183|        } else if let array = value as? [AnyObject] {
      0|  184|            for value in array {
      0|  185|                components += queryComponents("\(key)[]", value)
      0|  186|            }
      0|  187|        } else {
      0|  188|            components.append((escape(key), escape("\(value)")))
      0|  189|        }
      0|  190|
      0|  191|        return components
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Returns a percent-escaped string following RFC 3986 for a query string key or value.
       |  196|
       |  197|        RFC 3986 states that the following characters are "reserved" characters.
       |  198|
       |  199|        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
       |  200|        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
       |  201|
       |  202|        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
       |  203|        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
       |  204|        should be percent-escaped in the query string.
       |  205|
       |  206|        - parameter string: The string to be percent-escaped.
       |  207|
       |  208|        - returns: The percent-escaped string.
       |  209|    */
      0|  210|    public func escape(string: String) -> String {
      0|  211|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
      0|  212|        let subDelimitersToEncode = "!$&'()*+,;="
      0|  213|
      0|  214|        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
      0|  215|        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
      0|  216|
      0|  217|        var escaped = ""
      0|  218|
      0|  219|        //==========================================================================================================
      0|  220|        //
      0|  221|        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
      0|  222|        //  hundred Chinense characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
      0|  223|        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
      0|  224|        //  info, please refer to:
      0|  225|        //
      0|  226|        //      - https://github.com/Alamofire/Alamofire/issues/206
      0|  227|        //
      0|  228|        //==========================================================================================================
      0|  229|
      0|  230|        if #available(iOS 8.3, OSX 10.10, *) {
      0|  231|            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
      0|  232|        } else {
      0|  233|            let batchSize = 50
      0|  234|            var index = string.startIndex
      0|  235|
      0|  236|            while index != string.endIndex {
      0|  237|                let startIndex = index
      0|  238|                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
      0|  239|                let range = Range(start: startIndex, end: endIndex)
      0|  240|
      0|  241|                let substring = string.substringWithRange(range)
      0|  242|
      0|  243|                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
      0|  244|
      0|  245|                index = endIndex
      0|  246|            }
      0|  247|        }
      0|  248|
      0|  249|        return escaped
      0|  250|    }
       |  251|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Request.swift:
       |    1|// Request.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for sending a request and receiving the response and associated data from the server, as well as 
       |   27|    managing its underlying `NSURLSessionTask`.
       |   28|*/
       |   29|public class Request {
       |   30|
       |   31|    // MARK: - Properties
       |   32|
       |   33|    /// The delegate for the underlying task.
       |   34|    public let delegate: TaskDelegate
       |   35|
       |   36|    /// The underlying task.
      5|   37|    public var task: NSURLSessionTask { return delegate.task }
       |   38|
       |   39|    /// The session belonging to the underlying task.
       |   40|    public let session: NSURLSession
       |   41|
       |   42|    /// The request sent or to be sent to the server.
      2|   43|    public var request: NSURLRequest? { return task.originalRequest }
       |   44|
       |   45|    /// The response received from the server, if any.
      2|   46|    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
       |   47|
       |   48|    /// The progress of the request lifecycle.
      0|   49|    public var progress: NSProgress { return delegate.progress }
       |   50|
       |   51|    // MARK: - Lifecycle
       |   52|
      1|   53|    init(session: NSURLSession, task: NSURLSessionTask) {
      1|   54|        self.session = session
      1|   55|
      1|   56|        switch task {
      0|   57|        case is NSURLSessionUploadTask:
      0|   58|            self.delegate = UploadTaskDelegate(task: task)
      1|   59|        case is NSURLSessionDataTask:
      1|   60|            self.delegate = DataTaskDelegate(task: task)
      0|   61|        case is NSURLSessionDownloadTask:
      0|   62|            self.delegate = DownloadTaskDelegate(task: task)
      0|   63|        default:
      0|   64|            self.delegate = TaskDelegate(task: task)
      1|   65|        }
      1|   66|    }
       |   67|
       |   68|    // MARK: - Authentication
       |   69|
       |   70|    /**
       |   71|        Associates an HTTP Basic credential with the request.
       |   72|
       |   73|        - parameter user:        The user.
       |   74|        - parameter password:    The password.
       |   75|        - parameter persistence: The URL credential persistence. `.ForSession` by default.
       |   76|
       |   77|        - returns: The request.
       |   78|    */
       |   79|    public func authenticate(
       |   80|        user user: String,
       |   81|        password: String,
       |   82|        persistence: NSURLCredentialPersistence = .ForSession)
       |   83|        -> Self
      0|   84|    {
      0|   85|        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
      0|   86|
      0|   87|        return authenticate(usingCredential: credential)
      0|   88|    }
       |   89|
       |   90|    /**
       |   91|        Associates a specified credential with the request.
       |   92|
       |   93|        - parameter credential: The credential.
       |   94|
       |   95|        - returns: The request.
       |   96|    */
      0|   97|    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
      0|   98|        delegate.credential = credential
      0|   99|
      0|  100|        return self
      0|  101|    }
       |  102|
       |  103|    // MARK: - Progress
       |  104|
       |  105|    /**
       |  106|        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
       |  107|        from the server.
       |  108|
       |  109|        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
       |  110|          to write.
       |  111|        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
       |  112|          expected to read.
       |  113|
       |  114|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  115|
       |  116|        - returns: The request.
       |  117|    */
      0|  118|    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
      0|  119|        if let uploadDelegate = delegate as? UploadTaskDelegate {
      0|  120|            uploadDelegate.uploadProgress = closure
      0|  121|        } else if let dataDelegate = delegate as? DataTaskDelegate {
      0|  122|            dataDelegate.dataProgress = closure
      0|  123|        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
      0|  124|            downloadDelegate.downloadProgress = closure
      0|  125|        }
      0|  126|
      0|  127|        return self
      0|  128|    }
       |  129|
       |  130|    /**
       |  131|        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
       |  132|
       |  133|        This closure returns the bytes most recently received from the server, not including data from previous calls. 
       |  134|        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
       |  135|        also important to note that the `response` closure will be called with nil `responseData`.
       |  136|
       |  137|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  138|
       |  139|        - returns: The request.
       |  140|    */
      0|  141|    public func stream(closure: (NSData -> Void)? = nil) -> Self {
      0|  142|        if let dataDelegate = delegate as? DataTaskDelegate {
      0|  143|            dataDelegate.dataStream = closure
      0|  144|        }
      0|  145|
      0|  146|        return self
      0|  147|    }
       |  148|
       |  149|    // MARK: - State
       |  150|
       |  151|    /**
       |  152|        Suspends the request.
       |  153|    */
      0|  154|    public func suspend() {
      0|  155|        task.suspend()
      0|  156|    }
       |  157|
       |  158|    /**
       |  159|        Resumes the request.
       |  160|    */
      1|  161|    public func resume() {
      1|  162|        task.resume()
      1|  163|    }
       |  164|
       |  165|    /**
       |  166|        Cancels the request.
       |  167|    */
      0|  168|    public func cancel() {
      0|  169|        if let
      0|  170|            downloadDelegate = delegate as? DownloadTaskDelegate,
      0|  171|            downloadTask = downloadDelegate.downloadTask
      0|  172|        {
      0|  173|            downloadTask.cancelByProducingResumeData { data in
      0|  174|                downloadDelegate.resumeData = data
      0|  175|            }
      0|  176|        } else {
      0|  177|            task.cancel()
      0|  178|        }
      0|  179|    }
       |  180|
       |  181|    // MARK: - TaskDelegate
       |  182|
       |  183|    /**
       |  184|        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
       |  185|        executing all operations attached to the serial operation queue upon task completion.
       |  186|    */
       |  187|    public class TaskDelegate: NSObject {
       |  188|
       |  189|        /// The serial operation queue used to execute all operations after the task completes.
       |  190|        public let queue: NSOperationQueue
       |  191|
       |  192|        let task: NSURLSessionTask
       |  193|        let progress: NSProgress
       |  194|
      0|  195|        var data: NSData? { return nil }
       |  196|        var error: NSError?
       |  197|
       |  198|        var credential: NSURLCredential?
       |  199|
      1|  200|        init(task: NSURLSessionTask) {
      1|  201|            self.task = task
      1|  202|            self.progress = NSProgress(totalUnitCount: 0)
      1|  203|            self.queue = {
      1|  204|                let operationQueue = NSOperationQueue()
      1|  205|                operationQueue.maxConcurrentOperationCount = 1
      1|  206|                operationQueue.suspended = true
      1|  207|
      1|  208|                if #available(OSX 10.10, *) {
      1|  209|                    operationQueue.qualityOfService = NSQualityOfService.Utility
      1|  210|                }
      1|  211|
      1|  212|                return operationQueue
      1|  213|            }()
      1|  214|        }
       |  215|
      0|  216|        deinit {
      0|  217|            queue.cancelAllOperations()
      0|  218|            queue.suspended = false
      0|  219|        }
       |  220|
       |  221|        // MARK: - NSURLSessionTaskDelegate
       |  222|
       |  223|        // MARK: Override Closures
       |  224|
       |  225|        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  226|        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  227|        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
       |  228|        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  229|
       |  230|        // MARK: Delegate Methods
       |  231|
       |  232|        func URLSession(
       |  233|            session: NSURLSession,
       |  234|            task: NSURLSessionTask,
       |  235|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  236|            newRequest request: NSURLRequest,
       |  237|            completionHandler: ((NSURLRequest?) -> Void))
      0|  238|        {
      0|  239|            var redirectRequest: NSURLRequest? = request
      0|  240|
      0|  241|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  242|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  243|            }
      0|  244|
      0|  245|            completionHandler(redirectRequest)
      0|  246|        }
       |  247|
       |  248|        func URLSession(
       |  249|            session: NSURLSession,
       |  250|            task: NSURLSessionTask,
       |  251|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  252|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  253|        {
      1|  254|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      1|  255|            var credential: NSURLCredential?
      1|  256|
      0|  257|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  258|                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
      1|  259|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      1|  260|                let host = challenge.protectionSpace.host
      1|  261|
      1|  262|                if let
      1|  263|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      1|  264|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  265|                {
      0|  266|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  267|                        disposition = .UseCredential
      0|  268|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  269|                    } else {
      0|  270|                        disposition = .CancelAuthenticationChallenge
      0|  271|                    }
      0|  272|                }
      0|  273|            } else {
      0|  274|                if challenge.previousFailureCount > 0 {
      0|  275|                    disposition = .CancelAuthenticationChallenge
      0|  276|                } else {
      0|  277|                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
      0|  278|
      0|  279|                    if credential != nil {
      0|  280|                        disposition = .UseCredential
      0|  281|                    }
      0|  282|                }
      0|  283|            }
      1|  284|
      1|  285|            completionHandler(disposition, credential)
      1|  286|        }
       |  287|
       |  288|        func URLSession(
       |  289|            session: NSURLSession,
       |  290|            task: NSURLSessionTask,
       |  291|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  292|        {
      0|  293|            var bodyStream: NSInputStream?
      0|  294|
      0|  295|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  296|                bodyStream = taskNeedNewBodyStream(session, task)
      0|  297|            }
      0|  298|
      0|  299|            completionHandler(bodyStream)
      0|  300|        }
       |  301|
      1|  302|        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  303|            if let taskDidCompleteWithError = taskDidCompleteWithError {
      0|  304|                taskDidCompleteWithError(session, task, error)
      1|  305|            } else {
      0|  306|                if let error = error {
      0|  307|                    self.error = error
      0|  308|
      0|  309|                    if let
      0|  310|                        downloadDelegate = self as? DownloadTaskDelegate,
      0|  311|                        userInfo = error.userInfo as? [String: AnyObject],
      0|  312|                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
      0|  313|                    {
      0|  314|                        downloadDelegate.resumeData = resumeData
      0|  315|                    }
      0|  316|                }
      1|  317|
      1|  318|                queue.suspended = false
      1|  319|            }
      1|  320|        }
       |  321|    }
       |  322|
       |  323|    // MARK: - DataTaskDelegate
       |  324|
       |  325|    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
      0|  326|        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
       |  327|
       |  328|        private var totalBytesReceived: Int64 = 0
       |  329|        private var mutableData: NSMutableData
      2|  330|        override var data: NSData? {
      0|  331|            if dataStream != nil {
      0|  332|                return nil
      2|  333|            } else {
      2|  334|                return mutableData
      2|  335|            }
      0|  336|        }
       |  337|
       |  338|        private var expectedContentLength: Int64?
       |  339|        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
       |  340|        private var dataStream: ((data: NSData) -> Void)?
       |  341|
      1|  342|        override init(task: NSURLSessionTask) {
      1|  343|            mutableData = NSMutableData()
      1|  344|            super.init(task: task)
      1|  345|        }
       |  346|
       |  347|        // MARK: - NSURLSessionDataDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  352|        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  353|        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  354|        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
       |  355|
       |  356|        // MARK: Delegate Methods
       |  357|
       |  358|        func URLSession(
       |  359|            session: NSURLSession,
       |  360|            dataTask: NSURLSessionDataTask,
       |  361|            didReceiveResponse response: NSURLResponse,
       |  362|            completionHandler: (NSURLSessionResponseDisposition -> Void))
      0|  363|        {
      0|  364|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  365|
      0|  366|            expectedContentLength = response.expectedContentLength
      0|  367|
      0|  368|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  369|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  370|            }
      0|  371|
      0|  372|            completionHandler(disposition)
      0|  373|        }
       |  374|
       |  375|        func URLSession(
       |  376|            session: NSURLSession,
       |  377|            dataTask: NSURLSessionDataTask,
       |  378|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  379|        {
      0|  380|            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
      0|  381|        }
       |  382|
      1|  383|        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  384|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  385|                dataTaskDidReceiveData(session, dataTask, data)
      1|  386|            } else {
      0|  387|                if let dataStream = dataStream {
      0|  388|                    dataStream(data: data)
      1|  389|                } else {
      1|  390|                    mutableData.appendData(data)
      1|  391|                }
      1|  392|
      1|  393|                totalBytesReceived += data.length
      0|  394|                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
      1|  395|
      1|  396|                progress.totalUnitCount = totalBytesExpected
      1|  397|                progress.completedUnitCount = totalBytesReceived
      1|  398|
      1|  399|                dataProgress?(
      1|  400|                    bytesReceived: Int64(data.length),
      1|  401|                    totalBytesReceived: totalBytesReceived,
      1|  402|                    totalBytesExpectedToReceive: totalBytesExpected
      1|  403|                )
      1|  404|            }
      1|  405|        }
       |  406|
       |  407|        func URLSession(
       |  408|            session: NSURLSession,
       |  409|            dataTask: NSURLSessionDataTask,
       |  410|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  411|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  412|        {
      0|  413|            var cachedResponse: NSCachedURLResponse? = proposedResponse
      0|  414|
      0|  415|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  416|                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
      0|  417|            }
      0|  418|
      0|  419|            completionHandler(cachedResponse)
      0|  420|        }
       |  421|    }
       |  422|}
       |  423|
       |  424|// MARK: - CustomStringConvertible
       |  425|
       |  426|extension Request: CustomStringConvertible {
       |  427|
       |  428|    /**
       |  429|        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
       |  430|        well as the response status code if a response has been received.
       |  431|    */
      0|  432|    public var description: String {
      0|  433|        var components: [String] = []
      0|  434|
      0|  435|        if let HTTPMethod = request?.HTTPMethod {
      0|  436|            components.append(HTTPMethod)
      0|  437|        }
      0|  438|
      0|  439|        if let URLString = request?.URL?.absoluteString {
      0|  440|            components.append(URLString)
      0|  441|        }
      0|  442|
      0|  443|        if let response = response {
      0|  444|            components.append("(\(response.statusCode))")
      0|  445|        }
      0|  446|
      0|  447|        return components.joinWithSeparator(" ")
      0|  448|    }
       |  449|}
       |  450|
       |  451|// MARK: - CustomDebugStringConvertible
       |  452|
       |  453|extension Request: CustomDebugStringConvertible {
      0|  454|    func cURLRepresentation() -> String {
      0|  455|        var components = ["$ curl -i"]
      0|  456|
      0|  457|        guard let request = self.request else {
      0|  458|            return "$ curl command could not be created"
      0|  459|        }
      0|  460|
      0|  461|        let URL = request.URL
      0|  462|
      0|  463|        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
      0|  464|            components.append("-X \(HTTPMethod)")
      0|  465|        }
      0|  466|
      0|  467|        if let credentialStorage = self.session.configuration.URLCredentialStorage {
      0|  468|            let protectionSpace = NSURLProtectionSpace(
      0|  469|                host: URL!.host!,
      0|  470|                port: URL!.port?.integerValue ?? 0,
      0|  471|                `protocol`: URL!.scheme,
      0|  472|                realm: URL!.host!,
      0|  473|                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
      0|  474|            )
      0|  475|
      0|  476|            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
      0|  477|                for credential in credentials {
      0|  478|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  479|                }
      0|  480|            } else {
      0|  481|                if let credential = delegate.credential {
      0|  482|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  483|                }
      0|  484|            }
      0|  485|        }
      0|  486|
      0|  487|        if session.configuration.HTTPShouldSetCookies {
      0|  488|            if let
      0|  489|                cookieStorage = session.configuration.HTTPCookieStorage,
      0|  490|                cookies = cookieStorage.cookiesForURL(URL!) where !cookies.isEmpty
      0|  491|            {
      0|  492|                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
      0|  493|                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
      0|  494|            }
      0|  495|        }
      0|  496|
      0|  497|        if let headerFields = request.allHTTPHeaderFields {
      0|  498|            for (field, value) in headerFields {
      0|  499|                switch field {
      0|  500|                case "Cookie":
      0|  501|                    continue
      0|  502|                default:
      0|  503|                    components.append("-H \"\(field): \(value)\"")
      0|  504|                }
      0|  505|            }
      0|  506|        }
      0|  507|
      0|  508|        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
      0|  509|            for (field, value) in additionalHeaders {
      0|  510|                switch field {
      0|  511|                case "Cookie":
      0|  512|                    continue
      0|  513|                default:
      0|  514|                    components.append("-H \"\(field): \(value)\"")
      0|  515|                }
      0|  516|            }
      0|  517|        }
      0|  518|
      0|  519|        if let
      0|  520|            HTTPBodyData = request.HTTPBody,
      0|  521|            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
      0|  522|        {
      0|  523|            let escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
      0|  524|            components.append("-d \"\(escapedBody)\"")
      0|  525|        }
      0|  526|
      0|  527|        components.append("\"\(URL!.absoluteString)\"")
      0|  528|
      0|  529|        return components.joinWithSeparator(" \\\n\t")
      0|  530|    }
       |  531|
       |  532|    /// The textual representation used when written to an output stream, in the form of a cURL command.
      0|  533|    public var debugDescription: String {
      0|  534|        return cURLRepresentation()
      0|  535|    }
       |  536|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Response.swift:
       |    1|// Response.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Used to store all response data returned from a completed `Request`.
       |   26|public struct Response<Value, Error: ErrorType> {
       |   27|    /// The URL request sent to the server.
       |   28|    public let request: NSURLRequest?
       |   29|
       |   30|    /// The server's response to the URL request.
       |   31|    public let response: NSHTTPURLResponse?
       |   32|
       |   33|    /// The data returned by the server.
       |   34|    public let data: NSData?
       |   35|
       |   36|    /// The result of response serialization.
       |   37|    public let result: Result<Value, Error>
       |   38|
       |   39|    /**
       |   40|        Initializes the `Response` instance with the specified URL request, URL response, server data and response
       |   41|        serialization result.
       |   42|    
       |   43|        - parameter request:  The URL request sent to the server.
       |   44|        - parameter response: The server's response to the URL request.
       |   45|        - parameter data:     The data returned by the server.
       |   46|        - parameter result:   The result of response serialization.
       |   47|    
       |   48|        - returns: the new `Response` instance.
       |   49|    */
      1|   50|    public init(request: NSURLRequest?, response: NSHTTPURLResponse?, data: NSData?, result: Result<Value, Error>) {
      1|   51|        self.request = request
      1|   52|        self.response = response
      1|   53|        self.data = data
      1|   54|        self.result = result
      1|   55|    }
       |   56|}
       |   57|
       |   58|// MARK: - CustomStringConvertible
       |   59|
       |   60|extension Response: CustomStringConvertible {
       |   61|    /// The textual representation used when written to an output stream, which includes whether the result was a
       |   62|    /// success or failure.
      0|   63|    public var description: String {
      0|   64|        return result.debugDescription
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - CustomDebugStringConvertible
       |   69|
       |   70|extension Response: CustomDebugStringConvertible {
       |   71|    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
       |   72|    /// response, the server data and the response serialization result.
      0|   73|    public var debugDescription: String {
      0|   74|        var output: [String] = []
      0|   75|
      0|   76|        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
      0|   77|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
      0|   78|        output.append("[Data]: \(data?.length ?? 0) bytes")
      0|   79|        output.append("[Result]: \(result.debugDescription)")
      0|   80|
      0|   81|        return output.joinWithSeparator("\n")
      0|   82|    }
       |   83|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ResponseSerialization.swift:
       |    1|// ResponseSerialization.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: ResponseSerializer
       |   26|
       |   27|/**
       |   28|    The type in which all response serializers must conform to in order to serialize a response.
       |   29|*/
       |   30|public protocol ResponseSerializerType {
       |   31|    /// The type of serialized object to be created by this `ResponseSerializerType`.
       |   32|    typealias SerializedObject
       |   33|
       |   34|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   35|    typealias ErrorObject: ErrorType
       |   36|
       |   37|    /**
       |   38|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   39|    */
       |   40|    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
       |   41|}
       |   42|
       |   43|// MARK: -
       |   44|
       |   45|/**
       |   46|    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
       |   47|*/
       |   48|public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
       |   49|    /// The type of serialized object to be created by this `ResponseSerializer`.
       |   50|    public typealias SerializedObject = Value
       |   51|
       |   52|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   53|    public typealias ErrorObject = Error
       |   54|
       |   55|    /**
       |   56|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   57|    */
       |   58|    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
       |   59|
       |   60|    /**
       |   61|        Initializes the `ResponseSerializer` instance with the given serialize response closure.
       |   62|
       |   63|        - parameter serializeResponse: The closure used to serialize the response.
       |   64|
       |   65|        - returns: The new generic response serializer instance.
       |   66|    */
      1|   67|    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
      1|   68|        self.serializeResponse = serializeResponse
      1|   69|    }
       |   70|}
       |   71|
       |   72|// MARK: - Default
       |   73|
       |   74|extension Request {
       |   75|
       |   76|    /**
       |   77|        Adds a handler to be called once the request has finished.
       |   78|
       |   79|        - parameter queue:             The queue on which the completion handler is dispatched.
       |   80|        - parameter completionHandler: The code to be executed once the request has finished.
       |   81|
       |   82|        - returns: The request.
       |   83|    */
       |   84|    public func response(
       |   85|        queue queue: dispatch_queue_t? = nil,
       |   86|        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
       |   87|        -> Self
      0|   88|    {
      0|   89|        delegate.queue.addOperationWithBlock {
      0|   90|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      0|   91|                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
      0|   92|            }
      0|   93|        }
      0|   94|
      0|   95|        return self
      0|   96|    }
       |   97|
       |   98|    /**
       |   99|        Adds a handler to be called once the request has finished.
       |  100|
       |  101|        - parameter queue:              The queue on which the completion handler is dispatched.
       |  102|        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
       |  103|                                        and data.
       |  104|        - parameter completionHandler:  The code to be executed once the request has finished.
       |  105|
       |  106|        - returns: The request.
       |  107|    */
       |  108|    public func response<T: ResponseSerializerType>(
       |  109|        queue queue: dispatch_queue_t? = nil,
       |  110|        responseSerializer: T,
       |  111|        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
       |  112|        -> Self
      1|  113|    {
      1|  114|        delegate.queue.addOperationWithBlock {
      1|  115|            let result = responseSerializer.serializeResponse(
      1|  116|                self.request,
      1|  117|                self.response,
      1|  118|                self.delegate.data,
      1|  119|                self.delegate.error
      1|  120|            )
      1|  121|
      1|  122|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      1|  123|                let response = Response<T.SerializedObject, T.ErrorObject>(
      1|  124|                    request: self.request,
      1|  125|                    response: self.response,
      1|  126|                    data: self.delegate.data,
      1|  127|                    result: result
      1|  128|                )
      1|  129|
      1|  130|                completionHandler(response)
      1|  131|            }
      1|  132|        }
      1|  133|
      1|  134|        return self
      1|  135|    }
       |  136|}
       |  137|
       |  138|// MARK: - Data
       |  139|
       |  140|extension Request {
       |  141|
       |  142|    /**
       |  143|        Creates a response serializer that returns the associated data as-is.
       |  144|
       |  145|        - returns: A data response serializer.
       |  146|    */
      0|  147|    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
      0|  148|        return ResponseSerializer { _, response, data, error in
      0|  149|            guard error == nil else { return .Failure(error!) }
      0|  150|
      0|  151|            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
      0|  152|
      0|  153|            guard let validData = data else {
      0|  154|                let failureReason = "Data could not be serialized. Input data was nil."
      0|  155|                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
      0|  156|                return .Failure(error)
      0|  157|            }
      0|  158|
      0|  159|            return .Success(validData)
      0|  160|        }
      0|  161|    }
       |  162|
       |  163|    /**
       |  164|        Adds a handler to be called once the request has finished.
       |  165|
       |  166|        - parameter completionHandler: The code to be executed once the request has finished.
       |  167|
       |  168|        - returns: The request.
       |  169|    */
      0|  170|    public func responseData(completionHandler: Response<NSData, NSError> -> Void) -> Self {
      0|  171|        return response(responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
      0|  172|    }
       |  173|}
       |  174|
       |  175|// MARK: - String
       |  176|
       |  177|extension Request {
       |  178|
       |  179|    /**
       |  180|        Creates a response serializer that returns a string initialized from the response data with the specified 
       |  181|        string encoding.
       |  182|
       |  183|        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
       |  184|                              response, falling back to the default HTTP default character set, ISO-8859-1.
       |  185|
       |  186|        - returns: A string response serializer.
       |  187|    */
       |  188|    public static func stringResponseSerializer(
       |  189|        var encoding encoding: NSStringEncoding? = nil)
       |  190|        -> ResponseSerializer<String, NSError>
      0|  191|    {
      0|  192|        return ResponseSerializer { _, response, data, error in
      0|  193|            guard error == nil else { return .Failure(error!) }
      0|  194|
      0|  195|            if let response = response where response.statusCode == 204 { return .Success("") }
      0|  196|
      0|  197|            guard let validData = data else {
      0|  198|                let failureReason = "String could not be serialized. Input data was nil."
      0|  199|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  200|                return .Failure(error)
      0|  201|            }
      0|  202|
      0|  203|            if let encodingName = response?.textEncodingName where encoding == nil {
      0|  204|                encoding = CFStringConvertEncodingToNSStringEncoding(
      0|  205|                    CFStringConvertIANACharSetNameToEncoding(encodingName)
      0|  206|                )
      0|  207|            }
      0|  208|
      0|  209|            let actualEncoding = encoding ?? NSISOLatin1StringEncoding
      0|  210|
      0|  211|            if let string = String(data: validData, encoding: actualEncoding) {
      0|  212|                return .Success(string)
      0|  213|            } else {
      0|  214|                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
      0|  215|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  216|                return .Failure(error)
      0|  217|            }
      0|  218|        }
      0|  219|    }
       |  220|
       |  221|    /**
       |  222|        Adds a handler to be called once the request has finished.
       |  223|
       |  224|        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
       |  225|                                       server response, falling back to the default HTTP default character set, 
       |  226|                                       ISO-8859-1.
       |  227|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  228|
       |  229|        - returns: The request.
       |  230|    */
       |  231|    public func responseString(
       |  232|        encoding encoding: NSStringEncoding? = nil,
       |  233|        completionHandler: Response<String, NSError> -> Void)
       |  234|        -> Self
      0|  235|    {
      0|  236|        return response(
      0|  237|            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
      0|  238|            completionHandler: completionHandler
      0|  239|        )
      0|  240|    }
       |  241|}
       |  242|
       |  243|// MARK: - JSON
       |  244|
       |  245|extension Request {
       |  246|
       |  247|    /**
       |  248|        Creates a response serializer that returns a JSON object constructed from the response data using 
       |  249|        `NSJSONSerialization` with the specified reading options.
       |  250|
       |  251|        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
       |  252|
       |  253|        - returns: A JSON object response serializer.
       |  254|    */
       |  255|    public static func JSONResponseSerializer(
       |  256|        options options: NSJSONReadingOptions = .AllowFragments)
       |  257|        -> ResponseSerializer<AnyObject, NSError>
      1|  258|    {
      1|  259|        return ResponseSerializer { _, response, data, error in
      0|  260|            guard error == nil else { return .Failure(error!) }
      1|  261|
      0|  262|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      1|  263|
      0|  264|            guard let validData = data where validData.length > 0 else {
      0|  265|                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
      0|  266|                let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
      0|  267|                return .Failure(error)
      0|  268|            }
      1|  269|
      1|  270|            do {
      1|  271|                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
      1|  272|                return .Success(JSON)
      1|  273|            } catch {
      1|  274|                return .Failure(error as NSError)
      1|  275|            }
      0|  276|        }
      1|  277|    }
       |  278|
       |  279|    /**
       |  280|        Adds a handler to be called once the request has finished.
       |  281|
       |  282|        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
       |  283|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  284|
       |  285|        - returns: The request.
       |  286|    */
       |  287|    public func responseJSON(
       |  288|        options options: NSJSONReadingOptions = .AllowFragments,
       |  289|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  290|        -> Self
      1|  291|    {
      1|  292|        return response(
      1|  293|            responseSerializer: Request.JSONResponseSerializer(options: options),
      1|  294|            completionHandler: completionHandler
      1|  295|        )
      1|  296|    }
       |  297|}
       |  298|
       |  299|// MARK: - Property List
       |  300|
       |  301|extension Request {
       |  302|
       |  303|    /**
       |  304|        Creates a response serializer that returns an object constructed from the response data using 
       |  305|        `NSPropertyListSerialization` with the specified reading options.
       |  306|
       |  307|        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
       |  308|
       |  309|        - returns: A property list object response serializer.
       |  310|    */
       |  311|    public static func propertyListResponseSerializer(
       |  312|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
       |  313|        -> ResponseSerializer<AnyObject, NSError>
      0|  314|    {
      0|  315|        return ResponseSerializer { _, response, data, error in
      0|  316|            guard error == nil else { return .Failure(error!) }
      0|  317|
      0|  318|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      0|  319|
      0|  320|            guard let validData = data where validData.length > 0 else {
      0|  321|                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
      0|  322|                let error = Error.errorWithCode(.PropertyListSerializationFailed, failureReason: failureReason)
      0|  323|                return .Failure(error)
      0|  324|            }
      0|  325|
      0|  326|            do {
      0|  327|                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
      0|  328|                return .Success(plist)
      0|  329|            } catch {
      0|  330|                return .Failure(error as NSError)
      0|  331|            }
      0|  332|        }
      0|  333|    }
       |  334|
       |  335|    /**
       |  336|        Adds a handler to be called once the request has finished.
       |  337|
       |  338|        - parameter options:           The property list reading options. `0` by default.
       |  339|        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
       |  340|                                       arguments: the URL request, the URL response, the server data and the result 
       |  341|                                       produced while creating the property list.
       |  342|
       |  343|        - returns: The request.
       |  344|    */
       |  345|    public func responsePropertyList(
       |  346|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
       |  347|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  348|        -> Self
      0|  349|    {
      0|  350|        return response(
      0|  351|            responseSerializer: Request.propertyListResponseSerializer(options: options),
      0|  352|            completionHandler: completionHandler
      0|  353|        )
      0|  354|    }
       |  355|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Result.swift:
       |    1|// Result.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Used to represent whether a request was successful or encountered an error.
       |   27|
       |   28|    - Success: The request and all post processing operations were successful resulting in the serialization of the 
       |   29|               provided associated value.
       |   30|    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
       |   31|               provided by the server as well as the error that caused the failure.
       |   32|*/
       |   33|public enum Result<Value, Error: ErrorType> {
       |   34|    case Success(Value)
       |   35|    case Failure(Error)
       |   36|
       |   37|    /// Returns `true` if the result is a success, `false` otherwise.
      0|   38|    public var isSuccess: Bool {
      0|   39|        switch self {
      0|   40|        case .Success:
      0|   41|            return true
      0|   42|        case .Failure:
      0|   43|            return false
      0|   44|        }
      0|   45|    }
       |   46|
       |   47|    /// Returns `true` if the result is a failure, `false` otherwise.
      0|   48|    public var isFailure: Bool {
      0|   49|        return !isSuccess
      0|   50|    }
       |   51|
       |   52|    /// Returns the associated value if the result is a success, `nil` otherwise.
      0|   53|    public var value: Value? {
      0|   54|        switch self {
      0|   55|        case .Success(let value):
      0|   56|            return value
      0|   57|        case .Failure:
      0|   58|            return nil
      0|   59|        }
      0|   60|    }
       |   61|
       |   62|    /// Returns the associated error value if the result is a failure, `nil` otherwise.
      0|   63|    public var error: Error? {
      0|   64|        switch self {
      0|   65|        case .Success:
      0|   66|            return nil
      0|   67|        case .Failure(let error):
      0|   68|            return error
      0|   69|        }
      0|   70|    }
       |   71|}
       |   72|
       |   73|// MARK: - CustomStringConvertible
       |   74|
       |   75|extension Result: CustomStringConvertible {
       |   76|    /// The textual representation used when written to an output stream, which includes whether the result was a 
       |   77|    /// success or failure.
      0|   78|    public var description: String {
      0|   79|        switch self {
      0|   80|        case .Success:
      0|   81|            return "SUCCESS"
      0|   82|        case .Failure:
      0|   83|            return "FAILURE"
      0|   84|        }
      0|   85|    }
       |   86|}
       |   87|
       |   88|// MARK: - CustomDebugStringConvertible
       |   89|
       |   90|extension Result: CustomDebugStringConvertible {
       |   91|    /// The debug textual representation used when written to an output stream, which includes whether the result was a
       |   92|    /// success or failure in addition to the value or error.
      1|   93|    public var debugDescription: String {
      1|   94|        switch self {
      0|   95|        case .Success(let value):
      0|   96|            return "SUCCESS: \(value)"
      1|   97|        case .Failure(let error):
      1|   98|            return "FAILURE: \(error)"
      1|   99|        }
      1|  100|    }
       |  101|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ServerTrustPolicy.swift:
       |    1|// ServerTrustPolicy.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
       |   26|public class ServerTrustPolicyManager {
       |   27|    /// The dictionary of policies mapped to a particular host.
       |   28|    public let policies: [String: ServerTrustPolicy]
       |   29|
       |   30|    /**
       |   31|        Initializes the `ServerTrustPolicyManager` instance with the given policies.
       |   32|
       |   33|        Since different servers and web services can have different leaf certificates, intermediate and even root 
       |   34|        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
       |   35|        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
       |   36|        pinning for host3 and disabling evaluation for host4.
       |   37|
       |   38|        - parameter policies: A dictionary of all policies mapped to a particular host.
       |   39|
       |   40|        - returns: The new `ServerTrustPolicyManager` instance.
       |   41|    */
      0|   42|    public init(policies: [String: ServerTrustPolicy]) {
      0|   43|        self.policies = policies
      0|   44|    }
       |   45|
       |   46|    /**
       |   47|        Returns the `ServerTrustPolicy` for the given host if applicable.
       |   48|
       |   49|        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
       |   50|        this method and implement more complex mapping implementations such as wildcards.
       |   51|
       |   52|        - parameter host: The host to use when searching for a matching policy.
       |   53|
       |   54|        - returns: The server trust policy for the given host if found.
       |   55|    */
      0|   56|    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
      0|   57|        return policies[host]
      0|   58|    }
       |   59|}
       |   60|
       |   61|// MARK: -
       |   62|
       |   63|extension NSURLSession {
       |   64|    private struct AssociatedKeys {
       |   65|        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
       |   66|    }
       |   67|
       |   68|    var serverTrustPolicyManager: ServerTrustPolicyManager? {
      1|   69|        get {
      1|   70|            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
      1|   71|        }
      1|   72|        set (manager) {
      1|   73|            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
      1|   74|        }
       |   75|    }
       |   76|}
       |   77|
       |   78|// MARK: - ServerTrustPolicy
       |   79|
       |   80|/**
       |   81|    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
       |   82|    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
       |   83|    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
       |   84|
       |   85|    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
       |   86|    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
       |   87|    to route all communication over an HTTPS connection with pinning enabled.
       |   88|
       |   89|    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
       |   90|                                validate the host provided by the challenge. Applications are encouraged to always 
       |   91|                                validate the host in production environments to guarantee the validity of the server's 
       |   92|                                certificate chain.
       |   93|
       |   94|    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
       |   95|                                considered valid if one of the pinned certificates match one of the server certificates. 
       |   96|                                By validating both the certificate chain and host, certificate pinning provides a very 
       |   97|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |   98|                                Applications are encouraged to always validate the host and require a valid certificate 
       |   99|                                chain in production environments.
       |  100|
       |  101|    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
       |  102|                                valid if one of the pinned public keys match one of the server certificate public keys. 
       |  103|                                By validating both the certificate chain and host, public key pinning provides a very 
       |  104|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |  105|                                Applications are encouraged to always validate the host and require a valid certificate 
       |  106|                                chain in production environments.
       |  107|
       |  108|    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
       |  109|
       |  110|    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
       |  111|*/
       |  112|public enum ServerTrustPolicy {
       |  113|    case PerformDefaultEvaluation(validateHost: Bool)
       |  114|    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
       |  115|    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
       |  116|    case DisableEvaluation
       |  117|    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
       |  118|
       |  119|    // MARK: - Bundle Location
       |  120|
       |  121|    /**
       |  122|        Returns all certificates within the given bundle with a `.cer` file extension.
       |  123|
       |  124|        - parameter bundle: The bundle to search for all `.cer` files.
       |  125|
       |  126|        - returns: All certificates within the given bundle.
       |  127|    */
      0|  128|    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
      0|  129|        var certificates: [SecCertificate] = []
      0|  130|
      0|  131|        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
      0|  132|            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
      0|  133|        }.flatten())
      0|  134|
      0|  135|        for path in paths {
      0|  136|            if let
      0|  137|                certificateData = NSData(contentsOfFile: path),
      0|  138|                certificate = SecCertificateCreateWithData(nil, certificateData)
      0|  139|            {
      0|  140|                certificates.append(certificate)
      0|  141|            }
       |  142|        }
       |  143|
       |  144|        return certificates
       |  145|    }
       |  146|
       |  147|    /**
       |  148|        Returns all public keys within the given bundle with a `.cer` file extension.
       |  149|
      0|  150|        - parameter bundle: The bundle to search for all `*.cer` files.
      0|  151|
      0|  152|        - returns: All public keys within the given bundle.
      0|  153|    */
      0|  154|    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
      0|  155|        var publicKeys: [SecKey] = []
      0|  156|
      0|  157|        for certificate in certificatesInBundle(bundle) {
      0|  158|            if let publicKey = publicKeyForCertificate(certificate) {
      0|  159|                publicKeys.append(publicKey)
      0|  160|            }
       |  161|        }
       |  162|
       |  163|        return publicKeys
       |  164|    }
       |  165|
       |  166|    // MARK: - Evaluation
       |  167|
       |  168|    /**
       |  169|        Evaluates whether the server trust is valid for the given host.
       |  170|
       |  171|        - parameter serverTrust: The server trust to evaluate.
      0|  172|        - parameter host:        The host of the challenge protection space.
      0|  173|
      0|  174|        - returns: Whether the server trust is valid.
      0|  175|    */
      0|  176|    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
      0|  177|        var serverTrustIsValid = false
      0|  178|
      0|  179|        switch self {
      0|  180|        case let .PerformDefaultEvaluation(validateHost):
      0|  181|            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  182|            SecTrustSetPolicies(serverTrust, [policy])
      0|  183|
      0|  184|            serverTrustIsValid = trustIsValid(serverTrust)
      0|  185|        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
      0|  186|            if validateCertificateChain {
      0|  187|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  188|                SecTrustSetPolicies(serverTrust, [policy])
      0|  189|
      0|  190|                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
      0|  191|                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
      0|  192|
      0|  193|                serverTrustIsValid = trustIsValid(serverTrust)
      0|  194|            } else {
      0|  195|                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
      0|  196|                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
      0|  197|
      0|  198|                outerLoop: for serverCertificateData in serverCertificatesDataArray {
      0|  199|                    for pinnedCertificateData in pinnedCertificatesDataArray {
      0|  200|                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
      0|  201|                            serverTrustIsValid = true
      0|  202|                            break outerLoop
      0|  203|                        }
      0|  204|                    }
      0|  205|                }
      0|  206|            }
      0|  207|        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
      0|  208|            var certificateChainEvaluationPassed = true
      0|  209|
      0|  210|            if validateCertificateChain {
      0|  211|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  212|                SecTrustSetPolicies(serverTrust, [policy])
      0|  213|
      0|  214|                certificateChainEvaluationPassed = trustIsValid(serverTrust)
      0|  215|            }
      0|  216|
      0|  217|            if certificateChainEvaluationPassed {
      0|  218|                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
      0|  219|                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
      0|  220|                        if serverPublicKey.isEqual(pinnedPublicKey) {
      0|  221|                            serverTrustIsValid = true
      0|  222|                            break outerLoop
      0|  223|                        }
      0|  224|                    }
      0|  225|                }
      0|  226|            }
      0|  227|        case .DisableEvaluation:
      0|  228|            serverTrustIsValid = true
      0|  229|        case let .CustomEvaluation(closure):
      0|  230|            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
      0|  231|        }
      0|  232|
      0|  233|        return serverTrustIsValid
      0|  234|    }
      0|  235|
      0|  236|    // MARK: - Private - Trust Validation
      0|  237|
       |  238|    private func trustIsValid(trust: SecTrust) -> Bool {
       |  239|        var isValid = false
       |  240|
      0|  241|        var result = SecTrustResultType(kSecTrustResultInvalid)
      0|  242|        let status = SecTrustEvaluate(trust, &result)
      0|  243|
      0|  244|        if status == errSecSuccess {
      0|  245|            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
      0|  246|            let proceed = SecTrustResultType(kSecTrustResultProceed)
      0|  247|
      0|  248|            isValid = result == unspecified || result == proceed
      0|  249|        }
      0|  250|
      0|  251|        return isValid
      0|  252|    }
      0|  253|
      0|  254|    // MARK: - Private - Certificate Data
      0|  255|
       |  256|    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
       |  257|        var certificates: [SecCertificate] = []
       |  258|
      0|  259|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  260|            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
      0|  261|                certificates.append(certificate)
      0|  262|            }
      0|  263|        }
      0|  264|
      0|  265|        return certificateDataForCertificates(certificates)
      0|  266|    }
      0|  267|
      0|  268|    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
      0|  269|        return certificates.map { SecCertificateCopyData($0) as NSData }
       |  270|    }
      0|  271|
      0|  272|    // MARK: - Private - Public Key Extraction
      0|  273|
       |  274|    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
       |  275|        var publicKeys: [SecKey] = []
       |  276|
      0|  277|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  278|            if let
      0|  279|                certificate = SecTrustGetCertificateAtIndex(trust, index),
      0|  280|                publicKey = publicKeyForCertificate(certificate)
      0|  281|            {
      0|  282|                publicKeys.append(publicKey)
      0|  283|            }
      0|  284|        }
      0|  285|
      0|  286|        return publicKeys
      0|  287|    }
      0|  288|
      0|  289|    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
      0|  290|        var publicKey: SecKey?
       |  291|
      0|  292|        let policy = SecPolicyCreateBasicX509()
      0|  293|        var trust: SecTrust?
      0|  294|        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
      0|  295|
      0|  296|        if let trust = trust where trustCreationStatus == errSecSuccess {
      0|  297|            publicKey = SecTrustCopyPublicKey(trust)
      0|  298|        }
      0|  299|
      0|  300|        return publicKey
      0|  301|    }
      0|  302|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Stream.swift:
       |    1|// Stream.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if !os(watchOS)
       |   26|
       |   27|@available(iOS 9.0, OSX 10.11, *)
       |   28|extension Manager {
       |   29|    private enum Streamable {
       |   30|        case Stream(String, Int)
       |   31|        case NetService(NSNetService)
       |   32|    }
       |   33|
      0|   34|    private func stream(streamable: Streamable) -> Request {
      0|   35|        var streamTask: NSURLSessionStreamTask!
      0|   36|
      0|   37|        switch streamable {
      0|   38|        case .Stream(let hostName, let port):
      0|   39|            dispatch_sync(queue) {
      0|   40|                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
      0|   41|            }
      0|   42|        case .NetService(let netService):
      0|   43|            dispatch_sync(queue) {
      0|   44|                streamTask = self.session.streamTaskWithNetService(netService)
      0|   45|            }
      0|   46|        }
      0|   47|
      0|   48|        let request = Request(session: session, task: streamTask)
      0|   49|
      0|   50|        delegate[request.delegate.task] = request.delegate
      0|   51|
      0|   52|        if startRequestsImmediately {
      0|   53|            request.resume()
      0|   54|        }
      0|   55|
      0|   56|        return request
      0|   57|    }
       |   58|
       |   59|    /**
       |   60|        Creates a request for bidirectional streaming with the given hostname and port.
       |   61|
       |   62|        - parameter hostName: The hostname of the server to connect to.
       |   63|        - parameter port:     The port of the server to connect to.
       |   64|
       |   65|        :returns: The created stream request.
       |   66|    */
      0|   67|    public func stream(hostName hostName: String, port: Int) -> Request {
      0|   68|        return stream(.Stream(hostName, port))
      0|   69|    }
       |   70|
       |   71|    /**
       |   72|        Creates a request for bidirectional streaming with the given `NSNetService`.
       |   73|
       |   74|        - parameter netService: The net service used to identify the endpoint.
       |   75|
       |   76|        - returns: The created stream request.
       |   77|    */
      0|   78|    public func stream(netService netService: NSNetService) -> Request {
      0|   79|        return stream(.NetService(netService))
      0|   80|    }
       |   81|}
       |   82|
       |   83|// MARK: -
       |   84|
       |   85|@available(iOS 9.0, OSX 10.11, *)
       |   86|extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
       |   87|
       |   88|    // MARK: Override Closures
       |   89|
       |   90|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
       |   91|    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|   92|        get {
      0|   93|            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|   94|        }
      0|   95|        set {
      0|   96|            _streamTaskReadClosed = newValue
      0|   97|        }
       |   98|    }
       |   99|
       |  100|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
       |  101|    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  102|        get {
      0|  103|            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  104|        }
      0|  105|        set {
      0|  106|            _streamTaskWriteClosed = newValue
      0|  107|        }
       |  108|    }
       |  109|
       |  110|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
       |  111|    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  112|        get {
      0|  113|            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  114|        }
      0|  115|        set {
      0|  116|            _streamTaskBetterRouteDiscovered = newValue
      0|  117|        }
       |  118|    }
       |  119|
       |  120|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
       |  121|    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
      0|  122|        get {
      0|  123|            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
      0|  124|        }
      0|  125|        set {
      0|  126|            _streamTaskDidBecomeInputStream = newValue
      0|  127|        }
       |  128|    }
       |  129|
       |  130|    // MARK: Delegate Methods
       |  131|
       |  132|    /**
       |  133|        Tells the delegate that the read side of the connection has been closed.
       |  134|
       |  135|        - parameter session:    The session.
       |  136|        - parameter streamTask: The stream task.
       |  137|    */
      0|  138|    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  139|        streamTaskReadClosed?(session, streamTask)
      0|  140|    }
       |  141|
       |  142|    /**
       |  143|        Tells the delegate that the write side of the connection has been closed.
       |  144|
       |  145|        - parameter session:    The session.
       |  146|        - parameter streamTask: The stream task.
       |  147|    */
      0|  148|    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  149|        streamTaskWriteClosed?(session, streamTask)
      0|  150|    }
       |  151|
       |  152|    /**
       |  153|        Tells the delegate that the system has determined that a better route to the host is available.
       |  154|
       |  155|        - parameter session:    The session.
       |  156|        - parameter streamTask: The stream task.
       |  157|    */
      0|  158|    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  159|        streamTaskBetterRouteDiscovered?(session, streamTask)
      0|  160|    }
       |  161|
       |  162|    /**
       |  163|        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
       |  164|
       |  165|        - parameter session:      The session.
       |  166|        - parameter streamTask:   The stream task.
       |  167|        - parameter inputStream:  The new input stream.
       |  168|        - parameter outputStream: The new output stream.
       |  169|    */
       |  170|    public func URLSession(
       |  171|        session: NSURLSession,
       |  172|        streamTask: NSURLSessionStreamTask,
       |  173|        didBecomeInputStream inputStream: NSInputStream,
       |  174|        outputStream: NSOutputStream)
      0|  175|    {
      0|  176|        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
      0|  177|    }
       |  178|}
       |  179|
       |  180|#endif

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Upload.swift:
       |    1|// Upload.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Uploadable {
       |   27|        case Data(NSURLRequest, NSData)
       |   28|        case File(NSURLRequest, NSURL)
       |   29|        case Stream(NSURLRequest, NSInputStream)
       |   30|    }
       |   31|
      0|   32|    private func upload(uploadable: Uploadable) -> Request {
      0|   33|        var uploadTask: NSURLSessionUploadTask!
      0|   34|        var HTTPBodyStream: NSInputStream?
      0|   35|
      0|   36|        switch uploadable {
      0|   37|        case .Data(let request, let data):
      0|   38|            dispatch_sync(queue) {
      0|   39|                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
      0|   40|            }
      0|   41|        case .File(let request, let fileURL):
      0|   42|            dispatch_sync(queue) {
      0|   43|                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
      0|   44|            }
      0|   45|        case .Stream(let request, let stream):
      0|   46|            dispatch_sync(queue) {
      0|   47|                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
      0|   48|            }
      0|   49|
      0|   50|            HTTPBodyStream = stream
      0|   51|        }
      0|   52|
      0|   53|        let request = Request(session: session, task: uploadTask)
      0|   54|
      0|   55|        if HTTPBodyStream != nil {
      0|   56|            request.delegate.taskNeedNewBodyStream = { _, _ in
      0|   57|                return HTTPBodyStream
      0|   58|            }
      0|   59|        }
      0|   60|
      0|   61|        delegate[request.delegate.task] = request.delegate
      0|   62|
      0|   63|        if startRequestsImmediately {
      0|   64|            request.resume()
      0|   65|        }
      0|   66|
      0|   67|        return request
      0|   68|    }
       |   69|
       |   70|    // MARK: File
       |   71|
       |   72|    /**
       |   73|        Creates a request for uploading a file to the specified URL request.
       |   74|
       |   75|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   76|
       |   77|        - parameter URLRequest: The URL request
       |   78|        - parameter file:       The file to upload
       |   79|
       |   80|        - returns: The created upload request.
       |   81|    */
      0|   82|    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|   83|        return upload(.File(URLRequest.URLRequest, file))
      0|   84|    }
       |   85|
       |   86|    /**
       |   87|        Creates a request for uploading a file to the specified URL request.
       |   88|
       |   89|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   90|
       |   91|        - parameter method:    The HTTP method.
       |   92|        - parameter URLString: The URL string.
       |   93|        - parameter headers:   The HTTP headers. `nil` by default.
       |   94|        - parameter file:      The file to upload
       |   95|
       |   96|        - returns: The created upload request.
       |   97|    */
       |   98|    public func upload(
       |   99|        method: Method,
       |  100|        _ URLString: URLStringConvertible,
       |  101|        headers: [String: String]? = nil,
       |  102|        file: NSURL)
       |  103|        -> Request
      0|  104|    {
      0|  105|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  106|        return upload(mutableURLRequest, file: file)
      0|  107|    }
       |  108|
       |  109|    // MARK: Data
       |  110|
       |  111|    /**
       |  112|        Creates a request for uploading data to the specified URL request.
       |  113|
       |  114|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  115|
       |  116|        - parameter URLRequest: The URL request.
       |  117|        - parameter data:       The data to upload.
       |  118|
       |  119|        - returns: The created upload request.
       |  120|    */
      0|  121|    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  122|        return upload(.Data(URLRequest.URLRequest, data))
      0|  123|    }
       |  124|
       |  125|    /**
       |  126|        Creates a request for uploading data to the specified URL request.
       |  127|
       |  128|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  129|
       |  130|        - parameter method:    The HTTP method.
       |  131|        - parameter URLString: The URL string.
       |  132|        - parameter headers:   The HTTP headers. `nil` by default.
       |  133|        - parameter data:      The data to upload
       |  134|
       |  135|        - returns: The created upload request.
       |  136|    */
       |  137|    public func upload(
       |  138|        method: Method,
       |  139|        _ URLString: URLStringConvertible,
       |  140|        headers: [String: String]? = nil,
       |  141|        data: NSData)
       |  142|        -> Request
      0|  143|    {
      0|  144|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  145|
      0|  146|        return upload(mutableURLRequest, data: data)
      0|  147|    }
       |  148|
       |  149|    // MARK: Stream
       |  150|
       |  151|    /**
       |  152|        Creates a request for uploading a stream to the specified URL request.
       |  153|
       |  154|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  155|
       |  156|        - parameter URLRequest: The URL request.
       |  157|        - parameter stream:     The stream to upload.
       |  158|
       |  159|        - returns: The created upload request.
       |  160|    */
      0|  161|    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  162|        return upload(.Stream(URLRequest.URLRequest, stream))
      0|  163|    }
       |  164|
       |  165|    /**
       |  166|        Creates a request for uploading a stream to the specified URL request.
       |  167|
       |  168|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  169|
       |  170|        - parameter method:    The HTTP method.
       |  171|        - parameter URLString: The URL string.
       |  172|        - parameter headers:   The HTTP headers. `nil` by default.
       |  173|        - parameter stream:    The stream to upload.
       |  174|
       |  175|        - returns: The created upload request.
       |  176|    */
       |  177|    public func upload(
       |  178|        method: Method,
       |  179|        _ URLString: URLStringConvertible,
       |  180|        headers: [String: String]? = nil,
       |  181|        stream: NSInputStream)
       |  182|        -> Request
      0|  183|    {
      0|  184|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  185|
      0|  186|        return upload(mutableURLRequest, stream: stream)
      0|  187|    }
       |  188|
       |  189|    // MARK: MultipartFormData
       |  190|
       |  191|    /// Default memory threshold used when encoding `MultipartFormData`.
       |  192|    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
       |  193|
       |  194|    /**
       |  195|        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
       |  196|        associated values.
       |  197|
       |  198|        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
       |  199|                   streaming information.
       |  200|        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
       |  201|                   error.
       |  202|    */
       |  203|    public enum MultipartFormDataEncodingResult {
       |  204|        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
       |  205|        case Failure(ErrorType)
       |  206|    }
       |  207|
       |  208|    /**
       |  209|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  210|
       |  211|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
       |  212|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
       |  213|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
       |  214|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
       |  215|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
       |  216|        used for larger payloads such as video content.
       |  217|
       |  218|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
       |  219|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  220|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
       |  221|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
       |  222|        technique was used.
       |  223|
       |  224|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  225|
       |  226|        - parameter method:                  The HTTP method.
       |  227|        - parameter URLString:               The URL string.
       |  228|        - parameter headers:                 The HTTP headers. `nil` by default.
       |  229|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  230|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  231|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  232|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  233|    */
       |  234|    public func upload(
       |  235|        method: Method,
       |  236|        _ URLString: URLStringConvertible,
       |  237|        headers: [String: String]? = nil,
       |  238|        multipartFormData: MultipartFormData -> Void,
       |  239|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  240|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  241|    {
      0|  242|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  243|
      0|  244|        return upload(
      0|  245|            mutableURLRequest,
      0|  246|            multipartFormData: multipartFormData,
      0|  247|            encodingMemoryThreshold: encodingMemoryThreshold,
      0|  248|            encodingCompletion: encodingCompletion
      0|  249|        )
      0|  250|    }
       |  251|
       |  252|    /**
       |  253|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  254|
       |  255|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
       |  256|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
       |  257|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
       |  258|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
       |  259|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
       |  260|        used for larger payloads such as video content.
       |  261|
       |  262|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
       |  263|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  264|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
       |  265|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
       |  266|        technique was used.
       |  267|
       |  268|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  269|
       |  270|        - parameter URLRequest:              The URL request.
       |  271|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  272|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  273|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  274|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  275|    */
       |  276|    public func upload(
       |  277|        URLRequest: URLRequestConvertible,
       |  278|        multipartFormData: MultipartFormData -> Void,
       |  279|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  280|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  281|    {
      0|  282|        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
      0|  283|            let formData = MultipartFormData()
      0|  284|            multipartFormData(formData)
      0|  285|
      0|  286|            let URLRequestWithContentType = URLRequest.URLRequest
      0|  287|            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
      0|  288|
      0|  289|            let isBackgroundSession = self.session.configuration.identifier != nil
      0|  290|
      0|  291|            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
      0|  292|                do {
      0|  293|                    let data = try formData.encode()
      0|  294|                    let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  295|                        request: self.upload(URLRequestWithContentType, data: data),
      0|  296|                        streamingFromDisk: false,
      0|  297|                        streamFileURL: nil
      0|  298|                    )
      0|  299|
      0|  300|                    dispatch_async(dispatch_get_main_queue()) {
      0|  301|                        encodingCompletion?(encodingResult)
      0|  302|                    }
      0|  303|                } catch {
      0|  304|                    dispatch_async(dispatch_get_main_queue()) {
      0|  305|                        encodingCompletion?(.Failure(error as NSError))
      0|  306|                    }
      0|  307|                }
      0|  308|            } else {
      0|  309|                let fileManager = NSFileManager.defaultManager()
      0|  310|                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
      0|  311|                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
      0|  312|                let fileName = NSUUID().UUIDString
      0|  313|                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
      0|  314|
      0|  315|                do {
      0|  316|                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
      0|  317|                    try formData.writeEncodedDataToDisk(fileURL)
      0|  318|
      0|  319|                    dispatch_async(dispatch_get_main_queue()) {
      0|  320|                        let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  321|                            request: self.upload(URLRequestWithContentType, file: fileURL),
      0|  322|                            streamingFromDisk: true,
      0|  323|                            streamFileURL: fileURL
      0|  324|                        )
      0|  325|                        encodingCompletion?(encodingResult)
      0|  326|                    }
      0|  327|                } catch {
      0|  328|                    dispatch_async(dispatch_get_main_queue()) {
      0|  329|                        encodingCompletion?(.Failure(error as NSError))
      0|  330|                    }
      0|  331|                }
      0|  332|            }
      0|  333|        }
      0|  334|    }
       |  335|}
       |  336|
       |  337|// MARK: -
       |  338|
       |  339|extension Request {
       |  340|
       |  341|    // MARK: - UploadTaskDelegate
       |  342|
       |  343|    class UploadTaskDelegate: DataTaskDelegate {
      0|  344|        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
       |  345|        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
       |  346|
       |  347|        // MARK: - NSURLSessionTaskDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  352|
       |  353|        // MARK: Delegate Methods
       |  354|
       |  355|        func URLSession(
       |  356|            session: NSURLSession,
       |  357|            task: NSURLSessionTask,
       |  358|            didSendBodyData bytesSent: Int64,
       |  359|            totalBytesSent: Int64,
       |  360|            totalBytesExpectedToSend: Int64)
      0|  361|        {
      0|  362|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  363|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  364|            } else {
      0|  365|                progress.totalUnitCount = totalBytesExpectedToSend
      0|  366|                progress.completedUnitCount = totalBytesSent
      0|  367|
      0|  368|                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  369|            }
      0|  370|        }
       |  371|    }
       |  372|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Validation.swift:
       |    1|// Validation.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Request {
       |   26|
       |   27|    /**
       |   28|        Used to represent whether validation was successful or encountered an error resulting in a failure.
       |   29|
       |   30|        - Success: The validation was successful.
       |   31|        - Failure: The validation failed encountering the provided error.
       |   32|    */
       |   33|    public enum ValidationResult {
       |   34|        case Success
       |   35|        case Failure(NSError)
       |   36|    }
       |   37|
       |   38|    /**
       |   39|        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
       |   40|        request was valid.
       |   41|    */
       |   42|    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
       |   43|
       |   44|    /**
       |   45|        Validates the request, using the specified closure.
       |   46|
       |   47|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   48|
       |   49|        - parameter validation: A closure to validate the request.
       |   50|
       |   51|        - returns: The request.
       |   52|    */
      0|   53|    public func validate(validation: Validation) -> Self {
      0|   54|        delegate.queue.addOperationWithBlock {
      0|   55|            if let
      0|   56|                response = self.response where self.delegate.error == nil,
      0|   57|                case let .Failure(error) = validation(self.request, response)
      0|   58|            {
      0|   59|                self.delegate.error = error
      0|   60|            }
      0|   61|        }
      0|   62|
      0|   63|        return self
      0|   64|    }
       |   65|
       |   66|    // MARK: - Status Code
       |   67|
       |   68|    /**
       |   69|        Validates that the response has a status code in the specified range.
       |   70|
       |   71|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   72|
       |   73|        - parameter range: The range of acceptable status codes.
       |   74|
       |   75|        - returns: The request.
       |   76|    */
      0|   77|    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
      0|   78|        return validate { _, response in
      0|   79|            if acceptableStatusCode.contains(response.statusCode) {
      0|   80|                return .Success
      0|   81|            } else {
      0|   82|                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
      0|   83|                return .Failure(Error.errorWithCode(.StatusCodeValidationFailed, failureReason: failureReason))
      0|   84|            }
      0|   85|        }
      0|   86|    }
       |   87|
       |   88|    // MARK: - Content-Type
       |   89|
       |   90|    private struct MIMEType {
       |   91|        let type: String
       |   92|        let subtype: String
       |   93|
      0|   94|        init?(_ string: String) {
      0|   95|            let components: [String] = {
      0|   96|                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
      0|   97|                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
      0|   98|                return split.componentsSeparatedByString("/")
      0|   99|            }()
      0|  100|
      0|  101|            if let
      0|  102|                type = components.first,
      0|  103|                subtype = components.last
      0|  104|            {
      0|  105|                self.type = type
      0|  106|                self.subtype = subtype
      0|  107|            } else {
      0|  108|                return nil
      0|  109|            }
      0|  110|        }
       |  111|
      0|  112|        func matches(MIME: MIMEType) -> Bool {
      0|  113|            switch (type, subtype) {
      0|  114|            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
      0|  115|                return true
      0|  116|            default:
      0|  117|                return false
      0|  118|            }
      0|  119|        }
       |  120|    }
       |  121|
       |  122|    /**
       |  123|        Validates that the response has a content type in the specified array.
       |  124|
       |  125|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  126|
       |  127|        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
       |  128|
       |  129|        - returns: The request.
       |  130|    */
      0|  131|    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
      0|  132|        return validate { _, response in
      0|  133|            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
      0|  134|
      0|  135|            if let
      0|  136|                responseContentType = response.MIMEType,
      0|  137|                responseMIMEType = MIMEType(responseContentType)
      0|  138|            {
      0|  139|                for contentType in acceptableContentTypes {
      0|  140|                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
      0|  141|                        return .Success
      0|  142|                    }
      0|  143|                }
      0|  144|            } else {
      0|  145|                for contentType in acceptableContentTypes {
      0|  146|                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
      0|  147|                        return .Success
      0|  148|                    }
      0|  149|                }
      0|  150|            }
      0|  151|
      0|  152|            let failureReason: String
      0|  153|
      0|  154|            if let responseContentType = response.MIMEType {
      0|  155|                failureReason = (
      0|  156|                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
      0|  157|                    "content types: \(acceptableContentTypes)"
      0|  158|                )
      0|  159|            } else {
      0|  160|                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
      0|  161|            }
      0|  162|
      0|  163|            return .Failure(Error.errorWithCode(.ContentTypeValidationFailed, failureReason: failureReason))
      0|  164|        }
      0|  165|    }
       |  166|
       |  167|    // MARK: - Automatic
       |  168|
       |  169|    /**
       |  170|        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
       |  171|        type matches any specified in the Accept HTTP header field.
       |  172|
       |  173|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  174|
       |  175|        - returns: The request.
       |  176|    */
      0|  177|    public func validate() -> Self {
      0|  178|        let acceptableStatusCodes: Range<Int> = 200..<300
      0|  179|        let acceptableContentTypes: [String] = {
      0|  180|            if let accept = request?.valueForHTTPHeaderField("Accept") {
      0|  181|                return accept.componentsSeparatedByString(",")
      0|  182|            }
      0|  183|
      0|  184|            return ["*/*"]
      0|  185|        }()
      0|  186|
      0|  187|        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
      0|  188|    }
       |  189|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Alamofire.swift:
       |    1|// Alamofire.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: - URLStringConvertible
       |   26|
       |   27|/**
       |   28|    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
       |   29|    construct URL requests.
       |   30|*/
       |   31|public protocol URLStringConvertible {
       |   32|    /**
       |   33|        A URL that conforms to RFC 2396.
       |   34|
       |   35|        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
       |   36|
       |   37|        See https://tools.ietf.org/html/rfc2396
       |   38|        See https://tools.ietf.org/html/rfc1738
       |   39|        See https://tools.ietf.org/html/rfc1808
       |   40|    */
       |   41|    var URLString: String { get }
       |   42|}
       |   43|
       |   44|extension String: URLStringConvertible {
      1|   45|    public var URLString: String {
      1|   46|        return self
      1|   47|    }
       |   48|}
       |   49|
       |   50|extension NSURL: URLStringConvertible {
      0|   51|    public var URLString: String {
      0|   52|        return absoluteString
      0|   53|    }
       |   54|}
       |   55|
       |   56|extension NSURLComponents: URLStringConvertible {
      0|   57|    public var URLString: String {
      0|   58|        return URL!.URLString
      0|   59|    }
       |   60|}
       |   61|
       |   62|extension NSURLRequest: URLStringConvertible {
      0|   63|    public var URLString: String {
      0|   64|        return URL!.URLString
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - URLRequestConvertible
       |   69|
       |   70|/**
       |   71|    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
       |   72|*/
       |   73|public protocol URLRequestConvertible {
       |   74|    /// The URL request.
       |   75|    var URLRequest: NSMutableURLRequest { get }
       |   76|}
       |   77|
       |   78|extension NSURLRequest: URLRequestConvertible {
      2|   79|    public var URLRequest: NSMutableURLRequest {
      2|   80|        return self.mutableCopy() as! NSMutableURLRequest
      2|   81|    }
       |   82|}
       |   83|
       |   84|// MARK: - Convenience
       |   85|
       |   86|func URLRequest(
       |   87|    method: Method,
       |   88|    _ URLString: URLStringConvertible,
       |   89|    headers: [String: String]? = nil)
       |   90|    -> NSMutableURLRequest
      1|   91|{
      1|   92|    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
      1|   93|    mutableURLRequest.HTTPMethod = method.rawValue
      1|   94|
      1|   95|    if let headers = headers {
      2|   96|        for (headerField, headerValue) in headers {
      2|   97|            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
      2|   98|        }
      1|   99|    }
      1|  100|
      1|  101|    return mutableURLRequest
      1|  102|}
       |  103|
       |  104|// MARK: - Request Methods
       |  105|
       |  106|/**
       |  107|    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
       |  108|    parameter encoding.
       |  109|
       |  110|    - parameter method:     The HTTP method.
       |  111|    - parameter URLString:  The URL string.
       |  112|    - parameter parameters: The parameters. `nil` by default.
       |  113|    - parameter encoding:   The parameter encoding. `.URL` by default.
       |  114|    - parameter headers:    The HTTP headers. `nil` by default.
       |  115|
       |  116|    - returns: The created request.
       |  117|*/
       |  118|public func request(
       |  119|    method: Method,
       |  120|    _ URLString: URLStringConvertible,
       |  121|    parameters: [String: AnyObject]? = nil,
       |  122|    encoding: ParameterEncoding = .URL,
       |  123|    headers: [String: String]? = nil)
       |  124|    -> Request
      1|  125|{
      1|  126|    return Manager.sharedInstance.request(
      1|  127|        method,
      1|  128|        URLString,
      1|  129|        parameters: parameters,
      1|  130|        encoding: encoding,
      1|  131|        headers: headers
      1|  132|    )
      1|  133|}
       |  134|
       |  135|/**
       |  136|    Creates a request using the shared manager instance for the specified URL request.
       |  137|
       |  138|    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  139|
       |  140|    - parameter URLRequest: The URL request
       |  141|
       |  142|    - returns: The created request.
       |  143|*/
      0|  144|public func request(URLRequest: URLRequestConvertible) -> Request {
      0|  145|    return Manager.sharedInstance.request(URLRequest.URLRequest)
      0|  146|}
       |  147|
       |  148|// MARK: - Upload Methods
       |  149|
       |  150|// MARK: File
       |  151|
       |  152|/**
       |  153|    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
       |  154|
       |  155|    - parameter method:    The HTTP method.
       |  156|    - parameter URLString: The URL string.
       |  157|    - parameter headers:   The HTTP headers. `nil` by default.
       |  158|    - parameter file:      The file to upload.
       |  159|
       |  160|    - returns: The created upload request.
       |  161|*/
       |  162|public func upload(
       |  163|    method: Method,
       |  164|    _ URLString: URLStringConvertible,
       |  165|    headers: [String: String]? = nil,
       |  166|    file: NSURL)
       |  167|    -> Request
      0|  168|{
      0|  169|    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
      0|  170|}
       |  171|
       |  172|/**
       |  173|    Creates an upload request using the shared manager instance for the specified URL request and file.
       |  174|
       |  175|    - parameter URLRequest: The URL request.
       |  176|    - parameter file:       The file to upload.
       |  177|
       |  178|    - returns: The created upload request.
       |  179|*/
      0|  180|public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|  181|    return Manager.sharedInstance.upload(URLRequest, file: file)
      0|  182|}
       |  183|
       |  184|// MARK: Data
       |  185|
       |  186|/**
       |  187|    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
       |  188|
       |  189|    - parameter method:    The HTTP method.
       |  190|    - parameter URLString: The URL string.
       |  191|    - parameter headers:   The HTTP headers. `nil` by default.
       |  192|    - parameter data:      The data to upload.
       |  193|
       |  194|    - returns: The created upload request.
       |  195|*/
       |  196|public func upload(
       |  197|    method: Method,
       |  198|    _ URLString: URLStringConvertible,
       |  199|    headers: [String: String]? = nil,
       |  200|    data: NSData)
       |  201|    -> Request
      0|  202|{
      0|  203|    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
      0|  204|}
       |  205|
       |  206|/**
       |  207|    Creates an upload request using the shared manager instance for the specified URL request and data.
       |  208|
       |  209|    - parameter URLRequest: The URL request.
       |  210|    - parameter data:       The data to upload.
       |  211|
       |  212|    - returns: The created upload request.
       |  213|*/
      0|  214|public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  215|    return Manager.sharedInstance.upload(URLRequest, data: data)
      0|  216|}
       |  217|
       |  218|// MARK: Stream
       |  219|
       |  220|/**
       |  221|    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
       |  222|
       |  223|    - parameter method:    The HTTP method.
       |  224|    - parameter URLString: The URL string.
       |  225|    - parameter headers:   The HTTP headers. `nil` by default.
       |  226|    - parameter stream:    The stream to upload.
       |  227|
       |  228|    - returns: The created upload request.
       |  229|*/
       |  230|public func upload(
       |  231|    method: Method,
       |  232|    _ URLString: URLStringConvertible,
       |  233|    headers: [String: String]? = nil,
       |  234|    stream: NSInputStream)
       |  235|    -> Request
      0|  236|{
      0|  237|    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
      0|  238|}
       |  239|
       |  240|/**
       |  241|    Creates an upload request using the shared manager instance for the specified URL request and stream.
       |  242|
       |  243|    - parameter URLRequest: The URL request.
       |  244|    - parameter stream:     The stream to upload.
       |  245|
       |  246|    - returns: The created upload request.
       |  247|*/
      0|  248|public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  249|    return Manager.sharedInstance.upload(URLRequest, stream: stream)
      0|  250|}
       |  251|
       |  252|// MARK: MultipartFormData
       |  253|
       |  254|/**
       |  255|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  256|
       |  257|    - parameter method:                  The HTTP method.
       |  258|    - parameter URLString:               The URL string.
       |  259|    - parameter headers:                 The HTTP headers. `nil` by default.
       |  260|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  261|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  262|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  263|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  264|*/
       |  265|public func upload(
       |  266|    method: Method,
       |  267|    _ URLString: URLStringConvertible,
       |  268|    headers: [String: String]? = nil,
       |  269|    multipartFormData: MultipartFormData -> Void,
       |  270|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  271|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  272|{
      0|  273|    return Manager.sharedInstance.upload(
      0|  274|        method,
      0|  275|        URLString,
      0|  276|        headers: headers,
      0|  277|        multipartFormData: multipartFormData,
      0|  278|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  279|        encodingCompletion: encodingCompletion
      0|  280|    )
      0|  281|}
       |  282|
       |  283|/**
       |  284|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  285|
       |  286|    - parameter URLRequest:              The URL request.
       |  287|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  288|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  289|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  290|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  291|*/
       |  292|public func upload(
       |  293|    URLRequest: URLRequestConvertible,
       |  294|    multipartFormData: MultipartFormData -> Void,
       |  295|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  296|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  297|{
      0|  298|    return Manager.sharedInstance.upload(
      0|  299|        URLRequest,
      0|  300|        multipartFormData: multipartFormData,
      0|  301|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  302|        encodingCompletion: encodingCompletion
      0|  303|    )
      0|  304|}
       |  305|
       |  306|// MARK: - Download Methods
       |  307|
       |  308|// MARK: URL Request
       |  309|
       |  310|/**
       |  311|    Creates a download request using the shared manager instance for the specified method and URL string.
       |  312|
       |  313|    - parameter method:      The HTTP method.
       |  314|    - parameter URLString:   The URL string.
       |  315|    - parameter parameters:  The parameters. `nil` by default.
       |  316|    - parameter encoding:    The parameter encoding. `.URL` by default.
       |  317|    - parameter headers:     The HTTP headers. `nil` by default.
       |  318|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  319|
       |  320|    - returns: The created download request.
       |  321|*/
       |  322|public func download(
       |  323|    method: Method,
       |  324|    _ URLString: URLStringConvertible,
       |  325|    parameters: [String: AnyObject]? = nil,
       |  326|    encoding: ParameterEncoding = .URL,
       |  327|    headers: [String: String]? = nil,
       |  328|    destination: Request.DownloadFileDestination)
       |  329|    -> Request
      0|  330|{
      0|  331|    return Manager.sharedInstance.download(
      0|  332|        method,
      0|  333|        URLString,
      0|  334|        parameters: parameters,
      0|  335|        encoding: encoding,
      0|  336|        headers: headers,
      0|  337|        destination: destination
      0|  338|    )
      0|  339|}
       |  340|
       |  341|/**
       |  342|    Creates a download request using the shared manager instance for the specified URL request.
       |  343|
       |  344|    - parameter URLRequest:  The URL request.
       |  345|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  346|
       |  347|    - returns: The created download request.
       |  348|*/
      0|  349|public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  350|    return Manager.sharedInstance.download(URLRequest, destination: destination)
      0|  351|}
       |  352|
       |  353|// MARK: Resume Data
       |  354|
       |  355|/**
       |  356|    Creates a request using the shared manager instance for downloading from the resume data produced from a 
       |  357|    previous request cancellation.
       |  358|
       |  359|    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
       |  360|                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
       |  361|                             information.
       |  362|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  363|
       |  364|    - returns: The created download request.
       |  365|*/
      0|  366|public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  367|    return Manager.sharedInstance.download(data, destination: destination)
      0|  368|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Download.swift:
       |    1|// Download.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Downloadable {
       |   27|        case Request(NSURLRequest)
       |   28|        case ResumeData(NSData)
       |   29|    }
       |   30|
      0|   31|    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
      0|   32|        var downloadTask: NSURLSessionDownloadTask!
      0|   33|
      0|   34|        switch downloadable {
      0|   35|        case .Request(let request):
      0|   36|            dispatch_sync(queue) {
      0|   37|                downloadTask = self.session.downloadTaskWithRequest(request)
      0|   38|            }
      0|   39|        case .ResumeData(let resumeData):
      0|   40|            dispatch_sync(queue) {
      0|   41|                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
      0|   42|            }
      0|   43|        }
      0|   44|
      0|   45|        let request = Request(session: session, task: downloadTask)
      0|   46|
      0|   47|        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
      0|   48|            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
      0|   49|                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
      0|   50|            }
      0|   51|        }
      0|   52|
      0|   53|        delegate[request.delegate.task] = request.delegate
      0|   54|
      0|   55|        if startRequestsImmediately {
      0|   56|            request.resume()
      0|   57|        }
      0|   58|
      0|   59|        return request
      0|   60|    }
       |   61|
       |   62|    // MARK: Request
       |   63|
       |   64|    /**
       |   65|        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
       |   66|        and destination.
       |   67|
       |   68|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   69|
       |   70|        - parameter method:      The HTTP method.
       |   71|        - parameter URLString:   The URL string.
       |   72|        - parameter parameters:  The parameters. `nil` by default.
       |   73|        - parameter encoding:    The parameter encoding. `.URL` by default.
       |   74|        - parameter headers:     The HTTP headers. `nil` by default.
       |   75|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |   76|
       |   77|        - returns: The created download request.
       |   78|    */
       |   79|    public func download(
       |   80|        method: Method,
       |   81|        _ URLString: URLStringConvertible,
       |   82|        parameters: [String: AnyObject]? = nil,
       |   83|        encoding: ParameterEncoding = .URL,
       |   84|        headers: [String: String]? = nil,
       |   85|        destination: Request.DownloadFileDestination)
       |   86|        -> Request
      0|   87|    {
      0|   88|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|   89|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      0|   90|
      0|   91|        return download(encodedURLRequest, destination: destination)
      0|   92|    }
       |   93|
       |   94|    /**
       |   95|        Creates a request for downloading from the specified URL request.
       |   96|
       |   97|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   98|
       |   99|        - parameter URLRequest:  The URL request
       |  100|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  101|
       |  102|        - returns: The created download request.
       |  103|    */
      0|  104|    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  105|        return download(.Request(URLRequest.URLRequest), destination: destination)
      0|  106|    }
       |  107|
       |  108|    // MARK: Resume Data
       |  109|
       |  110|    /**
       |  111|        Creates a request for downloading from the resume data produced from a previous request cancellation.
       |  112|
       |  113|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  114|
       |  115|        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
       |  116|                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
       |  117|                                 additional information.
       |  118|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  119|
       |  120|        - returns: The created download request.
       |  121|    */
      0|  122|    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  123|        return download(.ResumeData(resumeData), destination: destination)
      0|  124|    }
       |  125|}
       |  126|
       |  127|// MARK: -
       |  128|
       |  129|extension Request {
       |  130|    /**
       |  131|        A closure executed once a request has successfully completed in order to determine where to move the temporary 
       |  132|        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
       |  133|        response, and returns a single argument: the file URL where the temporary file should be moved.
       |  134|    */
       |  135|    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
       |  136|
       |  137|    /**
       |  138|        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
       |  139|        file URL in the first available directory with the specified search path directory and search path domain mask.
       |  140|
       |  141|        - parameter directory: The search path directory. `.DocumentDirectory` by default.
       |  142|        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
       |  143|
       |  144|        - returns: A download file destination closure.
       |  145|    */
       |  146|    public class func suggestedDownloadDestination(
       |  147|        directory directory: NSSearchPathDirectory = .DocumentDirectory,
       |  148|        domain: NSSearchPathDomainMask = .UserDomainMask)
       |  149|        -> DownloadFileDestination
      0|  150|    {
      0|  151|        return { temporaryURL, response -> NSURL in
      0|  152|            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
      0|  153|
      0|  154|            if !directoryURLs.isEmpty {
      0|  155|                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
      0|  156|            }
      0|  157|
      0|  158|            return temporaryURL
      0|  159|        }
      0|  160|    }
       |  161|
       |  162|    /// The resume data of the underlying download task if available after a failure.
      0|  163|    public var resumeData: NSData? {
      0|  164|        var data: NSData?
      0|  165|
      0|  166|        if let delegate = delegate as? DownloadTaskDelegate {
      0|  167|            data = delegate.resumeData
      0|  168|        }
      0|  169|
      0|  170|        return data
      0|  171|    }
       |  172|
       |  173|    // MARK: - DownloadTaskDelegate
       |  174|
       |  175|    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
      0|  176|        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
       |  177|        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
       |  178|
       |  179|        var resumeData: NSData?
      0|  180|        override var data: NSData? { return resumeData }
       |  181|
       |  182|        // MARK: - NSURLSessionDownloadDelegate
       |  183|
       |  184|        // MARK: Override Closures
       |  185|
       |  186|        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
       |  187|        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  188|        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  189|
       |  190|        // MARK: Delegate Methods
       |  191|
       |  192|        func URLSession(
       |  193|            session: NSURLSession,
       |  194|            downloadTask: NSURLSessionDownloadTask,
       |  195|            didFinishDownloadingToURL location: NSURL)
      0|  196|        {
      0|  197|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  198|                do {
      0|  199|                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  200|                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
      0|  201|                } catch {
      0|  202|                    self.error = error as NSError
      0|  203|                }
      0|  204|            }
      0|  205|        }
       |  206|
       |  207|        func URLSession(
       |  208|            session: NSURLSession,
       |  209|            downloadTask: NSURLSessionDownloadTask,
       |  210|            didWriteData bytesWritten: Int64,
       |  211|            totalBytesWritten: Int64,
       |  212|            totalBytesExpectedToWrite: Int64)
      0|  213|        {
      0|  214|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  215|                downloadTaskDidWriteData(
      0|  216|                    session,
      0|  217|                    downloadTask,
      0|  218|                    bytesWritten,
      0|  219|                    totalBytesWritten, 
      0|  220|                    totalBytesExpectedToWrite
      0|  221|                )
      0|  222|            } else {
      0|  223|                progress.totalUnitCount = totalBytesExpectedToWrite
      0|  224|                progress.completedUnitCount = totalBytesWritten
      0|  225|
      0|  226|                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  227|            }
      0|  228|        }
       |  229|
       |  230|        func URLSession(
       |  231|            session: NSURLSession,
       |  232|            downloadTask: NSURLSessionDownloadTask,
       |  233|            didResumeAtOffset fileOffset: Int64,
       |  234|            expectedTotalBytes: Int64)
      0|  235|        {
      0|  236|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  237|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  238|            } else {
      0|  239|                progress.totalUnitCount = expectedTotalBytes
      0|  240|                progress.completedUnitCount = fileOffset
      0|  241|            }
      0|  242|        }
       |  243|    }
       |  244|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Error.swift:
       |    1|// Error.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
       |   26|public struct Error {
       |   27|    /// The domain used for creating all Alamofire errors.
       |   28|    public static let Domain = "com.alamofire.error"
       |   29|
       |   30|    /// The custom error codes generated by Alamofire.
       |   31|    public enum Code: Int {
       |   32|        case InputStreamReadFailed           = -6000
       |   33|        case OutputStreamWriteFailed         = -6001
       |   34|        case ContentTypeValidationFailed     = -6002
       |   35|        case StatusCodeValidationFailed      = -6003
       |   36|        case DataSerializationFailed         = -6004
       |   37|        case StringSerializationFailed       = -6005
       |   38|        case JSONSerializationFailed         = -6006
       |   39|        case PropertyListSerializationFailed = -6007
       |   40|    }
       |   41|
       |   42|    /**
       |   43|        Creates an `NSError` with the given error code and failure reason.
       |   44|
       |   45|        - parameter code:          The error code.
       |   46|        - parameter failureReason: The failure reason.
       |   47|
       |   48|        - returns: An `NSError` with the given error code and failure reason.
       |   49|    */
      0|   50|    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
      0|   51|        return errorWithCode(code.rawValue, failureReason: failureReason)
      0|   52|    }
       |   53|
       |   54|    /**
       |   55|        Creates an `NSError` with the given error code and failure reason.
       |   56|
       |   57|        - parameter code:          The error code.
       |   58|        - parameter failureReason: The failure reason.
       |   59|
       |   60|        - returns: An `NSError` with the given error code and failure reason.
       |   61|    */
      0|   62|    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
      0|   63|        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
      0|   64|        return NSError(domain: Domain, code: code, userInfo: userInfo)
      0|   65|    }
       |   66|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Manager.swift:
       |    1|// Manager.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
       |   27|*/
       |   28|public class Manager {
       |   29|
       |   30|    // MARK: - Properties
       |   31|
       |   32|    /**
       |   33|        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
       |   34|        for any ad hoc requests.
       |   35|    */
       |   36|    public static let sharedInstance: Manager = {
       |   37|        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
       |   38|        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
       |   39|
       |   40|        return Manager(configuration: configuration)
       |   41|    }()
       |   42|
       |   43|    /**
       |   44|        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
       |   45|    */
       |   46|    public static let defaultHTTPHeaders: [String: String] = {
       |   47|        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
       |   48|        let acceptEncoding: String = "gzip;q=1.0,compress;q=0.5"
       |   49|
       |   50|        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
       |   51|        let acceptLanguage: String = {
       |   52|            var components: [String] = []
       |   53|            for (index, languageCode) in (NSLocale.preferredLanguages() as [String]).enumerate() {
       |   54|                let q = 1.0 - (Double(index) * 0.1)
       |   55|                components.append("\(languageCode);q=\(q)")
       |   56|                if q <= 0.5 {
       |   57|                    break
       |   58|                }
       |   59|            }
       |   60|
       |   61|            return components.joinWithSeparator(",")
       |   62|        }()
       |   63|
       |   64|        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
       |   65|        let userAgent: String = {
       |   66|            if let info = NSBundle.mainBundle().infoDictionary {
       |   67|                let executable: AnyObject = info[kCFBundleExecutableKey as String] ?? "Unknown"
       |   68|                let bundle: AnyObject = info[kCFBundleIdentifierKey as String] ?? "Unknown"
       |   69|                let version: AnyObject = info[kCFBundleVersionKey as String] ?? "Unknown"
       |   70|                let os: AnyObject = NSProcessInfo.processInfo().operatingSystemVersionString ?? "Unknown"
       |   71|
       |   72|                var mutableUserAgent = NSMutableString(string: "\(executable)/\(bundle) (\(version); OS \(os))") as CFMutableString
       |   73|                let transform = NSString(string: "Any-Latin; Latin-ASCII; [:^ASCII:] Remove") as CFString
       |   74|
       |   75|                if CFStringTransform(mutableUserAgent, UnsafeMutablePointer<CFRange>(nil), transform, false) {
       |   76|                    return mutableUserAgent as String
       |   77|                }
       |   78|            }
       |   79|
       |   80|            return "Alamofire"
       |   81|        }()
       |   82|
       |   83|        return [
       |   84|            "Accept-Encoding": acceptEncoding,
       |   85|            "Accept-Language": acceptLanguage,
       |   86|            "User-Agent": userAgent
       |   87|        ]
       |   88|    }()
       |   89|
       |   90|    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
       |   91|
       |   92|    /// The underlying session.
       |   93|    public let session: NSURLSession
       |   94|
       |   95|    /// The session delegate handling all the task and session delegate callbacks.
       |   96|    public let delegate: SessionDelegate
       |   97|
       |   98|    /// Whether to start requests immediately after being constructed. `true` by default.
       |   99|    public var startRequestsImmediately: Bool = true
       |  100|
       |  101|    /**
       |  102|        The background completion handler closure provided by the UIApplicationDelegate 
       |  103|        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
       |  104|        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
       |  105|        will automatically call the handler.
       |  106|    
       |  107|        If you need to handle your own events before the handler is called, then you need to override the 
       |  108|        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
       |  109|    
       |  110|        `nil` by default.
       |  111|    */
       |  112|    public var backgroundCompletionHandler: (() -> Void)?
       |  113|
       |  114|    // MARK: - Lifecycle
       |  115|
       |  116|    /**
       |  117|        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
       |  118|
       |  119|        - parameter configuration:            The configuration used to construct the managed session. 
       |  120|                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
       |  121|        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
       |  122|                                              default.
       |  123|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
       |  124|                                              challenges. `nil` by default.
       |  125|
       |  126|        - returns: The new `Manager` instance.
       |  127|    */
       |  128|    public init(
       |  129|        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
       |  130|        delegate: SessionDelegate = SessionDelegate(),
       |  131|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      1|  132|    {
      1|  133|        self.delegate = delegate
      1|  134|        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
      1|  135|
      1|  136|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      1|  137|    }
       |  138|
       |  139|    /**
       |  140|        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
       |  141|
       |  142|        - parameter session:                  The URL session.
       |  143|        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
       |  144|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
       |  145|                                              challenges. `nil` by default.
       |  146|
       |  147|        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
       |  148|    */
       |  149|    public init?(
       |  150|        session: NSURLSession,
       |  151|        delegate: SessionDelegate,
       |  152|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      0|  153|    {
      0|  154|        self.delegate = delegate
      0|  155|        self.session = session
      0|  156|
      0|  157|        guard delegate === session.delegate else { return nil }
      0|  158|
      0|  159|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      0|  160|    }
       |  161|
      1|  162|    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
      1|  163|        session.serverTrustPolicyManager = serverTrustPolicyManager
      1|  164|
      0|  165|        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
      0|  166|            guard let strongSelf = self else { return }
      0|  167|            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
      0|  168|        }
      1|  169|    }
       |  170|
      0|  171|    deinit {
      0|  172|        session.invalidateAndCancel()
      0|  173|    }
       |  174|
       |  175|    // MARK: - Request
       |  176|
       |  177|    /**
       |  178|        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
       |  179|
       |  180|        - parameter method:     The HTTP method.
       |  181|        - parameter URLString:  The URL string.
       |  182|        - parameter parameters: The parameters. `nil` by default.
       |  183|        - parameter encoding:   The parameter encoding. `.URL` by default.
       |  184|        - parameter headers:    The HTTP headers. `nil` by default.
       |  185|
       |  186|        - returns: The created request.
       |  187|    */
       |  188|    public func request(
       |  189|        method: Method,
       |  190|        _ URLString: URLStringConvertible,
       |  191|        parameters: [String: AnyObject]? = nil,
       |  192|        encoding: ParameterEncoding = .URL,
       |  193|        headers: [String: String]? = nil)
       |  194|        -> Request
      1|  195|    {
      1|  196|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      1|  197|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      1|  198|        return request(encodedURLRequest)
      1|  199|    }
       |  200|
       |  201|    /**
       |  202|        Creates a request for the specified URL request.
       |  203|
       |  204|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  205|
       |  206|        - parameter URLRequest: The URL request
       |  207|
       |  208|        - returns: The created request.
       |  209|    */
      1|  210|    public func request(URLRequest: URLRequestConvertible) -> Request {
      1|  211|        var dataTask: NSURLSessionDataTask!
      1|  212|        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
      1|  213|
      1|  214|        let request = Request(session: session, task: dataTask)
      1|  215|        delegate[request.delegate.task] = request.delegate
      1|  216|
      1|  217|        if startRequestsImmediately {
      1|  218|            request.resume()
      1|  219|        }
      1|  220|
      1|  221|        return request
      1|  222|    }
       |  223|
       |  224|    // MARK: - SessionDelegate
       |  225|
       |  226|    /**
       |  227|        Responsible for handling all delegate callbacks for the underlying session.
       |  228|    */
       |  229|    public final class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
       |  230|        private var subdelegates: [Int: Request.TaskDelegate] = [:]
       |  231|        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
       |  232|
       |  233|        subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
      4|  234|            get {
      4|  235|                var subdelegate: Request.TaskDelegate?
      4|  236|                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
      4|  237|
      4|  238|                return subdelegate
      4|  239|            }
       |  240|
      2|  241|            set {
      2|  242|                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
      2|  243|            }
       |  244|        }
       |  245|
       |  246|        /**
       |  247|            Initializes the `SessionDelegate` instance.
       |  248|
       |  249|            - returns: The new `SessionDelegate` instance.
       |  250|        */
      1|  251|        public override init() {
      1|  252|            super.init()
      1|  253|        }
       |  254|
       |  255|        // MARK: - NSURLSessionDelegate
       |  256|
       |  257|        // MARK: Override Closures
       |  258|
       |  259|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
       |  260|        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
       |  261|
       |  262|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
       |  263|        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  264|
       |  265|        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
       |  266|        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
       |  267|
       |  268|        // MARK: Delegate Methods
       |  269|
       |  270|        /**
       |  271|            Tells the delegate that the session has been invalidated.
       |  272|
       |  273|            - parameter session: The session object that was invalidated.
       |  274|            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
       |  275|        */
      0|  276|        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
      0|  277|            sessionDidBecomeInvalidWithError?(session, error)
      0|  278|        }
       |  279|
       |  280|        /**
       |  281|            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
       |  282|
       |  283|            - parameter session:           The session containing the task that requested authentication.
       |  284|            - parameter challenge:         An object that contains the request for authentication.
       |  285|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  286|        */
       |  287|        public func URLSession(
       |  288|            session: NSURLSession,
       |  289|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  290|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      0|  291|        {
      0|  292|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      0|  293|            var credential: NSURLCredential?
      0|  294|
      0|  295|            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
      0|  296|                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
      0|  297|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      0|  298|                let host = challenge.protectionSpace.host
      0|  299|
      0|  300|                if let
      0|  301|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      0|  302|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  303|                {
      0|  304|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  305|                        disposition = .UseCredential
      0|  306|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  307|                    } else {
      0|  308|                        disposition = .CancelAuthenticationChallenge
      0|  309|                    }
      0|  310|                }
      0|  311|            }
      0|  312|
      0|  313|            completionHandler(disposition, credential)
      0|  314|        }
       |  315|
       |  316|        /**
       |  317|            Tells the delegate that all messages enqueued for a session have been delivered.
       |  318|
       |  319|            - parameter session: The session that no longer has any outstanding requests.
       |  320|        */
      0|  321|        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
      0|  322|            sessionDidFinishEventsForBackgroundURLSession?(session)
      0|  323|        }
       |  324|
       |  325|        // MARK: - NSURLSessionTaskDelegate
       |  326|
       |  327|        // MARK: Override Closures
       |  328|
       |  329|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
       |  330|        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  331|
       |  332|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
       |  333|        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  334|
       |  335|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
       |  336|        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream!)?
       |  337|
       |  338|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
       |  339|        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  340|
       |  341|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
       |  342|        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  343|
       |  344|        // MARK: Delegate Methods
       |  345|
       |  346|        /**
       |  347|            Tells the delegate that the remote server requested an HTTP redirect.
       |  348|
       |  349|            - parameter session:           The session containing the task whose request resulted in a redirect.
       |  350|            - parameter task:              The task whose request resulted in a redirect.
       |  351|            - parameter response:          An object containing the server’s response to the original request.
       |  352|            - parameter request:           A URL request object filled out with the new location.
       |  353|            - parameter completionHandler: A closure that your handler should call with either the value of the request 
       |  354|                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
       |  355|                                           return the body of the redirect response.
       |  356|        */
       |  357|        public func URLSession(
       |  358|            session: NSURLSession,
       |  359|            task: NSURLSessionTask,
       |  360|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  361|            newRequest request: NSURLRequest,
       |  362|            completionHandler: ((NSURLRequest?) -> Void))
      0|  363|        {
      0|  364|            var redirectRequest: NSURLRequest? = request
      0|  365|
      0|  366|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  367|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  368|            }
      0|  369|
      0|  370|            completionHandler(redirectRequest)
      0|  371|        }
       |  372|
       |  373|        /**
       |  374|            Requests credentials from the delegate in response to an authentication request from the remote server.
       |  375|
       |  376|            - parameter session:           The session containing the task whose request requires authentication.
       |  377|            - parameter task:              The task whose request requires authentication.
       |  378|            - parameter challenge:         An object that contains the request for authentication.
       |  379|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  380|        */
       |  381|        public func URLSession(
       |  382|            session: NSURLSession,
       |  383|            task: NSURLSessionTask,
       |  384|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  385|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  386|        {
      0|  387|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  388|                completionHandler(taskDidReceiveChallenge(session, task, challenge))
      1|  389|            } else if let delegate = self[task] {
      1|  390|                delegate.URLSession(
      1|  391|                    session,
      1|  392|                    task: task,
      1|  393|                    didReceiveChallenge: challenge,
      1|  394|                    completionHandler: completionHandler
      1|  395|                )
      0|  396|            } else {
      0|  397|                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
      0|  398|            }
      1|  399|        }
       |  400|
       |  401|        /**
       |  402|            Tells the delegate when a task requires a new request body stream to send to the remote server.
       |  403|
       |  404|            - parameter session:           The session containing the task that needs a new body stream.
       |  405|            - parameter task:              The task that needs a new body stream.
       |  406|            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
       |  407|        */
       |  408|        public func URLSession(
       |  409|            session: NSURLSession,
       |  410|            task: NSURLSessionTask,
       |  411|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  412|        {
      0|  413|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  414|                completionHandler(taskNeedNewBodyStream(session, task))
      0|  415|            } else if let delegate = self[task] {
      0|  416|                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
      0|  417|            }
      0|  418|        }
       |  419|
       |  420|        /**
       |  421|            Periodically informs the delegate of the progress of sending body content to the server.
       |  422|
       |  423|            - parameter session:                  The session containing the data task.
       |  424|            - parameter task:                     The data task.
       |  425|            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
       |  426|            - parameter totalBytesSent:           The total number of bytes sent so far.
       |  427|            - parameter totalBytesExpectedToSend: The expected length of the body data.
       |  428|        */
       |  429|        public func URLSession(
       |  430|            session: NSURLSession,
       |  431|            task: NSURLSessionTask,
       |  432|            didSendBodyData bytesSent: Int64,
       |  433|            totalBytesSent: Int64,
       |  434|            totalBytesExpectedToSend: Int64)
      1|  435|        {
      0|  436|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  437|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  438|            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
      0|  439|                delegate.URLSession(
      0|  440|                    session,
      0|  441|                    task: task,
      0|  442|                    didSendBodyData: bytesSent,
      0|  443|                    totalBytesSent: totalBytesSent,
      0|  444|                    totalBytesExpectedToSend: totalBytesExpectedToSend
      0|  445|                )
      0|  446|            }
      1|  447|        }
       |  448|
       |  449|        /**
       |  450|            Tells the delegate that the task finished transferring data.
       |  451|
       |  452|            - parameter session: The session containing the task whose request finished transferring data.
       |  453|            - parameter task:    The task whose request finished transferring data.
       |  454|            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
       |  455|        */
      1|  456|        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  457|            if let taskDidComplete = taskDidComplete {
      0|  458|                taskDidComplete(session, task, error)
      1|  459|            } else if let delegate = self[task] {
      1|  460|                delegate.URLSession(session, task: task, didCompleteWithError: error)
      1|  461|            }
      1|  462|
      1|  463|            self[task] = nil
      1|  464|        }
       |  465|
       |  466|        // MARK: - NSURLSessionDataDelegate
       |  467|
       |  468|        // MARK: Override Closures
       |  469|
       |  470|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
       |  471|        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  472|
       |  473|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
       |  474|        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  475|
       |  476|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
       |  477|        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  478|
       |  479|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
       |  480|        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse!)?
       |  481|
       |  482|        // MARK: Delegate Methods
       |  483|
       |  484|        /**
       |  485|            Tells the delegate that the data task received the initial reply (headers) from the server.
       |  486|
       |  487|            - parameter session:           The session containing the data task that received an initial reply.
       |  488|            - parameter dataTask:          The data task that received an initial reply.
       |  489|            - parameter response:          A URL response object populated with headers.
       |  490|            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
       |  491|                                           constant to indicate whether the transfer should continue as a data task or 
       |  492|                                           should become a download task.
       |  493|        */
       |  494|        public func URLSession(
       |  495|            session: NSURLSession,
       |  496|            dataTask: NSURLSessionDataTask,
       |  497|            didReceiveResponse response: NSURLResponse,
       |  498|            completionHandler: ((NSURLSessionResponseDisposition) -> Void))
      0|  499|        {
      0|  500|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  501|
      0|  502|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  503|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  504|            }
      0|  505|
      0|  506|            completionHandler(disposition)
      0|  507|        }
       |  508|
       |  509|        /**
       |  510|            Tells the delegate that the data task was changed to a download task.
       |  511|
       |  512|            - parameter session:      The session containing the task that was replaced by a download task.
       |  513|            - parameter dataTask:     The data task that was replaced by a download task.
       |  514|            - parameter downloadTask: The new download task that replaced the data task.
       |  515|        */
       |  516|        public func URLSession(
       |  517|            session: NSURLSession,
       |  518|            dataTask: NSURLSessionDataTask,
       |  519|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  520|        {
      0|  521|            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
      0|  522|                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
      0|  523|            } else {
      0|  524|                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
      0|  525|                self[downloadTask] = downloadDelegate
      0|  526|            }
      0|  527|        }
       |  528|
       |  529|        /**
       |  530|            Tells the delegate that the data task has received some of the expected data.
       |  531|
       |  532|            - parameter session:  The session containing the data task that provided data.
       |  533|            - parameter dataTask: The data task that provided data.
       |  534|            - parameter data:     A data object containing the transferred data.
       |  535|        */
      1|  536|        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  537|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  538|                dataTaskDidReceiveData(session, dataTask, data)
      1|  539|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      1|  540|                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
      1|  541|            }
      1|  542|        }
       |  543|
       |  544|        /**
       |  545|            Asks the delegate whether the data (or upload) task should store the response in the cache.
       |  546|
       |  547|            - parameter session:           The session containing the data (or upload) task.
       |  548|            - parameter dataTask:          The data (or upload) task.
       |  549|            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
       |  550|                                           caching policy and the values of certain received headers, such as the Pragma 
       |  551|                                           and Cache-Control headers.
       |  552|            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
       |  553|                                           response, a modified version of that response, or NULL to prevent caching the 
       |  554|                                           response. If your delegate implements this method, it must call this completion 
       |  555|                                           handler; otherwise, your app leaks memory.
       |  556|        */
       |  557|        public func URLSession(
       |  558|            session: NSURLSession,
       |  559|            dataTask: NSURLSessionDataTask,
       |  560|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  561|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  562|        {
      0|  563|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  564|                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
      0|  565|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      0|  566|                delegate.URLSession(
      0|  567|                    session,
      0|  568|                    dataTask: dataTask,
      0|  569|                    willCacheResponse: proposedResponse,
      0|  570|                    completionHandler: completionHandler
      0|  571|                )
      0|  572|            } else {
      0|  573|                completionHandler(proposedResponse)
      0|  574|            }
      0|  575|        }
       |  576|
       |  577|        // MARK: - NSURLSessionDownloadDelegate
       |  578|
       |  579|        // MARK: Override Closures
       |  580|
       |  581|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
       |  582|        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
       |  583|
       |  584|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
       |  585|        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  586|
       |  587|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
       |  588|        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  589|
       |  590|        // MARK: Delegate Methods
       |  591|
       |  592|        /**
       |  593|            Tells the delegate that a download task has finished downloading.
       |  594|
       |  595|            - parameter session:      The session containing the download task that finished.
       |  596|            - parameter downloadTask: The download task that finished.
       |  597|            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
       |  598|                                      open the file for reading or move it to a permanent location in your app’s sandbox 
       |  599|                                      container directory before returning from this delegate method.
       |  600|        */
       |  601|        public func URLSession(
       |  602|            session: NSURLSession,
       |  603|            downloadTask: NSURLSessionDownloadTask,
       |  604|            didFinishDownloadingToURL location: NSURL)
      0|  605|        {
      0|  606|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  607|                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  608|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  609|                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
      0|  610|            }
      0|  611|        }
       |  612|
       |  613|        /**
       |  614|            Periodically informs the delegate about the download’s progress.
       |  615|
       |  616|            - parameter session:                   The session containing the download task.
       |  617|            - parameter downloadTask:              The download task.
       |  618|            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
       |  619|                                                   method was called.
       |  620|            - parameter totalBytesWritten:         The total number of bytes transferred so far.
       |  621|            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
       |  622|                                                   header. If this header was not provided, the value is 
       |  623|                                                   `NSURLSessionTransferSizeUnknown`.
       |  624|        */
       |  625|        public func URLSession(
       |  626|            session: NSURLSession,
       |  627|            downloadTask: NSURLSessionDownloadTask,
       |  628|            didWriteData bytesWritten: Int64,
       |  629|            totalBytesWritten: Int64,
       |  630|            totalBytesExpectedToWrite: Int64)
      0|  631|        {
      0|  632|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  633|                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  634|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  635|                delegate.URLSession(
      0|  636|                    session,
      0|  637|                    downloadTask: downloadTask,
      0|  638|                    didWriteData: bytesWritten,
      0|  639|                    totalBytesWritten: totalBytesWritten,
      0|  640|                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
      0|  641|                )
      0|  642|            }
      0|  643|        }
       |  644|
       |  645|        /**
       |  646|            Tells the delegate that the download task has resumed downloading.
       |  647|
       |  648|            - parameter session:            The session containing the download task that finished.
       |  649|            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
       |  650|            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
       |  651|                                            existing content, then this value is zero. Otherwise, this value is an 
       |  652|                                            integer representing the number of bytes on disk that do not need to be 
       |  653|                                            retrieved again.
       |  654|            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
       |  655|                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
       |  656|        */
       |  657|        public func URLSession(
       |  658|            session: NSURLSession,
       |  659|            downloadTask: NSURLSessionDownloadTask,
       |  660|            didResumeAtOffset fileOffset: Int64,
       |  661|            expectedTotalBytes: Int64)
      0|  662|        {
      0|  663|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  664|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  665|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  666|                delegate.URLSession(
      0|  667|                    session,
      0|  668|                    downloadTask: downloadTask,
      0|  669|                    didResumeAtOffset: fileOffset,
      0|  670|                    expectedTotalBytes: expectedTotalBytes
      0|  671|                )
      0|  672|            }
      0|  673|        }
       |  674|
       |  675|        // MARK: - NSURLSessionStreamDelegate
       |  676|
       |  677|        var _streamTaskReadClosed: Any?
       |  678|        var _streamTaskWriteClosed: Any?
       |  679|        var _streamTaskBetterRouteDiscovered: Any?
       |  680|        var _streamTaskDidBecomeInputStream: Any?
       |  681|
       |  682|        // MARK: - NSObject
       |  683|
     11|  684|        public override func respondsToSelector(selector: Selector) -> Bool {
     11|  685|            switch selector {
      0|  686|            case "URLSession:didBecomeInvalidWithError:":
      0|  687|                return sessionDidBecomeInvalidWithError != nil
      1|  688|            case "URLSession:didReceiveChallenge:completionHandler:":
      1|  689|                return sessionDidReceiveChallenge != nil
      0|  690|            case "URLSessionDidFinishEventsForBackgroundURLSession:":
      0|  691|                return sessionDidFinishEventsForBackgroundURLSession != nil
      0|  692|            case "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:":
      0|  693|                return taskWillPerformHTTPRedirection != nil
      1|  694|            case "URLSession:dataTask:didReceiveResponse:completionHandler:":
      1|  695|                return dataTaskDidReceiveResponse != nil
      9|  696|            default:
      9|  697|                return self.dynamicType.instancesRespondToSelector(selector)
     11|  698|            }
     11|  699|        }
       |  700|    }
       |  701|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/MultipartFormData.swift:
       |    1|// MultipartFormData.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if os(iOS) || os(watchOS) || os(tvOS)
       |   26|import MobileCoreServices
       |   27|#elseif os(OSX)
       |   28|import CoreServices
       |   29|#endif
       |   30|
       |   31|/**
       |   32|    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
       |   33|    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
       |   34|    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
       |   35|    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
       |   36|    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
       |   37|
       |   38|    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
       |   39|    and the w3 form documentation.
       |   40|
       |   41|    - https://www.ietf.org/rfc/rfc2388.txt
       |   42|    - https://www.ietf.org/rfc/rfc2045.txt
       |   43|    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
       |   44|*/
       |   45|public class MultipartFormData {
       |   46|
       |   47|    // MARK: - Helper Types
       |   48|
       |   49|    struct EncodingCharacters {
       |   50|        static let CRLF = "\r\n"
       |   51|    }
       |   52|
       |   53|    struct BoundaryGenerator {
       |   54|        enum BoundaryType {
       |   55|            case Initial, Encapsulated, Final
       |   56|        }
       |   57|
      0|   58|        static func randomBoundary() -> String {
      0|   59|            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
      0|   60|        }
       |   61|
      0|   62|        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
      0|   63|            let boundaryText: String
      0|   64|
      0|   65|            switch boundaryType {
      0|   66|            case .Initial:
      0|   67|                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
      0|   68|            case .Encapsulated:
      0|   69|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
      0|   70|            case .Final:
      0|   71|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
      0|   72|            }
      0|   73|
      0|   74|            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|   75|        }
       |   76|    }
       |   77|
       |   78|    class BodyPart {
       |   79|        let headers: [String: String]
       |   80|        let bodyStream: NSInputStream
       |   81|        let bodyContentLength: UInt64
       |   82|        var hasInitialBoundary = false
       |   83|        var hasFinalBoundary = false
       |   84|
      0|   85|        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
      0|   86|            self.headers = headers
      0|   87|            self.bodyStream = bodyStream
      0|   88|            self.bodyContentLength = bodyContentLength
      0|   89|        }
       |   90|    }
       |   91|
       |   92|    // MARK: - Properties
       |   93|
       |   94|    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
      0|   95|    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
       |   96|
       |   97|    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
      0|   98|    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
       |   99|
       |  100|    /// The boundary used to separate the body parts in the encoded form data.
       |  101|    public let boundary: String
       |  102|
       |  103|    private var bodyParts: [BodyPart]
       |  104|    private var bodyPartError: NSError?
       |  105|    private let streamBufferSize: Int
       |  106|
       |  107|    // MARK: - Lifecycle
       |  108|
       |  109|    /**
       |  110|        Creates a multipart form data object.
       |  111|
       |  112|        - returns: The multipart form data object.
       |  113|    */
      0|  114|    public init() {
      0|  115|        self.boundary = BoundaryGenerator.randomBoundary()
      0|  116|        self.bodyParts = []
      0|  117|
      0|  118|        /**
      0|  119|         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
      0|  120|         *  information, please refer to the following article:
      0|  121|         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
      0|  122|         */
      0|  123|
      0|  124|        self.streamBufferSize = 1024
      0|  125|    }
       |  126|
       |  127|    // MARK: - Body Parts
       |  128|
       |  129|    /**
       |  130|        Creates a body part from the data and appends it to the multipart form data object.
       |  131|
       |  132|        The body part data will be encoded using the following format:
       |  133|
       |  134|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  135|        - Encoded data
       |  136|        - Multipart form boundary
       |  137|
       |  138|        - parameter data: The data to encode into the multipart form data.
       |  139|        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
       |  140|    */
      0|  141|    public func appendBodyPart(data data: NSData, name: String) {
      0|  142|        let headers = contentHeaders(name: name)
      0|  143|        let stream = NSInputStream(data: data)
      0|  144|        let length = UInt64(data.length)
      0|  145|
      0|  146|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  147|    }
       |  148|
       |  149|    /**
       |  150|        Creates a body part from the data and appends it to the multipart form data object.
       |  151|
       |  152|        The body part data will be encoded using the following format:
       |  153|
       |  154|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  155|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  156|        - Encoded data
       |  157|        - Multipart form boundary
       |  158|
       |  159|        - parameter data:     The data to encode into the multipart form data.
       |  160|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  161|        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
       |  162|    */
      0|  163|    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
      0|  164|        let headers = contentHeaders(name: name, mimeType: mimeType)
      0|  165|        let stream = NSInputStream(data: data)
      0|  166|        let length = UInt64(data.length)
      0|  167|
      0|  168|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  169|    }
       |  170|
       |  171|    /**
       |  172|        Creates a body part from the data and appends it to the multipart form data object.
       |  173|
       |  174|        The body part data will be encoded using the following format:
       |  175|
       |  176|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  177|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  178|        - Encoded file data
       |  179|        - Multipart form boundary
       |  180|
       |  181|        - parameter data:     The data to encode into the multipart form data.
       |  182|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  183|        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
       |  184|        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
       |  185|    */
      0|  186|    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
      0|  187|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  188|        let stream = NSInputStream(data: data)
      0|  189|        let length = UInt64(data.length)
      0|  190|
      0|  191|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Creates a body part from the file and appends it to the multipart form data object.
       |  196|
       |  197|        The body part data will be encoded using the following format:
       |  198|
       |  199|        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
       |  200|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  201|        - Encoded file data
       |  202|        - Multipart form boundary
       |  203|
       |  204|        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
       |  205|        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
       |  206|        system associated MIME type.
       |  207|
       |  208|        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
       |  209|        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  210|    */
      0|  211|    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
      0|  212|        if let
      0|  213|            fileName = fileURL.lastPathComponent,
      0|  214|            pathExtension = fileURL.pathExtension
      0|  215|        {
      0|  216|            let mimeType = mimeTypeForPathExtension(pathExtension)
      0|  217|            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
      0|  218|        } else {
      0|  219|            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
      0|  220|            setBodyPartError(Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason))
      0|  221|        }
      0|  222|    }
       |  223|
       |  224|    /**
       |  225|        Creates a body part from the file and appends it to the multipart form data object.
       |  226|
       |  227|        The body part data will be encoded using the following format:
       |  228|
       |  229|        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
       |  230|        - Content-Type: #{mimeType} (HTTP Header)
       |  231|        - Encoded file data
       |  232|        - Multipart form boundary
       |  233|
       |  234|        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
       |  235|        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  236|        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
       |  237|        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
       |  238|    */
      0|  239|    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
      0|  240|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  241|
      0|  242|        //============================================================
      0|  243|        //                 Check 1 - is file URL?
      0|  244|        //============================================================
      0|  245|
      0|  246|        guard fileURL.fileURL else {
      0|  247|            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
      0|  248|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  249|            setBodyPartError(error)
      0|  250|            return
      0|  251|        }
      0|  252|
      0|  253|        //============================================================
      0|  254|        //              Check 2 - is file URL reachable?
      0|  255|        //============================================================
      0|  256|
      0|  257|        var isReachable = true
      0|  258|
      0|  259|        if #available(OSX 10.10, *) {
      0|  260|            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
      0|  261|        }
      0|  262|
      0|  263|        guard isReachable else {
      0|  264|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
      0|  265|            setBodyPartError(error)
      0|  266|            return
      0|  267|        }
      0|  268|
      0|  269|        //============================================================
      0|  270|        //            Check 3 - is file URL a directory?
      0|  271|        //============================================================
      0|  272|
      0|  273|        var isDirectory: ObjCBool = false
      0|  274|
      0|  275|        guard let
      0|  276|            path = fileURL.path
      0|  277|            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
      0|  278|        {
      0|  279|            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
      0|  280|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  281|            setBodyPartError(error)
      0|  282|            return
      0|  283|        }
      0|  284|
      0|  285|        //============================================================
      0|  286|        //          Check 4 - can the file size be extracted?
      0|  287|        //============================================================
      0|  288|
      0|  289|        var bodyContentLength: UInt64?
      0|  290|
      0|  291|        do {
      0|  292|            if let
      0|  293|                path = fileURL.path,
      0|  294|                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
      0|  295|            {
      0|  296|                bodyContentLength = fileSize.unsignedLongLongValue
      0|  297|            }
      0|  298|        } catch {
      0|  299|            // No-op
      0|  300|        }
      0|  301|
      0|  302|        guard let length = bodyContentLength else {
      0|  303|            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
      0|  304|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  305|            setBodyPartError(error)
      0|  306|            return
      0|  307|        }
      0|  308|
      0|  309|        //============================================================
      0|  310|        //       Check 5 - can a stream be created from file URL?
      0|  311|        //============================================================
      0|  312|
      0|  313|        guard let stream = NSInputStream(URL: fileURL) else {
      0|  314|            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
      0|  315|            let error = Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  316|            setBodyPartError(error)
      0|  317|            return
      0|  318|        }
      0|  319|
      0|  320|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  321|    }
       |  322|
       |  323|    /**
       |  324|        Creates a body part from the stream and appends it to the multipart form data object.
       |  325|
       |  326|        The body part data will be encoded using the following format:
       |  327|
       |  328|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  329|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  330|        - Encoded stream data
       |  331|        - Multipart form boundary
       |  332|
       |  333|        - parameter stream:   The input stream to encode in the multipart form data.
       |  334|        - parameter length:   The content length of the stream.
       |  335|        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
       |  336|        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
       |  337|        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
       |  338|    */
       |  339|    public func appendBodyPart(
       |  340|        stream stream: NSInputStream,
       |  341|        length: UInt64,
       |  342|        name: String,
       |  343|        fileName: String,
       |  344|        mimeType: String)
      0|  345|    {
      0|  346|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  347|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  348|    }
       |  349|
       |  350|    /**
       |  351|        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
       |  352|
       |  353|        The body part data will be encoded using the following format:
       |  354|
       |  355|        - HTTP headers
       |  356|        - Encoded stream data
       |  357|        - Multipart form boundary
       |  358|
       |  359|        - parameter stream:  The input stream to encode in the multipart form data.
       |  360|        - parameter length:  The content length of the stream.
       |  361|        - parameter headers: The HTTP headers for the body part.
       |  362|    */
      0|  363|    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
      0|  364|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
      0|  365|        bodyParts.append(bodyPart)
      0|  366|    }
       |  367|
       |  368|    // MARK: - Data Encoding
       |  369|
       |  370|    /**
       |  371|        Encodes all the appended body parts into a single `NSData` object.
       |  372|
       |  373|        It is important to note that this method will load all the appended body parts into memory all at the same 
       |  374|        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
       |  375|        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
       |  376|
       |  377|        - throws: An `NSError` if encoding encounters an error.
       |  378|
       |  379|        - returns: The encoded `NSData` if encoding is successful.
       |  380|    */
      0|  381|    public func encode() throws -> NSData {
      0|  382|        if let bodyPartError = bodyPartError {
      0|  383|            throw bodyPartError
      0|  384|        }
      0|  385|
      0|  386|        let encoded = NSMutableData()
      0|  387|
      0|  388|        bodyParts.first?.hasInitialBoundary = true
      0|  389|        bodyParts.last?.hasFinalBoundary = true
      0|  390|
      0|  391|        for bodyPart in bodyParts {
      0|  392|            let encodedData = try encodeBodyPart(bodyPart)
      0|  393|            encoded.appendData(encodedData)
      0|  394|        }
      0|  395|
      0|  396|        return encoded
      0|  397|    }
       |  398|
       |  399|    /**
       |  400|        Writes the appended body parts into the given file URL.
       |  401|
       |  402|        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
       |  403|        this approach is very memory efficient and should be used for large body part data.
       |  404|
       |  405|        - parameter fileURL: The file URL to write the multipart form data into.
       |  406|
       |  407|        - throws: An `NSError` if encoding encounters an error.
       |  408|    */
      0|  409|    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
      0|  410|        if let bodyPartError = bodyPartError {
      0|  411|            throw bodyPartError
      0|  412|        }
      0|  413|
      0|  414|        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
      0|  415|            let failureReason = "A file already exists at the given file URL: \(fileURL)"
      0|  416|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  417|        } else if !fileURL.fileURL {
      0|  418|            let failureReason = "The URL does not point to a valid file: \(fileURL)"
      0|  419|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  420|        }
      0|  421|
      0|  422|        let outputStream: NSOutputStream
      0|  423|
      0|  424|        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
      0|  425|            outputStream = possibleOutputStream
      0|  426|        } else {
      0|  427|            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
      0|  428|            throw Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  429|        }
      0|  430|
      0|  431|        outputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  432|        outputStream.open()
      0|  433|
      0|  434|        self.bodyParts.first?.hasInitialBoundary = true
      0|  435|        self.bodyParts.last?.hasFinalBoundary = true
      0|  436|
      0|  437|        for bodyPart in self.bodyParts {
      0|  438|            try writeBodyPart(bodyPart, toOutputStream: outputStream)
      0|  439|        }
      0|  440|
      0|  441|        outputStream.close()
      0|  442|        outputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  443|    }
       |  444|
       |  445|    // MARK: - Private - Body Part Encoding
       |  446|
      0|  447|    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  448|        let encoded = NSMutableData()
      0|  449|
      0|  450|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  451|        encoded.appendData(initialData)
      0|  452|
      0|  453|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  454|        encoded.appendData(headerData)
      0|  455|
      0|  456|        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
      0|  457|        encoded.appendData(bodyStreamData)
      0|  458|
      0|  459|        if bodyPart.hasFinalBoundary {
      0|  460|            encoded.appendData(finalBoundaryData())
      0|  461|        }
      0|  462|
      0|  463|        return encoded
      0|  464|    }
       |  465|
      0|  466|    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
      0|  467|        var headerText = ""
      0|  468|
      0|  469|        for (key, value) in bodyPart.headers {
      0|  470|            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
      0|  471|        }
      0|  472|        headerText += EncodingCharacters.CRLF
      0|  473|
      0|  474|        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|  475|    }
       |  476|
      0|  477|    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  478|        let inputStream = bodyPart.bodyStream
      0|  479|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  480|        inputStream.open()
      0|  481|
      0|  482|        var error: NSError?
      0|  483|        let encoded = NSMutableData()
      0|  484|
      0|  485|        while inputStream.hasBytesAvailable {
      0|  486|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  487|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  488|
      0|  489|            if inputStream.streamError != nil {
      0|  490|                error = inputStream.streamError
      0|  491|                break
      0|  492|            }
      0|  493|
      0|  494|            if bytesRead > 0 {
      0|  495|                encoded.appendBytes(buffer, length: bytesRead)
      0|  496|            } else if bytesRead < 0 {
      0|  497|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  498|                error = Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  499|                break
      0|  500|            } else {
      0|  501|                break
      0|  502|            }
      0|  503|        }
      0|  504|
      0|  505|        inputStream.close()
      0|  506|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  507|
      0|  508|        if let error = error {
      0|  509|            throw error
      0|  510|        }
      0|  511|
      0|  512|        return encoded
      0|  513|    }
       |  514|
       |  515|    // MARK: - Private - Writing Body Part to Output Stream
       |  516|
      0|  517|    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  518|        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  519|        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  520|        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  521|        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  522|    }
       |  523|
       |  524|    private func writeInitialBoundaryDataForBodyPart(
       |  525|        bodyPart: BodyPart,
       |  526|        toOutputStream outputStream: NSOutputStream)
       |  527|        throws
      0|  528|    {
      0|  529|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  530|        return try writeData(initialData, toOutputStream: outputStream)
      0|  531|    }
       |  532|
      0|  533|    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  534|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  535|        return try writeData(headerData, toOutputStream: outputStream)
      0|  536|    }
       |  537|
      0|  538|    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  539|        let inputStream = bodyPart.bodyStream
      0|  540|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  541|        inputStream.open()
      0|  542|
      0|  543|        while inputStream.hasBytesAvailable {
      0|  544|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  545|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  546|
      0|  547|            if let streamError = inputStream.streamError {
      0|  548|                throw streamError
      0|  549|            }
      0|  550|
      0|  551|            if bytesRead > 0 {
      0|  552|                if buffer.count != bytesRead {
      0|  553|                    buffer = Array(buffer[0..<bytesRead])
      0|  554|                }
      0|  555|
      0|  556|                try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  557|            } else if bytesRead < 0 {
      0|  558|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  559|                throw Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  560|            } else {
      0|  561|                break
      0|  562|            }
      0|  563|        }
      0|  564|
      0|  565|        inputStream.close()
      0|  566|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  567|    }
       |  568|
       |  569|    private func writeFinalBoundaryDataForBodyPart(
       |  570|        bodyPart: BodyPart,
       |  571|        toOutputStream outputStream: NSOutputStream)
       |  572|        throws
      0|  573|    {
      0|  574|        if bodyPart.hasFinalBoundary {
      0|  575|            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
      0|  576|        }
      0|  577|    }
       |  578|
       |  579|    // MARK: - Private - Writing Buffered Data to Output Stream
       |  580|
      0|  581|    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
      0|  582|        var buffer = [UInt8](count: data.length, repeatedValue: 0)
      0|  583|        data.getBytes(&buffer, length: data.length)
      0|  584|
      0|  585|        return try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  586|    }
       |  587|
      0|  588|    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
      0|  589|        var bytesToWrite = buffer.count
      0|  590|
      0|  591|        while bytesToWrite > 0 {
      0|  592|            if outputStream.hasSpaceAvailable {
      0|  593|                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
      0|  594|
      0|  595|                if let streamError = outputStream.streamError {
      0|  596|                    throw streamError
      0|  597|                }
      0|  598|
      0|  599|                if bytesWritten < 0 {
      0|  600|                    let failureReason = "Failed to write to output stream: \(outputStream)"
      0|  601|                    throw Error.errorWithCode(.OutputStreamWriteFailed, failureReason: failureReason)
      0|  602|                }
      0|  603|
      0|  604|                bytesToWrite -= bytesWritten
      0|  605|
      0|  606|                if bytesToWrite > 0 {
      0|  607|                    buffer = Array(buffer[bytesWritten..<buffer.count])
      0|  608|                }
      0|  609|            } else if let streamError = outputStream.streamError {
      0|  610|                throw streamError
      0|  611|            }
      0|  612|        }
      0|  613|    }
       |  614|
       |  615|    // MARK: - Private - Mime Type
       |  616|
      0|  617|    private func mimeTypeForPathExtension(pathExtension: String) -> String {
      0|  618|        if let
      0|  619|            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
      0|  620|            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
      0|  621|        {
      0|  622|            return contentType as String
      0|  623|        }
      0|  624|
      0|  625|        return "application/octet-stream"
      0|  626|    }
       |  627|
       |  628|    // MARK: - Private - Content Headers
       |  629|
      0|  630|    private func contentHeaders(name name: String) -> [String: String] {
      0|  631|        return ["Content-Disposition": "form-data; name=\"\(name)\""]
      0|  632|    }
       |  633|
      0|  634|    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
      0|  635|        return [
      0|  636|            "Content-Disposition": "form-data; name=\"\(name)\"",
      0|  637|            "Content-Type": "\(mimeType)"
      0|  638|        ]
      0|  639|    }
       |  640|
      0|  641|    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
      0|  642|        return [
      0|  643|            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
      0|  644|            "Content-Type": "\(mimeType)"
      0|  645|        ]
      0|  646|    }
       |  647|
       |  648|    // MARK: - Private - Boundary Encoding
       |  649|
      0|  650|    private func initialBoundaryData() -> NSData {
      0|  651|        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
      0|  652|    }
       |  653|
      0|  654|    private func encapsulatedBoundaryData() -> NSData {
      0|  655|        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
      0|  656|    }
       |  657|
      0|  658|    private func finalBoundaryData() -> NSData {
      0|  659|        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
      0|  660|    }
       |  661|
       |  662|    // MARK: - Private - Errors
       |  663|
      0|  664|    private func setBodyPartError(error: NSError) {
      0|  665|        if bodyPartError == nil {
      0|  666|            bodyPartError = error
      0|  667|        }
      0|  668|    }
       |  669|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ParameterEncoding.swift:
       |    1|// ParameterEncoding.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    HTTP method definitions.
       |   27|
       |   28|    See https://tools.ietf.org/html/rfc7231#section-4.3
       |   29|*/
       |   30|public enum Method: String {
       |   31|    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
       |   32|}
       |   33|
       |   34|// MARK: ParameterEncoding
       |   35|
       |   36|/**
       |   37|    Used to specify the way in which a set of parameters are applied to a URL request.
       |   38|
       |   39|    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
       |   40|                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
       |   41|                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
       |   42|                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
       |   43|                         for how to encode collection types, the convention of appending `[]` to the key for array
       |   44|                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
       |   45|                         dictionary values (`foo[bar]=baz`).
       |   46|
       |   47|    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
       |   48|                         implementation as the `.URL` case, but always applies the encoded result to the URL.
       |   49|
       |   50|    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
       |   51|                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
       |   52|                         set to `application/json`.
       |   53|
       |   54|    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
       |   55|                         according to the associated format and write options values, which is set as the body of the
       |   56|                         request. The `Content-Type` HTTP header field of an encoded request is set to
       |   57|                         `application/x-plist`.
       |   58|
       |   59|    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
       |   60|                         parameters.
       |   61|*/
       |   62|public enum ParameterEncoding {
       |   63|    case URL
       |   64|    case URLEncodedInURL
       |   65|    case JSON
       |   66|    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
       |   67|    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
       |   68|
       |   69|    /**
       |   70|        Creates a URL request by encoding parameters and applying them onto an existing request.
       |   71|
       |   72|        - parameter URLRequest: The request to have parameters applied
       |   73|        - parameter parameters: The parameters to apply
       |   74|
       |   75|        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
       |   76|                   if any.
       |   77|    */
       |   78|    public func encode(
       |   79|        URLRequest: URLRequestConvertible,
       |   80|        parameters: [String: AnyObject]?)
       |   81|        -> (NSMutableURLRequest, NSError?)
      1|   82|    {
      1|   83|        var mutableURLRequest = URLRequest.URLRequest
      1|   84|
      0|   85|        guard let parameters = parameters where !parameters.isEmpty else {
      0|   86|            return (mutableURLRequest, nil)
      0|   87|        }
      1|   88|
      1|   89|        var encodingError: NSError? = nil
      1|   90|
      1|   91|        switch self {
      0|   92|        case .URL, .URLEncodedInURL:
      0|   93|            func query(parameters: [String: AnyObject]) -> String {
      0|   94|                var components: [(String, String)] = []
      0|   95|
      0|   96|                for key in parameters.keys.sort(<) {
      0|   97|                    let value = parameters[key]!
      0|   98|                    components += queryComponents(key, value)
      0|   99|                }
      0|  100|
      0|  101|                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
      0|  102|            }
      0|  103|
      0|  104|            func encodesParametersInURL(method: Method) -> Bool {
      0|  105|                switch self {
      0|  106|                case .URLEncodedInURL:
      0|  107|                    return true
      0|  108|                default:
      0|  109|                    break
      0|  110|                }
      0|  111|
      0|  112|                switch method {
      0|  113|                case .GET, .HEAD, .DELETE:
      0|  114|                    return true
      0|  115|                default:
      0|  116|                    return false
      0|  117|                }
      0|  118|            }
      0|  119|
      0|  120|            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
      0|  121|                if let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false) {
      0|  122|                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
      0|  123|                    URLComponents.percentEncodedQuery = percentEncodedQuery
      0|  124|                    mutableURLRequest.URL = URLComponents.URL
      0|  125|                }
      0|  126|            } else {
      0|  127|                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
      0|  128|                    mutableURLRequest.setValue(
      0|  129|                        "application/x-www-form-urlencoded; charset=utf-8",
      0|  130|                        forHTTPHeaderField: "Content-Type"
      0|  131|                    )
      0|  132|                }
      0|  133|
      0|  134|                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
      0|  135|                    NSUTF8StringEncoding,
      0|  136|                    allowLossyConversion: false
      0|  137|                )
      0|  138|            }
      1|  139|        case .JSON:
      1|  140|            do {
      1|  141|                let options = NSJSONWritingOptions()
      1|  142|                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
      1|  143|
      1|  144|                mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
      1|  145|                mutableURLRequest.HTTPBody = data
      0|  146|            } catch {
      0|  147|                encodingError = error as NSError
      0|  148|            }
      0|  149|        case .PropertyList(let format, let options):
      0|  150|            do {
      0|  151|                let data = try NSPropertyListSerialization.dataWithPropertyList(
      0|  152|                    parameters,
      0|  153|                    format: format,
      0|  154|                    options: options
      0|  155|                )
      0|  156|                mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
      0|  157|                mutableURLRequest.HTTPBody = data
      0|  158|            } catch {
      0|  159|                encodingError = error as NSError
      0|  160|            }
      0|  161|        case .Custom(let closure):
      0|  162|            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
      1|  163|        }
      1|  164|
      1|  165|        return (mutableURLRequest, encodingError)
      1|  166|    }
       |  167|
       |  168|    /**
       |  169|        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
       |  170|
       |  171|        - parameter key:   The key of the query component.
       |  172|        - parameter value: The value of the query component.
       |  173|
       |  174|        - returns: The percent-escaped, URL encoded query string components.
       |  175|    */
      0|  176|    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
      0|  177|        var components: [(String, String)] = []
      0|  178|
      0|  179|        if let dictionary = value as? [String: AnyObject] {
      0|  180|            for (nestedKey, value) in dictionary {
      0|  181|                components += queryComponents("\(key)[\(nestedKey)]", value)
      0|  182|            }
      0|  183|        } else if let array = value as? [AnyObject] {
      0|  184|            for value in array {
      0|  185|                components += queryComponents("\(key)[]", value)
      0|  186|            }
      0|  187|        } else {
      0|  188|            components.append((escape(key), escape("\(value)")))
      0|  189|        }
      0|  190|
      0|  191|        return components
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Returns a percent-escaped string following RFC 3986 for a query string key or value.
       |  196|
       |  197|        RFC 3986 states that the following characters are "reserved" characters.
       |  198|
       |  199|        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
       |  200|        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
       |  201|
       |  202|        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
       |  203|        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
       |  204|        should be percent-escaped in the query string.
       |  205|
       |  206|        - parameter string: The string to be percent-escaped.
       |  207|
       |  208|        - returns: The percent-escaped string.
       |  209|    */
      0|  210|    public func escape(string: String) -> String {
      0|  211|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
      0|  212|        let subDelimitersToEncode = "!$&'()*+,;="
      0|  213|
      0|  214|        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
      0|  215|        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
      0|  216|
      0|  217|        var escaped = ""
      0|  218|
      0|  219|        //==========================================================================================================
      0|  220|        //
      0|  221|        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
      0|  222|        //  hundred Chinense characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
      0|  223|        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
      0|  224|        //  info, please refer to:
      0|  225|        //
      0|  226|        //      - https://github.com/Alamofire/Alamofire/issues/206
      0|  227|        //
      0|  228|        //==========================================================================================================
      0|  229|
      0|  230|        if #available(iOS 8.3, OSX 10.10, *) {
      0|  231|            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
      0|  232|        } else {
      0|  233|            let batchSize = 50
      0|  234|            var index = string.startIndex
      0|  235|
      0|  236|            while index != string.endIndex {
      0|  237|                let startIndex = index
      0|  238|                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
      0|  239|                let range = Range(start: startIndex, end: endIndex)
      0|  240|
      0|  241|                let substring = string.substringWithRange(range)
      0|  242|
      0|  243|                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
      0|  244|
      0|  245|                index = endIndex
      0|  246|            }
      0|  247|        }
      0|  248|
      0|  249|        return escaped
      0|  250|    }
       |  251|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Request.swift:
       |    1|// Request.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for sending a request and receiving the response and associated data from the server, as well as 
       |   27|    managing its underlying `NSURLSessionTask`.
       |   28|*/
       |   29|public class Request {
       |   30|
       |   31|    // MARK: - Properties
       |   32|
       |   33|    /// The delegate for the underlying task.
       |   34|    public let delegate: TaskDelegate
       |   35|
       |   36|    /// The underlying task.
      5|   37|    public var task: NSURLSessionTask { return delegate.task }
       |   38|
       |   39|    /// The session belonging to the underlying task.
       |   40|    public let session: NSURLSession
       |   41|
       |   42|    /// The request sent or to be sent to the server.
      2|   43|    public var request: NSURLRequest? { return task.originalRequest }
       |   44|
       |   45|    /// The response received from the server, if any.
      2|   46|    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
       |   47|
       |   48|    /// The progress of the request lifecycle.
      0|   49|    public var progress: NSProgress { return delegate.progress }
       |   50|
       |   51|    // MARK: - Lifecycle
       |   52|
      1|   53|    init(session: NSURLSession, task: NSURLSessionTask) {
      1|   54|        self.session = session
      1|   55|
      1|   56|        switch task {
      0|   57|        case is NSURLSessionUploadTask:
      0|   58|            self.delegate = UploadTaskDelegate(task: task)
      1|   59|        case is NSURLSessionDataTask:
      1|   60|            self.delegate = DataTaskDelegate(task: task)
      0|   61|        case is NSURLSessionDownloadTask:
      0|   62|            self.delegate = DownloadTaskDelegate(task: task)
      0|   63|        default:
      0|   64|            self.delegate = TaskDelegate(task: task)
      1|   65|        }
      1|   66|    }
       |   67|
       |   68|    // MARK: - Authentication
       |   69|
       |   70|    /**
       |   71|        Associates an HTTP Basic credential with the request.
       |   72|
       |   73|        - parameter user:        The user.
       |   74|        - parameter password:    The password.
       |   75|        - parameter persistence: The URL credential persistence. `.ForSession` by default.
       |   76|
       |   77|        - returns: The request.
       |   78|    */
       |   79|    public func authenticate(
       |   80|        user user: String,
       |   81|        password: String,
       |   82|        persistence: NSURLCredentialPersistence = .ForSession)
       |   83|        -> Self
      0|   84|    {
      0|   85|        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
      0|   86|
      0|   87|        return authenticate(usingCredential: credential)
      0|   88|    }
       |   89|
       |   90|    /**
       |   91|        Associates a specified credential with the request.
       |   92|
       |   93|        - parameter credential: The credential.
       |   94|
       |   95|        - returns: The request.
       |   96|    */
      0|   97|    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
      0|   98|        delegate.credential = credential
      0|   99|
      0|  100|        return self
      0|  101|    }
       |  102|
       |  103|    // MARK: - Progress
       |  104|
       |  105|    /**
       |  106|        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
       |  107|        from the server.
       |  108|
       |  109|        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
       |  110|          to write.
       |  111|        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
       |  112|          expected to read.
       |  113|
       |  114|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  115|
       |  116|        - returns: The request.
       |  117|    */
      0|  118|    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
      0|  119|        if let uploadDelegate = delegate as? UploadTaskDelegate {
      0|  120|            uploadDelegate.uploadProgress = closure
      0|  121|        } else if let dataDelegate = delegate as? DataTaskDelegate {
      0|  122|            dataDelegate.dataProgress = closure
      0|  123|        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
      0|  124|            downloadDelegate.downloadProgress = closure
      0|  125|        }
      0|  126|
      0|  127|        return self
      0|  128|    }
       |  129|
       |  130|    /**
       |  131|        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
       |  132|
       |  133|        This closure returns the bytes most recently received from the server, not including data from previous calls. 
       |  134|        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
       |  135|        also important to note that the `response` closure will be called with nil `responseData`.
       |  136|
       |  137|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  138|
       |  139|        - returns: The request.
       |  140|    */
      0|  141|    public func stream(closure: (NSData -> Void)? = nil) -> Self {
      0|  142|        if let dataDelegate = delegate as? DataTaskDelegate {
      0|  143|            dataDelegate.dataStream = closure
      0|  144|        }
      0|  145|
      0|  146|        return self
      0|  147|    }
       |  148|
       |  149|    // MARK: - State
       |  150|
       |  151|    /**
       |  152|        Suspends the request.
       |  153|    */
      0|  154|    public func suspend() {
      0|  155|        task.suspend()
      0|  156|    }
       |  157|
       |  158|    /**
       |  159|        Resumes the request.
       |  160|    */
      1|  161|    public func resume() {
      1|  162|        task.resume()
      1|  163|    }
       |  164|
       |  165|    /**
       |  166|        Cancels the request.
       |  167|    */
      0|  168|    public func cancel() {
      0|  169|        if let
      0|  170|            downloadDelegate = delegate as? DownloadTaskDelegate,
      0|  171|            downloadTask = downloadDelegate.downloadTask
      0|  172|        {
      0|  173|            downloadTask.cancelByProducingResumeData { data in
      0|  174|                downloadDelegate.resumeData = data
      0|  175|            }
      0|  176|        } else {
      0|  177|            task.cancel()
      0|  178|        }
      0|  179|    }
       |  180|
       |  181|    // MARK: - TaskDelegate
       |  182|
       |  183|    /**
       |  184|        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
       |  185|        executing all operations attached to the serial operation queue upon task completion.
       |  186|    */
       |  187|    public class TaskDelegate: NSObject {
       |  188|
       |  189|        /// The serial operation queue used to execute all operations after the task completes.
       |  190|        public let queue: NSOperationQueue
       |  191|
       |  192|        let task: NSURLSessionTask
       |  193|        let progress: NSProgress
       |  194|
      0|  195|        var data: NSData? { return nil }
       |  196|        var error: NSError?
       |  197|
       |  198|        var credential: NSURLCredential?
       |  199|
      1|  200|        init(task: NSURLSessionTask) {
      1|  201|            self.task = task
      1|  202|            self.progress = NSProgress(totalUnitCount: 0)
      1|  203|            self.queue = {
      1|  204|                let operationQueue = NSOperationQueue()
      1|  205|                operationQueue.maxConcurrentOperationCount = 1
      1|  206|                operationQueue.suspended = true
      1|  207|
      1|  208|                if #available(OSX 10.10, *) {
      1|  209|                    operationQueue.qualityOfService = NSQualityOfService.Utility
      1|  210|                }
      1|  211|
      1|  212|                return operationQueue
      1|  213|            }()
      1|  214|        }
       |  215|
      0|  216|        deinit {
      0|  217|            queue.cancelAllOperations()
      0|  218|            queue.suspended = false
      0|  219|        }
       |  220|
       |  221|        // MARK: - NSURLSessionTaskDelegate
       |  222|
       |  223|        // MARK: Override Closures
       |  224|
       |  225|        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  226|        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  227|        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
       |  228|        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  229|
       |  230|        // MARK: Delegate Methods
       |  231|
       |  232|        func URLSession(
       |  233|            session: NSURLSession,
       |  234|            task: NSURLSessionTask,
       |  235|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  236|            newRequest request: NSURLRequest,
       |  237|            completionHandler: ((NSURLRequest?) -> Void))
      0|  238|        {
      0|  239|            var redirectRequest: NSURLRequest? = request
      0|  240|
      0|  241|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  242|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  243|            }
      0|  244|
      0|  245|            completionHandler(redirectRequest)
      0|  246|        }
       |  247|
       |  248|        func URLSession(
       |  249|            session: NSURLSession,
       |  250|            task: NSURLSessionTask,
       |  251|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  252|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  253|        {
      1|  254|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      1|  255|            var credential: NSURLCredential?
      1|  256|
      0|  257|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  258|                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
      1|  259|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      1|  260|                let host = challenge.protectionSpace.host
      1|  261|
      1|  262|                if let
      1|  263|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      1|  264|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  265|                {
      0|  266|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  267|                        disposition = .UseCredential
      0|  268|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  269|                    } else {
      0|  270|                        disposition = .CancelAuthenticationChallenge
      0|  271|                    }
      0|  272|                }
      0|  273|            } else {
      0|  274|                if challenge.previousFailureCount > 0 {
      0|  275|                    disposition = .CancelAuthenticationChallenge
      0|  276|                } else {
      0|  277|                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
      0|  278|
      0|  279|                    if credential != nil {
      0|  280|                        disposition = .UseCredential
      0|  281|                    }
      0|  282|                }
      0|  283|            }
      1|  284|
      1|  285|            completionHandler(disposition, credential)
      1|  286|        }
       |  287|
       |  288|        func URLSession(
       |  289|            session: NSURLSession,
       |  290|            task: NSURLSessionTask,
       |  291|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  292|        {
      0|  293|            var bodyStream: NSInputStream?
      0|  294|
      0|  295|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  296|                bodyStream = taskNeedNewBodyStream(session, task)
      0|  297|            }
      0|  298|
      0|  299|            completionHandler(bodyStream)
      0|  300|        }
       |  301|
      1|  302|        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  303|            if let taskDidCompleteWithError = taskDidCompleteWithError {
      0|  304|                taskDidCompleteWithError(session, task, error)
      1|  305|            } else {
      0|  306|                if let error = error {
      0|  307|                    self.error = error
      0|  308|
      0|  309|                    if let
      0|  310|                        downloadDelegate = self as? DownloadTaskDelegate,
      0|  311|                        userInfo = error.userInfo as? [String: AnyObject],
      0|  312|                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
      0|  313|                    {
      0|  314|                        downloadDelegate.resumeData = resumeData
      0|  315|                    }
      0|  316|                }
      1|  317|
      1|  318|                queue.suspended = false
      1|  319|            }
      1|  320|        }
       |  321|    }
       |  322|
       |  323|    // MARK: - DataTaskDelegate
       |  324|
       |  325|    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
      0|  326|        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
       |  327|
       |  328|        private var totalBytesReceived: Int64 = 0
       |  329|        private var mutableData: NSMutableData
      2|  330|        override var data: NSData? {
      0|  331|            if dataStream != nil {
      0|  332|                return nil
      2|  333|            } else {
      2|  334|                return mutableData
      2|  335|            }
      0|  336|        }
       |  337|
       |  338|        private var expectedContentLength: Int64?
       |  339|        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
       |  340|        private var dataStream: ((data: NSData) -> Void)?
       |  341|
      1|  342|        override init(task: NSURLSessionTask) {
      1|  343|            mutableData = NSMutableData()
      1|  344|            super.init(task: task)
      1|  345|        }
       |  346|
       |  347|        // MARK: - NSURLSessionDataDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  352|        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  353|        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  354|        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
       |  355|
       |  356|        // MARK: Delegate Methods
       |  357|
       |  358|        func URLSession(
       |  359|            session: NSURLSession,
       |  360|            dataTask: NSURLSessionDataTask,
       |  361|            didReceiveResponse response: NSURLResponse,
       |  362|            completionHandler: (NSURLSessionResponseDisposition -> Void))
      0|  363|        {
      0|  364|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  365|
      0|  366|            expectedContentLength = response.expectedContentLength
      0|  367|
      0|  368|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  369|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  370|            }
      0|  371|
      0|  372|            completionHandler(disposition)
      0|  373|        }
       |  374|
       |  375|        func URLSession(
       |  376|            session: NSURLSession,
       |  377|            dataTask: NSURLSessionDataTask,
       |  378|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  379|        {
      0|  380|            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
      0|  381|        }
       |  382|
      1|  383|        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  384|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  385|                dataTaskDidReceiveData(session, dataTask, data)
      1|  386|            } else {
      0|  387|                if let dataStream = dataStream {
      0|  388|                    dataStream(data: data)
      1|  389|                } else {
      1|  390|                    mutableData.appendData(data)
      1|  391|                }
      1|  392|
      1|  393|                totalBytesReceived += data.length
      0|  394|                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
      1|  395|
      1|  396|                progress.totalUnitCount = totalBytesExpected
      1|  397|                progress.completedUnitCount = totalBytesReceived
      1|  398|
      1|  399|                dataProgress?(
      1|  400|                    bytesReceived: Int64(data.length),
      1|  401|                    totalBytesReceived: totalBytesReceived,
      1|  402|                    totalBytesExpectedToReceive: totalBytesExpected
      1|  403|                )
      1|  404|            }
      1|  405|        }
       |  406|
       |  407|        func URLSession(
       |  408|            session: NSURLSession,
       |  409|            dataTask: NSURLSessionDataTask,
       |  410|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  411|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  412|        {
      0|  413|            var cachedResponse: NSCachedURLResponse? = proposedResponse
      0|  414|
      0|  415|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  416|                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
      0|  417|            }
      0|  418|
      0|  419|            completionHandler(cachedResponse)
      0|  420|        }
       |  421|    }
       |  422|}
       |  423|
       |  424|// MARK: - CustomStringConvertible
       |  425|
       |  426|extension Request: CustomStringConvertible {
       |  427|
       |  428|    /**
       |  429|        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
       |  430|        well as the response status code if a response has been received.
       |  431|    */
      0|  432|    public var description: String {
      0|  433|        var components: [String] = []
      0|  434|
      0|  435|        if let HTTPMethod = request?.HTTPMethod {
      0|  436|            components.append(HTTPMethod)
      0|  437|        }
      0|  438|
      0|  439|        if let URLString = request?.URL?.absoluteString {
      0|  440|            components.append(URLString)
      0|  441|        }
      0|  442|
      0|  443|        if let response = response {
      0|  444|            components.append("(\(response.statusCode))")
      0|  445|        }
      0|  446|
      0|  447|        return components.joinWithSeparator(" ")
      0|  448|    }
       |  449|}
       |  450|
       |  451|// MARK: - CustomDebugStringConvertible
       |  452|
       |  453|extension Request: CustomDebugStringConvertible {
      0|  454|    func cURLRepresentation() -> String {
      0|  455|        var components = ["$ curl -i"]
      0|  456|
      0|  457|        guard let request = self.request else {
      0|  458|            return "$ curl command could not be created"
      0|  459|        }
      0|  460|
      0|  461|        let URL = request.URL
      0|  462|
      0|  463|        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
      0|  464|            components.append("-X \(HTTPMethod)")
      0|  465|        }
      0|  466|
      0|  467|        if let credentialStorage = self.session.configuration.URLCredentialStorage {
      0|  468|            let protectionSpace = NSURLProtectionSpace(
      0|  469|                host: URL!.host!,
      0|  470|                port: URL!.port?.integerValue ?? 0,
      0|  471|                `protocol`: URL!.scheme,
      0|  472|                realm: URL!.host!,
      0|  473|                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
      0|  474|            )
      0|  475|
      0|  476|            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
      0|  477|                for credential in credentials {
      0|  478|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  479|                }
      0|  480|            } else {
      0|  481|                if let credential = delegate.credential {
      0|  482|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  483|                }
      0|  484|            }
      0|  485|        }
      0|  486|
      0|  487|        if session.configuration.HTTPShouldSetCookies {
      0|  488|            if let
      0|  489|                cookieStorage = session.configuration.HTTPCookieStorage,
      0|  490|                cookies = cookieStorage.cookiesForURL(URL!) where !cookies.isEmpty
      0|  491|            {
      0|  492|                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
      0|  493|                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
      0|  494|            }
      0|  495|        }
      0|  496|
      0|  497|        if let headerFields = request.allHTTPHeaderFields {
      0|  498|            for (field, value) in headerFields {
      0|  499|                switch field {
      0|  500|                case "Cookie":
      0|  501|                    continue
      0|  502|                default:
      0|  503|                    components.append("-H \"\(field): \(value)\"")
      0|  504|                }
      0|  505|            }
      0|  506|        }
      0|  507|
      0|  508|        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
      0|  509|            for (field, value) in additionalHeaders {
      0|  510|                switch field {
      0|  511|                case "Cookie":
      0|  512|                    continue
      0|  513|                default:
      0|  514|                    components.append("-H \"\(field): \(value)\"")
      0|  515|                }
      0|  516|            }
      0|  517|        }
      0|  518|
      0|  519|        if let
      0|  520|            HTTPBodyData = request.HTTPBody,
      0|  521|            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
      0|  522|        {
      0|  523|            let escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
      0|  524|            components.append("-d \"\(escapedBody)\"")
      0|  525|        }
      0|  526|
      0|  527|        components.append("\"\(URL!.absoluteString)\"")
      0|  528|
      0|  529|        return components.joinWithSeparator(" \\\n\t")
      0|  530|    }
       |  531|
       |  532|    /// The textual representation used when written to an output stream, in the form of a cURL command.
      0|  533|    public var debugDescription: String {
      0|  534|        return cURLRepresentation()
      0|  535|    }
       |  536|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Response.swift:
       |    1|// Response.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Used to store all response data returned from a completed `Request`.
       |   26|public struct Response<Value, Error: ErrorType> {
       |   27|    /// The URL request sent to the server.
       |   28|    public let request: NSURLRequest?
       |   29|
       |   30|    /// The server's response to the URL request.
       |   31|    public let response: NSHTTPURLResponse?
       |   32|
       |   33|    /// The data returned by the server.
       |   34|    public let data: NSData?
       |   35|
       |   36|    /// The result of response serialization.
       |   37|    public let result: Result<Value, Error>
       |   38|
       |   39|    /**
       |   40|        Initializes the `Response` instance with the specified URL request, URL response, server data and response
       |   41|        serialization result.
       |   42|    
       |   43|        - parameter request:  The URL request sent to the server.
       |   44|        - parameter response: The server's response to the URL request.
       |   45|        - parameter data:     The data returned by the server.
       |   46|        - parameter result:   The result of response serialization.
       |   47|    
       |   48|        - returns: the new `Response` instance.
       |   49|    */
      1|   50|    public init(request: NSURLRequest?, response: NSHTTPURLResponse?, data: NSData?, result: Result<Value, Error>) {
      1|   51|        self.request = request
      1|   52|        self.response = response
      1|   53|        self.data = data
      1|   54|        self.result = result
      1|   55|    }
       |   56|}
       |   57|
       |   58|// MARK: - CustomStringConvertible
       |   59|
       |   60|extension Response: CustomStringConvertible {
       |   61|    /// The textual representation used when written to an output stream, which includes whether the result was a
       |   62|    /// success or failure.
      0|   63|    public var description: String {
      0|   64|        return result.debugDescription
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - CustomDebugStringConvertible
       |   69|
       |   70|extension Response: CustomDebugStringConvertible {
       |   71|    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
       |   72|    /// response, the server data and the response serialization result.
      0|   73|    public var debugDescription: String {
      0|   74|        var output: [String] = []
      0|   75|
      0|   76|        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
      0|   77|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
      0|   78|        output.append("[Data]: \(data?.length ?? 0) bytes")
      0|   79|        output.append("[Result]: \(result.debugDescription)")
      0|   80|
      0|   81|        return output.joinWithSeparator("\n")
      0|   82|    }
       |   83|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ResponseSerialization.swift:
       |    1|// ResponseSerialization.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: ResponseSerializer
       |   26|
       |   27|/**
       |   28|    The type in which all response serializers must conform to in order to serialize a response.
       |   29|*/
       |   30|public protocol ResponseSerializerType {
       |   31|    /// The type of serialized object to be created by this `ResponseSerializerType`.
       |   32|    typealias SerializedObject
       |   33|
       |   34|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   35|    typealias ErrorObject: ErrorType
       |   36|
       |   37|    /**
       |   38|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   39|    */
       |   40|    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
       |   41|}
       |   42|
       |   43|// MARK: -
       |   44|
       |   45|/**
       |   46|    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
       |   47|*/
       |   48|public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
       |   49|    /// The type of serialized object to be created by this `ResponseSerializer`.
       |   50|    public typealias SerializedObject = Value
       |   51|
       |   52|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   53|    public typealias ErrorObject = Error
       |   54|
       |   55|    /**
       |   56|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   57|    */
       |   58|    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
       |   59|
       |   60|    /**
       |   61|        Initializes the `ResponseSerializer` instance with the given serialize response closure.
       |   62|
       |   63|        - parameter serializeResponse: The closure used to serialize the response.
       |   64|
       |   65|        - returns: The new generic response serializer instance.
       |   66|    */
      1|   67|    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
      1|   68|        self.serializeResponse = serializeResponse
      1|   69|    }
       |   70|}
       |   71|
       |   72|// MARK: - Default
       |   73|
       |   74|extension Request {
       |   75|
       |   76|    /**
       |   77|        Adds a handler to be called once the request has finished.
       |   78|
       |   79|        - parameter queue:             The queue on which the completion handler is dispatched.
       |   80|        - parameter completionHandler: The code to be executed once the request has finished.
       |   81|
       |   82|        - returns: The request.
       |   83|    */
       |   84|    public func response(
       |   85|        queue queue: dispatch_queue_t? = nil,
       |   86|        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
       |   87|        -> Self
      0|   88|    {
      0|   89|        delegate.queue.addOperationWithBlock {
      0|   90|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      0|   91|                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
      0|   92|            }
      0|   93|        }
      0|   94|
      0|   95|        return self
      0|   96|    }
       |   97|
       |   98|    /**
       |   99|        Adds a handler to be called once the request has finished.
       |  100|
       |  101|        - parameter queue:              The queue on which the completion handler is dispatched.
       |  102|        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
       |  103|                                        and data.
       |  104|        - parameter completionHandler:  The code to be executed once the request has finished.
       |  105|
       |  106|        - returns: The request.
       |  107|    */
       |  108|    public func response<T: ResponseSerializerType>(
       |  109|        queue queue: dispatch_queue_t? = nil,
       |  110|        responseSerializer: T,
       |  111|        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
       |  112|        -> Self
      1|  113|    {
      1|  114|        delegate.queue.addOperationWithBlock {
      1|  115|            let result = responseSerializer.serializeResponse(
      1|  116|                self.request,
      1|  117|                self.response,
      1|  118|                self.delegate.data,
      1|  119|                self.delegate.error
      1|  120|            )
      1|  121|
      1|  122|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      1|  123|                let response = Response<T.SerializedObject, T.ErrorObject>(
      1|  124|                    request: self.request,
      1|  125|                    response: self.response,
      1|  126|                    data: self.delegate.data,
      1|  127|                    result: result
      1|  128|                )
      1|  129|
      1|  130|                completionHandler(response)
      1|  131|            }
      1|  132|        }
      1|  133|
      1|  134|        return self
      1|  135|    }
       |  136|}
       |  137|
       |  138|// MARK: - Data
       |  139|
       |  140|extension Request {
       |  141|
       |  142|    /**
       |  143|        Creates a response serializer that returns the associated data as-is.
       |  144|
       |  145|        - returns: A data response serializer.
       |  146|    */
      0|  147|    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
      0|  148|        return ResponseSerializer { _, response, data, error in
      0|  149|            guard error == nil else { return .Failure(error!) }
      0|  150|
      0|  151|            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
      0|  152|
      0|  153|            guard let validData = data else {
      0|  154|                let failureReason = "Data could not be serialized. Input data was nil."
      0|  155|                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
      0|  156|                return .Failure(error)
      0|  157|            }
      0|  158|
      0|  159|            return .Success(validData)
      0|  160|        }
      0|  161|    }
       |  162|
       |  163|    /**
       |  164|        Adds a handler to be called once the request has finished.
       |  165|
       |  166|        - parameter completionHandler: The code to be executed once the request has finished.
       |  167|
       |  168|        - returns: The request.
       |  169|    */
      0|  170|    public func responseData(completionHandler: Response<NSData, NSError> -> Void) -> Self {
      0|  171|        return response(responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
      0|  172|    }
       |  173|}
       |  174|
       |  175|// MARK: - String
       |  176|
       |  177|extension Request {
       |  178|
       |  179|    /**
       |  180|        Creates a response serializer that returns a string initialized from the response data with the specified 
       |  181|        string encoding.
       |  182|
       |  183|        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
       |  184|                              response, falling back to the default HTTP default character set, ISO-8859-1.
       |  185|
       |  186|        - returns: A string response serializer.
       |  187|    */
       |  188|    public static func stringResponseSerializer(
       |  189|        var encoding encoding: NSStringEncoding? = nil)
       |  190|        -> ResponseSerializer<String, NSError>
      0|  191|    {
      0|  192|        return ResponseSerializer { _, response, data, error in
      0|  193|            guard error == nil else { return .Failure(error!) }
      0|  194|
      0|  195|            if let response = response where response.statusCode == 204 { return .Success("") }
      0|  196|
      0|  197|            guard let validData = data else {
      0|  198|                let failureReason = "String could not be serialized. Input data was nil."
      0|  199|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  200|                return .Failure(error)
      0|  201|            }
      0|  202|
      0|  203|            if let encodingName = response?.textEncodingName where encoding == nil {
      0|  204|                encoding = CFStringConvertEncodingToNSStringEncoding(
      0|  205|                    CFStringConvertIANACharSetNameToEncoding(encodingName)
      0|  206|                )
      0|  207|            }
      0|  208|
      0|  209|            let actualEncoding = encoding ?? NSISOLatin1StringEncoding
      0|  210|
      0|  211|            if let string = String(data: validData, encoding: actualEncoding) {
      0|  212|                return .Success(string)
      0|  213|            } else {
      0|  214|                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
      0|  215|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  216|                return .Failure(error)
      0|  217|            }
      0|  218|        }
      0|  219|    }
       |  220|
       |  221|    /**
       |  222|        Adds a handler to be called once the request has finished.
       |  223|
       |  224|        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
       |  225|                                       server response, falling back to the default HTTP default character set, 
       |  226|                                       ISO-8859-1.
       |  227|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  228|
       |  229|        - returns: The request.
       |  230|    */
       |  231|    public func responseString(
       |  232|        encoding encoding: NSStringEncoding? = nil,
       |  233|        completionHandler: Response<String, NSError> -> Void)
       |  234|        -> Self
      0|  235|    {
      0|  236|        return response(
      0|  237|            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
      0|  238|            completionHandler: completionHandler
      0|  239|        )
      0|  240|    }
       |  241|}
       |  242|
       |  243|// MARK: - JSON
       |  244|
       |  245|extension Request {
       |  246|
       |  247|    /**
       |  248|        Creates a response serializer that returns a JSON object constructed from the response data using 
       |  249|        `NSJSONSerialization` with the specified reading options.
       |  250|
       |  251|        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
       |  252|
       |  253|        - returns: A JSON object response serializer.
       |  254|    */
       |  255|    public static func JSONResponseSerializer(
       |  256|        options options: NSJSONReadingOptions = .AllowFragments)
       |  257|        -> ResponseSerializer<AnyObject, NSError>
      1|  258|    {
      1|  259|        return ResponseSerializer { _, response, data, error in
      0|  260|            guard error == nil else { return .Failure(error!) }
      1|  261|
      0|  262|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      1|  263|
      0|  264|            guard let validData = data where validData.length > 0 else {
      0|  265|                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
      0|  266|                let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
      0|  267|                return .Failure(error)
      0|  268|            }
      1|  269|
      1|  270|            do {
      1|  271|                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
      1|  272|                return .Success(JSON)
      1|  273|            } catch {
      1|  274|                return .Failure(error as NSError)
      1|  275|            }
      0|  276|        }
      1|  277|    }
       |  278|
       |  279|    /**
       |  280|        Adds a handler to be called once the request has finished.
       |  281|
       |  282|        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
       |  283|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  284|
       |  285|        - returns: The request.
       |  286|    */
       |  287|    public func responseJSON(
       |  288|        options options: NSJSONReadingOptions = .AllowFragments,
       |  289|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  290|        -> Self
      1|  291|    {
      1|  292|        return response(
      1|  293|            responseSerializer: Request.JSONResponseSerializer(options: options),
      1|  294|            completionHandler: completionHandler
      1|  295|        )
      1|  296|    }
       |  297|}
       |  298|
       |  299|// MARK: - Property List
       |  300|
       |  301|extension Request {
       |  302|
       |  303|    /**
       |  304|        Creates a response serializer that returns an object constructed from the response data using 
       |  305|        `NSPropertyListSerialization` with the specified reading options.
       |  306|
       |  307|        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
       |  308|
       |  309|        - returns: A property list object response serializer.
       |  310|    */
       |  311|    public static func propertyListResponseSerializer(
       |  312|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
       |  313|        -> ResponseSerializer<AnyObject, NSError>
      0|  314|    {
      0|  315|        return ResponseSerializer { _, response, data, error in
      0|  316|            guard error == nil else { return .Failure(error!) }
      0|  317|
      0|  318|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      0|  319|
      0|  320|            guard let validData = data where validData.length > 0 else {
      0|  321|                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
      0|  322|                let error = Error.errorWithCode(.PropertyListSerializationFailed, failureReason: failureReason)
      0|  323|                return .Failure(error)
      0|  324|            }
      0|  325|
      0|  326|            do {
      0|  327|                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
      0|  328|                return .Success(plist)
      0|  329|            } catch {
      0|  330|                return .Failure(error as NSError)
      0|  331|            }
      0|  332|        }
      0|  333|    }
       |  334|
       |  335|    /**
       |  336|        Adds a handler to be called once the request has finished.
       |  337|
       |  338|        - parameter options:           The property list reading options. `0` by default.
       |  339|        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
       |  340|                                       arguments: the URL request, the URL response, the server data and the result 
       |  341|                                       produced while creating the property list.
       |  342|
       |  343|        - returns: The request.
       |  344|    */
       |  345|    public func responsePropertyList(
       |  346|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
       |  347|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  348|        -> Self
      0|  349|    {
      0|  350|        return response(
      0|  351|            responseSerializer: Request.propertyListResponseSerializer(options: options),
      0|  352|            completionHandler: completionHandler
      0|  353|        )
      0|  354|    }
       |  355|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Result.swift:
       |    1|// Result.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Used to represent whether a request was successful or encountered an error.
       |   27|
       |   28|    - Success: The request and all post processing operations were successful resulting in the serialization of the 
       |   29|               provided associated value.
       |   30|    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
       |   31|               provided by the server as well as the error that caused the failure.
       |   32|*/
       |   33|public enum Result<Value, Error: ErrorType> {
       |   34|    case Success(Value)
       |   35|    case Failure(Error)
       |   36|
       |   37|    /// Returns `true` if the result is a success, `false` otherwise.
      0|   38|    public var isSuccess: Bool {
      0|   39|        switch self {
      0|   40|        case .Success:
      0|   41|            return true
      0|   42|        case .Failure:
      0|   43|            return false
      0|   44|        }
      0|   45|    }
       |   46|
       |   47|    /// Returns `true` if the result is a failure, `false` otherwise.
      0|   48|    public var isFailure: Bool {
      0|   49|        return !isSuccess
      0|   50|    }
       |   51|
       |   52|    /// Returns the associated value if the result is a success, `nil` otherwise.
      0|   53|    public var value: Value? {
      0|   54|        switch self {
      0|   55|        case .Success(let value):
      0|   56|            return value
      0|   57|        case .Failure:
      0|   58|            return nil
      0|   59|        }
      0|   60|    }
       |   61|
       |   62|    /// Returns the associated error value if the result is a failure, `nil` otherwise.
      0|   63|    public var error: Error? {
      0|   64|        switch self {
      0|   65|        case .Success:
      0|   66|            return nil
      0|   67|        case .Failure(let error):
      0|   68|            return error
      0|   69|        }
      0|   70|    }
       |   71|}
       |   72|
       |   73|// MARK: - CustomStringConvertible
       |   74|
       |   75|extension Result: CustomStringConvertible {
       |   76|    /// The textual representation used when written to an output stream, which includes whether the result was a 
       |   77|    /// success or failure.
      0|   78|    public var description: String {
      0|   79|        switch self {
      0|   80|        case .Success:
      0|   81|            return "SUCCESS"
      0|   82|        case .Failure:
      0|   83|            return "FAILURE"
      0|   84|        }
      0|   85|    }
       |   86|}
       |   87|
       |   88|// MARK: - CustomDebugStringConvertible
       |   89|
       |   90|extension Result: CustomDebugStringConvertible {
       |   91|    /// The debug textual representation used when written to an output stream, which includes whether the result was a
       |   92|    /// success or failure in addition to the value or error.
      1|   93|    public var debugDescription: String {
      1|   94|        switch self {
      0|   95|        case .Success(let value):
      0|   96|            return "SUCCESS: \(value)"
      1|   97|        case .Failure(let error):
      1|   98|            return "FAILURE: \(error)"
      1|   99|        }
      1|  100|    }
       |  101|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ServerTrustPolicy.swift:
       |    1|// ServerTrustPolicy.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
       |   26|public class ServerTrustPolicyManager {
       |   27|    /// The dictionary of policies mapped to a particular host.
       |   28|    public let policies: [String: ServerTrustPolicy]
       |   29|
       |   30|    /**
       |   31|        Initializes the `ServerTrustPolicyManager` instance with the given policies.
       |   32|
       |   33|        Since different servers and web services can have different leaf certificates, intermediate and even root 
       |   34|        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
       |   35|        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
       |   36|        pinning for host3 and disabling evaluation for host4.
       |   37|
       |   38|        - parameter policies: A dictionary of all policies mapped to a particular host.
       |   39|
       |   40|        - returns: The new `ServerTrustPolicyManager` instance.
       |   41|    */
      0|   42|    public init(policies: [String: ServerTrustPolicy]) {
      0|   43|        self.policies = policies
      0|   44|    }
       |   45|
       |   46|    /**
       |   47|        Returns the `ServerTrustPolicy` for the given host if applicable.
       |   48|
       |   49|        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
       |   50|        this method and implement more complex mapping implementations such as wildcards.
       |   51|
       |   52|        - parameter host: The host to use when searching for a matching policy.
       |   53|
       |   54|        - returns: The server trust policy for the given host if found.
       |   55|    */
      0|   56|    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
      0|   57|        return policies[host]
      0|   58|    }
       |   59|}
       |   60|
       |   61|// MARK: -
       |   62|
       |   63|extension NSURLSession {
       |   64|    private struct AssociatedKeys {
       |   65|        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
       |   66|    }
       |   67|
       |   68|    var serverTrustPolicyManager: ServerTrustPolicyManager? {
      1|   69|        get {
      1|   70|            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
      1|   71|        }
      1|   72|        set (manager) {
      1|   73|            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
      1|   74|        }
       |   75|    }
       |   76|}
       |   77|
       |   78|// MARK: - ServerTrustPolicy
       |   79|
       |   80|/**
       |   81|    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
       |   82|    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
       |   83|    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
       |   84|
       |   85|    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
       |   86|    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
       |   87|    to route all communication over an HTTPS connection with pinning enabled.
       |   88|
       |   89|    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
       |   90|                                validate the host provided by the challenge. Applications are encouraged to always 
       |   91|                                validate the host in production environments to guarantee the validity of the server's 
       |   92|                                certificate chain.
       |   93|
       |   94|    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
       |   95|                                considered valid if one of the pinned certificates match one of the server certificates. 
       |   96|                                By validating both the certificate chain and host, certificate pinning provides a very 
       |   97|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |   98|                                Applications are encouraged to always validate the host and require a valid certificate 
       |   99|                                chain in production environments.
       |  100|
       |  101|    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
       |  102|                                valid if one of the pinned public keys match one of the server certificate public keys. 
       |  103|                                By validating both the certificate chain and host, public key pinning provides a very 
       |  104|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |  105|                                Applications are encouraged to always validate the host and require a valid certificate 
       |  106|                                chain in production environments.
       |  107|
       |  108|    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
       |  109|
       |  110|    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
       |  111|*/
       |  112|public enum ServerTrustPolicy {
       |  113|    case PerformDefaultEvaluation(validateHost: Bool)
       |  114|    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
       |  115|    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
       |  116|    case DisableEvaluation
       |  117|    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
       |  118|
       |  119|    // MARK: - Bundle Location
       |  120|
       |  121|    /**
       |  122|        Returns all certificates within the given bundle with a `.cer` file extension.
       |  123|
       |  124|        - parameter bundle: The bundle to search for all `.cer` files.
       |  125|
       |  126|        - returns: All certificates within the given bundle.
       |  127|    */
      0|  128|    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
      0|  129|        var certificates: [SecCertificate] = []
      0|  130|
      0|  131|        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
      0|  132|            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
      0|  133|        }.flatten())
      0|  134|
      0|  135|        for path in paths {
      0|  136|            if let
      0|  137|                certificateData = NSData(contentsOfFile: path),
      0|  138|                certificate = SecCertificateCreateWithData(nil, certificateData)
      0|  139|            {
      0|  140|                certificates.append(certificate)
      0|  141|            }
      0|  142|        }
      0|  143|
      0|  144|        return certificates
      0|  145|    }
       |  146|
       |  147|    /**
       |  148|        Returns all public keys within the given bundle with a `.cer` file extension.
       |  149|
       |  150|        - parameter bundle: The bundle to search for all `*.cer` files.
       |  151|
       |  152|        - returns: All public keys within the given bundle.
       |  153|    */
      0|  154|    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
      0|  155|        var publicKeys: [SecKey] = []
      0|  156|
      0|  157|        for certificate in certificatesInBundle(bundle) {
      0|  158|            if let publicKey = publicKeyForCertificate(certificate) {
      0|  159|                publicKeys.append(publicKey)
      0|  160|            }
      0|  161|        }
      0|  162|
      0|  163|        return publicKeys
      0|  164|    }
       |  165|
       |  166|    // MARK: - Evaluation
       |  167|
       |  168|    /**
       |  169|        Evaluates whether the server trust is valid for the given host.
       |  170|
       |  171|        - parameter serverTrust: The server trust to evaluate.
       |  172|        - parameter host:        The host of the challenge protection space.
       |  173|
       |  174|        - returns: Whether the server trust is valid.
       |  175|    */
      0|  176|    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
      0|  177|        var serverTrustIsValid = false
      0|  178|
      0|  179|        switch self {
      0|  180|        case let .PerformDefaultEvaluation(validateHost):
      0|  181|            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  182|            SecTrustSetPolicies(serverTrust, [policy])
      0|  183|
      0|  184|            serverTrustIsValid = trustIsValid(serverTrust)
      0|  185|        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
      0|  186|            if validateCertificateChain {
      0|  187|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  188|                SecTrustSetPolicies(serverTrust, [policy])
      0|  189|
      0|  190|                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
      0|  191|                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
      0|  192|
      0|  193|                serverTrustIsValid = trustIsValid(serverTrust)
      0|  194|            } else {
      0|  195|                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
      0|  196|                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
      0|  197|
      0|  198|                outerLoop: for serverCertificateData in serverCertificatesDataArray {
      0|  199|                    for pinnedCertificateData in pinnedCertificatesDataArray {
      0|  200|                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
      0|  201|                            serverTrustIsValid = true
      0|  202|                            break outerLoop
      0|  203|                        }
      0|  204|                    }
      0|  205|                }
      0|  206|            }
      0|  207|        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
      0|  208|            var certificateChainEvaluationPassed = true
      0|  209|
      0|  210|            if validateCertificateChain {
      0|  211|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  212|                SecTrustSetPolicies(serverTrust, [policy])
      0|  213|
      0|  214|                certificateChainEvaluationPassed = trustIsValid(serverTrust)
      0|  215|            }
      0|  216|
      0|  217|            if certificateChainEvaluationPassed {
      0|  218|                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
      0|  219|                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
      0|  220|                        if serverPublicKey.isEqual(pinnedPublicKey) {
      0|  221|                            serverTrustIsValid = true
      0|  222|                            break outerLoop
      0|  223|                        }
      0|  224|                    }
      0|  225|                }
      0|  226|            }
      0|  227|        case .DisableEvaluation:
      0|  228|            serverTrustIsValid = true
      0|  229|        case let .CustomEvaluation(closure):
      0|  230|            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
      0|  231|        }
      0|  232|
      0|  233|        return serverTrustIsValid
      0|  234|    }
       |  235|
       |  236|    // MARK: - Private - Trust Validation
       |  237|
      0|  238|    private func trustIsValid(trust: SecTrust) -> Bool {
      0|  239|        var isValid = false
      0|  240|
      0|  241|        var result = SecTrustResultType(kSecTrustResultInvalid)
      0|  242|        let status = SecTrustEvaluate(trust, &result)
      0|  243|
      0|  244|        if status == errSecSuccess {
      0|  245|            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
      0|  246|            let proceed = SecTrustResultType(kSecTrustResultProceed)
      0|  247|
      0|  248|            isValid = result == unspecified || result == proceed
      0|  249|        }
      0|  250|
      0|  251|        return isValid
      0|  252|    }
       |  253|
       |  254|    // MARK: - Private - Certificate Data
       |  255|
      0|  256|    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
      0|  257|        var certificates: [SecCertificate] = []
      0|  258|
      0|  259|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  260|            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
      0|  261|                certificates.append(certificate)
      0|  262|            }
      0|  263|        }
      0|  264|
      0|  265|        return certificateDataForCertificates(certificates)
      0|  266|    }
       |  267|
      0|  268|    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
      0|  269|        return certificates.map { SecCertificateCopyData($0) as NSData }
      0|  270|    }
       |  271|
       |  272|    // MARK: - Private - Public Key Extraction
       |  273|
      0|  274|    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
      0|  275|        var publicKeys: [SecKey] = []
      0|  276|
      0|  277|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  278|            if let
      0|  279|                certificate = SecTrustGetCertificateAtIndex(trust, index),
      0|  280|                publicKey = publicKeyForCertificate(certificate)
      0|  281|            {
      0|  282|                publicKeys.append(publicKey)
      0|  283|            }
      0|  284|        }
      0|  285|
      0|  286|        return publicKeys
      0|  287|    }
       |  288|
      0|  289|    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
      0|  290|        var publicKey: SecKey?
      0|  291|
      0|  292|        let policy = SecPolicyCreateBasicX509()
      0|  293|        var trust: SecTrust?
      0|  294|        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
      0|  295|
      0|  296|        if let trust = trust where trustCreationStatus == errSecSuccess {
      0|  297|            publicKey = SecTrustCopyPublicKey(trust)
      0|  298|        }
      0|  299|
      0|  300|        return publicKey
      0|  301|    }
       |  302|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Stream.swift:
       |    1|// Stream.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if !os(watchOS)
       |   26|
       |   27|@available(iOS 9.0, OSX 10.11, *)
       |   28|extension Manager {
       |   29|    private enum Streamable {
       |   30|        case Stream(String, Int)
       |   31|        case NetService(NSNetService)
       |   32|    }
       |   33|
      0|   34|    private func stream(streamable: Streamable) -> Request {
      0|   35|        var streamTask: NSURLSessionStreamTask!
      0|   36|
      0|   37|        switch streamable {
      0|   38|        case .Stream(let hostName, let port):
      0|   39|            dispatch_sync(queue) {
      0|   40|                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
      0|   41|            }
      0|   42|        case .NetService(let netService):
      0|   43|            dispatch_sync(queue) {
      0|   44|                streamTask = self.session.streamTaskWithNetService(netService)
      0|   45|            }
      0|   46|        }
      0|   47|
      0|   48|        let request = Request(session: session, task: streamTask)
      0|   49|
      0|   50|        delegate[request.delegate.task] = request.delegate
      0|   51|
      0|   52|        if startRequestsImmediately {
      0|   53|            request.resume()
      0|   54|        }
      0|   55|
      0|   56|        return request
      0|   57|    }
       |   58|
       |   59|    /**
       |   60|        Creates a request for bidirectional streaming with the given hostname and port.
       |   61|
       |   62|        - parameter hostName: The hostname of the server to connect to.
       |   63|        - parameter port:     The port of the server to connect to.
       |   64|
       |   65|        :returns: The created stream request.
       |   66|    */
      0|   67|    public func stream(hostName hostName: String, port: Int) -> Request {
      0|   68|        return stream(.Stream(hostName, port))
      0|   69|    }
       |   70|
       |   71|    /**
       |   72|        Creates a request for bidirectional streaming with the given `NSNetService`.
       |   73|
       |   74|        - parameter netService: The net service used to identify the endpoint.
       |   75|
       |   76|        - returns: The created stream request.
       |   77|    */
      0|   78|    public func stream(netService netService: NSNetService) -> Request {
      0|   79|        return stream(.NetService(netService))
      0|   80|    }
       |   81|}
       |   82|
       |   83|// MARK: -
       |   84|
       |   85|@available(iOS 9.0, OSX 10.11, *)
       |   86|extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
       |   87|
       |   88|    // MARK: Override Closures
       |   89|
       |   90|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
       |   91|    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|   92|        get {
      0|   93|            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|   94|        }
      0|   95|        set {
      0|   96|            _streamTaskReadClosed = newValue
      0|   97|        }
       |   98|    }
       |   99|
       |  100|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
       |  101|    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  102|        get {
      0|  103|            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  104|        }
      0|  105|        set {
      0|  106|            _streamTaskWriteClosed = newValue
      0|  107|        }
       |  108|    }
       |  109|
       |  110|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
       |  111|    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  112|        get {
      0|  113|            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  114|        }
      0|  115|        set {
      0|  116|            _streamTaskBetterRouteDiscovered = newValue
      0|  117|        }
       |  118|    }
       |  119|
       |  120|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
       |  121|    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
      0|  122|        get {
      0|  123|            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
      0|  124|        }
      0|  125|        set {
      0|  126|            _streamTaskDidBecomeInputStream = newValue
      0|  127|        }
       |  128|    }
       |  129|
       |  130|    // MARK: Delegate Methods
       |  131|
       |  132|    /**
       |  133|        Tells the delegate that the read side of the connection has been closed.
       |  134|
       |  135|        - parameter session:    The session.
       |  136|        - parameter streamTask: The stream task.
       |  137|    */
      0|  138|    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  139|        streamTaskReadClosed?(session, streamTask)
      0|  140|    }
       |  141|
       |  142|    /**
       |  143|        Tells the delegate that the write side of the connection has been closed.
       |  144|
       |  145|        - parameter session:    The session.
       |  146|        - parameter streamTask: The stream task.
       |  147|    */
      0|  148|    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  149|        streamTaskWriteClosed?(session, streamTask)
      0|  150|    }
       |  151|
       |  152|    /**
       |  153|        Tells the delegate that the system has determined that a better route to the host is available.
       |  154|
       |  155|        - parameter session:    The session.
       |  156|        - parameter streamTask: The stream task.
       |  157|    */
      0|  158|    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  159|        streamTaskBetterRouteDiscovered?(session, streamTask)
      0|  160|    }
       |  161|
       |  162|    /**
       |  163|        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
       |  164|
       |  165|        - parameter session:      The session.
       |  166|        - parameter streamTask:   The stream task.
       |  167|        - parameter inputStream:  The new input stream.
       |  168|        - parameter outputStream: The new output stream.
       |  169|    */
       |  170|    public func URLSession(
       |  171|        session: NSURLSession,
       |  172|        streamTask: NSURLSessionStreamTask,
       |  173|        didBecomeInputStream inputStream: NSInputStream,
       |  174|        outputStream: NSOutputStream)
      0|  175|    {
      0|  176|        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
      0|  177|    }
       |  178|}
       |  179|
       |  180|#endif

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Upload.swift:
       |    1|// Upload.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Uploadable {
       |   27|        case Data(NSURLRequest, NSData)
       |   28|        case File(NSURLRequest, NSURL)
       |   29|        case Stream(NSURLRequest, NSInputStream)
       |   30|    }
       |   31|
      0|   32|    private func upload(uploadable: Uploadable) -> Request {
      0|   33|        var uploadTask: NSURLSessionUploadTask!
      0|   34|        var HTTPBodyStream: NSInputStream?
      0|   35|
      0|   36|        switch uploadable {
      0|   37|        case .Data(let request, let data):
      0|   38|            dispatch_sync(queue) {
      0|   39|                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
      0|   40|            }
      0|   41|        case .File(let request, let fileURL):
      0|   42|            dispatch_sync(queue) {
      0|   43|                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
      0|   44|            }
      0|   45|        case .Stream(let request, let stream):
      0|   46|            dispatch_sync(queue) {
      0|   47|                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
      0|   48|            }
      0|   49|
      0|   50|            HTTPBodyStream = stream
      0|   51|        }
      0|   52|
      0|   53|        let request = Request(session: session, task: uploadTask)
      0|   54|
      0|   55|        if HTTPBodyStream != nil {
      0|   56|            request.delegate.taskNeedNewBodyStream = { _, _ in
      0|   57|                return HTTPBodyStream
      0|   58|            }
      0|   59|        }
      0|   60|
      0|   61|        delegate[request.delegate.task] = request.delegate
      0|   62|
      0|   63|        if startRequestsImmediately {
      0|   64|            request.resume()
      0|   65|        }
      0|   66|
      0|   67|        return request
      0|   68|    }
       |   69|
       |   70|    // MARK: File
       |   71|
       |   72|    /**
       |   73|        Creates a request for uploading a file to the specified URL request.
       |   74|
       |   75|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   76|
       |   77|        - parameter URLRequest: The URL request
       |   78|        - parameter file:       The file to upload
       |   79|
       |   80|        - returns: The created upload request.
       |   81|    */
      0|   82|    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|   83|        return upload(.File(URLRequest.URLRequest, file))
      0|   84|    }
       |   85|
       |   86|    /**
       |   87|        Creates a request for uploading a file to the specified URL request.
       |   88|
       |   89|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   90|
       |   91|        - parameter method:    The HTTP method.
       |   92|        - parameter URLString: The URL string.
       |   93|        - parameter headers:   The HTTP headers. `nil` by default.
       |   94|        - parameter file:      The file to upload
       |   95|
       |   96|        - returns: The created upload request.
       |   97|    */
       |   98|    public func upload(
       |   99|        method: Method,
       |  100|        _ URLString: URLStringConvertible,
       |  101|        headers: [String: String]? = nil,
       |  102|        file: NSURL)
       |  103|        -> Request
      0|  104|    {
      0|  105|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  106|        return upload(mutableURLRequest, file: file)
      0|  107|    }
       |  108|
       |  109|    // MARK: Data
       |  110|
       |  111|    /**
       |  112|        Creates a request for uploading data to the specified URL request.
       |  113|
       |  114|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  115|
       |  116|        - parameter URLRequest: The URL request.
       |  117|        - parameter data:       The data to upload.
       |  118|
       |  119|        - returns: The created upload request.
       |  120|    */
      0|  121|    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  122|        return upload(.Data(URLRequest.URLRequest, data))
      0|  123|    }
       |  124|
       |  125|    /**
       |  126|        Creates a request for uploading data to the specified URL request.
       |  127|
       |  128|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  129|
       |  130|        - parameter method:    The HTTP method.
       |  131|        - parameter URLString: The URL string.
       |  132|        - parameter headers:   The HTTP headers. `nil` by default.
       |  133|        - parameter data:      The data to upload
       |  134|
       |  135|        - returns: The created upload request.
       |  136|    */
       |  137|    public func upload(
       |  138|        method: Method,
       |  139|        _ URLString: URLStringConvertible,
       |  140|        headers: [String: String]? = nil,
       |  141|        data: NSData)
       |  142|        -> Request
      0|  143|    {
      0|  144|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  145|
      0|  146|        return upload(mutableURLRequest, data: data)
      0|  147|    }
       |  148|
       |  149|    // MARK: Stream
       |  150|
       |  151|    /**
       |  152|        Creates a request for uploading a stream to the specified URL request.
       |  153|
       |  154|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  155|
       |  156|        - parameter URLRequest: The URL request.
       |  157|        - parameter stream:     The stream to upload.
       |  158|
       |  159|        - returns: The created upload request.
       |  160|    */
      0|  161|    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  162|        return upload(.Stream(URLRequest.URLRequest, stream))
      0|  163|    }
       |  164|
       |  165|    /**
       |  166|        Creates a request for uploading a stream to the specified URL request.
       |  167|
       |  168|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  169|
       |  170|        - parameter method:    The HTTP method.
       |  171|        - parameter URLString: The URL string.
       |  172|        - parameter headers:   The HTTP headers. `nil` by default.
       |  173|        - parameter stream:    The stream to upload.
       |  174|
       |  175|        - returns: The created upload request.
       |  176|    */
       |  177|    public func upload(
       |  178|        method: Method,
       |  179|        _ URLString: URLStringConvertible,
       |  180|        headers: [String: String]? = nil,
       |  181|        stream: NSInputStream)
       |  182|        -> Request
      0|  183|    {
      0|  184|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  185|
      0|  186|        return upload(mutableURLRequest, stream: stream)
      0|  187|    }
       |  188|
       |  189|    // MARK: MultipartFormData
       |  190|
       |  191|    /// Default memory threshold used when encoding `MultipartFormData`.
       |  192|    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
       |  193|
       |  194|    /**
       |  195|        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
       |  196|        associated values.
       |  197|
       |  198|        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
       |  199|                   streaming information.
       |  200|        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
       |  201|                   error.
       |  202|    */
       |  203|    public enum MultipartFormDataEncodingResult {
       |  204|        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
       |  205|        case Failure(ErrorType)
       |  206|    }
       |  207|
       |  208|    /**
       |  209|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  210|
       |  211|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
       |  212|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
       |  213|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
       |  214|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
       |  215|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
       |  216|        used for larger payloads such as video content.
       |  217|
       |  218|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
       |  219|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  220|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
       |  221|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
       |  222|        technique was used.
       |  223|
       |  224|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  225|
       |  226|        - parameter method:                  The HTTP method.
       |  227|        - parameter URLString:               The URL string.
       |  228|        - parameter headers:                 The HTTP headers. `nil` by default.
       |  229|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  230|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  231|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  232|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  233|    */
       |  234|    public func upload(
       |  235|        method: Method,
       |  236|        _ URLString: URLStringConvertible,
       |  237|        headers: [String: String]? = nil,
       |  238|        multipartFormData: MultipartFormData -> Void,
       |  239|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  240|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  241|    {
      0|  242|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  243|
      0|  244|        return upload(
      0|  245|            mutableURLRequest,
      0|  246|            multipartFormData: multipartFormData,
      0|  247|            encodingMemoryThreshold: encodingMemoryThreshold,
      0|  248|            encodingCompletion: encodingCompletion
      0|  249|        )
      0|  250|    }
       |  251|
       |  252|    /**
       |  253|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  254|
       |  255|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
       |  256|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
       |  257|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
       |  258|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
       |  259|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
       |  260|        used for larger payloads such as video content.
       |  261|
       |  262|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
       |  263|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  264|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
       |  265|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
       |  266|        technique was used.
       |  267|
       |  268|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  269|
       |  270|        - parameter URLRequest:              The URL request.
       |  271|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  272|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  273|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  274|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  275|    */
       |  276|    public func upload(
       |  277|        URLRequest: URLRequestConvertible,
       |  278|        multipartFormData: MultipartFormData -> Void,
       |  279|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  280|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  281|    {
      0|  282|        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
      0|  283|            let formData = MultipartFormData()
      0|  284|            multipartFormData(formData)
      0|  285|
      0|  286|            let URLRequestWithContentType = URLRequest.URLRequest
      0|  287|            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
      0|  288|
      0|  289|            let isBackgroundSession = self.session.configuration.identifier != nil
      0|  290|
      0|  291|            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
      0|  292|                do {
      0|  293|                    let data = try formData.encode()
      0|  294|                    let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  295|                        request: self.upload(URLRequestWithContentType, data: data),
      0|  296|                        streamingFromDisk: false,
      0|  297|                        streamFileURL: nil
      0|  298|                    )
      0|  299|
      0|  300|                    dispatch_async(dispatch_get_main_queue()) {
      0|  301|                        encodingCompletion?(encodingResult)
      0|  302|                    }
      0|  303|                } catch {
      0|  304|                    dispatch_async(dispatch_get_main_queue()) {
      0|  305|                        encodingCompletion?(.Failure(error as NSError))
      0|  306|                    }
      0|  307|                }
      0|  308|            } else {
      0|  309|                let fileManager = NSFileManager.defaultManager()
      0|  310|                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
      0|  311|                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
      0|  312|                let fileName = NSUUID().UUIDString
      0|  313|                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
      0|  314|
      0|  315|                do {
      0|  316|                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
      0|  317|                    try formData.writeEncodedDataToDisk(fileURL)
      0|  318|
      0|  319|                    dispatch_async(dispatch_get_main_queue()) {
      0|  320|                        let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  321|                            request: self.upload(URLRequestWithContentType, file: fileURL),
      0|  322|                            streamingFromDisk: true,
      0|  323|                            streamFileURL: fileURL
      0|  324|                        )
      0|  325|                        encodingCompletion?(encodingResult)
      0|  326|                    }
      0|  327|                } catch {
      0|  328|                    dispatch_async(dispatch_get_main_queue()) {
      0|  329|                        encodingCompletion?(.Failure(error as NSError))
      0|  330|                    }
      0|  331|                }
      0|  332|            }
      0|  333|        }
      0|  334|    }
       |  335|}
       |  336|
       |  337|// MARK: -
       |  338|
       |  339|extension Request {
       |  340|
       |  341|    // MARK: - UploadTaskDelegate
       |  342|
       |  343|    class UploadTaskDelegate: DataTaskDelegate {
      0|  344|        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
       |  345|        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
       |  346|
       |  347|        // MARK: - NSURLSessionTaskDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  352|
       |  353|        // MARK: Delegate Methods
       |  354|
       |  355|        func URLSession(
       |  356|            session: NSURLSession,
       |  357|            task: NSURLSessionTask,
       |  358|            didSendBodyData bytesSent: Int64,
       |  359|            totalBytesSent: Int64,
       |  360|            totalBytesExpectedToSend: Int64)
      0|  361|        {
      0|  362|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  363|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  364|            } else {
      0|  365|                progress.totalUnitCount = totalBytesExpectedToSend
      0|  366|                progress.completedUnitCount = totalBytesSent
      0|  367|
      0|  368|                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  369|            }
      0|  370|        }
       |  371|    }
       |  372|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Validation.swift:
       |    1|// Validation.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Request {
       |   26|
       |   27|    /**
       |   28|        Used to represent whether validation was successful or encountered an error resulting in a failure.
       |   29|
       |   30|        - Success: The validation was successful.
       |   31|        - Failure: The validation failed encountering the provided error.
       |   32|    */
       |   33|    public enum ValidationResult {
       |   34|        case Success
       |   35|        case Failure(NSError)
       |   36|    }
       |   37|
       |   38|    /**
       |   39|        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
       |   40|        request was valid.
       |   41|    */
       |   42|    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
       |   43|
       |   44|    /**
       |   45|        Validates the request, using the specified closure.
       |   46|
       |   47|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   48|
       |   49|        - parameter validation: A closure to validate the request.
       |   50|
       |   51|        - returns: The request.
       |   52|    */
      0|   53|    public func validate(validation: Validation) -> Self {
      0|   54|        delegate.queue.addOperationWithBlock {
      0|   55|            if let
      0|   56|                response = self.response where self.delegate.error == nil,
      0|   57|                case let .Failure(error) = validation(self.request, response)
      0|   58|            {
      0|   59|                self.delegate.error = error
      0|   60|            }
      0|   61|        }
      0|   62|
      0|   63|        return self
      0|   64|    }
       |   65|
       |   66|    // MARK: - Status Code
       |   67|
       |   68|    /**
       |   69|        Validates that the response has a status code in the specified range.
       |   70|
       |   71|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   72|
       |   73|        - parameter range: The range of acceptable status codes.
       |   74|
       |   75|        - returns: The request.
       |   76|    */
      0|   77|    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
      0|   78|        return validate { _, response in
      0|   79|            if acceptableStatusCode.contains(response.statusCode) {
      0|   80|                return .Success
      0|   81|            } else {
      0|   82|                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
      0|   83|                return .Failure(Error.errorWithCode(.StatusCodeValidationFailed, failureReason: failureReason))
      0|   84|            }
      0|   85|        }
      0|   86|    }
       |   87|
       |   88|    // MARK: - Content-Type
       |   89|
       |   90|    private struct MIMEType {
       |   91|        let type: String
       |   92|        let subtype: String
       |   93|
      0|   94|        init?(_ string: String) {
      0|   95|            let components: [String] = {
      0|   96|                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
      0|   97|                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
      0|   98|                return split.componentsSeparatedByString("/")
      0|   99|            }()
      0|  100|
      0|  101|            if let
      0|  102|                type = components.first,
      0|  103|                subtype = components.last
      0|  104|            {
      0|  105|                self.type = type
      0|  106|                self.subtype = subtype
      0|  107|            } else {
      0|  108|                return nil
      0|  109|            }
      0|  110|        }
       |  111|
      0|  112|        func matches(MIME: MIMEType) -> Bool {
      0|  113|            switch (type, subtype) {
      0|  114|            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
      0|  115|                return true
      0|  116|            default:
      0|  117|                return false
      0|  118|            }
      0|  119|        }
       |  120|    }
       |  121|
       |  122|    /**
       |  123|        Validates that the response has a content type in the specified array.
       |  124|
       |  125|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  126|
       |  127|        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
       |  128|
       |  129|        - returns: The request.
       |  130|    */
      0|  131|    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
      0|  132|        return validate { _, response in
      0|  133|            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
      0|  134|
      0|  135|            if let
      0|  136|                responseContentType = response.MIMEType,
      0|  137|                responseMIMEType = MIMEType(responseContentType)
      0|  138|            {
      0|  139|                for contentType in acceptableContentTypes {
      0|  140|                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
      0|  141|                        return .Success
      0|  142|                    }
      0|  143|                }
      0|  144|            } else {
      0|  145|                for contentType in acceptableContentTypes {
      0|  146|                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
      0|  147|                        return .Success
      0|  148|                    }
      0|  149|                }
      0|  150|            }
      0|  151|
      0|  152|            let failureReason: String
      0|  153|
      0|  154|            if let responseContentType = response.MIMEType {
      0|  155|                failureReason = (
      0|  156|                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
      0|  157|                    "content types: \(acceptableContentTypes)"
      0|  158|                )
      0|  159|            } else {
      0|  160|                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
      0|  161|            }
      0|  162|
      0|  163|            return .Failure(Error.errorWithCode(.ContentTypeValidationFailed, failureReason: failureReason))
      0|  164|        }
      0|  165|    }
       |  166|
       |  167|    // MARK: - Automatic
       |  168|
       |  169|    /**
       |  170|        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
       |  171|        type matches any specified in the Accept HTTP header field.
       |  172|
       |  173|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  174|
       |  175|        - returns: The request.
       |  176|    */
      0|  177|    public func validate() -> Self {
      0|  178|        let acceptableStatusCodes: Range<Int> = 200..<300
      0|  179|        let acceptableContentTypes: [String] = {
      0|  180|            if let accept = request?.valueForHTTPHeaderField("Accept") {
      0|  181|                return accept.componentsSeparatedByString(",")
      0|  182|            }
      0|  183|
      0|  184|            return ["*/*"]
      0|  185|        }()
      0|  186|
      0|  187|        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
      0|  188|    }
       |  189|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Alamofire.swift:
       |    1|// Alamofire.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: - URLStringConvertible
       |   26|
       |   27|/**
       |   28|    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
       |   29|    construct URL requests.
       |   30|*/
       |   31|public protocol URLStringConvertible {
       |   32|    /**
       |   33|        A URL that conforms to RFC 2396.
       |   34|
       |   35|        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
       |   36|
       |   37|        See https://tools.ietf.org/html/rfc2396
       |   38|        See https://tools.ietf.org/html/rfc1738
       |   39|        See https://tools.ietf.org/html/rfc1808
       |   40|    */
       |   41|    var URLString: String { get }
       |   42|}
       |   43|
       |   44|extension String: URLStringConvertible {
      1|   45|    public var URLString: String {
      1|   46|        return self
      1|   47|    }
       |   48|}
       |   49|
       |   50|extension NSURL: URLStringConvertible {
      0|   51|    public var URLString: String {
      0|   52|        return absoluteString
      0|   53|    }
       |   54|}
       |   55|
       |   56|extension NSURLComponents: URLStringConvertible {
      0|   57|    public var URLString: String {
      0|   58|        return URL!.URLString
      0|   59|    }
       |   60|}
       |   61|
       |   62|extension NSURLRequest: URLStringConvertible {
      0|   63|    public var URLString: String {
      0|   64|        return URL!.URLString
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - URLRequestConvertible
       |   69|
       |   70|/**
       |   71|    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
       |   72|*/
       |   73|public protocol URLRequestConvertible {
       |   74|    /// The URL request.
       |   75|    var URLRequest: NSMutableURLRequest { get }
       |   76|}
       |   77|
       |   78|extension NSURLRequest: URLRequestConvertible {
      2|   79|    public var URLRequest: NSMutableURLRequest {
      2|   80|        return self.mutableCopy() as! NSMutableURLRequest
      2|   81|    }
       |   82|}
       |   83|
       |   84|// MARK: - Convenience
       |   85|
       |   86|func URLRequest(
       |   87|    method: Method,
       |   88|    _ URLString: URLStringConvertible,
       |   89|    headers: [String: String]? = nil)
       |   90|    -> NSMutableURLRequest
      1|   91|{
      1|   92|    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
      1|   93|    mutableURLRequest.HTTPMethod = method.rawValue
      1|   94|
      1|   95|    if let headers = headers {
      2|   96|        for (headerField, headerValue) in headers {
      2|   97|            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
      2|   98|        }
      1|   99|    }
      1|  100|
      1|  101|    return mutableURLRequest
      1|  102|}
       |  103|
       |  104|// MARK: - Request Methods
       |  105|
       |  106|/**
       |  107|    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
       |  108|    parameter encoding.
       |  109|
       |  110|    - parameter method:     The HTTP method.
       |  111|    - parameter URLString:  The URL string.
       |  112|    - parameter parameters: The parameters. `nil` by default.
       |  113|    - parameter encoding:   The parameter encoding. `.URL` by default.
       |  114|    - parameter headers:    The HTTP headers. `nil` by default.
       |  115|
       |  116|    - returns: The created request.
       |  117|*/
       |  118|public func request(
       |  119|    method: Method,
       |  120|    _ URLString: URLStringConvertible,
       |  121|    parameters: [String: AnyObject]? = nil,
       |  122|    encoding: ParameterEncoding = .URL,
       |  123|    headers: [String: String]? = nil)
       |  124|    -> Request
      1|  125|{
      1|  126|    return Manager.sharedInstance.request(
      1|  127|        method,
      1|  128|        URLString,
      1|  129|        parameters: parameters,
      1|  130|        encoding: encoding,
      1|  131|        headers: headers
      1|  132|    )
      1|  133|}
       |  134|
       |  135|/**
       |  136|    Creates a request using the shared manager instance for the specified URL request.
       |  137|
       |  138|    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  139|
       |  140|    - parameter URLRequest: The URL request
       |  141|
       |  142|    - returns: The created request.
       |  143|*/
      0|  144|public func request(URLRequest: URLRequestConvertible) -> Request {
      0|  145|    return Manager.sharedInstance.request(URLRequest.URLRequest)
      0|  146|}
       |  147|
       |  148|// MARK: - Upload Methods
       |  149|
       |  150|// MARK: File
       |  151|
       |  152|/**
       |  153|    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
       |  154|
       |  155|    - parameter method:    The HTTP method.
       |  156|    - parameter URLString: The URL string.
       |  157|    - parameter headers:   The HTTP headers. `nil` by default.
       |  158|    - parameter file:      The file to upload.
       |  159|
       |  160|    - returns: The created upload request.
       |  161|*/
       |  162|public func upload(
       |  163|    method: Method,
       |  164|    _ URLString: URLStringConvertible,
       |  165|    headers: [String: String]? = nil,
       |  166|    file: NSURL)
       |  167|    -> Request
      0|  168|{
      0|  169|    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
      0|  170|}
       |  171|
       |  172|/**
       |  173|    Creates an upload request using the shared manager instance for the specified URL request and file.
       |  174|
       |  175|    - parameter URLRequest: The URL request.
       |  176|    - parameter file:       The file to upload.
       |  177|
       |  178|    - returns: The created upload request.
       |  179|*/
      0|  180|public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|  181|    return Manager.sharedInstance.upload(URLRequest, file: file)
      0|  182|}
       |  183|
       |  184|// MARK: Data
       |  185|
       |  186|/**
       |  187|    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
       |  188|
       |  189|    - parameter method:    The HTTP method.
       |  190|    - parameter URLString: The URL string.
       |  191|    - parameter headers:   The HTTP headers. `nil` by default.
       |  192|    - parameter data:      The data to upload.
       |  193|
       |  194|    - returns: The created upload request.
       |  195|*/
       |  196|public func upload(
       |  197|    method: Method,
       |  198|    _ URLString: URLStringConvertible,
       |  199|    headers: [String: String]? = nil,
       |  200|    data: NSData)
       |  201|    -> Request
      0|  202|{
      0|  203|    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
      0|  204|}
       |  205|
       |  206|/**
       |  207|    Creates an upload request using the shared manager instance for the specified URL request and data.
       |  208|
       |  209|    - parameter URLRequest: The URL request.
       |  210|    - parameter data:       The data to upload.
       |  211|
       |  212|    - returns: The created upload request.
       |  213|*/
      0|  214|public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  215|    return Manager.sharedInstance.upload(URLRequest, data: data)
      0|  216|}
       |  217|
       |  218|// MARK: Stream
       |  219|
       |  220|/**
       |  221|    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
       |  222|
       |  223|    - parameter method:    The HTTP method.
       |  224|    - parameter URLString: The URL string.
       |  225|    - parameter headers:   The HTTP headers. `nil` by default.
       |  226|    - parameter stream:    The stream to upload.
       |  227|
       |  228|    - returns: The created upload request.
       |  229|*/
       |  230|public func upload(
       |  231|    method: Method,
       |  232|    _ URLString: URLStringConvertible,
       |  233|    headers: [String: String]? = nil,
       |  234|    stream: NSInputStream)
       |  235|    -> Request
      0|  236|{
      0|  237|    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
      0|  238|}
       |  239|
       |  240|/**
       |  241|    Creates an upload request using the shared manager instance for the specified URL request and stream.
       |  242|
       |  243|    - parameter URLRequest: The URL request.
       |  244|    - parameter stream:     The stream to upload.
       |  245|
       |  246|    - returns: The created upload request.
       |  247|*/
      0|  248|public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  249|    return Manager.sharedInstance.upload(URLRequest, stream: stream)
      0|  250|}
       |  251|
       |  252|// MARK: MultipartFormData
       |  253|
       |  254|/**
       |  255|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  256|
       |  257|    - parameter method:                  The HTTP method.
       |  258|    - parameter URLString:               The URL string.
       |  259|    - parameter headers:                 The HTTP headers. `nil` by default.
       |  260|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  261|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  262|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  263|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  264|*/
       |  265|public func upload(
       |  266|    method: Method,
       |  267|    _ URLString: URLStringConvertible,
       |  268|    headers: [String: String]? = nil,
       |  269|    multipartFormData: MultipartFormData -> Void,
       |  270|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  271|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  272|{
      0|  273|    return Manager.sharedInstance.upload(
      0|  274|        method,
      0|  275|        URLString,
      0|  276|        headers: headers,
      0|  277|        multipartFormData: multipartFormData,
      0|  278|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  279|        encodingCompletion: encodingCompletion
      0|  280|    )
      0|  281|}
       |  282|
       |  283|/**
       |  284|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  285|
       |  286|    - parameter URLRequest:              The URL request.
       |  287|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  288|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  289|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  290|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  291|*/
       |  292|public func upload(
       |  293|    URLRequest: URLRequestConvertible,
       |  294|    multipartFormData: MultipartFormData -> Void,
       |  295|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  296|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  297|{
      0|  298|    return Manager.sharedInstance.upload(
      0|  299|        URLRequest,
      0|  300|        multipartFormData: multipartFormData,
      0|  301|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  302|        encodingCompletion: encodingCompletion
      0|  303|    )
      0|  304|}
       |  305|
       |  306|// MARK: - Download Methods
       |  307|
       |  308|// MARK: URL Request
       |  309|
       |  310|/**
       |  311|    Creates a download request using the shared manager instance for the specified method and URL string.
       |  312|
       |  313|    - parameter method:      The HTTP method.
       |  314|    - parameter URLString:   The URL string.
       |  315|    - parameter parameters:  The parameters. `nil` by default.
       |  316|    - parameter encoding:    The parameter encoding. `.URL` by default.
       |  317|    - parameter headers:     The HTTP headers. `nil` by default.
       |  318|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  319|
       |  320|    - returns: The created download request.
       |  321|*/
       |  322|public func download(
       |  323|    method: Method,
       |  324|    _ URLString: URLStringConvertible,
       |  325|    parameters: [String: AnyObject]? = nil,
       |  326|    encoding: ParameterEncoding = .URL,
       |  327|    headers: [String: String]? = nil,
       |  328|    destination: Request.DownloadFileDestination)
       |  329|    -> Request
      0|  330|{
      0|  331|    return Manager.sharedInstance.download(
      0|  332|        method,
      0|  333|        URLString,
      0|  334|        parameters: parameters,
      0|  335|        encoding: encoding,
      0|  336|        headers: headers,
      0|  337|        destination: destination
      0|  338|    )
      0|  339|}
       |  340|
       |  341|/**
       |  342|    Creates a download request using the shared manager instance for the specified URL request.
       |  343|
       |  344|    - parameter URLRequest:  The URL request.
       |  345|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  346|
       |  347|    - returns: The created download request.
       |  348|*/
      0|  349|public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  350|    return Manager.sharedInstance.download(URLRequest, destination: destination)
      0|  351|}
       |  352|
       |  353|// MARK: Resume Data
       |  354|
       |  355|/**
       |  356|    Creates a request using the shared manager instance for downloading from the resume data produced from a 
       |  357|    previous request cancellation.
       |  358|
       |  359|    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
       |  360|                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
       |  361|                             information.
       |  362|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  363|
       |  364|    - returns: The created download request.
       |  365|*/
      0|  366|public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  367|    return Manager.sharedInstance.download(data, destination: destination)
      0|  368|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Download.swift:
       |    1|// Download.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Downloadable {
       |   27|        case Request(NSURLRequest)
       |   28|        case ResumeData(NSData)
       |   29|    }
       |   30|
      0|   31|    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
      0|   32|        var downloadTask: NSURLSessionDownloadTask!
      0|   33|
      0|   34|        switch downloadable {
      0|   35|        case .Request(let request):
      0|   36|            dispatch_sync(queue) {
      0|   37|                downloadTask = self.session.downloadTaskWithRequest(request)
      0|   38|            }
      0|   39|        case .ResumeData(let resumeData):
      0|   40|            dispatch_sync(queue) {
      0|   41|                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
      0|   42|            }
      0|   43|        }
      0|   44|
      0|   45|        let request = Request(session: session, task: downloadTask)
      0|   46|
      0|   47|        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
      0|   48|            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
      0|   49|                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
      0|   50|            }
      0|   51|        }
      0|   52|
      0|   53|        delegate[request.delegate.task] = request.delegate
      0|   54|
      0|   55|        if startRequestsImmediately {
      0|   56|            request.resume()
      0|   57|        }
      0|   58|
      0|   59|        return request
      0|   60|    }
       |   61|
       |   62|    // MARK: Request
       |   63|
       |   64|    /**
       |   65|        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
       |   66|        and destination.
       |   67|
       |   68|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   69|
       |   70|        - parameter method:      The HTTP method.
       |   71|        - parameter URLString:   The URL string.
       |   72|        - parameter parameters:  The parameters. `nil` by default.
       |   73|        - parameter encoding:    The parameter encoding. `.URL` by default.
       |   74|        - parameter headers:     The HTTP headers. `nil` by default.
       |   75|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |   76|
       |   77|        - returns: The created download request.
       |   78|    */
       |   79|    public func download(
       |   80|        method: Method,
       |   81|        _ URLString: URLStringConvertible,
       |   82|        parameters: [String: AnyObject]? = nil,
       |   83|        encoding: ParameterEncoding = .URL,
       |   84|        headers: [String: String]? = nil,
       |   85|        destination: Request.DownloadFileDestination)
       |   86|        -> Request
      0|   87|    {
      0|   88|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|   89|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      0|   90|
      0|   91|        return download(encodedURLRequest, destination: destination)
      0|   92|    }
       |   93|
       |   94|    /**
       |   95|        Creates a request for downloading from the specified URL request.
       |   96|
       |   97|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   98|
       |   99|        - parameter URLRequest:  The URL request
       |  100|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  101|
       |  102|        - returns: The created download request.
       |  103|    */
      0|  104|    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  105|        return download(.Request(URLRequest.URLRequest), destination: destination)
      0|  106|    }
       |  107|
       |  108|    // MARK: Resume Data
       |  109|
       |  110|    /**
       |  111|        Creates a request for downloading from the resume data produced from a previous request cancellation.
       |  112|
       |  113|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  114|
       |  115|        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
       |  116|                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
       |  117|                                 additional information.
       |  118|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  119|
       |  120|        - returns: The created download request.
       |  121|    */
      0|  122|    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  123|        return download(.ResumeData(resumeData), destination: destination)
      0|  124|    }
       |  125|}
       |  126|
       |  127|// MARK: -
       |  128|
       |  129|extension Request {
       |  130|    /**
       |  131|        A closure executed once a request has successfully completed in order to determine where to move the temporary 
       |  132|        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
       |  133|        response, and returns a single argument: the file URL where the temporary file should be moved.
       |  134|    */
       |  135|    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
       |  136|
       |  137|    /**
       |  138|        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
       |  139|        file URL in the first available directory with the specified search path directory and search path domain mask.
       |  140|
       |  141|        - parameter directory: The search path directory. `.DocumentDirectory` by default.
       |  142|        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
       |  143|
       |  144|        - returns: A download file destination closure.
       |  145|    */
       |  146|    public class func suggestedDownloadDestination(
       |  147|        directory directory: NSSearchPathDirectory = .DocumentDirectory,
       |  148|        domain: NSSearchPathDomainMask = .UserDomainMask)
       |  149|        -> DownloadFileDestination
      0|  150|    {
      0|  151|        return { temporaryURL, response -> NSURL in
      0|  152|            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
      0|  153|
      0|  154|            if !directoryURLs.isEmpty {
      0|  155|                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
      0|  156|            }
      0|  157|
      0|  158|            return temporaryURL
      0|  159|        }
      0|  160|    }
       |  161|
       |  162|    /// The resume data of the underlying download task if available after a failure.
      0|  163|    public var resumeData: NSData? {
      0|  164|        var data: NSData?
      0|  165|
      0|  166|        if let delegate = delegate as? DownloadTaskDelegate {
      0|  167|            data = delegate.resumeData
      0|  168|        }
      0|  169|
      0|  170|        return data
      0|  171|    }
       |  172|
       |  173|    // MARK: - DownloadTaskDelegate
       |  174|
       |  175|    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
      0|  176|        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
       |  177|        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
       |  178|
       |  179|        var resumeData: NSData?
      0|  180|        override var data: NSData? { return resumeData }
       |  181|
       |  182|        // MARK: - NSURLSessionDownloadDelegate
       |  183|
       |  184|        // MARK: Override Closures
       |  185|
       |  186|        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
       |  187|        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  188|        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  189|
       |  190|        // MARK: Delegate Methods
       |  191|
       |  192|        func URLSession(
       |  193|            session: NSURLSession,
       |  194|            downloadTask: NSURLSessionDownloadTask,
       |  195|            didFinishDownloadingToURL location: NSURL)
      0|  196|        {
      0|  197|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  198|                do {
      0|  199|                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  200|                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
      0|  201|                } catch {
      0|  202|                    self.error = error as NSError
      0|  203|                }
      0|  204|            }
      0|  205|        }
       |  206|
       |  207|        func URLSession(
       |  208|            session: NSURLSession,
       |  209|            downloadTask: NSURLSessionDownloadTask,
       |  210|            didWriteData bytesWritten: Int64,
       |  211|            totalBytesWritten: Int64,
       |  212|            totalBytesExpectedToWrite: Int64)
      0|  213|        {
      0|  214|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  215|                downloadTaskDidWriteData(
      0|  216|                    session,
      0|  217|                    downloadTask,
      0|  218|                    bytesWritten,
      0|  219|                    totalBytesWritten, 
      0|  220|                    totalBytesExpectedToWrite
      0|  221|                )
      0|  222|            } else {
      0|  223|                progress.totalUnitCount = totalBytesExpectedToWrite
      0|  224|                progress.completedUnitCount = totalBytesWritten
      0|  225|
      0|  226|                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  227|            }
      0|  228|        }
       |  229|
       |  230|        func URLSession(
       |  231|            session: NSURLSession,
       |  232|            downloadTask: NSURLSessionDownloadTask,
       |  233|            didResumeAtOffset fileOffset: Int64,
       |  234|            expectedTotalBytes: Int64)
      0|  235|        {
      0|  236|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  237|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  238|            } else {
      0|  239|                progress.totalUnitCount = expectedTotalBytes
      0|  240|                progress.completedUnitCount = fileOffset
      0|  241|            }
      0|  242|        }
       |  243|    }
       |  244|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Error.swift:
       |    1|// Error.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
       |   26|public struct Error {
       |   27|    /// The domain used for creating all Alamofire errors.
       |   28|    public static let Domain = "com.alamofire.error"
       |   29|
       |   30|    /// The custom error codes generated by Alamofire.
       |   31|    public enum Code: Int {
       |   32|        case InputStreamReadFailed           = -6000
       |   33|        case OutputStreamWriteFailed         = -6001
       |   34|        case ContentTypeValidationFailed     = -6002
       |   35|        case StatusCodeValidationFailed      = -6003
       |   36|        case DataSerializationFailed         = -6004
       |   37|        case StringSerializationFailed       = -6005
       |   38|        case JSONSerializationFailed         = -6006
       |   39|        case PropertyListSerializationFailed = -6007
       |   40|    }
       |   41|
       |   42|    /**
       |   43|        Creates an `NSError` with the given error code and failure reason.
       |   44|
       |   45|        - parameter code:          The error code.
       |   46|        - parameter failureReason: The failure reason.
       |   47|
       |   48|        - returns: An `NSError` with the given error code and failure reason.
       |   49|    */
      0|   50|    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
      0|   51|        return errorWithCode(code.rawValue, failureReason: failureReason)
      0|   52|    }
       |   53|
       |   54|    /**
       |   55|        Creates an `NSError` with the given error code and failure reason.
       |   56|
       |   57|        - parameter code:          The error code.
       |   58|        - parameter failureReason: The failure reason.
       |   59|
       |   60|        - returns: An `NSError` with the given error code and failure reason.
       |   61|    */
      0|   62|    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
      0|   63|        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
      0|   64|        return NSError(domain: Domain, code: code, userInfo: userInfo)
      0|   65|    }
       |   66|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Manager.swift:
       |    1|// Manager.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
       |   27|*/
       |   28|public class Manager {
       |   29|
       |   30|    // MARK: - Properties
       |   31|
       |   32|    /**
       |   33|        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
       |   34|        for any ad hoc requests.
       |   35|    */
       |   36|    public static let sharedInstance: Manager = {
       |   37|        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
       |   38|        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
       |   39|
       |   40|        return Manager(configuration: configuration)
       |   41|    }()
       |   42|
       |   43|    /**
       |   44|        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
       |   45|    */
       |   46|    public static let defaultHTTPHeaders: [String: String] = {
       |   47|        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
       |   48|        let acceptEncoding: String = "gzip;q=1.0,compress;q=0.5"
       |   49|
       |   50|        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
       |   51|        let acceptLanguage: String = {
       |   52|            var components: [String] = []
       |   53|            for (index, languageCode) in (NSLocale.preferredLanguages() as [String]).enumerate() {
       |   54|                let q = 1.0 - (Double(index) * 0.1)
       |   55|                components.append("\(languageCode);q=\(q)")
       |   56|                if q <= 0.5 {
       |   57|                    break
       |   58|                }
       |   59|            }
       |   60|
       |   61|            return components.joinWithSeparator(",")
       |   62|        }()
       |   63|
       |   64|        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
       |   65|        let userAgent: String = {
       |   66|            if let info = NSBundle.mainBundle().infoDictionary {
       |   67|                let executable: AnyObject = info[kCFBundleExecutableKey as String] ?? "Unknown"
       |   68|                let bundle: AnyObject = info[kCFBundleIdentifierKey as String] ?? "Unknown"
       |   69|                let version: AnyObject = info[kCFBundleVersionKey as String] ?? "Unknown"
       |   70|                let os: AnyObject = NSProcessInfo.processInfo().operatingSystemVersionString ?? "Unknown"
       |   71|
       |   72|                var mutableUserAgent = NSMutableString(string: "\(executable)/\(bundle) (\(version); OS \(os))") as CFMutableString
       |   73|                let transform = NSString(string: "Any-Latin; Latin-ASCII; [:^ASCII:] Remove") as CFString
       |   74|
       |   75|                if CFStringTransform(mutableUserAgent, UnsafeMutablePointer<CFRange>(nil), transform, false) {
       |   76|                    return mutableUserAgent as String
       |   77|                }
       |   78|            }
       |   79|
       |   80|            return "Alamofire"
       |   81|        }()
       |   82|
       |   83|        return [
       |   84|            "Accept-Encoding": acceptEncoding,
       |   85|            "Accept-Language": acceptLanguage,
       |   86|            "User-Agent": userAgent
       |   87|        ]
       |   88|    }()
       |   89|
       |   90|    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
       |   91|
       |   92|    /// The underlying session.
       |   93|    public let session: NSURLSession
       |   94|
       |   95|    /// The session delegate handling all the task and session delegate callbacks.
       |   96|    public let delegate: SessionDelegate
       |   97|
       |   98|    /// Whether to start requests immediately after being constructed. `true` by default.
       |   99|    public var startRequestsImmediately: Bool = true
       |  100|
       |  101|    /**
       |  102|        The background completion handler closure provided by the UIApplicationDelegate 
       |  103|        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
       |  104|        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
       |  105|        will automatically call the handler.
       |  106|    
       |  107|        If you need to handle your own events before the handler is called, then you need to override the 
       |  108|        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
       |  109|    
       |  110|        `nil` by default.
       |  111|    */
       |  112|    public var backgroundCompletionHandler: (() -> Void)?
       |  113|
       |  114|    // MARK: - Lifecycle
       |  115|
       |  116|    /**
       |  117|        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
       |  118|
       |  119|        - parameter configuration:            The configuration used to construct the managed session. 
       |  120|                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
       |  121|        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
       |  122|                                              default.
       |  123|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
       |  124|                                              challenges. `nil` by default.
       |  125|
       |  126|        - returns: The new `Manager` instance.
       |  127|    */
       |  128|    public init(
       |  129|        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
       |  130|        delegate: SessionDelegate = SessionDelegate(),
       |  131|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      1|  132|    {
      1|  133|        self.delegate = delegate
      1|  134|        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
      1|  135|
      1|  136|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      1|  137|    }
       |  138|
       |  139|    /**
       |  140|        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
       |  141|
       |  142|        - parameter session:                  The URL session.
       |  143|        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
       |  144|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
       |  145|                                              challenges. `nil` by default.
       |  146|
       |  147|        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
       |  148|    */
       |  149|    public init?(
       |  150|        session: NSURLSession,
       |  151|        delegate: SessionDelegate,
       |  152|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      0|  153|    {
      0|  154|        self.delegate = delegate
      0|  155|        self.session = session
      0|  156|
      0|  157|        guard delegate === session.delegate else { return nil }
      0|  158|
      0|  159|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      0|  160|    }
       |  161|
      1|  162|    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
      1|  163|        session.serverTrustPolicyManager = serverTrustPolicyManager
      1|  164|
      0|  165|        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
      0|  166|            guard let strongSelf = self else { return }
      0|  167|            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
      0|  168|        }
      1|  169|    }
       |  170|
      0|  171|    deinit {
      0|  172|        session.invalidateAndCancel()
      0|  173|    }
       |  174|
       |  175|    // MARK: - Request
       |  176|
       |  177|    /**
       |  178|        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
       |  179|
       |  180|        - parameter method:     The HTTP method.
       |  181|        - parameter URLString:  The URL string.
       |  182|        - parameter parameters: The parameters. `nil` by default.
       |  183|        - parameter encoding:   The parameter encoding. `.URL` by default.
       |  184|        - parameter headers:    The HTTP headers. `nil` by default.
       |  185|
       |  186|        - returns: The created request.
       |  187|    */
       |  188|    public func request(
       |  189|        method: Method,
       |  190|        _ URLString: URLStringConvertible,
       |  191|        parameters: [String: AnyObject]? = nil,
       |  192|        encoding: ParameterEncoding = .URL,
       |  193|        headers: [String: String]? = nil)
       |  194|        -> Request
      1|  195|    {
      1|  196|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      1|  197|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      1|  198|        return request(encodedURLRequest)
      1|  199|    }
       |  200|
       |  201|    /**
       |  202|        Creates a request for the specified URL request.
       |  203|
       |  204|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  205|
       |  206|        - parameter URLRequest: The URL request
       |  207|
       |  208|        - returns: The created request.
       |  209|    */
      1|  210|    public func request(URLRequest: URLRequestConvertible) -> Request {
      1|  211|        var dataTask: NSURLSessionDataTask!
      1|  212|        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
      1|  213|
      1|  214|        let request = Request(session: session, task: dataTask)
      1|  215|        delegate[request.delegate.task] = request.delegate
      1|  216|
      1|  217|        if startRequestsImmediately {
      1|  218|            request.resume()
      1|  219|        }
      1|  220|
      1|  221|        return request
      1|  222|    }
       |  223|
       |  224|    // MARK: - SessionDelegate
       |  225|
       |  226|    /**
       |  227|        Responsible for handling all delegate callbacks for the underlying session.
       |  228|    */
       |  229|    public final class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
       |  230|        private var subdelegates: [Int: Request.TaskDelegate] = [:]
       |  231|        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
       |  232|
       |  233|        subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
      4|  234|            get {
      4|  235|                var subdelegate: Request.TaskDelegate?
      4|  236|                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
      4|  237|
      4|  238|                return subdelegate
      4|  239|            }
       |  240|
      2|  241|            set {
      2|  242|                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
      2|  243|            }
       |  244|        }
       |  245|
       |  246|        /**
       |  247|            Initializes the `SessionDelegate` instance.
       |  248|
       |  249|            - returns: The new `SessionDelegate` instance.
       |  250|        */
      1|  251|        public override init() {
      1|  252|            super.init()
      1|  253|        }
       |  254|
       |  255|        // MARK: - NSURLSessionDelegate
       |  256|
       |  257|        // MARK: Override Closures
       |  258|
       |  259|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
       |  260|        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
       |  261|
       |  262|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
       |  263|        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  264|
       |  265|        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
       |  266|        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
       |  267|
       |  268|        // MARK: Delegate Methods
       |  269|
       |  270|        /**
       |  271|            Tells the delegate that the session has been invalidated.
       |  272|
       |  273|            - parameter session: The session object that was invalidated.
       |  274|            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
       |  275|        */
      0|  276|        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
      0|  277|            sessionDidBecomeInvalidWithError?(session, error)
      0|  278|        }
       |  279|
       |  280|        /**
       |  281|            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
       |  282|
       |  283|            - parameter session:           The session containing the task that requested authentication.
       |  284|            - parameter challenge:         An object that contains the request for authentication.
       |  285|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  286|        */
       |  287|        public func URLSession(
       |  288|            session: NSURLSession,
       |  289|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  290|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      0|  291|        {
      0|  292|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      0|  293|            var credential: NSURLCredential?
      0|  294|
      0|  295|            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
      0|  296|                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
      0|  297|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      0|  298|                let host = challenge.protectionSpace.host
      0|  299|
      0|  300|                if let
      0|  301|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      0|  302|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  303|                {
      0|  304|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  305|                        disposition = .UseCredential
      0|  306|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  307|                    } else {
      0|  308|                        disposition = .CancelAuthenticationChallenge
      0|  309|                    }
      0|  310|                }
      0|  311|            }
      0|  312|
      0|  313|            completionHandler(disposition, credential)
      0|  314|        }
       |  315|
       |  316|        /**
       |  317|            Tells the delegate that all messages enqueued for a session have been delivered.
       |  318|
       |  319|            - parameter session: The session that no longer has any outstanding requests.
       |  320|        */
      0|  321|        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
      0|  322|            sessionDidFinishEventsForBackgroundURLSession?(session)
      0|  323|        }
       |  324|
       |  325|        // MARK: - NSURLSessionTaskDelegate
       |  326|
       |  327|        // MARK: Override Closures
       |  328|
       |  329|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
       |  330|        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  331|
       |  332|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
       |  333|        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  334|
       |  335|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
       |  336|        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream!)?
       |  337|
       |  338|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
       |  339|        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  340|
       |  341|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
       |  342|        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  343|
       |  344|        // MARK: Delegate Methods
       |  345|
       |  346|        /**
       |  347|            Tells the delegate that the remote server requested an HTTP redirect.
       |  348|
       |  349|            - parameter session:           The session containing the task whose request resulted in a redirect.
       |  350|            - parameter task:              The task whose request resulted in a redirect.
       |  351|            - parameter response:          An object containing the server’s response to the original request.
       |  352|            - parameter request:           A URL request object filled out with the new location.
       |  353|            - parameter completionHandler: A closure that your handler should call with either the value of the request 
       |  354|                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
       |  355|                                           return the body of the redirect response.
       |  356|        */
       |  357|        public func URLSession(
       |  358|            session: NSURLSession,
       |  359|            task: NSURLSessionTask,
       |  360|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  361|            newRequest request: NSURLRequest,
       |  362|            completionHandler: ((NSURLRequest?) -> Void))
      0|  363|        {
      0|  364|            var redirectRequest: NSURLRequest? = request
      0|  365|
      0|  366|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  367|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  368|            }
      0|  369|
      0|  370|            completionHandler(redirectRequest)
      0|  371|        }
       |  372|
       |  373|        /**
       |  374|            Requests credentials from the delegate in response to an authentication request from the remote server.
       |  375|
       |  376|            - parameter session:           The session containing the task whose request requires authentication.
       |  377|            - parameter task:              The task whose request requires authentication.
       |  378|            - parameter challenge:         An object that contains the request for authentication.
       |  379|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  380|        */
       |  381|        public func URLSession(
       |  382|            session: NSURLSession,
       |  383|            task: NSURLSessionTask,
       |  384|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  385|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  386|        {
      0|  387|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  388|                completionHandler(taskDidReceiveChallenge(session, task, challenge))
      1|  389|            } else if let delegate = self[task] {
      1|  390|                delegate.URLSession(
      1|  391|                    session,
      1|  392|                    task: task,
      1|  393|                    didReceiveChallenge: challenge,
      1|  394|                    completionHandler: completionHandler
      1|  395|                )
      0|  396|            } else {
      0|  397|                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
      0|  398|            }
      1|  399|        }
       |  400|
       |  401|        /**
       |  402|            Tells the delegate when a task requires a new request body stream to send to the remote server.
       |  403|
       |  404|            - parameter session:           The session containing the task that needs a new body stream.
       |  405|            - parameter task:              The task that needs a new body stream.
       |  406|            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
       |  407|        */
       |  408|        public func URLSession(
       |  409|            session: NSURLSession,
       |  410|            task: NSURLSessionTask,
       |  411|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  412|        {
      0|  413|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  414|                completionHandler(taskNeedNewBodyStream(session, task))
      0|  415|            } else if let delegate = self[task] {
      0|  416|                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
      0|  417|            }
      0|  418|        }
       |  419|
       |  420|        /**
       |  421|            Periodically informs the delegate of the progress of sending body content to the server.
       |  422|
       |  423|            - parameter session:                  The session containing the data task.
       |  424|            - parameter task:                     The data task.
       |  425|            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
       |  426|            - parameter totalBytesSent:           The total number of bytes sent so far.
       |  427|            - parameter totalBytesExpectedToSend: The expected length of the body data.
       |  428|        */
       |  429|        public func URLSession(
       |  430|            session: NSURLSession,
       |  431|            task: NSURLSessionTask,
       |  432|            didSendBodyData bytesSent: Int64,
       |  433|            totalBytesSent: Int64,
       |  434|            totalBytesExpectedToSend: Int64)
      1|  435|        {
      0|  436|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  437|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  438|            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
      0|  439|                delegate.URLSession(
      0|  440|                    session,
      0|  441|                    task: task,
      0|  442|                    didSendBodyData: bytesSent,
      0|  443|                    totalBytesSent: totalBytesSent,
      0|  444|                    totalBytesExpectedToSend: totalBytesExpectedToSend
      0|  445|                )
      0|  446|            }
      1|  447|        }
       |  448|
       |  449|        /**
       |  450|            Tells the delegate that the task finished transferring data.
       |  451|
       |  452|            - parameter session: The session containing the task whose request finished transferring data.
       |  453|            - parameter task:    The task whose request finished transferring data.
       |  454|            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
       |  455|        */
      1|  456|        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  457|            if let taskDidComplete = taskDidComplete {
      0|  458|                taskDidComplete(session, task, error)
      1|  459|            } else if let delegate = self[task] {
      1|  460|                delegate.URLSession(session, task: task, didCompleteWithError: error)
      1|  461|            }
      1|  462|
      1|  463|            self[task] = nil
      1|  464|        }
       |  465|
       |  466|        // MARK: - NSURLSessionDataDelegate
       |  467|
       |  468|        // MARK: Override Closures
       |  469|
       |  470|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
       |  471|        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  472|
       |  473|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
       |  474|        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  475|
       |  476|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
       |  477|        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  478|
       |  479|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
       |  480|        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse!)?
       |  481|
       |  482|        // MARK: Delegate Methods
       |  483|
       |  484|        /**
       |  485|            Tells the delegate that the data task received the initial reply (headers) from the server.
       |  486|
       |  487|            - parameter session:           The session containing the data task that received an initial reply.
       |  488|            - parameter dataTask:          The data task that received an initial reply.
       |  489|            - parameter response:          A URL response object populated with headers.
       |  490|            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
       |  491|                                           constant to indicate whether the transfer should continue as a data task or 
       |  492|                                           should become a download task.
       |  493|        */
       |  494|        public func URLSession(
       |  495|            session: NSURLSession,
       |  496|            dataTask: NSURLSessionDataTask,
       |  497|            didReceiveResponse response: NSURLResponse,
       |  498|            completionHandler: ((NSURLSessionResponseDisposition) -> Void))
      0|  499|        {
      0|  500|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  501|
      0|  502|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  503|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  504|            }
      0|  505|
      0|  506|            completionHandler(disposition)
      0|  507|        }
       |  508|
       |  509|        /**
       |  510|            Tells the delegate that the data task was changed to a download task.
       |  511|
       |  512|            - parameter session:      The session containing the task that was replaced by a download task.
       |  513|            - parameter dataTask:     The data task that was replaced by a download task.
       |  514|            - parameter downloadTask: The new download task that replaced the data task.
       |  515|        */
       |  516|        public func URLSession(
       |  517|            session: NSURLSession,
       |  518|            dataTask: NSURLSessionDataTask,
       |  519|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  520|        {
      0|  521|            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
      0|  522|                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
      0|  523|            } else {
      0|  524|                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
      0|  525|                self[downloadTask] = downloadDelegate
      0|  526|            }
      0|  527|        }
       |  528|
       |  529|        /**
       |  530|            Tells the delegate that the data task has received some of the expected data.
       |  531|
       |  532|            - parameter session:  The session containing the data task that provided data.
       |  533|            - parameter dataTask: The data task that provided data.
       |  534|            - parameter data:     A data object containing the transferred data.
       |  535|        */
      1|  536|        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  537|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  538|                dataTaskDidReceiveData(session, dataTask, data)
      1|  539|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      1|  540|                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
      1|  541|            }
      1|  542|        }
       |  543|
       |  544|        /**
       |  545|            Asks the delegate whether the data (or upload) task should store the response in the cache.
       |  546|
       |  547|            - parameter session:           The session containing the data (or upload) task.
       |  548|            - parameter dataTask:          The data (or upload) task.
       |  549|            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
       |  550|                                           caching policy and the values of certain received headers, such as the Pragma 
       |  551|                                           and Cache-Control headers.
       |  552|            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
       |  553|                                           response, a modified version of that response, or NULL to prevent caching the 
       |  554|                                           response. If your delegate implements this method, it must call this completion 
       |  555|                                           handler; otherwise, your app leaks memory.
       |  556|        */
       |  557|        public func URLSession(
       |  558|            session: NSURLSession,
       |  559|            dataTask: NSURLSessionDataTask,
       |  560|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  561|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  562|        {
      0|  563|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  564|                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
      0|  565|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      0|  566|                delegate.URLSession(
      0|  567|                    session,
      0|  568|                    dataTask: dataTask,
      0|  569|                    willCacheResponse: proposedResponse,
      0|  570|                    completionHandler: completionHandler
      0|  571|                )
      0|  572|            } else {
      0|  573|                completionHandler(proposedResponse)
      0|  574|            }
      0|  575|        }
       |  576|
       |  577|        // MARK: - NSURLSessionDownloadDelegate
       |  578|
       |  579|        // MARK: Override Closures
       |  580|
       |  581|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
       |  582|        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
       |  583|
       |  584|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
       |  585|        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  586|
       |  587|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
       |  588|        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  589|
       |  590|        // MARK: Delegate Methods
       |  591|
       |  592|        /**
       |  593|            Tells the delegate that a download task has finished downloading.
       |  594|
       |  595|            - parameter session:      The session containing the download task that finished.
       |  596|            - parameter downloadTask: The download task that finished.
       |  597|            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
       |  598|                                      open the file for reading or move it to a permanent location in your app’s sandbox 
       |  599|                                      container directory before returning from this delegate method.
       |  600|        */
       |  601|        public func URLSession(
       |  602|            session: NSURLSession,
       |  603|            downloadTask: NSURLSessionDownloadTask,
       |  604|            didFinishDownloadingToURL location: NSURL)
      0|  605|        {
      0|  606|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  607|                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  608|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  609|                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
      0|  610|            }
      0|  611|        }
       |  612|
       |  613|        /**
       |  614|            Periodically informs the delegate about the download’s progress.
       |  615|
       |  616|            - parameter session:                   The session containing the download task.
       |  617|            - parameter downloadTask:              The download task.
       |  618|            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
       |  619|                                                   method was called.
       |  620|            - parameter totalBytesWritten:         The total number of bytes transferred so far.
       |  621|            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
       |  622|                                                   header. If this header was not provided, the value is 
       |  623|                                                   `NSURLSessionTransferSizeUnknown`.
       |  624|        */
       |  625|        public func URLSession(
       |  626|            session: NSURLSession,
       |  627|            downloadTask: NSURLSessionDownloadTask,
       |  628|            didWriteData bytesWritten: Int64,
       |  629|            totalBytesWritten: Int64,
       |  630|            totalBytesExpectedToWrite: Int64)
      0|  631|        {
      0|  632|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  633|                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  634|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  635|                delegate.URLSession(
      0|  636|                    session,
      0|  637|                    downloadTask: downloadTask,
      0|  638|                    didWriteData: bytesWritten,
      0|  639|                    totalBytesWritten: totalBytesWritten,
      0|  640|                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
      0|  641|                )
      0|  642|            }
      0|  643|        }
       |  644|
       |  645|        /**
       |  646|            Tells the delegate that the download task has resumed downloading.
       |  647|
       |  648|            - parameter session:            The session containing the download task that finished.
       |  649|            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
       |  650|            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
       |  651|                                            existing content, then this value is zero. Otherwise, this value is an 
       |  652|                                            integer representing the number of bytes on disk that do not need to be 
       |  653|                                            retrieved again.
       |  654|            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
       |  655|                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
       |  656|        */
       |  657|        public func URLSession(
       |  658|            session: NSURLSession,
       |  659|            downloadTask: NSURLSessionDownloadTask,
       |  660|            didResumeAtOffset fileOffset: Int64,
       |  661|            expectedTotalBytes: Int64)
      0|  662|        {
      0|  663|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  664|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  665|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  666|                delegate.URLSession(
      0|  667|                    session,
      0|  668|                    downloadTask: downloadTask,
      0|  669|                    didResumeAtOffset: fileOffset,
      0|  670|                    expectedTotalBytes: expectedTotalBytes
      0|  671|                )
      0|  672|            }
      0|  673|        }
       |  674|
       |  675|        // MARK: - NSURLSessionStreamDelegate
       |  676|
       |  677|        var _streamTaskReadClosed: Any?
       |  678|        var _streamTaskWriteClosed: Any?
       |  679|        var _streamTaskBetterRouteDiscovered: Any?
       |  680|        var _streamTaskDidBecomeInputStream: Any?
       |  681|
       |  682|        // MARK: - NSObject
       |  683|
     11|  684|        public override func respondsToSelector(selector: Selector) -> Bool {
     11|  685|            switch selector {
      0|  686|            case "URLSession:didBecomeInvalidWithError:":
      0|  687|                return sessionDidBecomeInvalidWithError != nil
      1|  688|            case "URLSession:didReceiveChallenge:completionHandler:":
      1|  689|                return sessionDidReceiveChallenge != nil
      0|  690|            case "URLSessionDidFinishEventsForBackgroundURLSession:":
      0|  691|                return sessionDidFinishEventsForBackgroundURLSession != nil
      0|  692|            case "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:":
      0|  693|                return taskWillPerformHTTPRedirection != nil
      1|  694|            case "URLSession:dataTask:didReceiveResponse:completionHandler:":
      1|  695|                return dataTaskDidReceiveResponse != nil
      9|  696|            default:
      9|  697|                return self.dynamicType.instancesRespondToSelector(selector)
     11|  698|            }
     11|  699|        }
       |  700|    }
       |  701|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/MultipartFormData.swift:
       |    1|// MultipartFormData.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if os(iOS) || os(watchOS) || os(tvOS)
       |   26|import MobileCoreServices
       |   27|#elseif os(OSX)
       |   28|import CoreServices
       |   29|#endif
       |   30|
       |   31|/**
       |   32|    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
       |   33|    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
       |   34|    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
       |   35|    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
       |   36|    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
       |   37|
       |   38|    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
       |   39|    and the w3 form documentation.
       |   40|
       |   41|    - https://www.ietf.org/rfc/rfc2388.txt
       |   42|    - https://www.ietf.org/rfc/rfc2045.txt
       |   43|    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
       |   44|*/
       |   45|public class MultipartFormData {
       |   46|
       |   47|    // MARK: - Helper Types
       |   48|
       |   49|    struct EncodingCharacters {
       |   50|        static let CRLF = "\r\n"
       |   51|    }
       |   52|
       |   53|    struct BoundaryGenerator {
       |   54|        enum BoundaryType {
       |   55|            case Initial, Encapsulated, Final
       |   56|        }
       |   57|
      0|   58|        static func randomBoundary() -> String {
      0|   59|            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
      0|   60|        }
       |   61|
      0|   62|        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
      0|   63|            let boundaryText: String
      0|   64|
      0|   65|            switch boundaryType {
      0|   66|            case .Initial:
      0|   67|                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
      0|   68|            case .Encapsulated:
      0|   69|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
      0|   70|            case .Final:
      0|   71|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
      0|   72|            }
      0|   73|
      0|   74|            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|   75|        }
       |   76|    }
       |   77|
       |   78|    class BodyPart {
       |   79|        let headers: [String: String]
       |   80|        let bodyStream: NSInputStream
       |   81|        let bodyContentLength: UInt64
       |   82|        var hasInitialBoundary = false
       |   83|        var hasFinalBoundary = false
       |   84|
      0|   85|        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
      0|   86|            self.headers = headers
      0|   87|            self.bodyStream = bodyStream
      0|   88|            self.bodyContentLength = bodyContentLength
      0|   89|        }
       |   90|    }
       |   91|
       |   92|    // MARK: - Properties
       |   93|
       |   94|    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
      0|   95|    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
       |   96|
       |   97|    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
      0|   98|    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
       |   99|
       |  100|    /// The boundary used to separate the body parts in the encoded form data.
       |  101|    public let boundary: String
       |  102|
       |  103|    private var bodyParts: [BodyPart]
       |  104|    private var bodyPartError: NSError?
       |  105|    private let streamBufferSize: Int
       |  106|
       |  107|    // MARK: - Lifecycle
       |  108|
       |  109|    /**
       |  110|        Creates a multipart form data object.
       |  111|
       |  112|        - returns: The multipart form data object.
       |  113|    */
      0|  114|    public init() {
      0|  115|        self.boundary = BoundaryGenerator.randomBoundary()
      0|  116|        self.bodyParts = []
      0|  117|
      0|  118|        /**
      0|  119|         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
      0|  120|         *  information, please refer to the following article:
      0|  121|         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
      0|  122|         */
      0|  123|
      0|  124|        self.streamBufferSize = 1024
      0|  125|    }
       |  126|
       |  127|    // MARK: - Body Parts
       |  128|
       |  129|    /**
       |  130|        Creates a body part from the data and appends it to the multipart form data object.
       |  131|
       |  132|        The body part data will be encoded using the following format:
       |  133|
       |  134|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  135|        - Encoded data
       |  136|        - Multipart form boundary
       |  137|
       |  138|        - parameter data: The data to encode into the multipart form data.
       |  139|        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
       |  140|    */
      0|  141|    public func appendBodyPart(data data: NSData, name: String) {
      0|  142|        let headers = contentHeaders(name: name)
      0|  143|        let stream = NSInputStream(data: data)
      0|  144|        let length = UInt64(data.length)
      0|  145|
      0|  146|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  147|    }
       |  148|
       |  149|    /**
       |  150|        Creates a body part from the data and appends it to the multipart form data object.
       |  151|
       |  152|        The body part data will be encoded using the following format:
       |  153|
       |  154|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  155|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  156|        - Encoded data
       |  157|        - Multipart form boundary
       |  158|
       |  159|        - parameter data:     The data to encode into the multipart form data.
       |  160|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  161|        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
       |  162|    */
      0|  163|    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
      0|  164|        let headers = contentHeaders(name: name, mimeType: mimeType)
      0|  165|        let stream = NSInputStream(data: data)
      0|  166|        let length = UInt64(data.length)
      0|  167|
      0|  168|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  169|    }
       |  170|
       |  171|    /**
       |  172|        Creates a body part from the data and appends it to the multipart form data object.
       |  173|
       |  174|        The body part data will be encoded using the following format:
       |  175|
       |  176|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  177|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  178|        - Encoded file data
       |  179|        - Multipart form boundary
       |  180|
       |  181|        - parameter data:     The data to encode into the multipart form data.
       |  182|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  183|        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
       |  184|        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
       |  185|    */
      0|  186|    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
      0|  187|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  188|        let stream = NSInputStream(data: data)
      0|  189|        let length = UInt64(data.length)
      0|  190|
      0|  191|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Creates a body part from the file and appends it to the multipart form data object.
       |  196|
       |  197|        The body part data will be encoded using the following format:
       |  198|
       |  199|        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
       |  200|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  201|        - Encoded file data
       |  202|        - Multipart form boundary
       |  203|
       |  204|        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
       |  205|        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
       |  206|        system associated MIME type.
       |  207|
       |  208|        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
       |  209|        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  210|    */
      0|  211|    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
      0|  212|        if let
      0|  213|            fileName = fileURL.lastPathComponent,
      0|  214|            pathExtension = fileURL.pathExtension
      0|  215|        {
      0|  216|            let mimeType = mimeTypeForPathExtension(pathExtension)
      0|  217|            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
      0|  218|        } else {
      0|  219|            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
      0|  220|            setBodyPartError(Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason))
      0|  221|        }
      0|  222|    }
       |  223|
       |  224|    /**
       |  225|        Creates a body part from the file and appends it to the multipart form data object.
       |  226|
       |  227|        The body part data will be encoded using the following format:
       |  228|
       |  229|        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
       |  230|        - Content-Type: #{mimeType} (HTTP Header)
       |  231|        - Encoded file data
       |  232|        - Multipart form boundary
       |  233|
       |  234|        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
       |  235|        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  236|        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
       |  237|        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
       |  238|    */
      0|  239|    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
      0|  240|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  241|
      0|  242|        //============================================================
      0|  243|        //                 Check 1 - is file URL?
      0|  244|        //============================================================
      0|  245|
      0|  246|        guard fileURL.fileURL else {
      0|  247|            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
      0|  248|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  249|            setBodyPartError(error)
      0|  250|            return
      0|  251|        }
      0|  252|
      0|  253|        //============================================================
      0|  254|        //              Check 2 - is file URL reachable?
      0|  255|        //============================================================
      0|  256|
      0|  257|        var isReachable = true
      0|  258|
      0|  259|        if #available(OSX 10.10, *) {
      0|  260|            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
      0|  261|        }
      0|  262|
      0|  263|        guard isReachable else {
      0|  264|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
      0|  265|            setBodyPartError(error)
      0|  266|            return
      0|  267|        }
      0|  268|
      0|  269|        //============================================================
      0|  270|        //            Check 3 - is file URL a directory?
      0|  271|        //============================================================
      0|  272|
      0|  273|        var isDirectory: ObjCBool = false
      0|  274|
      0|  275|        guard let
      0|  276|            path = fileURL.path
      0|  277|            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
      0|  278|        {
      0|  279|            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
      0|  280|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  281|            setBodyPartError(error)
      0|  282|            return
      0|  283|        }
      0|  284|
      0|  285|        //============================================================
      0|  286|        //          Check 4 - can the file size be extracted?
      0|  287|        //============================================================
      0|  288|
      0|  289|        var bodyContentLength: UInt64?
      0|  290|
      0|  291|        do {
      0|  292|            if let
      0|  293|                path = fileURL.path,
      0|  294|                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
      0|  295|            {
      0|  296|                bodyContentLength = fileSize.unsignedLongLongValue
      0|  297|            }
      0|  298|        } catch {
      0|  299|            // No-op
      0|  300|        }
      0|  301|
      0|  302|        guard let length = bodyContentLength else {
      0|  303|            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
      0|  304|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  305|            setBodyPartError(error)
      0|  306|            return
      0|  307|        }
      0|  308|
      0|  309|        //============================================================
      0|  310|        //       Check 5 - can a stream be created from file URL?
      0|  311|        //============================================================
      0|  312|
      0|  313|        guard let stream = NSInputStream(URL: fileURL) else {
      0|  314|            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
      0|  315|            let error = Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  316|            setBodyPartError(error)
      0|  317|            return
      0|  318|        }
      0|  319|
      0|  320|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  321|    }
       |  322|
       |  323|    /**
       |  324|        Creates a body part from the stream and appends it to the multipart form data object.
       |  325|
       |  326|        The body part data will be encoded using the following format:
       |  327|
       |  328|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  329|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  330|        - Encoded stream data
       |  331|        - Multipart form boundary
       |  332|
       |  333|        - parameter stream:   The input stream to encode in the multipart form data.
       |  334|        - parameter length:   The content length of the stream.
       |  335|        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
       |  336|        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
       |  337|        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
       |  338|    */
       |  339|    public func appendBodyPart(
       |  340|        stream stream: NSInputStream,
       |  341|        length: UInt64,
       |  342|        name: String,
       |  343|        fileName: String,
       |  344|        mimeType: String)
      0|  345|    {
      0|  346|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  347|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  348|    }
       |  349|
       |  350|    /**
       |  351|        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
       |  352|
       |  353|        The body part data will be encoded using the following format:
       |  354|
       |  355|        - HTTP headers
       |  356|        - Encoded stream data
       |  357|        - Multipart form boundary
       |  358|
       |  359|        - parameter stream:  The input stream to encode in the multipart form data.
       |  360|        - parameter length:  The content length of the stream.
       |  361|        - parameter headers: The HTTP headers for the body part.
       |  362|    */
      0|  363|    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
      0|  364|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
      0|  365|        bodyParts.append(bodyPart)
      0|  366|    }
       |  367|
       |  368|    // MARK: - Data Encoding
       |  369|
       |  370|    /**
       |  371|        Encodes all the appended body parts into a single `NSData` object.
       |  372|
       |  373|        It is important to note that this method will load all the appended body parts into memory all at the same 
       |  374|        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
       |  375|        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
       |  376|
       |  377|        - throws: An `NSError` if encoding encounters an error.
       |  378|
       |  379|        - returns: The encoded `NSData` if encoding is successful.
       |  380|    */
      0|  381|    public func encode() throws -> NSData {
      0|  382|        if let bodyPartError = bodyPartError {
      0|  383|            throw bodyPartError
      0|  384|        }
      0|  385|
      0|  386|        let encoded = NSMutableData()
      0|  387|
      0|  388|        bodyParts.first?.hasInitialBoundary = true
      0|  389|        bodyParts.last?.hasFinalBoundary = true
      0|  390|
      0|  391|        for bodyPart in bodyParts {
      0|  392|            let encodedData = try encodeBodyPart(bodyPart)
      0|  393|            encoded.appendData(encodedData)
      0|  394|        }
      0|  395|
      0|  396|        return encoded
      0|  397|    }
       |  398|
       |  399|    /**
       |  400|        Writes the appended body parts into the given file URL.
       |  401|
       |  402|        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
       |  403|        this approach is very memory efficient and should be used for large body part data.
       |  404|
       |  405|        - parameter fileURL: The file URL to write the multipart form data into.
       |  406|
       |  407|        - throws: An `NSError` if encoding encounters an error.
       |  408|    */
      0|  409|    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
      0|  410|        if let bodyPartError = bodyPartError {
      0|  411|            throw bodyPartError
      0|  412|        }
      0|  413|
      0|  414|        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
      0|  415|            let failureReason = "A file already exists at the given file URL: \(fileURL)"
      0|  416|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  417|        } else if !fileURL.fileURL {
      0|  418|            let failureReason = "The URL does not point to a valid file: \(fileURL)"
      0|  419|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  420|        }
      0|  421|
      0|  422|        let outputStream: NSOutputStream
      0|  423|
      0|  424|        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
      0|  425|            outputStream = possibleOutputStream
      0|  426|        } else {
      0|  427|            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
      0|  428|            throw Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  429|        }
      0|  430|
      0|  431|        outputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  432|        outputStream.open()
      0|  433|
      0|  434|        self.bodyParts.first?.hasInitialBoundary = true
      0|  435|        self.bodyParts.last?.hasFinalBoundary = true
      0|  436|
      0|  437|        for bodyPart in self.bodyParts {
      0|  438|            try writeBodyPart(bodyPart, toOutputStream: outputStream)
      0|  439|        }
      0|  440|
      0|  441|        outputStream.close()
      0|  442|        outputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  443|    }
       |  444|
       |  445|    // MARK: - Private - Body Part Encoding
       |  446|
      0|  447|    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  448|        let encoded = NSMutableData()
      0|  449|
      0|  450|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  451|        encoded.appendData(initialData)
      0|  452|
      0|  453|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  454|        encoded.appendData(headerData)
      0|  455|
      0|  456|        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
      0|  457|        encoded.appendData(bodyStreamData)
      0|  458|
      0|  459|        if bodyPart.hasFinalBoundary {
      0|  460|            encoded.appendData(finalBoundaryData())
      0|  461|        }
      0|  462|
      0|  463|        return encoded
      0|  464|    }
       |  465|
      0|  466|    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
      0|  467|        var headerText = ""
      0|  468|
      0|  469|        for (key, value) in bodyPart.headers {
      0|  470|            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
      0|  471|        }
      0|  472|        headerText += EncodingCharacters.CRLF
      0|  473|
      0|  474|        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|  475|    }
       |  476|
      0|  477|    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  478|        let inputStream = bodyPart.bodyStream
      0|  479|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  480|        inputStream.open()
      0|  481|
      0|  482|        var error: NSError?
      0|  483|        let encoded = NSMutableData()
      0|  484|
      0|  485|        while inputStream.hasBytesAvailable {
      0|  486|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  487|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  488|
      0|  489|            if inputStream.streamError != nil {
      0|  490|                error = inputStream.streamError
      0|  491|                break
      0|  492|            }
      0|  493|
      0|  494|            if bytesRead > 0 {
      0|  495|                encoded.appendBytes(buffer, length: bytesRead)
      0|  496|            } else if bytesRead < 0 {
      0|  497|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  498|                error = Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  499|                break
      0|  500|            } else {
      0|  501|                break
      0|  502|            }
      0|  503|        }
      0|  504|
      0|  505|        inputStream.close()
      0|  506|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  507|
      0|  508|        if let error = error {
      0|  509|            throw error
      0|  510|        }
      0|  511|
      0|  512|        return encoded
      0|  513|    }
       |  514|
       |  515|    // MARK: - Private - Writing Body Part to Output Stream
       |  516|
      0|  517|    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  518|        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  519|        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  520|        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  521|        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  522|    }
       |  523|
       |  524|    private func writeInitialBoundaryDataForBodyPart(
       |  525|        bodyPart: BodyPart,
       |  526|        toOutputStream outputStream: NSOutputStream)
       |  527|        throws
      0|  528|    {
      0|  529|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  530|        return try writeData(initialData, toOutputStream: outputStream)
      0|  531|    }
       |  532|
      0|  533|    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  534|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  535|        return try writeData(headerData, toOutputStream: outputStream)
      0|  536|    }
       |  537|
      0|  538|    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  539|        let inputStream = bodyPart.bodyStream
      0|  540|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  541|        inputStream.open()
      0|  542|
      0|  543|        while inputStream.hasBytesAvailable {
      0|  544|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  545|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  546|
      0|  547|            if let streamError = inputStream.streamError {
      0|  548|                throw streamError
      0|  549|            }
      0|  550|
      0|  551|            if bytesRead > 0 {
      0|  552|                if buffer.count != bytesRead {
      0|  553|                    buffer = Array(buffer[0..<bytesRead])
      0|  554|                }
      0|  555|
      0|  556|                try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  557|            } else if bytesRead < 0 {
      0|  558|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  559|                throw Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  560|            } else {
      0|  561|                break
      0|  562|            }
      0|  563|        }
      0|  564|
      0|  565|        inputStream.close()
      0|  566|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  567|    }
       |  568|
       |  569|    private func writeFinalBoundaryDataForBodyPart(
       |  570|        bodyPart: BodyPart,
       |  571|        toOutputStream outputStream: NSOutputStream)
       |  572|        throws
      0|  573|    {
      0|  574|        if bodyPart.hasFinalBoundary {
      0|  575|            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
      0|  576|        }
      0|  577|    }
       |  578|
       |  579|    // MARK: - Private - Writing Buffered Data to Output Stream
       |  580|
      0|  581|    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
      0|  582|        var buffer = [UInt8](count: data.length, repeatedValue: 0)
      0|  583|        data.getBytes(&buffer, length: data.length)
      0|  584|
      0|  585|        return try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  586|    }
       |  587|
      0|  588|    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
      0|  589|        var bytesToWrite = buffer.count
      0|  590|
      0|  591|        while bytesToWrite > 0 {
      0|  592|            if outputStream.hasSpaceAvailable {
      0|  593|                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
      0|  594|
      0|  595|                if let streamError = outputStream.streamError {
      0|  596|                    throw streamError
      0|  597|                }
      0|  598|
      0|  599|                if bytesWritten < 0 {
      0|  600|                    let failureReason = "Failed to write to output stream: \(outputStream)"
      0|  601|                    throw Error.errorWithCode(.OutputStreamWriteFailed, failureReason: failureReason)
      0|  602|                }
      0|  603|
      0|  604|                bytesToWrite -= bytesWritten
      0|  605|
      0|  606|                if bytesToWrite > 0 {
      0|  607|                    buffer = Array(buffer[bytesWritten..<buffer.count])
      0|  608|                }
      0|  609|            } else if let streamError = outputStream.streamError {
      0|  610|                throw streamError
      0|  611|            }
      0|  612|        }
      0|  613|    }
       |  614|
       |  615|    // MARK: - Private - Mime Type
       |  616|
      0|  617|    private func mimeTypeForPathExtension(pathExtension: String) -> String {
      0|  618|        if let
      0|  619|            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
      0|  620|            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
      0|  621|        {
      0|  622|            return contentType as String
      0|  623|        }
      0|  624|
      0|  625|        return "application/octet-stream"
      0|  626|    }
       |  627|
       |  628|    // MARK: - Private - Content Headers
       |  629|
      0|  630|    private func contentHeaders(name name: String) -> [String: String] {
      0|  631|        return ["Content-Disposition": "form-data; name=\"\(name)\""]
      0|  632|    }
       |  633|
      0|  634|    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
      0|  635|        return [
      0|  636|            "Content-Disposition": "form-data; name=\"\(name)\"",
      0|  637|            "Content-Type": "\(mimeType)"
      0|  638|        ]
      0|  639|    }
       |  640|
      0|  641|    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
      0|  642|        return [
      0|  643|            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
      0|  644|            "Content-Type": "\(mimeType)"
      0|  645|        ]
      0|  646|    }
       |  647|
       |  648|    // MARK: - Private - Boundary Encoding
       |  649|
      0|  650|    private func initialBoundaryData() -> NSData {
      0|  651|        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
      0|  652|    }
       |  653|
      0|  654|    private func encapsulatedBoundaryData() -> NSData {
      0|  655|        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
      0|  656|    }
       |  657|
      0|  658|    private func finalBoundaryData() -> NSData {
      0|  659|        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
      0|  660|    }
       |  661|
       |  662|    // MARK: - Private - Errors
       |  663|
      0|  664|    private func setBodyPartError(error: NSError) {
      0|  665|        if bodyPartError == nil {
      0|  666|            bodyPartError = error
      0|  667|        }
      0|  668|    }
       |  669|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ParameterEncoding.swift:
       |    1|// ParameterEncoding.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    HTTP method definitions.
       |   27|
       |   28|    See https://tools.ietf.org/html/rfc7231#section-4.3
       |   29|*/
       |   30|public enum Method: String {
       |   31|    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
       |   32|}
       |   33|
       |   34|// MARK: ParameterEncoding
       |   35|
       |   36|/**
       |   37|    Used to specify the way in which a set of parameters are applied to a URL request.
       |   38|
       |   39|    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
       |   40|                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
       |   41|                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
       |   42|                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
       |   43|                         for how to encode collection types, the convention of appending `[]` to the key for array
       |   44|                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
       |   45|                         dictionary values (`foo[bar]=baz`).
       |   46|
       |   47|    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
       |   48|                         implementation as the `.URL` case, but always applies the encoded result to the URL.
       |   49|
       |   50|    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
       |   51|                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
       |   52|                         set to `application/json`.
       |   53|
       |   54|    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
       |   55|                         according to the associated format and write options values, which is set as the body of the
       |   56|                         request. The `Content-Type` HTTP header field of an encoded request is set to
       |   57|                         `application/x-plist`.
       |   58|
       |   59|    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
       |   60|                         parameters.
       |   61|*/
       |   62|public enum ParameterEncoding {
       |   63|    case URL
       |   64|    case URLEncodedInURL
       |   65|    case JSON
       |   66|    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
       |   67|    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
       |   68|
       |   69|    /**
       |   70|        Creates a URL request by encoding parameters and applying them onto an existing request.
       |   71|
       |   72|        - parameter URLRequest: The request to have parameters applied
       |   73|        - parameter parameters: The parameters to apply
       |   74|
       |   75|        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
       |   76|                   if any.
       |   77|    */
       |   78|    public func encode(
       |   79|        URLRequest: URLRequestConvertible,
       |   80|        parameters: [String: AnyObject]?)
       |   81|        -> (NSMutableURLRequest, NSError?)
      1|   82|    {
      1|   83|        var mutableURLRequest = URLRequest.URLRequest
      1|   84|
      0|   85|        guard let parameters = parameters where !parameters.isEmpty else {
      0|   86|            return (mutableURLRequest, nil)
      0|   87|        }
      1|   88|
      1|   89|        var encodingError: NSError? = nil
      1|   90|
      1|   91|        switch self {
      0|   92|        case .URL, .URLEncodedInURL:
      0|   93|            func query(parameters: [String: AnyObject]) -> String {
      0|   94|                var components: [(String, String)] = []
      0|   95|
      0|   96|                for key in parameters.keys.sort(<) {
      0|   97|                    let value = parameters[key]!
      0|   98|                    components += queryComponents(key, value)
      0|   99|                }
      0|  100|
      0|  101|                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
      0|  102|            }
      0|  103|
      0|  104|            func encodesParametersInURL(method: Method) -> Bool {
      0|  105|                switch self {
      0|  106|                case .URLEncodedInURL:
      0|  107|                    return true
      0|  108|                default:
      0|  109|                    break
      0|  110|                }
      0|  111|
      0|  112|                switch method {
      0|  113|                case .GET, .HEAD, .DELETE:
      0|  114|                    return true
      0|  115|                default:
      0|  116|                    return false
      0|  117|                }
      0|  118|            }
      0|  119|
      0|  120|            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
      0|  121|                if let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false) {
      0|  122|                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
      0|  123|                    URLComponents.percentEncodedQuery = percentEncodedQuery
      0|  124|                    mutableURLRequest.URL = URLComponents.URL
      0|  125|                }
      0|  126|            } else {
      0|  127|                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
      0|  128|                    mutableURLRequest.setValue(
      0|  129|                        "application/x-www-form-urlencoded; charset=utf-8",
      0|  130|                        forHTTPHeaderField: "Content-Type"
      0|  131|                    )
      0|  132|                }
      0|  133|
      0|  134|                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
      0|  135|                    NSUTF8StringEncoding,
      0|  136|                    allowLossyConversion: false
      0|  137|                )
      0|  138|            }
      1|  139|        case .JSON:
      1|  140|            do {
      1|  141|                let options = NSJSONWritingOptions()
      1|  142|                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
      1|  143|
      1|  144|                mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
      1|  145|                mutableURLRequest.HTTPBody = data
      0|  146|            } catch {
      0|  147|                encodingError = error as NSError
      0|  148|            }
      0|  149|        case .PropertyList(let format, let options):
      0|  150|            do {
      0|  151|                let data = try NSPropertyListSerialization.dataWithPropertyList(
      0|  152|                    parameters,
      0|  153|                    format: format,
      0|  154|                    options: options
      0|  155|                )
      0|  156|                mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
      0|  157|                mutableURLRequest.HTTPBody = data
      0|  158|            } catch {
      0|  159|                encodingError = error as NSError
      0|  160|            }
      0|  161|        case .Custom(let closure):
      0|  162|            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
      1|  163|        }
      1|  164|
      1|  165|        return (mutableURLRequest, encodingError)
      1|  166|    }
       |  167|
       |  168|    /**
       |  169|        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
       |  170|
       |  171|        - parameter key:   The key of the query component.
       |  172|        - parameter value: The value of the query component.
       |  173|
       |  174|        - returns: The percent-escaped, URL encoded query string components.
       |  175|    */
      0|  176|    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
      0|  177|        var components: [(String, String)] = []
      0|  178|
      0|  179|        if let dictionary = value as? [String: AnyObject] {
      0|  180|            for (nestedKey, value) in dictionary {
      0|  181|                components += queryComponents("\(key)[\(nestedKey)]", value)
      0|  182|            }
      0|  183|        } else if let array = value as? [AnyObject] {
      0|  184|            for value in array {
      0|  185|                components += queryComponents("\(key)[]", value)
      0|  186|            }
      0|  187|        } else {
      0|  188|            components.append((escape(key), escape("\(value)")))
      0|  189|        }
      0|  190|
      0|  191|        return components
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Returns a percent-escaped string following RFC 3986 for a query string key or value.
       |  196|
       |  197|        RFC 3986 states that the following characters are "reserved" characters.
       |  198|
       |  199|        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
       |  200|        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
       |  201|
       |  202|        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
       |  203|        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
       |  204|        should be percent-escaped in the query string.
       |  205|
       |  206|        - parameter string: The string to be percent-escaped.
       |  207|
       |  208|        - returns: The percent-escaped string.
       |  209|    */
      0|  210|    public func escape(string: String) -> String {
      0|  211|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
      0|  212|        let subDelimitersToEncode = "!$&'()*+,;="
      0|  213|
      0|  214|        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
      0|  215|        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
      0|  216|
      0|  217|        var escaped = ""
      0|  218|
      0|  219|        //==========================================================================================================
      0|  220|        //
      0|  221|        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
      0|  222|        //  hundred Chinense characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
      0|  223|        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
      0|  224|        //  info, please refer to:
      0|  225|        //
      0|  226|        //      - https://github.com/Alamofire/Alamofire/issues/206
      0|  227|        //
      0|  228|        //==========================================================================================================
      0|  229|
      0|  230|        if #available(iOS 8.3, OSX 10.10, *) {
      0|  231|            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
      0|  232|        } else {
      0|  233|            let batchSize = 50
      0|  234|            var index = string.startIndex
      0|  235|
      0|  236|            while index != string.endIndex {
      0|  237|                let startIndex = index
      0|  238|                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
      0|  239|                let range = Range(start: startIndex, end: endIndex)
      0|  240|
      0|  241|                let substring = string.substringWithRange(range)
      0|  242|
      0|  243|                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
      0|  244|
      0|  245|                index = endIndex
      0|  246|            }
      0|  247|        }
      0|  248|
      0|  249|        return escaped
      0|  250|    }
       |  251|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Request.swift:
       |    1|// Request.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for sending a request and receiving the response and associated data from the server, as well as 
       |   27|    managing its underlying `NSURLSessionTask`.
       |   28|*/
       |   29|public class Request {
       |   30|
       |   31|    // MARK: - Properties
       |   32|
       |   33|    /// The delegate for the underlying task.
       |   34|    public let delegate: TaskDelegate
       |   35|
       |   36|    /// The underlying task.
      5|   37|    public var task: NSURLSessionTask { return delegate.task }
       |   38|
       |   39|    /// The session belonging to the underlying task.
       |   40|    public let session: NSURLSession
       |   41|
       |   42|    /// The request sent or to be sent to the server.
      2|   43|    public var request: NSURLRequest? { return task.originalRequest }
       |   44|
       |   45|    /// The response received from the server, if any.
      2|   46|    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
       |   47|
       |   48|    /// The progress of the request lifecycle.
      0|   49|    public var progress: NSProgress { return delegate.progress }
       |   50|
       |   51|    // MARK: - Lifecycle
       |   52|
      1|   53|    init(session: NSURLSession, task: NSURLSessionTask) {
      1|   54|        self.session = session
      1|   55|
      1|   56|        switch task {
      0|   57|        case is NSURLSessionUploadTask:
      0|   58|            self.delegate = UploadTaskDelegate(task: task)
      1|   59|        case is NSURLSessionDataTask:
      1|   60|            self.delegate = DataTaskDelegate(task: task)
      0|   61|        case is NSURLSessionDownloadTask:
      0|   62|            self.delegate = DownloadTaskDelegate(task: task)
      0|   63|        default:
      0|   64|            self.delegate = TaskDelegate(task: task)
      1|   65|        }
      1|   66|    }
       |   67|
       |   68|    // MARK: - Authentication
       |   69|
       |   70|    /**
       |   71|        Associates an HTTP Basic credential with the request.
       |   72|
       |   73|        - parameter user:        The user.
       |   74|        - parameter password:    The password.
       |   75|        - parameter persistence: The URL credential persistence. `.ForSession` by default.
       |   76|
       |   77|        - returns: The request.
       |   78|    */
       |   79|    public func authenticate(
       |   80|        user user: String,
       |   81|        password: String,
       |   82|        persistence: NSURLCredentialPersistence = .ForSession)
       |   83|        -> Self
      0|   84|    {
      0|   85|        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
      0|   86|
      0|   87|        return authenticate(usingCredential: credential)
      0|   88|    }
       |   89|
       |   90|    /**
       |   91|        Associates a specified credential with the request.
       |   92|
       |   93|        - parameter credential: The credential.
       |   94|
       |   95|        - returns: The request.
       |   96|    */
      0|   97|    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
      0|   98|        delegate.credential = credential
      0|   99|
      0|  100|        return self
      0|  101|    }
       |  102|
       |  103|    // MARK: - Progress
       |  104|
       |  105|    /**
       |  106|        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
       |  107|        from the server.
       |  108|
       |  109|        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
       |  110|          to write.
       |  111|        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
       |  112|          expected to read.
       |  113|
       |  114|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  115|
       |  116|        - returns: The request.
       |  117|    */
      0|  118|    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
      0|  119|        if let uploadDelegate = delegate as? UploadTaskDelegate {
      0|  120|            uploadDelegate.uploadProgress = closure
      0|  121|        } else if let dataDelegate = delegate as? DataTaskDelegate {
      0|  122|            dataDelegate.dataProgress = closure
      0|  123|        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
      0|  124|            downloadDelegate.downloadProgress = closure
      0|  125|        }
      0|  126|
      0|  127|        return self
      0|  128|    }
       |  129|
       |  130|    /**
       |  131|        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
       |  132|
       |  133|        This closure returns the bytes most recently received from the server, not including data from previous calls. 
       |  134|        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
       |  135|        also important to note that the `response` closure will be called with nil `responseData`.
       |  136|
       |  137|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  138|
       |  139|        - returns: The request.
       |  140|    */
      0|  141|    public func stream(closure: (NSData -> Void)? = nil) -> Self {
      0|  142|        if let dataDelegate = delegate as? DataTaskDelegate {
      0|  143|            dataDelegate.dataStream = closure
      0|  144|        }
      0|  145|
      0|  146|        return self
      0|  147|    }
       |  148|
       |  149|    // MARK: - State
       |  150|
       |  151|    /**
       |  152|        Suspends the request.
       |  153|    */
      0|  154|    public func suspend() {
      0|  155|        task.suspend()
      0|  156|    }
       |  157|
       |  158|    /**
       |  159|        Resumes the request.
       |  160|    */
      1|  161|    public func resume() {
      1|  162|        task.resume()
      1|  163|    }
       |  164|
       |  165|    /**
       |  166|        Cancels the request.
       |  167|    */
      0|  168|    public func cancel() {
      0|  169|        if let
      0|  170|            downloadDelegate = delegate as? DownloadTaskDelegate,
      0|  171|            downloadTask = downloadDelegate.downloadTask
      0|  172|        {
      0|  173|            downloadTask.cancelByProducingResumeData { data in
      0|  174|                downloadDelegate.resumeData = data
      0|  175|            }
      0|  176|        } else {
      0|  177|            task.cancel()
      0|  178|        }
      0|  179|    }
       |  180|
       |  181|    // MARK: - TaskDelegate
       |  182|
       |  183|    /**
       |  184|        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
       |  185|        executing all operations attached to the serial operation queue upon task completion.
       |  186|    */
       |  187|    public class TaskDelegate: NSObject {
       |  188|
       |  189|        /// The serial operation queue used to execute all operations after the task completes.
       |  190|        public let queue: NSOperationQueue
       |  191|
       |  192|        let task: NSURLSessionTask
       |  193|        let progress: NSProgress
       |  194|
      0|  195|        var data: NSData? { return nil }
       |  196|        var error: NSError?
       |  197|
       |  198|        var credential: NSURLCredential?
       |  199|
      1|  200|        init(task: NSURLSessionTask) {
      1|  201|            self.task = task
      1|  202|            self.progress = NSProgress(totalUnitCount: 0)
      1|  203|            self.queue = {
      1|  204|                let operationQueue = NSOperationQueue()
      1|  205|                operationQueue.maxConcurrentOperationCount = 1
      1|  206|                operationQueue.suspended = true
      1|  207|
      1|  208|                if #available(OSX 10.10, *) {
      1|  209|                    operationQueue.qualityOfService = NSQualityOfService.Utility
      1|  210|                }
      1|  211|
      1|  212|                return operationQueue
      1|  213|            }()
      1|  214|        }
       |  215|
      0|  216|        deinit {
      0|  217|            queue.cancelAllOperations()
      0|  218|            queue.suspended = false
      0|  219|        }
       |  220|
       |  221|        // MARK: - NSURLSessionTaskDelegate
       |  222|
       |  223|        // MARK: Override Closures
       |  224|
       |  225|        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  226|        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  227|        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
       |  228|        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  229|
       |  230|        // MARK: Delegate Methods
       |  231|
       |  232|        func URLSession(
       |  233|            session: NSURLSession,
       |  234|            task: NSURLSessionTask,
       |  235|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  236|            newRequest request: NSURLRequest,
       |  237|            completionHandler: ((NSURLRequest?) -> Void))
      0|  238|        {
      0|  239|            var redirectRequest: NSURLRequest? = request
      0|  240|
      0|  241|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  242|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  243|            }
      0|  244|
      0|  245|            completionHandler(redirectRequest)
      0|  246|        }
       |  247|
       |  248|        func URLSession(
       |  249|            session: NSURLSession,
       |  250|            task: NSURLSessionTask,
       |  251|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  252|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  253|        {
      1|  254|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      1|  255|            var credential: NSURLCredential?
      1|  256|
      0|  257|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  258|                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
      1|  259|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      1|  260|                let host = challenge.protectionSpace.host
      1|  261|
      1|  262|                if let
      1|  263|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      1|  264|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  265|                {
      0|  266|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  267|                        disposition = .UseCredential
      0|  268|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  269|                    } else {
      0|  270|                        disposition = .CancelAuthenticationChallenge
      0|  271|                    }
      0|  272|                }
      0|  273|            } else {
      0|  274|                if challenge.previousFailureCount > 0 {
      0|  275|                    disposition = .CancelAuthenticationChallenge
      0|  276|                } else {
      0|  277|                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
      0|  278|
      0|  279|                    if credential != nil {
      0|  280|                        disposition = .UseCredential
      0|  281|                    }
      0|  282|                }
      0|  283|            }
      1|  284|
      1|  285|            completionHandler(disposition, credential)
      1|  286|        }
       |  287|
       |  288|        func URLSession(
       |  289|            session: NSURLSession,
       |  290|            task: NSURLSessionTask,
       |  291|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  292|        {
      0|  293|            var bodyStream: NSInputStream?
      0|  294|
      0|  295|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  296|                bodyStream = taskNeedNewBodyStream(session, task)
      0|  297|            }
      0|  298|
      0|  299|            completionHandler(bodyStream)
      0|  300|        }
       |  301|
      1|  302|        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  303|            if let taskDidCompleteWithError = taskDidCompleteWithError {
      0|  304|                taskDidCompleteWithError(session, task, error)
      1|  305|            } else {
      0|  306|                if let error = error {
      0|  307|                    self.error = error
      0|  308|
      0|  309|                    if let
      0|  310|                        downloadDelegate = self as? DownloadTaskDelegate,
      0|  311|                        userInfo = error.userInfo as? [String: AnyObject],
      0|  312|                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
      0|  313|                    {
      0|  314|                        downloadDelegate.resumeData = resumeData
      0|  315|                    }
      0|  316|                }
      1|  317|
      1|  318|                queue.suspended = false
      1|  319|            }
      1|  320|        }
       |  321|    }
       |  322|
       |  323|    // MARK: - DataTaskDelegate
       |  324|
       |  325|    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
      0|  326|        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
       |  327|
       |  328|        private var totalBytesReceived: Int64 = 0
       |  329|        private var mutableData: NSMutableData
      2|  330|        override var data: NSData? {
      0|  331|            if dataStream != nil {
      0|  332|                return nil
      2|  333|            } else {
      2|  334|                return mutableData
      2|  335|            }
      0|  336|        }
       |  337|
       |  338|        private var expectedContentLength: Int64?
       |  339|        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
       |  340|        private var dataStream: ((data: NSData) -> Void)?
       |  341|
      1|  342|        override init(task: NSURLSessionTask) {
      1|  343|            mutableData = NSMutableData()
      1|  344|            super.init(task: task)
      1|  345|        }
       |  346|
       |  347|        // MARK: - NSURLSessionDataDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  352|        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  353|        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  354|        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
       |  355|
       |  356|        // MARK: Delegate Methods
       |  357|
       |  358|        func URLSession(
       |  359|            session: NSURLSession,
       |  360|            dataTask: NSURLSessionDataTask,
       |  361|            didReceiveResponse response: NSURLResponse,
       |  362|            completionHandler: (NSURLSessionResponseDisposition -> Void))
      0|  363|        {
      0|  364|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  365|
      0|  366|            expectedContentLength = response.expectedContentLength
      0|  367|
      0|  368|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  369|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  370|            }
      0|  371|
      0|  372|            completionHandler(disposition)
      0|  373|        }
       |  374|
       |  375|        func URLSession(
       |  376|            session: NSURLSession,
       |  377|            dataTask: NSURLSessionDataTask,
       |  378|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  379|        {
      0|  380|            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
      0|  381|        }
       |  382|
      1|  383|        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  384|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  385|                dataTaskDidReceiveData(session, dataTask, data)
      1|  386|            } else {
      0|  387|                if let dataStream = dataStream {
      0|  388|                    dataStream(data: data)
      1|  389|                } else {
      1|  390|                    mutableData.appendData(data)
      1|  391|                }
      1|  392|
      1|  393|                totalBytesReceived += data.length
      0|  394|                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
      1|  395|
      1|  396|                progress.totalUnitCount = totalBytesExpected
      1|  397|                progress.completedUnitCount = totalBytesReceived
      1|  398|
      1|  399|                dataProgress?(
      1|  400|                    bytesReceived: Int64(data.length),
      1|  401|                    totalBytesReceived: totalBytesReceived,
      1|  402|                    totalBytesExpectedToReceive: totalBytesExpected
      1|  403|                )
      1|  404|            }
      1|  405|        }
       |  406|
       |  407|        func URLSession(
       |  408|            session: NSURLSession,
       |  409|            dataTask: NSURLSessionDataTask,
       |  410|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  411|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  412|        {
      0|  413|            var cachedResponse: NSCachedURLResponse? = proposedResponse
      0|  414|
      0|  415|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  416|                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
      0|  417|            }
      0|  418|
      0|  419|            completionHandler(cachedResponse)
      0|  420|        }
       |  421|    }
       |  422|}
       |  423|
       |  424|// MARK: - CustomStringConvertible
       |  425|
       |  426|extension Request: CustomStringConvertible {
       |  427|
       |  428|    /**
       |  429|        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
       |  430|        well as the response status code if a response has been received.
       |  431|    */
      0|  432|    public var description: String {
      0|  433|        var components: [String] = []
      0|  434|
      0|  435|        if let HTTPMethod = request?.HTTPMethod {
      0|  436|            components.append(HTTPMethod)
      0|  437|        }
      0|  438|
      0|  439|        if let URLString = request?.URL?.absoluteString {
      0|  440|            components.append(URLString)
      0|  441|        }
      0|  442|
      0|  443|        if let response = response {
      0|  444|            components.append("(\(response.statusCode))")
      0|  445|        }
      0|  446|
      0|  447|        return components.joinWithSeparator(" ")
      0|  448|    }
       |  449|}
       |  450|
       |  451|// MARK: - CustomDebugStringConvertible
       |  452|
       |  453|extension Request: CustomDebugStringConvertible {
      0|  454|    func cURLRepresentation() -> String {
      0|  455|        var components = ["$ curl -i"]
      0|  456|
      0|  457|        guard let request = self.request else {
      0|  458|            return "$ curl command could not be created"
      0|  459|        }
      0|  460|
      0|  461|        let URL = request.URL
      0|  462|
      0|  463|        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
      0|  464|            components.append("-X \(HTTPMethod)")
      0|  465|        }
      0|  466|
      0|  467|        if let credentialStorage = self.session.configuration.URLCredentialStorage {
      0|  468|            let protectionSpace = NSURLProtectionSpace(
      0|  469|                host: URL!.host!,
      0|  470|                port: URL!.port?.integerValue ?? 0,
      0|  471|                `protocol`: URL!.scheme,
      0|  472|                realm: URL!.host!,
      0|  473|                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
      0|  474|            )
      0|  475|
      0|  476|            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
      0|  477|                for credential in credentials {
      0|  478|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  479|                }
      0|  480|            } else {
      0|  481|                if let credential = delegate.credential {
      0|  482|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  483|                }
      0|  484|            }
      0|  485|        }
      0|  486|
      0|  487|        if session.configuration.HTTPShouldSetCookies {
      0|  488|            if let
      0|  489|                cookieStorage = session.configuration.HTTPCookieStorage,
      0|  490|                cookies = cookieStorage.cookiesForURL(URL!) where !cookies.isEmpty
      0|  491|            {
      0|  492|                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
      0|  493|                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
      0|  494|            }
      0|  495|        }
      0|  496|
      0|  497|        if let headerFields = request.allHTTPHeaderFields {
      0|  498|            for (field, value) in headerFields {
      0|  499|                switch field {
      0|  500|                case "Cookie":
      0|  501|                    continue
      0|  502|                default:
      0|  503|                    components.append("-H \"\(field): \(value)\"")
      0|  504|                }
      0|  505|            }
      0|  506|        }
      0|  507|
      0|  508|        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
      0|  509|            for (field, value) in additionalHeaders {
      0|  510|                switch field {
      0|  511|                case "Cookie":
      0|  512|                    continue
      0|  513|                default:
      0|  514|                    components.append("-H \"\(field): \(value)\"")
      0|  515|                }
      0|  516|            }
      0|  517|        }
      0|  518|
      0|  519|        if let
      0|  520|            HTTPBodyData = request.HTTPBody,
      0|  521|            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
      0|  522|        {
      0|  523|            let escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
      0|  524|            components.append("-d \"\(escapedBody)\"")
      0|  525|        }
      0|  526|
      0|  527|        components.append("\"\(URL!.absoluteString)\"")
      0|  528|
      0|  529|        return components.joinWithSeparator(" \\\n\t")
      0|  530|    }
       |  531|
       |  532|    /// The textual representation used when written to an output stream, in the form of a cURL command.
      0|  533|    public var debugDescription: String {
      0|  534|        return cURLRepresentation()
      0|  535|    }
       |  536|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Response.swift:
       |    1|// Response.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Used to store all response data returned from a completed `Request`.
       |   26|public struct Response<Value, Error: ErrorType> {
       |   27|    /// The URL request sent to the server.
       |   28|    public let request: NSURLRequest?
       |   29|
       |   30|    /// The server's response to the URL request.
       |   31|    public let response: NSHTTPURLResponse?
       |   32|
       |   33|    /// The data returned by the server.
       |   34|    public let data: NSData?
       |   35|
       |   36|    /// The result of response serialization.
       |   37|    public let result: Result<Value, Error>
       |   38|
       |   39|    /**
       |   40|        Initializes the `Response` instance with the specified URL request, URL response, server data and response
       |   41|        serialization result.
       |   42|    
       |   43|        - parameter request:  The URL request sent to the server.
       |   44|        - parameter response: The server's response to the URL request.
       |   45|        - parameter data:     The data returned by the server.
       |   46|        - parameter result:   The result of response serialization.
       |   47|    
       |   48|        - returns: the new `Response` instance.
       |   49|    */
      1|   50|    public init(request: NSURLRequest?, response: NSHTTPURLResponse?, data: NSData?, result: Result<Value, Error>) {
      1|   51|        self.request = request
      1|   52|        self.response = response
      1|   53|        self.data = data
      1|   54|        self.result = result
      1|   55|    }
       |   56|}
       |   57|
       |   58|// MARK: - CustomStringConvertible
       |   59|
       |   60|extension Response: CustomStringConvertible {
       |   61|    /// The textual representation used when written to an output stream, which includes whether the result was a
       |   62|    /// success or failure.
      0|   63|    public var description: String {
      0|   64|        return result.debugDescription
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - CustomDebugStringConvertible
       |   69|
       |   70|extension Response: CustomDebugStringConvertible {
       |   71|    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
       |   72|    /// response, the server data and the response serialization result.
      0|   73|    public var debugDescription: String {
      0|   74|        var output: [String] = []
      0|   75|
      0|   76|        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
      0|   77|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
      0|   78|        output.append("[Data]: \(data?.length ?? 0) bytes")
      0|   79|        output.append("[Result]: \(result.debugDescription)")
      0|   80|
      0|   81|        return output.joinWithSeparator("\n")
      0|   82|    }
       |   83|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ResponseSerialization.swift:
       |    1|// ResponseSerialization.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: ResponseSerializer
       |   26|
       |   27|/**
       |   28|    The type in which all response serializers must conform to in order to serialize a response.
       |   29|*/
       |   30|public protocol ResponseSerializerType {
       |   31|    /// The type of serialized object to be created by this `ResponseSerializerType`.
       |   32|    typealias SerializedObject
       |   33|
       |   34|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   35|    typealias ErrorObject: ErrorType
       |   36|
       |   37|    /**
       |   38|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   39|    */
       |   40|    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
       |   41|}
       |   42|
       |   43|// MARK: -
       |   44|
       |   45|/**
       |   46|    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
       |   47|*/
       |   48|public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
       |   49|    /// The type of serialized object to be created by this `ResponseSerializer`.
       |   50|    public typealias SerializedObject = Value
       |   51|
       |   52|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   53|    public typealias ErrorObject = Error
       |   54|
       |   55|    /**
       |   56|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   57|    */
       |   58|    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
       |   59|
       |   60|    /**
       |   61|        Initializes the `ResponseSerializer` instance with the given serialize response closure.
       |   62|
       |   63|        - parameter serializeResponse: The closure used to serialize the response.
       |   64|
       |   65|        - returns: The new generic response serializer instance.
       |   66|    */
      1|   67|    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
      1|   68|        self.serializeResponse = serializeResponse
      1|   69|    }
       |   70|}
       |   71|
       |   72|// MARK: - Default
       |   73|
       |   74|extension Request {
       |   75|
       |   76|    /**
       |   77|        Adds a handler to be called once the request has finished.
       |   78|
       |   79|        - parameter queue:             The queue on which the completion handler is dispatched.
       |   80|        - parameter completionHandler: The code to be executed once the request has finished.
       |   81|
       |   82|        - returns: The request.
       |   83|    */
       |   84|    public func response(
       |   85|        queue queue: dispatch_queue_t? = nil,
       |   86|        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
       |   87|        -> Self
      0|   88|    {
      0|   89|        delegate.queue.addOperationWithBlock {
      0|   90|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      0|   91|                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
      0|   92|            }
      0|   93|        }
      0|   94|
      0|   95|        return self
      0|   96|    }
       |   97|
       |   98|    /**
       |   99|        Adds a handler to be called once the request has finished.
       |  100|
       |  101|        - parameter queue:              The queue on which the completion handler is dispatched.
       |  102|        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
       |  103|                                        and data.
       |  104|        - parameter completionHandler:  The code to be executed once the request has finished.
       |  105|
       |  106|        - returns: The request.
       |  107|    */
       |  108|    public func response<T: ResponseSerializerType>(
       |  109|        queue queue: dispatch_queue_t? = nil,
       |  110|        responseSerializer: T,
       |  111|        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
       |  112|        -> Self
      1|  113|    {
      1|  114|        delegate.queue.addOperationWithBlock {
      1|  115|            let result = responseSerializer.serializeResponse(
      1|  116|                self.request,
      1|  117|                self.response,
      1|  118|                self.delegate.data,
      1|  119|                self.delegate.error
      1|  120|            )
      1|  121|
      1|  122|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      1|  123|                let response = Response<T.SerializedObject, T.ErrorObject>(
      1|  124|                    request: self.request,
      1|  125|                    response: self.response,
      1|  126|                    data: self.delegate.data,
      1|  127|                    result: result
      1|  128|                )
      1|  129|
      1|  130|                completionHandler(response)
      1|  131|            }
      1|  132|        }
      1|  133|
      1|  134|        return self
      1|  135|    }
       |  136|}
       |  137|
       |  138|// MARK: - Data
       |  139|
       |  140|extension Request {
       |  141|
       |  142|    /**
       |  143|        Creates a response serializer that returns the associated data as-is.
       |  144|
       |  145|        - returns: A data response serializer.
       |  146|    */
      0|  147|    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
      0|  148|        return ResponseSerializer { _, response, data, error in
      0|  149|            guard error == nil else { return .Failure(error!) }
      0|  150|
      0|  151|            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
      0|  152|
      0|  153|            guard let validData = data else {
      0|  154|                let failureReason = "Data could not be serialized. Input data was nil."
      0|  155|                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
      0|  156|                return .Failure(error)
      0|  157|            }
      0|  158|
      0|  159|            return .Success(validData)
      0|  160|        }
      0|  161|    }
       |  162|
       |  163|    /**
       |  164|        Adds a handler to be called once the request has finished.
       |  165|
       |  166|        - parameter completionHandler: The code to be executed once the request has finished.
       |  167|
       |  168|        - returns: The request.
       |  169|    */
      0|  170|    public func responseData(completionHandler: Response<NSData, NSError> -> Void) -> Self {
      0|  171|        return response(responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
      0|  172|    }
       |  173|}
       |  174|
       |  175|// MARK: - String
       |  176|
       |  177|extension Request {
       |  178|
       |  179|    /**
       |  180|        Creates a response serializer that returns a string initialized from the response data with the specified 
       |  181|        string encoding.
       |  182|
       |  183|        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
       |  184|                              response, falling back to the default HTTP default character set, ISO-8859-1.
       |  185|
       |  186|        - returns: A string response serializer.
       |  187|    */
       |  188|    public static func stringResponseSerializer(
       |  189|        var encoding encoding: NSStringEncoding? = nil)
       |  190|        -> ResponseSerializer<String, NSError>
      0|  191|    {
      0|  192|        return ResponseSerializer { _, response, data, error in
      0|  193|            guard error == nil else { return .Failure(error!) }
      0|  194|
      0|  195|            if let response = response where response.statusCode == 204 { return .Success("") }
      0|  196|
      0|  197|            guard let validData = data else {
      0|  198|                let failureReason = "String could not be serialized. Input data was nil."
      0|  199|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  200|                return .Failure(error)
      0|  201|            }
      0|  202|
      0|  203|            if let encodingName = response?.textEncodingName where encoding == nil {
      0|  204|                encoding = CFStringConvertEncodingToNSStringEncoding(
      0|  205|                    CFStringConvertIANACharSetNameToEncoding(encodingName)
      0|  206|                )
      0|  207|            }
      0|  208|
      0|  209|            let actualEncoding = encoding ?? NSISOLatin1StringEncoding
      0|  210|
      0|  211|            if let string = String(data: validData, encoding: actualEncoding) {
      0|  212|                return .Success(string)
      0|  213|            } else {
      0|  214|                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
      0|  215|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  216|                return .Failure(error)
      0|  217|            }
      0|  218|        }
      0|  219|    }
       |  220|
       |  221|    /**
       |  222|        Adds a handler to be called once the request has finished.
       |  223|
       |  224|        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
       |  225|                                       server response, falling back to the default HTTP default character set, 
       |  226|                                       ISO-8859-1.
       |  227|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  228|
       |  229|        - returns: The request.
       |  230|    */
       |  231|    public func responseString(
       |  232|        encoding encoding: NSStringEncoding? = nil,
       |  233|        completionHandler: Response<String, NSError> -> Void)
       |  234|        -> Self
      0|  235|    {
      0|  236|        return response(
      0|  237|            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
      0|  238|            completionHandler: completionHandler
      0|  239|        )
      0|  240|    }
       |  241|}
       |  242|
       |  243|// MARK: - JSON
       |  244|
       |  245|extension Request {
       |  246|
       |  247|    /**
       |  248|        Creates a response serializer that returns a JSON object constructed from the response data using 
       |  249|        `NSJSONSerialization` with the specified reading options.
       |  250|
       |  251|        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
       |  252|
       |  253|        - returns: A JSON object response serializer.
       |  254|    */
       |  255|    public static func JSONResponseSerializer(
       |  256|        options options: NSJSONReadingOptions = .AllowFragments)
       |  257|        -> ResponseSerializer<AnyObject, NSError>
      1|  258|    {
      1|  259|        return ResponseSerializer { _, response, data, error in
      0|  260|            guard error == nil else { return .Failure(error!) }
      1|  261|
      0|  262|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      1|  263|
      0|  264|            guard let validData = data where validData.length > 0 else {
      0|  265|                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
      0|  266|                let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
      0|  267|                return .Failure(error)
      0|  268|            }
      1|  269|
      1|  270|            do {
      1|  271|                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
      1|  272|                return .Success(JSON)
      1|  273|            } catch {
      1|  274|                return .Failure(error as NSError)
      1|  275|            }
      0|  276|        }
      1|  277|    }
       |  278|
       |  279|    /**
       |  280|        Adds a handler to be called once the request has finished.
       |  281|
       |  282|        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
       |  283|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  284|
       |  285|        - returns: The request.
       |  286|    */
       |  287|    public func responseJSON(
       |  288|        options options: NSJSONReadingOptions = .AllowFragments,
       |  289|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  290|        -> Self
      1|  291|    {
      1|  292|        return response(
      1|  293|            responseSerializer: Request.JSONResponseSerializer(options: options),
      1|  294|            completionHandler: completionHandler
      1|  295|        )
      1|  296|    }
       |  297|}
       |  298|
       |  299|// MARK: - Property List
       |  300|
       |  301|extension Request {
       |  302|
       |  303|    /**
       |  304|        Creates a response serializer that returns an object constructed from the response data using 
       |  305|        `NSPropertyListSerialization` with the specified reading options.
       |  306|
       |  307|        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
       |  308|
       |  309|        - returns: A property list object response serializer.
       |  310|    */
       |  311|    public static func propertyListResponseSerializer(
       |  312|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
       |  313|        -> ResponseSerializer<AnyObject, NSError>
      0|  314|    {
      0|  315|        return ResponseSerializer { _, response, data, error in
      0|  316|            guard error == nil else { return .Failure(error!) }
      0|  317|
      0|  318|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      0|  319|
      0|  320|            guard let validData = data where validData.length > 0 else {
      0|  321|                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
      0|  322|                let error = Error.errorWithCode(.PropertyListSerializationFailed, failureReason: failureReason)
      0|  323|                return .Failure(error)
      0|  324|            }
      0|  325|
      0|  326|            do {
      0|  327|                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
      0|  328|                return .Success(plist)
      0|  329|            } catch {
      0|  330|                return .Failure(error as NSError)
      0|  331|            }
      0|  332|        }
      0|  333|    }
       |  334|
       |  335|    /**
       |  336|        Adds a handler to be called once the request has finished.
       |  337|
       |  338|        - parameter options:           The property list reading options. `0` by default.
       |  339|        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
       |  340|                                       arguments: the URL request, the URL response, the server data and the result 
       |  341|                                       produced while creating the property list.
       |  342|
       |  343|        - returns: The request.
       |  344|    */
       |  345|    public func responsePropertyList(
       |  346|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
       |  347|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  348|        -> Self
      0|  349|    {
      0|  350|        return response(
      0|  351|            responseSerializer: Request.propertyListResponseSerializer(options: options),
      0|  352|            completionHandler: completionHandler
      0|  353|        )
      0|  354|    }
       |  355|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Result.swift:
       |    1|// Result.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Used to represent whether a request was successful or encountered an error.
       |   27|
       |   28|    - Success: The request and all post processing operations were successful resulting in the serialization of the 
       |   29|               provided associated value.
       |   30|    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
       |   31|               provided by the server as well as the error that caused the failure.
       |   32|*/
       |   33|public enum Result<Value, Error: ErrorType> {
       |   34|    case Success(Value)
       |   35|    case Failure(Error)
       |   36|
       |   37|    /// Returns `true` if the result is a success, `false` otherwise.
      0|   38|    public var isSuccess: Bool {
      0|   39|        switch self {
      0|   40|        case .Success:
      0|   41|            return true
      0|   42|        case .Failure:
      0|   43|            return false
      0|   44|        }
      0|   45|    }
       |   46|
       |   47|    /// Returns `true` if the result is a failure, `false` otherwise.
      0|   48|    public var isFailure: Bool {
      0|   49|        return !isSuccess
      0|   50|    }
       |   51|
       |   52|    /// Returns the associated value if the result is a success, `nil` otherwise.
      0|   53|    public var value: Value? {
      0|   54|        switch self {
      0|   55|        case .Success(let value):
      0|   56|            return value
      0|   57|        case .Failure:
      0|   58|            return nil
      0|   59|        }
      0|   60|    }
       |   61|
       |   62|    /// Returns the associated error value if the result is a failure, `nil` otherwise.
      0|   63|    public var error: Error? {
      0|   64|        switch self {
      0|   65|        case .Success:
      0|   66|            return nil
      0|   67|        case .Failure(let error):
      0|   68|            return error
      0|   69|        }
      0|   70|    }
       |   71|}
       |   72|
       |   73|// MARK: - CustomStringConvertible
       |   74|
       |   75|extension Result: CustomStringConvertible {
       |   76|    /// The textual representation used when written to an output stream, which includes whether the result was a 
       |   77|    /// success or failure.
      0|   78|    public var description: String {
      0|   79|        switch self {
      0|   80|        case .Success:
      0|   81|            return "SUCCESS"
      0|   82|        case .Failure:
      0|   83|            return "FAILURE"
      0|   84|        }
      0|   85|    }
       |   86|}
       |   87|
       |   88|// MARK: - CustomDebugStringConvertible
       |   89|
       |   90|extension Result: CustomDebugStringConvertible {
       |   91|    /// The debug textual representation used when written to an output stream, which includes whether the result was a
       |   92|    /// success or failure in addition to the value or error.
      1|   93|    public var debugDescription: String {
      1|   94|        switch self {
      0|   95|        case .Success(let value):
      0|   96|            return "SUCCESS: \(value)"
      1|   97|        case .Failure(let error):
      1|   98|            return "FAILURE: \(error)"
      1|   99|        }
      1|  100|    }
       |  101|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ServerTrustPolicy.swift:
       |    1|// ServerTrustPolicy.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
       |   26|public class ServerTrustPolicyManager {
       |   27|    /// The dictionary of policies mapped to a particular host.
       |   28|    public let policies: [String: ServerTrustPolicy]
       |   29|
       |   30|    /**
       |   31|        Initializes the `ServerTrustPolicyManager` instance with the given policies.
       |   32|
       |   33|        Since different servers and web services can have different leaf certificates, intermediate and even root 
       |   34|        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
       |   35|        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
       |   36|        pinning for host3 and disabling evaluation for host4.
       |   37|
       |   38|        - parameter policies: A dictionary of all policies mapped to a particular host.
       |   39|
       |   40|        - returns: The new `ServerTrustPolicyManager` instance.
       |   41|    */
      0|   42|    public init(policies: [String: ServerTrustPolicy]) {
      0|   43|        self.policies = policies
      0|   44|    }
       |   45|
       |   46|    /**
       |   47|        Returns the `ServerTrustPolicy` for the given host if applicable.
       |   48|
       |   49|        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
       |   50|        this method and implement more complex mapping implementations such as wildcards.
       |   51|
       |   52|        - parameter host: The host to use when searching for a matching policy.
       |   53|
       |   54|        - returns: The server trust policy for the given host if found.
       |   55|    */
      0|   56|    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
      0|   57|        return policies[host]
      0|   58|    }
       |   59|}
       |   60|
       |   61|// MARK: -
       |   62|
       |   63|extension NSURLSession {
       |   64|    private struct AssociatedKeys {
       |   65|        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
       |   66|    }
       |   67|
       |   68|    var serverTrustPolicyManager: ServerTrustPolicyManager? {
      1|   69|        get {
      1|   70|            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
      1|   71|        }
      1|   72|        set (manager) {
      1|   73|            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
      1|   74|        }
       |   75|    }
       |   76|}
       |   77|
       |   78|// MARK: - ServerTrustPolicy
       |   79|
       |   80|/**
       |   81|    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
       |   82|    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
       |   83|    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
       |   84|
       |   85|    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
       |   86|    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
       |   87|    to route all communication over an HTTPS connection with pinning enabled.
       |   88|
       |   89|    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
       |   90|                                validate the host provided by the challenge. Applications are encouraged to always 
       |   91|                                validate the host in production environments to guarantee the validity of the server's 
       |   92|                                certificate chain.
       |   93|
       |   94|    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
       |   95|                                considered valid if one of the pinned certificates match one of the server certificates. 
       |   96|                                By validating both the certificate chain and host, certificate pinning provides a very 
       |   97|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |   98|                                Applications are encouraged to always validate the host and require a valid certificate 
       |   99|                                chain in production environments.
       |  100|
       |  101|    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
       |  102|                                valid if one of the pinned public keys match one of the server certificate public keys. 
       |  103|                                By validating both the certificate chain and host, public key pinning provides a very 
       |  104|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |  105|                                Applications are encouraged to always validate the host and require a valid certificate 
       |  106|                                chain in production environments.
       |  107|
       |  108|    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
       |  109|
       |  110|    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
       |  111|*/
       |  112|public enum ServerTrustPolicy {
       |  113|    case PerformDefaultEvaluation(validateHost: Bool)
       |  114|    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
       |  115|    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
       |  116|    case DisableEvaluation
       |  117|    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
       |  118|
       |  119|    // MARK: - Bundle Location
       |  120|
       |  121|    /**
       |  122|        Returns all certificates within the given bundle with a `.cer` file extension.
       |  123|
       |  124|        - parameter bundle: The bundle to search for all `.cer` files.
       |  125|
       |  126|        - returns: All certificates within the given bundle.
       |  127|    */
      0|  128|    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
      0|  129|        var certificates: [SecCertificate] = []
      0|  130|
      0|  131|        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
      0|  132|            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
      0|  133|        }.flatten())
      0|  134|
      0|  135|        for path in paths {
      0|  136|            if let
      0|  137|                certificateData = NSData(contentsOfFile: path),
      0|  138|                certificate = SecCertificateCreateWithData(nil, certificateData)
      0|  139|            {
      0|  140|                certificates.append(certificate)
      0|  141|            }
      0|  142|        }
      0|  143|
      0|  144|        return certificates
      0|  145|    }
       |  146|
       |  147|    /**
       |  148|        Returns all public keys within the given bundle with a `.cer` file extension.
       |  149|
       |  150|        - parameter bundle: The bundle to search for all `*.cer` files.
       |  151|
       |  152|        - returns: All public keys within the given bundle.
       |  153|    */
      0|  154|    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
      0|  155|        var publicKeys: [SecKey] = []
      0|  156|
      0|  157|        for certificate in certificatesInBundle(bundle) {
      0|  158|            if let publicKey = publicKeyForCertificate(certificate) {
      0|  159|                publicKeys.append(publicKey)
      0|  160|            }
      0|  161|        }
      0|  162|
      0|  163|        return publicKeys
      0|  164|    }
       |  165|
       |  166|    // MARK: - Evaluation
       |  167|
       |  168|    /**
       |  169|        Evaluates whether the server trust is valid for the given host.
       |  170|
       |  171|        - parameter serverTrust: The server trust to evaluate.
       |  172|        - parameter host:        The host of the challenge protection space.
       |  173|
       |  174|        - returns: Whether the server trust is valid.
       |  175|    */
      0|  176|    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
      0|  177|        var serverTrustIsValid = false
      0|  178|
      0|  179|        switch self {
      0|  180|        case let .PerformDefaultEvaluation(validateHost):
      0|  181|            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  182|            SecTrustSetPolicies(serverTrust, [policy])
      0|  183|
      0|  184|            serverTrustIsValid = trustIsValid(serverTrust)
      0|  185|        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
      0|  186|            if validateCertificateChain {
      0|  187|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  188|                SecTrustSetPolicies(serverTrust, [policy])
      0|  189|
      0|  190|                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
      0|  191|                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
      0|  192|
      0|  193|                serverTrustIsValid = trustIsValid(serverTrust)
      0|  194|            } else {
      0|  195|                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
      0|  196|                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
      0|  197|
      0|  198|                outerLoop: for serverCertificateData in serverCertificatesDataArray {
      0|  199|                    for pinnedCertificateData in pinnedCertificatesDataArray {
      0|  200|                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
      0|  201|                            serverTrustIsValid = true
      0|  202|                            break outerLoop
      0|  203|                        }
      0|  204|                    }
      0|  205|                }
      0|  206|            }
      0|  207|        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
      0|  208|            var certificateChainEvaluationPassed = true
      0|  209|
      0|  210|            if validateCertificateChain {
      0|  211|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  212|                SecTrustSetPolicies(serverTrust, [policy])
      0|  213|
      0|  214|                certificateChainEvaluationPassed = trustIsValid(serverTrust)
      0|  215|            }
      0|  216|
      0|  217|            if certificateChainEvaluationPassed {
      0|  218|                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
      0|  219|                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
      0|  220|                        if serverPublicKey.isEqual(pinnedPublicKey) {
      0|  221|                            serverTrustIsValid = true
      0|  222|                            break outerLoop
      0|  223|                        }
      0|  224|                    }
      0|  225|                }
      0|  226|            }
      0|  227|        case .DisableEvaluation:
      0|  228|            serverTrustIsValid = true
      0|  229|        case let .CustomEvaluation(closure):
      0|  230|            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
      0|  231|        }
      0|  232|
      0|  233|        return serverTrustIsValid
      0|  234|    }
       |  235|
       |  236|    // MARK: - Private - Trust Validation
       |  237|
      0|  238|    private func trustIsValid(trust: SecTrust) -> Bool {
      0|  239|        var isValid = false
      0|  240|
      0|  241|        var result = SecTrustResultType(kSecTrustResultInvalid)
      0|  242|        let status = SecTrustEvaluate(trust, &result)
      0|  243|
      0|  244|        if status == errSecSuccess {
      0|  245|            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
      0|  246|            let proceed = SecTrustResultType(kSecTrustResultProceed)
      0|  247|
      0|  248|            isValid = result == unspecified || result == proceed
      0|  249|        }
      0|  250|
      0|  251|        return isValid
      0|  252|    }
       |  253|
       |  254|    // MARK: - Private - Certificate Data
       |  255|
      0|  256|    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
      0|  257|        var certificates: [SecCertificate] = []
      0|  258|
      0|  259|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  260|            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
      0|  261|                certificates.append(certificate)
      0|  262|            }
      0|  263|        }
      0|  264|
      0|  265|        return certificateDataForCertificates(certificates)
      0|  266|    }
       |  267|
      0|  268|    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
      0|  269|        return certificates.map { SecCertificateCopyData($0) as NSData }
      0|  270|    }
       |  271|
       |  272|    // MARK: - Private - Public Key Extraction
       |  273|
      0|  274|    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
      0|  275|        var publicKeys: [SecKey] = []
      0|  276|
      0|  277|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  278|            if let
      0|  279|                certificate = SecTrustGetCertificateAtIndex(trust, index),
      0|  280|                publicKey = publicKeyForCertificate(certificate)
      0|  281|            {
      0|  282|                publicKeys.append(publicKey)
      0|  283|            }
      0|  284|        }
      0|  285|
      0|  286|        return publicKeys
      0|  287|    }
       |  288|
      0|  289|    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
      0|  290|        var publicKey: SecKey?
      0|  291|
      0|  292|        let policy = SecPolicyCreateBasicX509()
      0|  293|        var trust: SecTrust?
      0|  294|        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
      0|  295|
      0|  296|        if let trust = trust where trustCreationStatus == errSecSuccess {
      0|  297|            publicKey = SecTrustCopyPublicKey(trust)
      0|  298|        }
      0|  299|
      0|  300|        return publicKey
      0|  301|    }
       |  302|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Stream.swift:
       |    1|// Stream.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if !os(watchOS)
       |   26|
       |   27|@available(iOS 9.0, OSX 10.11, *)
       |   28|extension Manager {
       |   29|    private enum Streamable {
       |   30|        case Stream(String, Int)
       |   31|        case NetService(NSNetService)
       |   32|    }
       |   33|
      0|   34|    private func stream(streamable: Streamable) -> Request {
      0|   35|        var streamTask: NSURLSessionStreamTask!
      0|   36|
      0|   37|        switch streamable {
      0|   38|        case .Stream(let hostName, let port):
      0|   39|            dispatch_sync(queue) {
      0|   40|                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
      0|   41|            }
      0|   42|        case .NetService(let netService):
      0|   43|            dispatch_sync(queue) {
      0|   44|                streamTask = self.session.streamTaskWithNetService(netService)
      0|   45|            }
      0|   46|        }
      0|   47|
      0|   48|        let request = Request(session: session, task: streamTask)
      0|   49|
      0|   50|        delegate[request.delegate.task] = request.delegate
      0|   51|
      0|   52|        if startRequestsImmediately {
      0|   53|            request.resume()
      0|   54|        }
      0|   55|
      0|   56|        return request
      0|   57|    }
       |   58|
       |   59|    /**
       |   60|        Creates a request for bidirectional streaming with the given hostname and port.
       |   61|
       |   62|        - parameter hostName: The hostname of the server to connect to.
       |   63|        - parameter port:     The port of the server to connect to.
       |   64|
       |   65|        :returns: The created stream request.
       |   66|    */
      0|   67|    public func stream(hostName hostName: String, port: Int) -> Request {
      0|   68|        return stream(.Stream(hostName, port))
      0|   69|    }
       |   70|
       |   71|    /**
       |   72|        Creates a request for bidirectional streaming with the given `NSNetService`.
       |   73|
       |   74|        - parameter netService: The net service used to identify the endpoint.
       |   75|
       |   76|        - returns: The created stream request.
       |   77|    */
      0|   78|    public func stream(netService netService: NSNetService) -> Request {
      0|   79|        return stream(.NetService(netService))
      0|   80|    }
       |   81|}
       |   82|
       |   83|// MARK: -
       |   84|
       |   85|@available(iOS 9.0, OSX 10.11, *)
       |   86|extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
       |   87|
       |   88|    // MARK: Override Closures
       |   89|
       |   90|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
       |   91|    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|   92|        get {
      0|   93|            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|   94|        }
      0|   95|        set {
      0|   96|            _streamTaskReadClosed = newValue
      0|   97|        }
       |   98|    }
       |   99|
       |  100|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
       |  101|    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  102|        get {
      0|  103|            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  104|        }
      0|  105|        set {
      0|  106|            _streamTaskWriteClosed = newValue
      0|  107|        }
       |  108|    }
       |  109|
       |  110|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
       |  111|    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  112|        get {
      0|  113|            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  114|        }
      0|  115|        set {
      0|  116|            _streamTaskBetterRouteDiscovered = newValue
      0|  117|        }
       |  118|    }
       |  119|
       |  120|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
       |  121|    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
      0|  122|        get {
      0|  123|            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
      0|  124|        }
      0|  125|        set {
      0|  126|            _streamTaskDidBecomeInputStream = newValue
      0|  127|        }
       |  128|    }
       |  129|
       |  130|    // MARK: Delegate Methods
       |  131|
       |  132|    /**
       |  133|        Tells the delegate that the read side of the connection has been closed.
       |  134|
       |  135|        - parameter session:    The session.
       |  136|        - parameter streamTask: The stream task.
       |  137|    */
      0|  138|    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  139|        streamTaskReadClosed?(session, streamTask)
      0|  140|    }
       |  141|
       |  142|    /**
       |  143|        Tells the delegate that the write side of the connection has been closed.
       |  144|
       |  145|        - parameter session:    The session.
       |  146|        - parameter streamTask: The stream task.
       |  147|    */
      0|  148|    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  149|        streamTaskWriteClosed?(session, streamTask)
      0|  150|    }
       |  151|
       |  152|    /**
       |  153|        Tells the delegate that the system has determined that a better route to the host is available.
       |  154|
       |  155|        - parameter session:    The session.
       |  156|        - parameter streamTask: The stream task.
       |  157|    */
      0|  158|    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  159|        streamTaskBetterRouteDiscovered?(session, streamTask)
      0|  160|    }
       |  161|
       |  162|    /**
       |  163|        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
       |  164|
       |  165|        - parameter session:      The session.
       |  166|        - parameter streamTask:   The stream task.
       |  167|        - parameter inputStream:  The new input stream.
       |  168|        - parameter outputStream: The new output stream.
       |  169|    */
       |  170|    public func URLSession(
       |  171|        session: NSURLSession,
       |  172|        streamTask: NSURLSessionStreamTask,
       |  173|        didBecomeInputStream inputStream: NSInputStream,
       |  174|        outputStream: NSOutputStream)
      0|  175|    {
      0|  176|        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
      0|  177|    }
       |  178|}
       |  179|
       |  180|#endif

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Upload.swift:
       |    1|// Upload.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Uploadable {
       |   27|        case Data(NSURLRequest, NSData)
       |   28|        case File(NSURLRequest, NSURL)
       |   29|        case Stream(NSURLRequest, NSInputStream)
       |   30|    }
       |   31|
      0|   32|    private func upload(uploadable: Uploadable) -> Request {
      0|   33|        var uploadTask: NSURLSessionUploadTask!
      0|   34|        var HTTPBodyStream: NSInputStream?
      0|   35|
      0|   36|        switch uploadable {
      0|   37|        case .Data(let request, let data):
      0|   38|            dispatch_sync(queue) {
      0|   39|                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
      0|   40|            }
      0|   41|        case .File(let request, let fileURL):
      0|   42|            dispatch_sync(queue) {
      0|   43|                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
      0|   44|            }
      0|   45|        case .Stream(let request, let stream):
      0|   46|            dispatch_sync(queue) {
      0|   47|                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
      0|   48|            }
      0|   49|
      0|   50|            HTTPBodyStream = stream
      0|   51|        }
      0|   52|
      0|   53|        let request = Request(session: session, task: uploadTask)
      0|   54|
      0|   55|        if HTTPBodyStream != nil {
      0|   56|            request.delegate.taskNeedNewBodyStream = { _, _ in
      0|   57|                return HTTPBodyStream
      0|   58|            }
      0|   59|        }
      0|   60|
      0|   61|        delegate[request.delegate.task] = request.delegate
      0|   62|
      0|   63|        if startRequestsImmediately {
      0|   64|            request.resume()
      0|   65|        }
      0|   66|
      0|   67|        return request
      0|   68|    }
       |   69|
       |   70|    // MARK: File
       |   71|
       |   72|    /**
       |   73|        Creates a request for uploading a file to the specified URL request.
       |   74|
       |   75|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   76|
       |   77|        - parameter URLRequest: The URL request
       |   78|        - parameter file:       The file to upload
       |   79|
       |   80|        - returns: The created upload request.
       |   81|    */
      0|   82|    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|   83|        return upload(.File(URLRequest.URLRequest, file))
      0|   84|    }
       |   85|
       |   86|    /**
       |   87|        Creates a request for uploading a file to the specified URL request.
       |   88|
       |   89|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   90|
       |   91|        - parameter method:    The HTTP method.
       |   92|        - parameter URLString: The URL string.
       |   93|        - parameter headers:   The HTTP headers. `nil` by default.
       |   94|        - parameter file:      The file to upload
       |   95|
       |   96|        - returns: The created upload request.
       |   97|    */
       |   98|    public func upload(
       |   99|        method: Method,
       |  100|        _ URLString: URLStringConvertible,
       |  101|        headers: [String: String]? = nil,
       |  102|        file: NSURL)
       |  103|        -> Request
      0|  104|    {
      0|  105|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  106|        return upload(mutableURLRequest, file: file)
      0|  107|    }
       |  108|
       |  109|    // MARK: Data
       |  110|
       |  111|    /**
       |  112|        Creates a request for uploading data to the specified URL request.
       |  113|
       |  114|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  115|
       |  116|        - parameter URLRequest: The URL request.
       |  117|        - parameter data:       The data to upload.
       |  118|
       |  119|        - returns: The created upload request.
       |  120|    */
      0|  121|    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  122|        return upload(.Data(URLRequest.URLRequest, data))
      0|  123|    }
       |  124|
       |  125|    /**
       |  126|        Creates a request for uploading data to the specified URL request.
       |  127|
       |  128|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  129|
       |  130|        - parameter method:    The HTTP method.
       |  131|        - parameter URLString: The URL string.
       |  132|        - parameter headers:   The HTTP headers. `nil` by default.
       |  133|        - parameter data:      The data to upload
       |  134|
       |  135|        - returns: The created upload request.
       |  136|    */
       |  137|    public func upload(
       |  138|        method: Method,
       |  139|        _ URLString: URLStringConvertible,
       |  140|        headers: [String: String]? = nil,
       |  141|        data: NSData)
       |  142|        -> Request
      0|  143|    {
      0|  144|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  145|
      0|  146|        return upload(mutableURLRequest, data: data)
      0|  147|    }
       |  148|
       |  149|    // MARK: Stream
       |  150|
       |  151|    /**
       |  152|        Creates a request for uploading a stream to the specified URL request.
       |  153|
       |  154|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  155|
       |  156|        - parameter URLRequest: The URL request.
       |  157|        - parameter stream:     The stream to upload.
       |  158|
       |  159|        - returns: The created upload request.
       |  160|    */
      0|  161|    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  162|        return upload(.Stream(URLRequest.URLRequest, stream))
      0|  163|    }
       |  164|
       |  165|    /**
       |  166|        Creates a request for uploading a stream to the specified URL request.
       |  167|
       |  168|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  169|
       |  170|        - parameter method:    The HTTP method.
       |  171|        - parameter URLString: The URL string.
       |  172|        - parameter headers:   The HTTP headers. `nil` by default.
       |  173|        - parameter stream:    The stream to upload.
       |  174|
       |  175|        - returns: The created upload request.
       |  176|    */
       |  177|    public func upload(
       |  178|        method: Method,
       |  179|        _ URLString: URLStringConvertible,
       |  180|        headers: [String: String]? = nil,
       |  181|        stream: NSInputStream)
       |  182|        -> Request
      0|  183|    {
      0|  184|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  185|
      0|  186|        return upload(mutableURLRequest, stream: stream)
      0|  187|    }
       |  188|
       |  189|    // MARK: MultipartFormData
       |  190|
       |  191|    /// Default memory threshold used when encoding `MultipartFormData`.
       |  192|    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
       |  193|
       |  194|    /**
       |  195|        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
       |  196|        associated values.
       |  197|
       |  198|        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
       |  199|                   streaming information.
       |  200|        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
       |  201|                   error.
       |  202|    */
       |  203|    public enum MultipartFormDataEncodingResult {
       |  204|        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
       |  205|        case Failure(ErrorType)
       |  206|    }
       |  207|
       |  208|    /**
       |  209|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  210|
       |  211|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
       |  212|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
       |  213|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
       |  214|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
       |  215|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
       |  216|        used for larger payloads such as video content.
       |  217|
       |  218|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
       |  219|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  220|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
       |  221|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
       |  222|        technique was used.
       |  223|
       |  224|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  225|
       |  226|        - parameter method:                  The HTTP method.
       |  227|        - parameter URLString:               The URL string.
       |  228|        - parameter headers:                 The HTTP headers. `nil` by default.
       |  229|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  230|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  231|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  232|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  233|    */
       |  234|    public func upload(
       |  235|        method: Method,
       |  236|        _ URLString: URLStringConvertible,
       |  237|        headers: [String: String]? = nil,
       |  238|        multipartFormData: MultipartFormData -> Void,
       |  239|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  240|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  241|    {
      0|  242|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  243|
      0|  244|        return upload(
      0|  245|            mutableURLRequest,
      0|  246|            multipartFormData: multipartFormData,
      0|  247|            encodingMemoryThreshold: encodingMemoryThreshold,
      0|  248|            encodingCompletion: encodingCompletion
      0|  249|        )
      0|  250|    }
       |  251|
       |  252|    /**
       |  253|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  254|
       |  255|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
       |  256|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
       |  257|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
       |  258|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
       |  259|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
       |  260|        used for larger payloads such as video content.
       |  261|
       |  262|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
       |  263|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  264|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
       |  265|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
       |  266|        technique was used.
       |  267|
       |  268|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  269|
       |  270|        - parameter URLRequest:              The URL request.
       |  271|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  272|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  273|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  274|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  275|    */
       |  276|    public func upload(
       |  277|        URLRequest: URLRequestConvertible,
       |  278|        multipartFormData: MultipartFormData -> Void,
       |  279|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  280|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  281|    {
      0|  282|        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
      0|  283|            let formData = MultipartFormData()
      0|  284|            multipartFormData(formData)
      0|  285|
      0|  286|            let URLRequestWithContentType = URLRequest.URLRequest
      0|  287|            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
      0|  288|
      0|  289|            let isBackgroundSession = self.session.configuration.identifier != nil
      0|  290|
      0|  291|            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
      0|  292|                do {
      0|  293|                    let data = try formData.encode()
      0|  294|                    let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  295|                        request: self.upload(URLRequestWithContentType, data: data),
      0|  296|                        streamingFromDisk: false,
      0|  297|                        streamFileURL: nil
      0|  298|                    )
      0|  299|
      0|  300|                    dispatch_async(dispatch_get_main_queue()) {
      0|  301|                        encodingCompletion?(encodingResult)
      0|  302|                    }
      0|  303|                } catch {
      0|  304|                    dispatch_async(dispatch_get_main_queue()) {
      0|  305|                        encodingCompletion?(.Failure(error as NSError))
      0|  306|                    }
      0|  307|                }
      0|  308|            } else {
      0|  309|                let fileManager = NSFileManager.defaultManager()
      0|  310|                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
      0|  311|                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
      0|  312|                let fileName = NSUUID().UUIDString
      0|  313|                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
      0|  314|
      0|  315|                do {
      0|  316|                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
      0|  317|                    try formData.writeEncodedDataToDisk(fileURL)
      0|  318|
      0|  319|                    dispatch_async(dispatch_get_main_queue()) {
      0|  320|                        let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  321|                            request: self.upload(URLRequestWithContentType, file: fileURL),
      0|  322|                            streamingFromDisk: true,
      0|  323|                            streamFileURL: fileURL
      0|  324|                        )
      0|  325|                        encodingCompletion?(encodingResult)
      0|  326|                    }
      0|  327|                } catch {
      0|  328|                    dispatch_async(dispatch_get_main_queue()) {
      0|  329|                        encodingCompletion?(.Failure(error as NSError))
      0|  330|                    }
      0|  331|                }
      0|  332|            }
      0|  333|        }
      0|  334|    }
       |  335|}
       |  336|
       |  337|// MARK: -
       |  338|
       |  339|extension Request {
       |  340|
       |  341|    // MARK: - UploadTaskDelegate
       |  342|
       |  343|    class UploadTaskDelegate: DataTaskDelegate {
      0|  344|        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
       |  345|        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
       |  346|
       |  347|        // MARK: - NSURLSessionTaskDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  352|
       |  353|        // MARK: Delegate Methods
       |  354|
       |  355|        func URLSession(
       |  356|            session: NSURLSession,
       |  357|            task: NSURLSessionTask,
       |  358|            didSendBodyData bytesSent: Int64,
       |  359|            totalBytesSent: Int64,
       |  360|            totalBytesExpectedToSend: Int64)
      0|  361|        {
      0|  362|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  363|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  364|            } else {
      0|  365|                progress.totalUnitCount = totalBytesExpectedToSend
      0|  366|                progress.completedUnitCount = totalBytesSent
      0|  367|
      0|  368|                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  369|            }
      0|  370|        }
       |  371|    }
       |  372|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Validation.swift:
       |    1|// Validation.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Request {
       |   26|
       |   27|    /**
       |   28|        Used to represent whether validation was successful or encountered an error resulting in a failure.
       |   29|
       |   30|        - Success: The validation was successful.
       |   31|        - Failure: The validation failed encountering the provided error.
       |   32|    */
       |   33|    public enum ValidationResult {
       |   34|        case Success
       |   35|        case Failure(NSError)
       |   36|    }
       |   37|
       |   38|    /**
       |   39|        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
       |   40|        request was valid.
       |   41|    */
       |   42|    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
       |   43|
       |   44|    /**
       |   45|        Validates the request, using the specified closure.
       |   46|
       |   47|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   48|
       |   49|        - parameter validation: A closure to validate the request.
       |   50|
       |   51|        - returns: The request.
       |   52|    */
      0|   53|    public func validate(validation: Validation) -> Self {
      0|   54|        delegate.queue.addOperationWithBlock {
      0|   55|            if let
      0|   56|                response = self.response where self.delegate.error == nil,
      0|   57|                case let .Failure(error) = validation(self.request, response)
      0|   58|            {
      0|   59|                self.delegate.error = error
      0|   60|            }
      0|   61|        }
      0|   62|
      0|   63|        return self
      0|   64|    }
       |   65|
       |   66|    // MARK: - Status Code
       |   67|
       |   68|    /**
       |   69|        Validates that the response has a status code in the specified range.
       |   70|
       |   71|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   72|
       |   73|        - parameter range: The range of acceptable status codes.
       |   74|
       |   75|        - returns: The request.
       |   76|    */
      0|   77|    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
      0|   78|        return validate { _, response in
      0|   79|            if acceptableStatusCode.contains(response.statusCode) {
      0|   80|                return .Success
      0|   81|            } else {
      0|   82|                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
      0|   83|                return .Failure(Error.errorWithCode(.StatusCodeValidationFailed, failureReason: failureReason))
      0|   84|            }
      0|   85|        }
      0|   86|    }
       |   87|
       |   88|    // MARK: - Content-Type
       |   89|
       |   90|    private struct MIMEType {
       |   91|        let type: String
       |   92|        let subtype: String
       |   93|
      0|   94|        init?(_ string: String) {
      0|   95|            let components: [String] = {
      0|   96|                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
      0|   97|                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
      0|   98|                return split.componentsSeparatedByString("/")
      0|   99|            }()
      0|  100|
      0|  101|            if let
      0|  102|                type = components.first,
      0|  103|                subtype = components.last
      0|  104|            {
      0|  105|                self.type = type
      0|  106|                self.subtype = subtype
      0|  107|            } else {
      0|  108|                return nil
      0|  109|            }
      0|  110|        }
       |  111|
      0|  112|        func matches(MIME: MIMEType) -> Bool {
      0|  113|            switch (type, subtype) {
      0|  114|            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
      0|  115|                return true
      0|  116|            default:
      0|  117|                return false
      0|  118|            }
      0|  119|        }
       |  120|    }
       |  121|
       |  122|    /**
       |  123|        Validates that the response has a content type in the specified array.
       |  124|
       |  125|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  126|
       |  127|        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
       |  128|
       |  129|        - returns: The request.
       |  130|    */
      0|  131|    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
      0|  132|        return validate { _, response in
      0|  133|            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
      0|  134|
      0|  135|            if let
      0|  136|                responseContentType = response.MIMEType,
      0|  137|                responseMIMEType = MIMEType(responseContentType)
      0|  138|            {
      0|  139|                for contentType in acceptableContentTypes {
      0|  140|                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
      0|  141|                        return .Success
      0|  142|                    }
      0|  143|                }
      0|  144|            } else {
      0|  145|                for contentType in acceptableContentTypes {
      0|  146|                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
      0|  147|                        return .Success
      0|  148|                    }
      0|  149|                }
      0|  150|            }
      0|  151|
      0|  152|            let failureReason: String
      0|  153|
      0|  154|            if let responseContentType = response.MIMEType {
      0|  155|                failureReason = (
      0|  156|                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
      0|  157|                    "content types: \(acceptableContentTypes)"
      0|  158|                )
      0|  159|            } else {
      0|  160|                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
      0|  161|            }
      0|  162|
      0|  163|            return .Failure(Error.errorWithCode(.ContentTypeValidationFailed, failureReason: failureReason))
      0|  164|        }
      0|  165|    }
       |  166|
       |  167|    // MARK: - Automatic
       |  168|
       |  169|    /**
       |  170|        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
       |  171|        type matches any specified in the Accept HTTP header field.
       |  172|
       |  173|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  174|
       |  175|        - returns: The request.
       |  176|    */
      0|  177|    public func validate() -> Self {
      0|  178|        let acceptableStatusCodes: Range<Int> = 200..<300
      0|  179|        let acceptableContentTypes: [String] = {
      0|  180|            if let accept = request?.valueForHTTPHeaderField("Accept") {
      0|  181|                return accept.componentsSeparatedByString(",")
      0|  182|            }
      0|  183|
      0|  184|            return ["*/*"]
      0|  185|        }()
      0|  186|
      0|  187|        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
      0|  188|    }
       |  189|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Alamofire.swift:
       |    1|// Alamofire.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: - URLStringConvertible
       |   26|
       |   27|/**
       |   28|    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
       |   29|    construct URL requests.
       |   30|*/
       |   31|public protocol URLStringConvertible {
       |   32|    /**
       |   33|        A URL that conforms to RFC 2396.
       |   34|
       |   35|        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
       |   36|
       |   37|        See https://tools.ietf.org/html/rfc2396
       |   38|        See https://tools.ietf.org/html/rfc1738
       |   39|        See https://tools.ietf.org/html/rfc1808
       |   40|    */
       |   41|    var URLString: String { get }
       |   42|}
       |   43|
       |   44|extension String: URLStringConvertible {
      1|   45|    public var URLString: String {
      1|   46|        return self
      1|   47|    }
       |   48|}
       |   49|
       |   50|extension NSURL: URLStringConvertible {
      0|   51|    public var URLString: String {
      0|   52|        return absoluteString
      0|   53|    }
       |   54|}
       |   55|
       |   56|extension NSURLComponents: URLStringConvertible {
      0|   57|    public var URLString: String {
      0|   58|        return URL!.URLString
      0|   59|    }
       |   60|}
       |   61|
       |   62|extension NSURLRequest: URLStringConvertible {
      0|   63|    public var URLString: String {
      0|   64|        return URL!.URLString
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - URLRequestConvertible
       |   69|
       |   70|/**
       |   71|    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
       |   72|*/
       |   73|public protocol URLRequestConvertible {
       |   74|    /// The URL request.
       |   75|    var URLRequest: NSMutableURLRequest { get }
       |   76|}
       |   77|
       |   78|extension NSURLRequest: URLRequestConvertible {
      2|   79|    public var URLRequest: NSMutableURLRequest {
      2|   80|        return self.mutableCopy() as! NSMutableURLRequest
      2|   81|    }
       |   82|}
       |   83|
       |   84|// MARK: - Convenience
       |   85|
       |   86|func URLRequest(
       |   87|    method: Method,
       |   88|    _ URLString: URLStringConvertible,
       |   89|    headers: [String: String]? = nil)
       |   90|    -> NSMutableURLRequest
      1|   91|{
      1|   92|    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
      1|   93|    mutableURLRequest.HTTPMethod = method.rawValue
      1|   94|
      1|   95|    if let headers = headers {
      2|   96|        for (headerField, headerValue) in headers {
      2|   97|            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
      2|   98|        }
      1|   99|    }
      1|  100|
      1|  101|    return mutableURLRequest
      1|  102|}
       |  103|
       |  104|// MARK: - Request Methods
       |  105|
       |  106|/**
       |  107|    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
       |  108|    parameter encoding.
       |  109|
       |  110|    - parameter method:     The HTTP method.
       |  111|    - parameter URLString:  The URL string.
       |  112|    - parameter parameters: The parameters. `nil` by default.
       |  113|    - parameter encoding:   The parameter encoding. `.URL` by default.
       |  114|    - parameter headers:    The HTTP headers. `nil` by default.
       |  115|
       |  116|    - returns: The created request.
       |  117|*/
       |  118|public func request(
       |  119|    method: Method,
       |  120|    _ URLString: URLStringConvertible,
       |  121|    parameters: [String: AnyObject]? = nil,
       |  122|    encoding: ParameterEncoding = .URL,
       |  123|    headers: [String: String]? = nil)
       |  124|    -> Request
      1|  125|{
      1|  126|    return Manager.sharedInstance.request(
      1|  127|        method,
      1|  128|        URLString,
      1|  129|        parameters: parameters,
      1|  130|        encoding: encoding,
      1|  131|        headers: headers
      1|  132|    )
      1|  133|}
       |  134|
       |  135|/**
       |  136|    Creates a request using the shared manager instance for the specified URL request.
       |  137|
       |  138|    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  139|
       |  140|    - parameter URLRequest: The URL request
       |  141|
       |  142|    - returns: The created request.
       |  143|*/
      0|  144|public func request(URLRequest: URLRequestConvertible) -> Request {
      0|  145|    return Manager.sharedInstance.request(URLRequest.URLRequest)
      0|  146|}
       |  147|
       |  148|// MARK: - Upload Methods
       |  149|
       |  150|// MARK: File
       |  151|
       |  152|/**
       |  153|    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
       |  154|
       |  155|    - parameter method:    The HTTP method.
       |  156|    - parameter URLString: The URL string.
       |  157|    - parameter headers:   The HTTP headers. `nil` by default.
       |  158|    - parameter file:      The file to upload.
       |  159|
       |  160|    - returns: The created upload request.
       |  161|*/
       |  162|public func upload(
       |  163|    method: Method,
       |  164|    _ URLString: URLStringConvertible,
       |  165|    headers: [String: String]? = nil,
       |  166|    file: NSURL)
       |  167|    -> Request
      0|  168|{
      0|  169|    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
      0|  170|}
       |  171|
       |  172|/**
       |  173|    Creates an upload request using the shared manager instance for the specified URL request and file.
       |  174|
       |  175|    - parameter URLRequest: The URL request.
       |  176|    - parameter file:       The file to upload.
       |  177|
       |  178|    - returns: The created upload request.
       |  179|*/
      0|  180|public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|  181|    return Manager.sharedInstance.upload(URLRequest, file: file)
      0|  182|}
       |  183|
       |  184|// MARK: Data
       |  185|
       |  186|/**
       |  187|    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
       |  188|
       |  189|    - parameter method:    The HTTP method.
       |  190|    - parameter URLString: The URL string.
       |  191|    - parameter headers:   The HTTP headers. `nil` by default.
       |  192|    - parameter data:      The data to upload.
       |  193|
       |  194|    - returns: The created upload request.
       |  195|*/
       |  196|public func upload(
       |  197|    method: Method,
       |  198|    _ URLString: URLStringConvertible,
       |  199|    headers: [String: String]? = nil,
       |  200|    data: NSData)
       |  201|    -> Request
      0|  202|{
      0|  203|    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
      0|  204|}
       |  205|
       |  206|/**
       |  207|    Creates an upload request using the shared manager instance for the specified URL request and data.
       |  208|
       |  209|    - parameter URLRequest: The URL request.
       |  210|    - parameter data:       The data to upload.
       |  211|
       |  212|    - returns: The created upload request.
       |  213|*/
      0|  214|public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  215|    return Manager.sharedInstance.upload(URLRequest, data: data)
      0|  216|}
       |  217|
       |  218|// MARK: Stream
       |  219|
       |  220|/**
       |  221|    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
       |  222|
       |  223|    - parameter method:    The HTTP method.
       |  224|    - parameter URLString: The URL string.
       |  225|    - parameter headers:   The HTTP headers. `nil` by default.
       |  226|    - parameter stream:    The stream to upload.
       |  227|
       |  228|    - returns: The created upload request.
       |  229|*/
       |  230|public func upload(
       |  231|    method: Method,
       |  232|    _ URLString: URLStringConvertible,
       |  233|    headers: [String: String]? = nil,
       |  234|    stream: NSInputStream)
       |  235|    -> Request
      0|  236|{
      0|  237|    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
      0|  238|}
       |  239|
       |  240|/**
       |  241|    Creates an upload request using the shared manager instance for the specified URL request and stream.
       |  242|
       |  243|    - parameter URLRequest: The URL request.
       |  244|    - parameter stream:     The stream to upload.
       |  245|
       |  246|    - returns: The created upload request.
       |  247|*/
      0|  248|public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  249|    return Manager.sharedInstance.upload(URLRequest, stream: stream)
      0|  250|}
       |  251|
       |  252|// MARK: MultipartFormData
       |  253|
       |  254|/**
       |  255|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  256|
       |  257|    - parameter method:                  The HTTP method.
       |  258|    - parameter URLString:               The URL string.
       |  259|    - parameter headers:                 The HTTP headers. `nil` by default.
       |  260|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  261|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  262|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  263|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  264|*/
       |  265|public func upload(
       |  266|    method: Method,
       |  267|    _ URLString: URLStringConvertible,
       |  268|    headers: [String: String]? = nil,
       |  269|    multipartFormData: MultipartFormData -> Void,
       |  270|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  271|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  272|{
      0|  273|    return Manager.sharedInstance.upload(
      0|  274|        method,
      0|  275|        URLString,
      0|  276|        headers: headers,
      0|  277|        multipartFormData: multipartFormData,
      0|  278|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  279|        encodingCompletion: encodingCompletion
      0|  280|    )
      0|  281|}
       |  282|
       |  283|/**
       |  284|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  285|
       |  286|    - parameter URLRequest:              The URL request.
       |  287|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  288|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  289|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  290|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  291|*/
       |  292|public func upload(
       |  293|    URLRequest: URLRequestConvertible,
       |  294|    multipartFormData: MultipartFormData -> Void,
       |  295|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  296|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  297|{
      0|  298|    return Manager.sharedInstance.upload(
      0|  299|        URLRequest,
      0|  300|        multipartFormData: multipartFormData,
      0|  301|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  302|        encodingCompletion: encodingCompletion
      0|  303|    )
      0|  304|}
       |  305|
       |  306|// MARK: - Download Methods
       |  307|
       |  308|// MARK: URL Request
       |  309|
       |  310|/**
       |  311|    Creates a download request using the shared manager instance for the specified method and URL string.
       |  312|
       |  313|    - parameter method:      The HTTP method.
       |  314|    - parameter URLString:   The URL string.
       |  315|    - parameter parameters:  The parameters. `nil` by default.
       |  316|    - parameter encoding:    The parameter encoding. `.URL` by default.
       |  317|    - parameter headers:     The HTTP headers. `nil` by default.
       |  318|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  319|
       |  320|    - returns: The created download request.
       |  321|*/
       |  322|public func download(
       |  323|    method: Method,
       |  324|    _ URLString: URLStringConvertible,
       |  325|    parameters: [String: AnyObject]? = nil,
       |  326|    encoding: ParameterEncoding = .URL,
       |  327|    headers: [String: String]? = nil,
       |  328|    destination: Request.DownloadFileDestination)
       |  329|    -> Request
      0|  330|{
      0|  331|    return Manager.sharedInstance.download(
      0|  332|        method,
      0|  333|        URLString,
      0|  334|        parameters: parameters,
      0|  335|        encoding: encoding,
      0|  336|        headers: headers,
      0|  337|        destination: destination
      0|  338|    )
      0|  339|}
       |  340|
       |  341|/**
       |  342|    Creates a download request using the shared manager instance for the specified URL request.
       |  343|
       |  344|    - parameter URLRequest:  The URL request.
       |  345|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  346|
       |  347|    - returns: The created download request.
       |  348|*/
      0|  349|public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  350|    return Manager.sharedInstance.download(URLRequest, destination: destination)
      0|  351|}
       |  352|
       |  353|// MARK: Resume Data
       |  354|
       |  355|/**
       |  356|    Creates a request using the shared manager instance for downloading from the resume data produced from a 
       |  357|    previous request cancellation.
       |  358|
       |  359|    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
       |  360|                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
       |  361|                             information.
       |  362|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  363|
       |  364|    - returns: The created download request.
       |  365|*/
      0|  366|public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  367|    return Manager.sharedInstance.download(data, destination: destination)
      0|  368|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Download.swift:
       |    1|// Download.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Downloadable {
       |   27|        case Request(NSURLRequest)
       |   28|        case ResumeData(NSData)
       |   29|    }
       |   30|
      0|   31|    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
      0|   32|        var downloadTask: NSURLSessionDownloadTask!
      0|   33|
      0|   34|        switch downloadable {
      0|   35|        case .Request(let request):
      0|   36|            dispatch_sync(queue) {
      0|   37|                downloadTask = self.session.downloadTaskWithRequest(request)
      0|   38|            }
      0|   39|        case .ResumeData(let resumeData):
      0|   40|            dispatch_sync(queue) {
      0|   41|                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
      0|   42|            }
      0|   43|        }
      0|   44|
      0|   45|        let request = Request(session: session, task: downloadTask)
      0|   46|
      0|   47|        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
      0|   48|            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
      0|   49|                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
      0|   50|            }
      0|   51|        }
      0|   52|
      0|   53|        delegate[request.delegate.task] = request.delegate
      0|   54|
      0|   55|        if startRequestsImmediately {
      0|   56|            request.resume()
      0|   57|        }
      0|   58|
      0|   59|        return request
      0|   60|    }
       |   61|
       |   62|    // MARK: Request
       |   63|
       |   64|    /**
       |   65|        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
       |   66|        and destination.
       |   67|
       |   68|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   69|
       |   70|        - parameter method:      The HTTP method.
       |   71|        - parameter URLString:   The URL string.
       |   72|        - parameter parameters:  The parameters. `nil` by default.
       |   73|        - parameter encoding:    The parameter encoding. `.URL` by default.
       |   74|        - parameter headers:     The HTTP headers. `nil` by default.
       |   75|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |   76|
       |   77|        - returns: The created download request.
       |   78|    */
       |   79|    public func download(
       |   80|        method: Method,
       |   81|        _ URLString: URLStringConvertible,
       |   82|        parameters: [String: AnyObject]? = nil,
       |   83|        encoding: ParameterEncoding = .URL,
       |   84|        headers: [String: String]? = nil,
       |   85|        destination: Request.DownloadFileDestination)
       |   86|        -> Request
      0|   87|    {
      0|   88|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|   89|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      0|   90|
      0|   91|        return download(encodedURLRequest, destination: destination)
      0|   92|    }
       |   93|
       |   94|    /**
       |   95|        Creates a request for downloading from the specified URL request.
       |   96|
       |   97|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   98|
       |   99|        - parameter URLRequest:  The URL request
       |  100|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  101|
       |  102|        - returns: The created download request.
       |  103|    */
      0|  104|    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  105|        return download(.Request(URLRequest.URLRequest), destination: destination)
      0|  106|    }
       |  107|
       |  108|    // MARK: Resume Data
       |  109|
       |  110|    /**
       |  111|        Creates a request for downloading from the resume data produced from a previous request cancellation.
       |  112|
       |  113|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  114|
       |  115|        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
       |  116|                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
       |  117|                                 additional information.
       |  118|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  119|
       |  120|        - returns: The created download request.
       |  121|    */
      0|  122|    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  123|        return download(.ResumeData(resumeData), destination: destination)
      0|  124|    }
       |  125|}
       |  126|
       |  127|// MARK: -
       |  128|
       |  129|extension Request {
       |  130|    /**
       |  131|        A closure executed once a request has successfully completed in order to determine where to move the temporary 
       |  132|        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
       |  133|        response, and returns a single argument: the file URL where the temporary file should be moved.
       |  134|    */
       |  135|    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
       |  136|
       |  137|    /**
       |  138|        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
       |  139|        file URL in the first available directory with the specified search path directory and search path domain mask.
       |  140|
       |  141|        - parameter directory: The search path directory. `.DocumentDirectory` by default.
       |  142|        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
       |  143|
       |  144|        - returns: A download file destination closure.
       |  145|    */
       |  146|    public class func suggestedDownloadDestination(
       |  147|        directory directory: NSSearchPathDirectory = .DocumentDirectory,
       |  148|        domain: NSSearchPathDomainMask = .UserDomainMask)
       |  149|        -> DownloadFileDestination
      0|  150|    {
      0|  151|        return { temporaryURL, response -> NSURL in
      0|  152|            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
      0|  153|
      0|  154|            if !directoryURLs.isEmpty {
      0|  155|                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
      0|  156|            }
      0|  157|
      0|  158|            return temporaryURL
      0|  159|        }
      0|  160|    }
       |  161|
       |  162|    /// The resume data of the underlying download task if available after a failure.
      0|  163|    public var resumeData: NSData? {
      0|  164|        var data: NSData?
      0|  165|
      0|  166|        if let delegate = delegate as? DownloadTaskDelegate {
      0|  167|            data = delegate.resumeData
      0|  168|        }
      0|  169|
      0|  170|        return data
      0|  171|    }
       |  172|
       |  173|    // MARK: - DownloadTaskDelegate
       |  174|
       |  175|    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
      0|  176|        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
       |  177|        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
       |  178|
       |  179|        var resumeData: NSData?
      0|  180|        override var data: NSData? { return resumeData }
       |  181|
       |  182|        // MARK: - NSURLSessionDownloadDelegate
       |  183|
       |  184|        // MARK: Override Closures
       |  185|
       |  186|        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
       |  187|        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  188|        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  189|
       |  190|        // MARK: Delegate Methods
       |  191|
       |  192|        func URLSession(
       |  193|            session: NSURLSession,
       |  194|            downloadTask: NSURLSessionDownloadTask,
       |  195|            didFinishDownloadingToURL location: NSURL)
      0|  196|        {
      0|  197|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  198|                do {
      0|  199|                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  200|                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
      0|  201|                } catch {
      0|  202|                    self.error = error as NSError
      0|  203|                }
      0|  204|            }
      0|  205|        }
       |  206|
       |  207|        func URLSession(
       |  208|            session: NSURLSession,
       |  209|            downloadTask: NSURLSessionDownloadTask,
       |  210|            didWriteData bytesWritten: Int64,
       |  211|            totalBytesWritten: Int64,
       |  212|            totalBytesExpectedToWrite: Int64)
      0|  213|        {
      0|  214|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  215|                downloadTaskDidWriteData(
      0|  216|                    session,
      0|  217|                    downloadTask,
      0|  218|                    bytesWritten,
      0|  219|                    totalBytesWritten, 
      0|  220|                    totalBytesExpectedToWrite
      0|  221|                )
      0|  222|            } else {
      0|  223|                progress.totalUnitCount = totalBytesExpectedToWrite
      0|  224|                progress.completedUnitCount = totalBytesWritten
      0|  225|
      0|  226|                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  227|            }
      0|  228|        }
       |  229|
       |  230|        func URLSession(
       |  231|            session: NSURLSession,
       |  232|            downloadTask: NSURLSessionDownloadTask,
       |  233|            didResumeAtOffset fileOffset: Int64,
       |  234|            expectedTotalBytes: Int64)
      0|  235|        {
      0|  236|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  237|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  238|            } else {
      0|  239|                progress.totalUnitCount = expectedTotalBytes
      0|  240|                progress.completedUnitCount = fileOffset
      0|  241|            }
      0|  242|        }
       |  243|    }
       |  244|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Error.swift:
       |    1|// Error.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
       |   26|public struct Error {
       |   27|    /// The domain used for creating all Alamofire errors.
       |   28|    public static let Domain = "com.alamofire.error"
       |   29|
       |   30|    /// The custom error codes generated by Alamofire.
       |   31|    public enum Code: Int {
       |   32|        case InputStreamReadFailed           = -6000
       |   33|        case OutputStreamWriteFailed         = -6001
       |   34|        case ContentTypeValidationFailed     = -6002
       |   35|        case StatusCodeValidationFailed      = -6003
       |   36|        case DataSerializationFailed         = -6004
       |   37|        case StringSerializationFailed       = -6005
       |   38|        case JSONSerializationFailed         = -6006
       |   39|        case PropertyListSerializationFailed = -6007
       |   40|    }
       |   41|
       |   42|    /**
       |   43|        Creates an `NSError` with the given error code and failure reason.
       |   44|
       |   45|        - parameter code:          The error code.
       |   46|        - parameter failureReason: The failure reason.
       |   47|
       |   48|        - returns: An `NSError` with the given error code and failure reason.
       |   49|    */
      0|   50|    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
      0|   51|        return errorWithCode(code.rawValue, failureReason: failureReason)
      0|   52|    }
       |   53|
       |   54|    /**
       |   55|        Creates an `NSError` with the given error code and failure reason.
       |   56|
       |   57|        - parameter code:          The error code.
       |   58|        - parameter failureReason: The failure reason.
       |   59|
       |   60|        - returns: An `NSError` with the given error code and failure reason.
       |   61|    */
      0|   62|    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
      0|   63|        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
      0|   64|        return NSError(domain: Domain, code: code, userInfo: userInfo)
      0|   65|    }
       |   66|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Manager.swift:
       |    1|// Manager.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
       |   27|*/
       |   28|public class Manager {
       |   29|
       |   30|    // MARK: - Properties
       |   31|
       |   32|    /**
       |   33|        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
       |   34|        for any ad hoc requests.
       |   35|    */
       |   36|    public static let sharedInstance: Manager = {
       |   37|        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
       |   38|        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
       |   39|
       |   40|        return Manager(configuration: configuration)
       |   41|    }()
       |   42|
       |   43|    /**
       |   44|        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
       |   45|    */
       |   46|    public static let defaultHTTPHeaders: [String: String] = {
       |   47|        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
       |   48|        let acceptEncoding: String = "gzip;q=1.0,compress;q=0.5"
       |   49|
       |   50|        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
       |   51|        let acceptLanguage: String = {
       |   52|            var components: [String] = []
       |   53|            for (index, languageCode) in (NSLocale.preferredLanguages() as [String]).enumerate() {
       |   54|                let q = 1.0 - (Double(index) * 0.1)
       |   55|                components.append("\(languageCode);q=\(q)")
       |   56|                if q <= 0.5 {
       |   57|                    break
       |   58|                }
       |   59|            }
       |   60|
       |   61|            return components.joinWithSeparator(",")
       |   62|        }()
       |   63|
       |   64|        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
       |   65|        let userAgent: String = {
       |   66|            if let info = NSBundle.mainBundle().infoDictionary {
       |   67|                let executable: AnyObject = info[kCFBundleExecutableKey as String] ?? "Unknown"
       |   68|                let bundle: AnyObject = info[kCFBundleIdentifierKey as String] ?? "Unknown"
       |   69|                let version: AnyObject = info[kCFBundleVersionKey as String] ?? "Unknown"
       |   70|                let os: AnyObject = NSProcessInfo.processInfo().operatingSystemVersionString ?? "Unknown"
       |   71|
       |   72|                var mutableUserAgent = NSMutableString(string: "\(executable)/\(bundle) (\(version); OS \(os))") as CFMutableString
       |   73|                let transform = NSString(string: "Any-Latin; Latin-ASCII; [:^ASCII:] Remove") as CFString
       |   74|
       |   75|                if CFStringTransform(mutableUserAgent, UnsafeMutablePointer<CFRange>(nil), transform, false) {
       |   76|                    return mutableUserAgent as String
       |   77|                }
       |   78|            }
       |   79|
       |   80|            return "Alamofire"
       |   81|        }()
       |   82|
       |   83|        return [
       |   84|            "Accept-Encoding": acceptEncoding,
       |   85|            "Accept-Language": acceptLanguage,
       |   86|            "User-Agent": userAgent
       |   87|        ]
       |   88|    }()
       |   89|
       |   90|    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
       |   91|
       |   92|    /// The underlying session.
       |   93|    public let session: NSURLSession
       |   94|
       |   95|    /// The session delegate handling all the task and session delegate callbacks.
       |   96|    public let delegate: SessionDelegate
       |   97|
       |   98|    /// Whether to start requests immediately after being constructed. `true` by default.
       |   99|    public var startRequestsImmediately: Bool = true
       |  100|
       |  101|    /**
       |  102|        The background completion handler closure provided by the UIApplicationDelegate 
       |  103|        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
       |  104|        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
       |  105|        will automatically call the handler.
       |  106|    
       |  107|        If you need to handle your own events before the handler is called, then you need to override the 
       |  108|        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
       |  109|    
       |  110|        `nil` by default.
       |  111|    */
       |  112|    public var backgroundCompletionHandler: (() -> Void)?
       |  113|
       |  114|    // MARK: - Lifecycle
       |  115|
       |  116|    /**
       |  117|        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
       |  118|
       |  119|        - parameter configuration:            The configuration used to construct the managed session. 
       |  120|                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
       |  121|        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
       |  122|                                              default.
       |  123|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
       |  124|                                              challenges. `nil` by default.
       |  125|
       |  126|        - returns: The new `Manager` instance.
       |  127|    */
       |  128|    public init(
       |  129|        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
       |  130|        delegate: SessionDelegate = SessionDelegate(),
       |  131|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      1|  132|    {
      1|  133|        self.delegate = delegate
      1|  134|        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
      1|  135|
      1|  136|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      1|  137|    }
       |  138|
       |  139|    /**
       |  140|        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
       |  141|
       |  142|        - parameter session:                  The URL session.
       |  143|        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
       |  144|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
       |  145|                                              challenges. `nil` by default.
       |  146|
       |  147|        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
       |  148|    */
       |  149|    public init?(
       |  150|        session: NSURLSession,
       |  151|        delegate: SessionDelegate,
       |  152|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      0|  153|    {
      0|  154|        self.delegate = delegate
      0|  155|        self.session = session
      0|  156|
      0|  157|        guard delegate === session.delegate else { return nil }
      0|  158|
      0|  159|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      0|  160|    }
       |  161|
      1|  162|    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
      1|  163|        session.serverTrustPolicyManager = serverTrustPolicyManager
      1|  164|
      0|  165|        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
      0|  166|            guard let strongSelf = self else { return }
      0|  167|            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
      0|  168|        }
      1|  169|    }
       |  170|
      0|  171|    deinit {
      0|  172|        session.invalidateAndCancel()
      0|  173|    }
       |  174|
       |  175|    // MARK: - Request
       |  176|
       |  177|    /**
       |  178|        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
       |  179|
       |  180|        - parameter method:     The HTTP method.
       |  181|        - parameter URLString:  The URL string.
       |  182|        - parameter parameters: The parameters. `nil` by default.
       |  183|        - parameter encoding:   The parameter encoding. `.URL` by default.
       |  184|        - parameter headers:    The HTTP headers. `nil` by default.
       |  185|
       |  186|        - returns: The created request.
       |  187|    */
       |  188|    public func request(
       |  189|        method: Method,
       |  190|        _ URLString: URLStringConvertible,
       |  191|        parameters: [String: AnyObject]? = nil,
       |  192|        encoding: ParameterEncoding = .URL,
       |  193|        headers: [String: String]? = nil)
       |  194|        -> Request
      1|  195|    {
      1|  196|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      1|  197|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      1|  198|        return request(encodedURLRequest)
      1|  199|    }
       |  200|
       |  201|    /**
       |  202|        Creates a request for the specified URL request.
       |  203|
       |  204|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  205|
       |  206|        - parameter URLRequest: The URL request
       |  207|
       |  208|        - returns: The created request.
       |  209|    */
      1|  210|    public func request(URLRequest: URLRequestConvertible) -> Request {
      1|  211|        var dataTask: NSURLSessionDataTask!
      1|  212|        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
      1|  213|
      1|  214|        let request = Request(session: session, task: dataTask)
      1|  215|        delegate[request.delegate.task] = request.delegate
      1|  216|
      1|  217|        if startRequestsImmediately {
      1|  218|            request.resume()
      1|  219|        }
      1|  220|
      1|  221|        return request
      1|  222|    }
      1|  223|
      1|  224|    // MARK: - SessionDelegate
      1|  225|
       |  226|    /**
       |  227|        Responsible for handling all delegate callbacks for the underlying session.
       |  228|    */
       |  229|    public final class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
       |  230|        private var subdelegates: [Int: Request.TaskDelegate] = [:]
       |  231|        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
       |  232|
       |  233|        subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
       |  234|            get {
       |  235|                var subdelegate: Request.TaskDelegate?
       |  236|                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
      4|  237|
      4|  238|                return subdelegate
      4|  239|            }
      4|  240|
      4|  241|            set {
      4|  242|                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
      4|  243|            }
      4|  244|        }
       |  245|
      2|  246|        /**
      2|  247|            Initializes the `SessionDelegate` instance.
      2|  248|
      2|  249|            - returns: The new `SessionDelegate` instance.
      2|  250|        */
       |  251|        public override init() {
       |  252|            super.init()
       |  253|        }
       |  254|
       |  255|        // MARK: - NSURLSessionDelegate
       |  256|
       |  257|        // MARK: Override Closures
      1|  258|
      1|  259|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
      1|  260|        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
       |  261|
       |  262|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
       |  263|        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  264|
       |  265|        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
       |  266|        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
       |  267|
       |  268|        // MARK: Delegate Methods
       |  269|
       |  270|        /**
       |  271|            Tells the delegate that the session has been invalidated.
       |  272|
       |  273|            - parameter session: The session object that was invalidated.
       |  274|            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
       |  275|        */
       |  276|        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
       |  277|            sessionDidBecomeInvalidWithError?(session, error)
       |  278|        }
       |  279|
       |  280|        /**
       |  281|            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
       |  282|
      0|  283|            - parameter session:           The session containing the task that requested authentication.
      0|  284|            - parameter challenge:         An object that contains the request for authentication.
      0|  285|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  286|        */
       |  287|        public func URLSession(
       |  288|            session: NSURLSession,
       |  289|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  290|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
       |  291|        {
       |  292|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
       |  293|            var credential: NSURLCredential?
       |  294|
       |  295|            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
       |  296|                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
       |  297|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      0|  298|                let host = challenge.protectionSpace.host
      0|  299|
      0|  300|                if let
      0|  301|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      0|  302|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  303|                {
      0|  304|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  305|                        disposition = .UseCredential
      0|  306|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  307|                    } else {
      0|  308|                        disposition = .CancelAuthenticationChallenge
      0|  309|                    }
      0|  310|                }
      0|  311|            }
      0|  312|
      0|  313|            completionHandler(disposition, credential)
      0|  314|        }
      0|  315|
      0|  316|        /**
      0|  317|            Tells the delegate that all messages enqueued for a session have been delivered.
      0|  318|
      0|  319|            - parameter session: The session that no longer has any outstanding requests.
      0|  320|        */
      0|  321|        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
       |  322|            sessionDidFinishEventsForBackgroundURLSession?(session)
       |  323|        }
       |  324|
       |  325|        // MARK: - NSURLSessionTaskDelegate
       |  326|
       |  327|        // MARK: Override Closures
      0|  328|
      0|  329|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
      0|  330|        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  331|
       |  332|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
       |  333|        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  334|
       |  335|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
       |  336|        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream!)?
       |  337|
       |  338|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
       |  339|        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  340|
       |  341|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
       |  342|        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  343|
       |  344|        // MARK: Delegate Methods
       |  345|
       |  346|        /**
       |  347|            Tells the delegate that the remote server requested an HTTP redirect.
       |  348|
       |  349|            - parameter session:           The session containing the task whose request resulted in a redirect.
       |  350|            - parameter task:              The task whose request resulted in a redirect.
       |  351|            - parameter response:          An object containing the server’s response to the original request.
       |  352|            - parameter request:           A URL request object filled out with the new location.
       |  353|            - parameter completionHandler: A closure that your handler should call with either the value of the request 
       |  354|                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
       |  355|                                           return the body of the redirect response.
       |  356|        */
       |  357|        public func URLSession(
       |  358|            session: NSURLSession,
       |  359|            task: NSURLSessionTask,
       |  360|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  361|            newRequest request: NSURLRequest,
       |  362|            completionHandler: ((NSURLRequest?) -> Void))
       |  363|        {
       |  364|            var redirectRequest: NSURLRequest? = request
       |  365|
       |  366|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
       |  367|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
       |  368|            }
       |  369|
      0|  370|            completionHandler(redirectRequest)
      0|  371|        }
      0|  372|
      0|  373|        /**
      0|  374|            Requests credentials from the delegate in response to an authentication request from the remote server.
      0|  375|
      0|  376|            - parameter session:           The session containing the task whose request requires authentication.
      0|  377|            - parameter task:              The task whose request requires authentication.
      0|  378|            - parameter challenge:         An object that contains the request for authentication.
       |  379|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  380|        */
       |  381|        public func URLSession(
       |  382|            session: NSURLSession,
       |  383|            task: NSURLSessionTask,
       |  384|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  385|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
       |  386|        {
       |  387|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
       |  388|                completionHandler(taskDidReceiveChallenge(session, task, challenge))
       |  389|            } else if let delegate = self[task] {
       |  390|                delegate.URLSession(
       |  391|                    session,
       |  392|                    task: task,
      1|  393|                    didReceiveChallenge: challenge,
      0|  394|                    completionHandler: completionHandler
      0|  395|                )
      1|  396|            } else {
      1|  397|                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
      1|  398|            }
      1|  399|        }
      1|  400|
      1|  401|        /**
      1|  402|            Tells the delegate when a task requires a new request body stream to send to the remote server.
      0|  403|
      0|  404|            - parameter session:           The session containing the task that needs a new body stream.
      0|  405|            - parameter task:              The task that needs a new body stream.
      1|  406|            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
       |  407|        */
       |  408|        public func URLSession(
       |  409|            session: NSURLSession,
       |  410|            task: NSURLSessionTask,
       |  411|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
       |  412|        {
       |  413|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
       |  414|                completionHandler(taskNeedNewBodyStream(session, task))
       |  415|            } else if let delegate = self[task] {
       |  416|                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
       |  417|            }
       |  418|        }
      0|  419|
      0|  420|        /**
      0|  421|            Periodically informs the delegate of the progress of sending body content to the server.
      0|  422|
      0|  423|            - parameter session:                  The session containing the data task.
      0|  424|            - parameter task:                     The data task.
      0|  425|            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
       |  426|            - parameter totalBytesSent:           The total number of bytes sent so far.
       |  427|            - parameter totalBytesExpectedToSend: The expected length of the body data.
       |  428|        */
       |  429|        public func URLSession(
       |  430|            session: NSURLSession,
       |  431|            task: NSURLSessionTask,
       |  432|            didSendBodyData bytesSent: Int64,
       |  433|            totalBytesSent: Int64,
       |  434|            totalBytesExpectedToSend: Int64)
       |  435|        {
       |  436|            if let taskDidSendBodyData = taskDidSendBodyData {
       |  437|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
       |  438|            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
       |  439|                delegate.URLSession(
       |  440|                    session,
       |  441|                    task: task,
      1|  442|                    didSendBodyData: bytesSent,
      0|  443|                    totalBytesSent: totalBytesSent,
      0|  444|                    totalBytesExpectedToSend: totalBytesExpectedToSend
      0|  445|                )
      0|  446|            }
      0|  447|        }
      0|  448|
      0|  449|        /**
      0|  450|            Tells the delegate that the task finished transferring data.
      0|  451|
      0|  452|            - parameter session: The session containing the task whose request finished transferring data.
      0|  453|            - parameter task:    The task whose request finished transferring data.
      1|  454|            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
       |  455|        */
       |  456|        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
       |  457|            if let taskDidComplete = taskDidComplete {
       |  458|                taskDidComplete(session, task, error)
       |  459|            } else if let delegate = self[task] {
       |  460|                delegate.URLSession(session, task: task, didCompleteWithError: error)
       |  461|            }
       |  462|
      1|  463|            self[task] = nil
      0|  464|        }
      0|  465|
      1|  466|        // MARK: - NSURLSessionDataDelegate
      1|  467|
      1|  468|        // MARK: Override Closures
      1|  469|
      1|  470|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
      1|  471|        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  472|
       |  473|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
       |  474|        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  475|
       |  476|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
       |  477|        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  478|
       |  479|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
       |  480|        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse!)?
       |  481|
       |  482|        // MARK: Delegate Methods
       |  483|
       |  484|        /**
       |  485|            Tells the delegate that the data task received the initial reply (headers) from the server.
       |  486|
       |  487|            - parameter session:           The session containing the data task that received an initial reply.
       |  488|            - parameter dataTask:          The data task that received an initial reply.
       |  489|            - parameter response:          A URL response object populated with headers.
       |  490|            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
       |  491|                                           constant to indicate whether the transfer should continue as a data task or 
       |  492|                                           should become a download task.
       |  493|        */
       |  494|        public func URLSession(
       |  495|            session: NSURLSession,
       |  496|            dataTask: NSURLSessionDataTask,
       |  497|            didReceiveResponse response: NSURLResponse,
       |  498|            completionHandler: ((NSURLSessionResponseDisposition) -> Void))
       |  499|        {
       |  500|            var disposition: NSURLSessionResponseDisposition = .Allow
       |  501|
       |  502|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
       |  503|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
       |  504|            }
       |  505|
      0|  506|            completionHandler(disposition)
      0|  507|        }
      0|  508|
      0|  509|        /**
      0|  510|            Tells the delegate that the data task was changed to a download task.
      0|  511|
      0|  512|            - parameter session:      The session containing the task that was replaced by a download task.
      0|  513|            - parameter dataTask:     The data task that was replaced by a download task.
      0|  514|            - parameter downloadTask: The new download task that replaced the data task.
       |  515|        */
       |  516|        public func URLSession(
       |  517|            session: NSURLSession,
       |  518|            dataTask: NSURLSessionDataTask,
       |  519|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
       |  520|        {
       |  521|            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
       |  522|                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
       |  523|            } else {
       |  524|                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
       |  525|                self[downloadTask] = downloadDelegate
       |  526|            }
      0|  527|        }
      0|  528|
      0|  529|        /**
      0|  530|            Tells the delegate that the data task has received some of the expected data.
      0|  531|
      0|  532|            - parameter session:  The session containing the data task that provided data.
      0|  533|            - parameter dataTask: The data task that provided data.
      0|  534|            - parameter data:     A data object containing the transferred data.
       |  535|        */
       |  536|        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
       |  537|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
       |  538|                dataTaskDidReceiveData(session, dataTask, data)
       |  539|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
       |  540|                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
       |  541|            }
       |  542|        }
      1|  543|
      0|  544|        /**
      0|  545|            Asks the delegate whether the data (or upload) task should store the response in the cache.
      1|  546|
      1|  547|            - parameter session:           The session containing the data (or upload) task.
      1|  548|            - parameter dataTask:          The data (or upload) task.
      1|  549|            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
       |  550|                                           caching policy and the values of certain received headers, such as the Pragma 
       |  551|                                           and Cache-Control headers.
       |  552|            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
       |  553|                                           response, a modified version of that response, or NULL to prevent caching the 
       |  554|                                           response. If your delegate implements this method, it must call this completion 
       |  555|                                           handler; otherwise, your app leaks memory.
       |  556|        */
       |  557|        public func URLSession(
       |  558|            session: NSURLSession,
       |  559|            dataTask: NSURLSessionDataTask,
       |  560|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  561|            completionHandler: ((NSCachedURLResponse?) -> Void))
       |  562|        {
       |  563|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
       |  564|                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
       |  565|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
       |  566|                delegate.URLSession(
       |  567|                    session,
       |  568|                    dataTask: dataTask,
      0|  569|                    willCacheResponse: proposedResponse,
      0|  570|                    completionHandler: completionHandler
      0|  571|                )
      0|  572|            } else {
      0|  573|                completionHandler(proposedResponse)
      0|  574|            }
      0|  575|        }
      0|  576|
      0|  577|        // MARK: - NSURLSessionDownloadDelegate
      0|  578|
      0|  579|        // MARK: Override Closures
      0|  580|
      0|  581|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
      0|  582|        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
       |  583|
       |  584|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
       |  585|        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  586|
       |  587|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
       |  588|        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  589|
       |  590|        // MARK: Delegate Methods
       |  591|
       |  592|        /**
       |  593|            Tells the delegate that a download task has finished downloading.
       |  594|
       |  595|            - parameter session:      The session containing the download task that finished.
       |  596|            - parameter downloadTask: The download task that finished.
       |  597|            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
       |  598|                                      open the file for reading or move it to a permanent location in your app’s sandbox 
       |  599|                                      container directory before returning from this delegate method.
       |  600|        */
       |  601|        public func URLSession(
       |  602|            session: NSURLSession,
       |  603|            downloadTask: NSURLSessionDownloadTask,
       |  604|            didFinishDownloadingToURL location: NSURL)
       |  605|        {
       |  606|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
       |  607|                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
       |  608|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  609|                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
       |  610|            }
       |  611|        }
      0|  612|
      0|  613|        /**
      0|  614|            Periodically informs the delegate about the download’s progress.
      0|  615|
      0|  616|            - parameter session:                   The session containing the download task.
      0|  617|            - parameter downloadTask:              The download task.
      0|  618|            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
       |  619|                                                   method was called.
       |  620|            - parameter totalBytesWritten:         The total number of bytes transferred so far.
       |  621|            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
       |  622|                                                   header. If this header was not provided, the value is 
       |  623|                                                   `NSURLSessionTransferSizeUnknown`.
       |  624|        */
       |  625|        public func URLSession(
       |  626|            session: NSURLSession,
       |  627|            downloadTask: NSURLSessionDownloadTask,
       |  628|            didWriteData bytesWritten: Int64,
       |  629|            totalBytesWritten: Int64,
       |  630|            totalBytesExpectedToWrite: Int64)
       |  631|        {
       |  632|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
       |  633|                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
       |  634|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  635|                delegate.URLSession(
       |  636|                    session,
       |  637|                    downloadTask: downloadTask,
      0|  638|                    didWriteData: bytesWritten,
      0|  639|                    totalBytesWritten: totalBytesWritten,
      0|  640|                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
      0|  641|                )
      0|  642|            }
      0|  643|        }
      0|  644|
      0|  645|        /**
      0|  646|            Tells the delegate that the download task has resumed downloading.
      0|  647|
      0|  648|            - parameter session:            The session containing the download task that finished.
      0|  649|            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
      0|  650|            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
       |  651|                                            existing content, then this value is zero. Otherwise, this value is an 
       |  652|                                            integer representing the number of bytes on disk that do not need to be 
       |  653|                                            retrieved again.
       |  654|            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
       |  655|                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
       |  656|        */
       |  657|        public func URLSession(
       |  658|            session: NSURLSession,
       |  659|            downloadTask: NSURLSessionDownloadTask,
       |  660|            didResumeAtOffset fileOffset: Int64,
       |  661|            expectedTotalBytes: Int64)
       |  662|        {
       |  663|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
       |  664|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
       |  665|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  666|                delegate.URLSession(
       |  667|                    session,
       |  668|                    downloadTask: downloadTask,
      0|  669|                    didResumeAtOffset: fileOffset,
      0|  670|                    expectedTotalBytes: expectedTotalBytes
      0|  671|                )
      0|  672|            }
      0|  673|        }
      0|  674|
      0|  675|        // MARK: - NSURLSessionStreamDelegate
      0|  676|
      0|  677|        var _streamTaskReadClosed: Any?
      0|  678|        var _streamTaskWriteClosed: Any?
      0|  679|        var _streamTaskBetterRouteDiscovered: Any?
      0|  680|        var _streamTaskDidBecomeInputStream: Any?
       |  681|
       |  682|        // MARK: - NSObject
       |  683|
       |  684|        public override func respondsToSelector(selector: Selector) -> Bool {
       |  685|            switch selector {
       |  686|            case "URLSession:didBecomeInvalidWithError:":
       |  687|                return sessionDidBecomeInvalidWithError != nil
       |  688|            case "URLSession:didReceiveChallenge:completionHandler:":
       |  689|                return sessionDidReceiveChallenge != nil
       |  690|            case "URLSessionDidFinishEventsForBackgroundURLSession:":
     11|  691|                return sessionDidFinishEventsForBackgroundURLSession != nil
     11|  692|            case "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:":
      0|  693|                return taskWillPerformHTTPRedirection != nil
      0|  694|            case "URLSession:dataTask:didReceiveResponse:completionHandler:":
      1|  695|                return dataTaskDidReceiveResponse != nil
      1|  696|            default:
      0|  697|                return self.dynamicType.instancesRespondToSelector(selector)
      0|  698|            }
      0|  699|        }
      0|  700|    }
      1|  701|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/MultipartFormData.swift:
       |    1|// MultipartFormData.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if os(iOS) || os(watchOS) || os(tvOS)
       |   26|import MobileCoreServices
       |   27|#elseif os(OSX)
       |   28|import CoreServices
       |   29|#endif
       |   30|
       |   31|/**
       |   32|    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
       |   33|    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
       |   34|    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
       |   35|    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
       |   36|    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
       |   37|
       |   38|    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
       |   39|    and the w3 form documentation.
       |   40|
       |   41|    - https://www.ietf.org/rfc/rfc2388.txt
       |   42|    - https://www.ietf.org/rfc/rfc2045.txt
       |   43|    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
       |   44|*/
       |   45|public class MultipartFormData {
       |   46|
       |   47|    // MARK: - Helper Types
       |   48|
       |   49|    struct EncodingCharacters {
       |   50|        static let CRLF = "\r\n"
       |   51|    }
       |   52|
       |   53|    struct BoundaryGenerator {
       |   54|        enum BoundaryType {
       |   55|            case Initial, Encapsulated, Final
       |   56|        }
       |   57|
      0|   58|        static func randomBoundary() -> String {
      0|   59|            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
      0|   60|        }
       |   61|
      0|   62|        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
      0|   63|            let boundaryText: String
      0|   64|
      0|   65|            switch boundaryType {
      0|   66|            case .Initial:
      0|   67|                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
      0|   68|            case .Encapsulated:
      0|   69|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
      0|   70|            case .Final:
      0|   71|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
      0|   72|            }
      0|   73|
      0|   74|            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|   75|        }
       |   76|    }
       |   77|
       |   78|    class BodyPart {
       |   79|        let headers: [String: String]
       |   80|        let bodyStream: NSInputStream
       |   81|        let bodyContentLength: UInt64
       |   82|        var hasInitialBoundary = false
       |   83|        var hasFinalBoundary = false
       |   84|
      0|   85|        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
      0|   86|            self.headers = headers
      0|   87|            self.bodyStream = bodyStream
      0|   88|            self.bodyContentLength = bodyContentLength
      0|   89|        }
       |   90|    }
       |   91|
       |   92|    // MARK: - Properties
       |   93|
       |   94|    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
      0|   95|    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
       |   96|
       |   97|    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
      0|   98|    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
       |   99|
       |  100|    /// The boundary used to separate the body parts in the encoded form data.
       |  101|    public let boundary: String
       |  102|
       |  103|    private var bodyParts: [BodyPart]
       |  104|    private var bodyPartError: NSError?
       |  105|    private let streamBufferSize: Int
       |  106|
       |  107|    // MARK: - Lifecycle
       |  108|
       |  109|    /**
       |  110|        Creates a multipart form data object.
       |  111|
       |  112|        - returns: The multipart form data object.
       |  113|    */
      0|  114|    public init() {
      0|  115|        self.boundary = BoundaryGenerator.randomBoundary()
      0|  116|        self.bodyParts = []
      0|  117|
      0|  118|        /**
      0|  119|         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
      0|  120|         *  information, please refer to the following article:
      0|  121|         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
      0|  122|         */
      0|  123|
      0|  124|        self.streamBufferSize = 1024
      0|  125|    }
       |  126|
       |  127|    // MARK: - Body Parts
       |  128|
       |  129|    /**
       |  130|        Creates a body part from the data and appends it to the multipart form data object.
       |  131|
       |  132|        The body part data will be encoded using the following format:
       |  133|
       |  134|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  135|        - Encoded data
       |  136|        - Multipart form boundary
       |  137|
       |  138|        - parameter data: The data to encode into the multipart form data.
       |  139|        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
       |  140|    */
      0|  141|    public func appendBodyPart(data data: NSData, name: String) {
      0|  142|        let headers = contentHeaders(name: name)
      0|  143|        let stream = NSInputStream(data: data)
      0|  144|        let length = UInt64(data.length)
      0|  145|
      0|  146|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  147|    }
       |  148|
       |  149|    /**
       |  150|        Creates a body part from the data and appends it to the multipart form data object.
       |  151|
       |  152|        The body part data will be encoded using the following format:
       |  153|
       |  154|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  155|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  156|        - Encoded data
       |  157|        - Multipart form boundary
       |  158|
       |  159|        - parameter data:     The data to encode into the multipart form data.
       |  160|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  161|        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
       |  162|    */
      0|  163|    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
      0|  164|        let headers = contentHeaders(name: name, mimeType: mimeType)
      0|  165|        let stream = NSInputStream(data: data)
      0|  166|        let length = UInt64(data.length)
      0|  167|
      0|  168|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  169|    }
       |  170|
       |  171|    /**
       |  172|        Creates a body part from the data and appends it to the multipart form data object.
       |  173|
       |  174|        The body part data will be encoded using the following format:
       |  175|
       |  176|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  177|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  178|        - Encoded file data
       |  179|        - Multipart form boundary
       |  180|
       |  181|        - parameter data:     The data to encode into the multipart form data.
       |  182|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  183|        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
       |  184|        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
       |  185|    */
      0|  186|    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
      0|  187|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  188|        let stream = NSInputStream(data: data)
      0|  189|        let length = UInt64(data.length)
      0|  190|
      0|  191|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Creates a body part from the file and appends it to the multipart form data object.
       |  196|
       |  197|        The body part data will be encoded using the following format:
       |  198|
       |  199|        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
       |  200|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  201|        - Encoded file data
       |  202|        - Multipart form boundary
       |  203|
       |  204|        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
       |  205|        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
       |  206|        system associated MIME type.
       |  207|
       |  208|        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
       |  209|        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  210|    */
      0|  211|    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
      0|  212|        if let
      0|  213|            fileName = fileURL.lastPathComponent,
      0|  214|            pathExtension = fileURL.pathExtension
      0|  215|        {
      0|  216|            let mimeType = mimeTypeForPathExtension(pathExtension)
      0|  217|            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
      0|  218|        } else {
      0|  219|            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
      0|  220|            setBodyPartError(Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason))
      0|  221|        }
      0|  222|    }
       |  223|
       |  224|    /**
       |  225|        Creates a body part from the file and appends it to the multipart form data object.
       |  226|
       |  227|        The body part data will be encoded using the following format:
       |  228|
       |  229|        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
       |  230|        - Content-Type: #{mimeType} (HTTP Header)
       |  231|        - Encoded file data
       |  232|        - Multipart form boundary
       |  233|
       |  234|        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
       |  235|        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  236|        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
       |  237|        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
       |  238|    */
      0|  239|    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
      0|  240|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  241|
      0|  242|        //============================================================
      0|  243|        //                 Check 1 - is file URL?
      0|  244|        //============================================================
      0|  245|
      0|  246|        guard fileURL.fileURL else {
      0|  247|            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
      0|  248|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  249|            setBodyPartError(error)
      0|  250|            return
      0|  251|        }
      0|  252|
      0|  253|        //============================================================
      0|  254|        //              Check 2 - is file URL reachable?
      0|  255|        //============================================================
      0|  256|
      0|  257|        var isReachable = true
      0|  258|
      0|  259|        if #available(OSX 10.10, *) {
      0|  260|            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
      0|  261|        }
      0|  262|
      0|  263|        guard isReachable else {
      0|  264|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
      0|  265|            setBodyPartError(error)
      0|  266|            return
      0|  267|        }
      0|  268|
      0|  269|        //============================================================
      0|  270|        //            Check 3 - is file URL a directory?
      0|  271|        //============================================================
      0|  272|
      0|  273|        var isDirectory: ObjCBool = false
      0|  274|
      0|  275|        guard let
      0|  276|            path = fileURL.path
      0|  277|            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
      0|  278|        {
      0|  279|            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
      0|  280|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  281|            setBodyPartError(error)
      0|  282|            return
      0|  283|        }
      0|  284|
      0|  285|        //============================================================
      0|  286|        //          Check 4 - can the file size be extracted?
      0|  287|        //============================================================
      0|  288|
      0|  289|        var bodyContentLength: UInt64?
      0|  290|
      0|  291|        do {
      0|  292|            if let
      0|  293|                path = fileURL.path,
      0|  294|                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
      0|  295|            {
      0|  296|                bodyContentLength = fileSize.unsignedLongLongValue
      0|  297|            }
      0|  298|        } catch {
      0|  299|            // No-op
      0|  300|        }
      0|  301|
      0|  302|        guard let length = bodyContentLength else {
      0|  303|            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
      0|  304|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  305|            setBodyPartError(error)
      0|  306|            return
      0|  307|        }
      0|  308|
      0|  309|        //============================================================
      0|  310|        //       Check 5 - can a stream be created from file URL?
      0|  311|        //============================================================
      0|  312|
      0|  313|        guard let stream = NSInputStream(URL: fileURL) else {
      0|  314|            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
      0|  315|            let error = Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  316|            setBodyPartError(error)
      0|  317|            return
      0|  318|        }
      0|  319|
      0|  320|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  321|    }
       |  322|
       |  323|    /**
       |  324|        Creates a body part from the stream and appends it to the multipart form data object.
       |  325|
       |  326|        The body part data will be encoded using the following format:
       |  327|
       |  328|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  329|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  330|        - Encoded stream data
       |  331|        - Multipart form boundary
       |  332|
       |  333|        - parameter stream:   The input stream to encode in the multipart form data.
       |  334|        - parameter length:   The content length of the stream.
       |  335|        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
       |  336|        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
       |  337|        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
       |  338|    */
       |  339|    public func appendBodyPart(
       |  340|        stream stream: NSInputStream,
       |  341|        length: UInt64,
       |  342|        name: String,
       |  343|        fileName: String,
       |  344|        mimeType: String)
      0|  345|    {
      0|  346|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  347|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  348|    }
       |  349|
       |  350|    /**
       |  351|        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
       |  352|
       |  353|        The body part data will be encoded using the following format:
       |  354|
       |  355|        - HTTP headers
       |  356|        - Encoded stream data
       |  357|        - Multipart form boundary
       |  358|
       |  359|        - parameter stream:  The input stream to encode in the multipart form data.
       |  360|        - parameter length:  The content length of the stream.
       |  361|        - parameter headers: The HTTP headers for the body part.
       |  362|    */
      0|  363|    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
      0|  364|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
      0|  365|        bodyParts.append(bodyPart)
      0|  366|    }
       |  367|
       |  368|    // MARK: - Data Encoding
       |  369|
       |  370|    /**
       |  371|        Encodes all the appended body parts into a single `NSData` object.
       |  372|
       |  373|        It is important to note that this method will load all the appended body parts into memory all at the same 
       |  374|        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
       |  375|        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
       |  376|
       |  377|        - throws: An `NSError` if encoding encounters an error.
       |  378|
       |  379|        - returns: The encoded `NSData` if encoding is successful.
       |  380|    */
      0|  381|    public func encode() throws -> NSData {
      0|  382|        if let bodyPartError = bodyPartError {
      0|  383|            throw bodyPartError
      0|  384|        }
      0|  385|
      0|  386|        let encoded = NSMutableData()
      0|  387|
      0|  388|        bodyParts.first?.hasInitialBoundary = true
      0|  389|        bodyParts.last?.hasFinalBoundary = true
      0|  390|
      0|  391|        for bodyPart in bodyParts {
      0|  392|            let encodedData = try encodeBodyPart(bodyPart)
      0|  393|            encoded.appendData(encodedData)
      0|  394|        }
      0|  395|
      0|  396|        return encoded
      0|  397|    }
       |  398|
       |  399|    /**
       |  400|        Writes the appended body parts into the given file URL.
       |  401|
       |  402|        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
       |  403|        this approach is very memory efficient and should be used for large body part data.
       |  404|
       |  405|        - parameter fileURL: The file URL to write the multipart form data into.
       |  406|
       |  407|        - throws: An `NSError` if encoding encounters an error.
       |  408|    */
      0|  409|    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
      0|  410|        if let bodyPartError = bodyPartError {
      0|  411|            throw bodyPartError
      0|  412|        }
      0|  413|
      0|  414|        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
      0|  415|            let failureReason = "A file already exists at the given file URL: \(fileURL)"
      0|  416|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  417|        } else if !fileURL.fileURL {
      0|  418|            let failureReason = "The URL does not point to a valid file: \(fileURL)"
      0|  419|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  420|        }
      0|  421|
      0|  422|        let outputStream: NSOutputStream
      0|  423|
      0|  424|        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
      0|  425|            outputStream = possibleOutputStream
      0|  426|        } else {
      0|  427|            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
      0|  428|            throw Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  429|        }
      0|  430|
      0|  431|        outputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  432|        outputStream.open()
      0|  433|
      0|  434|        self.bodyParts.first?.hasInitialBoundary = true
      0|  435|        self.bodyParts.last?.hasFinalBoundary = true
      0|  436|
      0|  437|        for bodyPart in self.bodyParts {
      0|  438|            try writeBodyPart(bodyPart, toOutputStream: outputStream)
      0|  439|        }
      0|  440|
      0|  441|        outputStream.close()
      0|  442|        outputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  443|    }
       |  444|
       |  445|    // MARK: - Private - Body Part Encoding
       |  446|
      0|  447|    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  448|        let encoded = NSMutableData()
      0|  449|
      0|  450|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  451|        encoded.appendData(initialData)
      0|  452|
      0|  453|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  454|        encoded.appendData(headerData)
      0|  455|
      0|  456|        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
      0|  457|        encoded.appendData(bodyStreamData)
      0|  458|
      0|  459|        if bodyPart.hasFinalBoundary {
      0|  460|            encoded.appendData(finalBoundaryData())
      0|  461|        }
      0|  462|
      0|  463|        return encoded
      0|  464|    }
       |  465|
      0|  466|    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
      0|  467|        var headerText = ""
      0|  468|
      0|  469|        for (key, value) in bodyPart.headers {
      0|  470|            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
      0|  471|        }
      0|  472|        headerText += EncodingCharacters.CRLF
      0|  473|
      0|  474|        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|  475|    }
       |  476|
      0|  477|    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  478|        let inputStream = bodyPart.bodyStream
      0|  479|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  480|        inputStream.open()
      0|  481|
      0|  482|        var error: NSError?
      0|  483|        let encoded = NSMutableData()
      0|  484|
      0|  485|        while inputStream.hasBytesAvailable {
      0|  486|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  487|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  488|
      0|  489|            if inputStream.streamError != nil {
      0|  490|                error = inputStream.streamError
      0|  491|                break
      0|  492|            }
      0|  493|
      0|  494|            if bytesRead > 0 {
      0|  495|                encoded.appendBytes(buffer, length: bytesRead)
      0|  496|            } else if bytesRead < 0 {
      0|  497|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  498|                error = Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  499|                break
      0|  500|            } else {
      0|  501|                break
      0|  502|            }
      0|  503|        }
      0|  504|
      0|  505|        inputStream.close()
      0|  506|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  507|
      0|  508|        if let error = error {
      0|  509|            throw error
      0|  510|        }
      0|  511|
      0|  512|        return encoded
      0|  513|    }
       |  514|
       |  515|    // MARK: - Private - Writing Body Part to Output Stream
       |  516|
      0|  517|    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  518|        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  519|        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  520|        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  521|        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  522|    }
       |  523|
       |  524|    private func writeInitialBoundaryDataForBodyPart(
       |  525|        bodyPart: BodyPart,
       |  526|        toOutputStream outputStream: NSOutputStream)
       |  527|        throws
      0|  528|    {
      0|  529|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  530|        return try writeData(initialData, toOutputStream: outputStream)
      0|  531|    }
       |  532|
      0|  533|    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  534|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  535|        return try writeData(headerData, toOutputStream: outputStream)
      0|  536|    }
       |  537|
      0|  538|    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  539|        let inputStream = bodyPart.bodyStream
      0|  540|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  541|        inputStream.open()
      0|  542|
      0|  543|        while inputStream.hasBytesAvailable {
      0|  544|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  545|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  546|
      0|  547|            if let streamError = inputStream.streamError {
      0|  548|                throw streamError
      0|  549|            }
      0|  550|
      0|  551|            if bytesRead > 0 {
      0|  552|                if buffer.count != bytesRead {
      0|  553|                    buffer = Array(buffer[0..<bytesRead])
      0|  554|                }
      0|  555|
      0|  556|                try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  557|            } else if bytesRead < 0 {
      0|  558|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  559|                throw Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  560|            } else {
      0|  561|                break
      0|  562|            }
      0|  563|        }
      0|  564|
      0|  565|        inputStream.close()
      0|  566|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  567|    }
       |  568|
       |  569|    private func writeFinalBoundaryDataForBodyPart(
       |  570|        bodyPart: BodyPart,
       |  571|        toOutputStream outputStream: NSOutputStream)
       |  572|        throws
      0|  573|    {
      0|  574|        if bodyPart.hasFinalBoundary {
      0|  575|            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
      0|  576|        }
      0|  577|    }
       |  578|
       |  579|    // MARK: - Private - Writing Buffered Data to Output Stream
       |  580|
      0|  581|    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
      0|  582|        var buffer = [UInt8](count: data.length, repeatedValue: 0)
      0|  583|        data.getBytes(&buffer, length: data.length)
      0|  584|
      0|  585|        return try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  586|    }
       |  587|
      0|  588|    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
      0|  589|        var bytesToWrite = buffer.count
      0|  590|
      0|  591|        while bytesToWrite > 0 {
      0|  592|            if outputStream.hasSpaceAvailable {
      0|  593|                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
      0|  594|
      0|  595|                if let streamError = outputStream.streamError {
      0|  596|                    throw streamError
      0|  597|                }
      0|  598|
      0|  599|                if bytesWritten < 0 {
      0|  600|                    let failureReason = "Failed to write to output stream: \(outputStream)"
      0|  601|                    throw Error.errorWithCode(.OutputStreamWriteFailed, failureReason: failureReason)
      0|  602|                }
      0|  603|
      0|  604|                bytesToWrite -= bytesWritten
      0|  605|
      0|  606|                if bytesToWrite > 0 {
      0|  607|                    buffer = Array(buffer[bytesWritten..<buffer.count])
      0|  608|                }
      0|  609|            } else if let streamError = outputStream.streamError {
      0|  610|                throw streamError
      0|  611|            }
      0|  612|        }
      0|  613|    }
       |  614|
       |  615|    // MARK: - Private - Mime Type
       |  616|
      0|  617|    private func mimeTypeForPathExtension(pathExtension: String) -> String {
      0|  618|        if let
      0|  619|            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
      0|  620|            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
      0|  621|        {
      0|  622|            return contentType as String
      0|  623|        }
      0|  624|
      0|  625|        return "application/octet-stream"
      0|  626|    }
       |  627|
       |  628|    // MARK: - Private - Content Headers
       |  629|
      0|  630|    private func contentHeaders(name name: String) -> [String: String] {
      0|  631|        return ["Content-Disposition": "form-data; name=\"\(name)\""]
      0|  632|    }
       |  633|
      0|  634|    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
      0|  635|        return [
      0|  636|            "Content-Disposition": "form-data; name=\"\(name)\"",
      0|  637|            "Content-Type": "\(mimeType)"
      0|  638|        ]
      0|  639|    }
       |  640|
      0|  641|    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
      0|  642|        return [
      0|  643|            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
      0|  644|            "Content-Type": "\(mimeType)"
      0|  645|        ]
      0|  646|    }
       |  647|
       |  648|    // MARK: - Private - Boundary Encoding
       |  649|
      0|  650|    private func initialBoundaryData() -> NSData {
      0|  651|        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
      0|  652|    }
       |  653|
      0|  654|    private func encapsulatedBoundaryData() -> NSData {
      0|  655|        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
      0|  656|    }
       |  657|
      0|  658|    private func finalBoundaryData() -> NSData {
      0|  659|        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
      0|  660|    }
       |  661|
       |  662|    // MARK: - Private - Errors
       |  663|
      0|  664|    private func setBodyPartError(error: NSError) {
      0|  665|        if bodyPartError == nil {
      0|  666|            bodyPartError = error
      0|  667|        }
      0|  668|    }
       |  669|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ParameterEncoding.swift:
       |    1|// ParameterEncoding.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    HTTP method definitions.
       |   27|
       |   28|    See https://tools.ietf.org/html/rfc7231#section-4.3
       |   29|*/
       |   30|public enum Method: String {
       |   31|    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
       |   32|}
       |   33|
       |   34|// MARK: ParameterEncoding
       |   35|
       |   36|/**
       |   37|    Used to specify the way in which a set of parameters are applied to a URL request.
       |   38|
       |   39|    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
       |   40|                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
       |   41|                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
       |   42|                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
       |   43|                         for how to encode collection types, the convention of appending `[]` to the key for array
       |   44|                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
       |   45|                         dictionary values (`foo[bar]=baz`).
       |   46|
       |   47|    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
       |   48|                         implementation as the `.URL` case, but always applies the encoded result to the URL.
       |   49|
       |   50|    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
       |   51|                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
       |   52|                         set to `application/json`.
       |   53|
       |   54|    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
       |   55|                         according to the associated format and write options values, which is set as the body of the
       |   56|                         request. The `Content-Type` HTTP header field of an encoded request is set to
       |   57|                         `application/x-plist`.
       |   58|
       |   59|    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
       |   60|                         parameters.
       |   61|*/
       |   62|public enum ParameterEncoding {
       |   63|    case URL
       |   64|    case URLEncodedInURL
       |   65|    case JSON
       |   66|    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
       |   67|    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
       |   68|
       |   69|    /**
       |   70|        Creates a URL request by encoding parameters and applying them onto an existing request.
       |   71|
       |   72|        - parameter URLRequest: The request to have parameters applied
       |   73|        - parameter parameters: The parameters to apply
       |   74|
       |   75|        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
       |   76|                   if any.
       |   77|    */
       |   78|    public func encode(
       |   79|        URLRequest: URLRequestConvertible,
       |   80|        parameters: [String: AnyObject]?)
       |   81|        -> (NSMutableURLRequest, NSError?)
      1|   82|    {
      1|   83|        var mutableURLRequest = URLRequest.URLRequest
      1|   84|
      0|   85|        guard let parameters = parameters where !parameters.isEmpty else {
      0|   86|            return (mutableURLRequest, nil)
      0|   87|        }
      1|   88|
      1|   89|        var encodingError: NSError? = nil
      1|   90|
      1|   91|        switch self {
      0|   92|        case .URL, .URLEncodedInURL:
      0|   93|            func query(parameters: [String: AnyObject]) -> String {
      0|   94|                var components: [(String, String)] = []
      0|   95|
      0|   96|                for key in parameters.keys.sort(<) {
      0|   97|                    let value = parameters[key]!
      0|   98|                    components += queryComponents(key, value)
      0|   99|                }
      0|  100|
      0|  101|                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
      0|  102|            }
      0|  103|
      0|  104|            func encodesParametersInURL(method: Method) -> Bool {
      0|  105|                switch self {
      0|  106|                case .URLEncodedInURL:
      0|  107|                    return true
      0|  108|                default:
      0|  109|                    break
      0|  110|                }
      0|  111|
      0|  112|                switch method {
      0|  113|                case .GET, .HEAD, .DELETE:
      0|  114|                    return true
      0|  115|                default:
      0|  116|                    return false
      0|  117|                }
      0|  118|            }
      0|  119|
      0|  120|            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
      0|  121|                if let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false) {
      0|  122|                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
      0|  123|                    URLComponents.percentEncodedQuery = percentEncodedQuery
      0|  124|                    mutableURLRequest.URL = URLComponents.URL
      0|  125|                }
      0|  126|            } else {
      0|  127|                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
      0|  128|                    mutableURLRequest.setValue(
      0|  129|                        "application/x-www-form-urlencoded; charset=utf-8",
      0|  130|                        forHTTPHeaderField: "Content-Type"
      0|  131|                    )
      0|  132|                }
      0|  133|
      0|  134|                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
      0|  135|                    NSUTF8StringEncoding,
      0|  136|                    allowLossyConversion: false
      0|  137|                )
      0|  138|            }
      1|  139|        case .JSON:
      1|  140|            do {
      1|  141|                let options = NSJSONWritingOptions()
      1|  142|                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
      1|  143|
      1|  144|                mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
      1|  145|                mutableURLRequest.HTTPBody = data
      0|  146|            } catch {
      0|  147|                encodingError = error as NSError
      0|  148|            }
      0|  149|        case .PropertyList(let format, let options):
      0|  150|            do {
      0|  151|                let data = try NSPropertyListSerialization.dataWithPropertyList(
      0|  152|                    parameters,
      0|  153|                    format: format,
      0|  154|                    options: options
      0|  155|                )
      0|  156|                mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
      0|  157|                mutableURLRequest.HTTPBody = data
      0|  158|            } catch {
      0|  159|                encodingError = error as NSError
      0|  160|            }
      0|  161|        case .Custom(let closure):
      0|  162|            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
      1|  163|        }
      1|  164|
      1|  165|        return (mutableURLRequest, encodingError)
      1|  166|    }
       |  167|
       |  168|    /**
       |  169|        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
       |  170|
       |  171|        - parameter key:   The key of the query component.
       |  172|        - parameter value: The value of the query component.
       |  173|
       |  174|        - returns: The percent-escaped, URL encoded query string components.
       |  175|    */
      0|  176|    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
      0|  177|        var components: [(String, String)] = []
      0|  178|
      0|  179|        if let dictionary = value as? [String: AnyObject] {
      0|  180|            for (nestedKey, value) in dictionary {
      0|  181|                components += queryComponents("\(key)[\(nestedKey)]", value)
      0|  182|            }
      0|  183|        } else if let array = value as? [AnyObject] {
      0|  184|            for value in array {
      0|  185|                components += queryComponents("\(key)[]", value)
      0|  186|            }
      0|  187|        } else {
      0|  188|            components.append((escape(key), escape("\(value)")))
      0|  189|        }
      0|  190|
      0|  191|        return components
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Returns a percent-escaped string following RFC 3986 for a query string key or value.
       |  196|
       |  197|        RFC 3986 states that the following characters are "reserved" characters.
       |  198|
       |  199|        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
       |  200|        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
       |  201|
       |  202|        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
       |  203|        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
       |  204|        should be percent-escaped in the query string.
       |  205|
       |  206|        - parameter string: The string to be percent-escaped.
       |  207|
       |  208|        - returns: The percent-escaped string.
       |  209|    */
      0|  210|    public func escape(string: String) -> String {
      0|  211|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
      0|  212|        let subDelimitersToEncode = "!$&'()*+,;="
      0|  213|
      0|  214|        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
      0|  215|        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
      0|  216|
      0|  217|        var escaped = ""
      0|  218|
      0|  219|        //==========================================================================================================
      0|  220|        //
      0|  221|        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
      0|  222|        //  hundred Chinense characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
      0|  223|        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
      0|  224|        //  info, please refer to:
      0|  225|        //
      0|  226|        //      - https://github.com/Alamofire/Alamofire/issues/206
      0|  227|        //
      0|  228|        //==========================================================================================================
      0|  229|
      0|  230|        if #available(iOS 8.3, OSX 10.10, *) {
      0|  231|            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
      0|  232|        } else {
      0|  233|            let batchSize = 50
      0|  234|            var index = string.startIndex
      0|  235|
      0|  236|            while index != string.endIndex {
      0|  237|                let startIndex = index
      0|  238|                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
      0|  239|                let range = Range(start: startIndex, end: endIndex)
      0|  240|
      0|  241|                let substring = string.substringWithRange(range)
      0|  242|
      0|  243|                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
      0|  244|
      0|  245|                index = endIndex
      0|  246|            }
      0|  247|        }
      0|  248|
      0|  249|        return escaped
      0|  250|    }
       |  251|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Request.swift:
       |    1|// Request.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for sending a request and receiving the response and associated data from the server, as well as 
       |   27|    managing its underlying `NSURLSessionTask`.
       |   28|*/
       |   29|public class Request {
       |   30|
       |   31|    // MARK: - Properties
       |   32|
       |   33|    /// The delegate for the underlying task.
       |   34|    public let delegate: TaskDelegate
       |   35|
       |   36|    /// The underlying task.
      5|   37|    public var task: NSURLSessionTask { return delegate.task }
       |   38|
       |   39|    /// The session belonging to the underlying task.
       |   40|    public let session: NSURLSession
       |   41|
       |   42|    /// The request sent or to be sent to the server.
      2|   43|    public var request: NSURLRequest? { return task.originalRequest }
       |   44|
       |   45|    /// The response received from the server, if any.
      2|   46|    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
       |   47|
       |   48|    /// The progress of the request lifecycle.
      0|   49|    public var progress: NSProgress { return delegate.progress }
       |   50|
       |   51|    // MARK: - Lifecycle
       |   52|
      1|   53|    init(session: NSURLSession, task: NSURLSessionTask) {
      1|   54|        self.session = session
      1|   55|
      1|   56|        switch task {
      0|   57|        case is NSURLSessionUploadTask:
      0|   58|            self.delegate = UploadTaskDelegate(task: task)
      1|   59|        case is NSURLSessionDataTask:
      1|   60|            self.delegate = DataTaskDelegate(task: task)
      0|   61|        case is NSURLSessionDownloadTask:
      0|   62|            self.delegate = DownloadTaskDelegate(task: task)
      0|   63|        default:
      0|   64|            self.delegate = TaskDelegate(task: task)
      1|   65|        }
      1|   66|    }
       |   67|
       |   68|    // MARK: - Authentication
       |   69|
       |   70|    /**
       |   71|        Associates an HTTP Basic credential with the request.
       |   72|
       |   73|        - parameter user:        The user.
       |   74|        - parameter password:    The password.
       |   75|        - parameter persistence: The URL credential persistence. `.ForSession` by default.
       |   76|
       |   77|        - returns: The request.
       |   78|    */
       |   79|    public func authenticate(
       |   80|        user user: String,
       |   81|        password: String,
       |   82|        persistence: NSURLCredentialPersistence = .ForSession)
       |   83|        -> Self
      0|   84|    {
      0|   85|        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
      0|   86|
      0|   87|        return authenticate(usingCredential: credential)
      0|   88|    }
       |   89|
       |   90|    /**
       |   91|        Associates a specified credential with the request.
       |   92|
       |   93|        - parameter credential: The credential.
       |   94|
       |   95|        - returns: The request.
       |   96|    */
      0|   97|    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
      0|   98|        delegate.credential = credential
      0|   99|
      0|  100|        return self
      0|  101|    }
       |  102|
       |  103|    // MARK: - Progress
       |  104|
       |  105|    /**
       |  106|        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
       |  107|        from the server.
       |  108|
       |  109|        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
       |  110|          to write.
       |  111|        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
       |  112|          expected to read.
       |  113|
       |  114|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  115|
       |  116|        - returns: The request.
       |  117|    */
      0|  118|    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
      0|  119|        if let uploadDelegate = delegate as? UploadTaskDelegate {
      0|  120|            uploadDelegate.uploadProgress = closure
      0|  121|        } else if let dataDelegate = delegate as? DataTaskDelegate {
      0|  122|            dataDelegate.dataProgress = closure
      0|  123|        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
      0|  124|            downloadDelegate.downloadProgress = closure
      0|  125|        }
      0|  126|
      0|  127|        return self
      0|  128|    }
       |  129|
       |  130|    /**
       |  131|        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
       |  132|
       |  133|        This closure returns the bytes most recently received from the server, not including data from previous calls. 
       |  134|        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
       |  135|        also important to note that the `response` closure will be called with nil `responseData`.
       |  136|
       |  137|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  138|
       |  139|        - returns: The request.
       |  140|    */
      0|  141|    public func stream(closure: (NSData -> Void)? = nil) -> Self {
      0|  142|        if let dataDelegate = delegate as? DataTaskDelegate {
      0|  143|            dataDelegate.dataStream = closure
      0|  144|        }
      0|  145|
      0|  146|        return self
      0|  147|    }
       |  148|
       |  149|    // MARK: - State
       |  150|
       |  151|    /**
       |  152|        Suspends the request.
       |  153|    */
      0|  154|    public func suspend() {
      0|  155|        task.suspend()
      0|  156|    }
       |  157|
       |  158|    /**
       |  159|        Resumes the request.
       |  160|    */
      1|  161|    public func resume() {
      1|  162|        task.resume()
      1|  163|    }
       |  164|
       |  165|    /**
       |  166|        Cancels the request.
       |  167|    */
      0|  168|    public func cancel() {
      0|  169|        if let
      0|  170|            downloadDelegate = delegate as? DownloadTaskDelegate,
      0|  171|            downloadTask = downloadDelegate.downloadTask
      0|  172|        {
      0|  173|            downloadTask.cancelByProducingResumeData { data in
      0|  174|                downloadDelegate.resumeData = data
      0|  175|            }
      0|  176|        } else {
      0|  177|            task.cancel()
      0|  178|        }
      0|  179|    }
       |  180|
       |  181|    // MARK: - TaskDelegate
       |  182|
       |  183|    /**
       |  184|        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
       |  185|        executing all operations attached to the serial operation queue upon task completion.
       |  186|    */
       |  187|    public class TaskDelegate: NSObject {
       |  188|
       |  189|        /// The serial operation queue used to execute all operations after the task completes.
       |  190|        public let queue: NSOperationQueue
       |  191|
       |  192|        let task: NSURLSessionTask
       |  193|        let progress: NSProgress
       |  194|
      0|  195|        var data: NSData? { return nil }
       |  196|        var error: NSError?
       |  197|
       |  198|        var credential: NSURLCredential?
       |  199|
      1|  200|        init(task: NSURLSessionTask) {
      1|  201|            self.task = task
      1|  202|            self.progress = NSProgress(totalUnitCount: 0)
      1|  203|            self.queue = {
      1|  204|                let operationQueue = NSOperationQueue()
      1|  205|                operationQueue.maxConcurrentOperationCount = 1
      1|  206|                operationQueue.suspended = true
      1|  207|
      1|  208|                if #available(OSX 10.10, *) {
      1|  209|                    operationQueue.qualityOfService = NSQualityOfService.Utility
      1|  210|                }
      1|  211|
      1|  212|                return operationQueue
      1|  213|            }()
      1|  214|        }
       |  215|
      0|  216|        deinit {
      0|  217|            queue.cancelAllOperations()
      0|  218|            queue.suspended = false
      0|  219|        }
       |  220|
       |  221|        // MARK: - NSURLSessionTaskDelegate
       |  222|
       |  223|        // MARK: Override Closures
       |  224|
       |  225|        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  226|        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  227|        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
       |  228|        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  229|
       |  230|        // MARK: Delegate Methods
       |  231|
       |  232|        func URLSession(
       |  233|            session: NSURLSession,
       |  234|            task: NSURLSessionTask,
       |  235|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  236|            newRequest request: NSURLRequest,
       |  237|            completionHandler: ((NSURLRequest?) -> Void))
      0|  238|        {
      0|  239|            var redirectRequest: NSURLRequest? = request
      0|  240|
      0|  241|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  242|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  243|            }
      0|  244|
      0|  245|            completionHandler(redirectRequest)
      0|  246|        }
       |  247|
       |  248|        func URLSession(
       |  249|            session: NSURLSession,
       |  250|            task: NSURLSessionTask,
       |  251|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  252|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  253|        {
      1|  254|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      1|  255|            var credential: NSURLCredential?
      1|  256|
      0|  257|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  258|                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
      1|  259|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      1|  260|                let host = challenge.protectionSpace.host
      1|  261|
      1|  262|                if let
      1|  263|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      1|  264|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  265|                {
      0|  266|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  267|                        disposition = .UseCredential
      0|  268|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  269|                    } else {
      0|  270|                        disposition = .CancelAuthenticationChallenge
      0|  271|                    }
      0|  272|                }
      0|  273|            } else {
      0|  274|                if challenge.previousFailureCount > 0 {
      0|  275|                    disposition = .CancelAuthenticationChallenge
      0|  276|                } else {
      0|  277|                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
      0|  278|
      0|  279|                    if credential != nil {
      0|  280|                        disposition = .UseCredential
      0|  281|                    }
      0|  282|                }
      0|  283|            }
      1|  284|
      1|  285|            completionHandler(disposition, credential)
      1|  286|        }
       |  287|
       |  288|        func URLSession(
       |  289|            session: NSURLSession,
       |  290|            task: NSURLSessionTask,
       |  291|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  292|        {
      0|  293|            var bodyStream: NSInputStream?
      0|  294|
      0|  295|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  296|                bodyStream = taskNeedNewBodyStream(session, task)
      0|  297|            }
      0|  298|
      0|  299|            completionHandler(bodyStream)
      0|  300|        }
       |  301|
      1|  302|        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  303|            if let taskDidCompleteWithError = taskDidCompleteWithError {
      0|  304|                taskDidCompleteWithError(session, task, error)
      1|  305|            } else {
      0|  306|                if let error = error {
      0|  307|                    self.error = error
      0|  308|
      0|  309|                    if let
      0|  310|                        downloadDelegate = self as? DownloadTaskDelegate,
      0|  311|                        userInfo = error.userInfo as? [String: AnyObject],
      0|  312|                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
      0|  313|                    {
      0|  314|                        downloadDelegate.resumeData = resumeData
      0|  315|                    }
      0|  316|                }
      1|  317|
      1|  318|                queue.suspended = false
      1|  319|            }
      1|  320|        }
       |  321|    }
       |  322|
       |  323|    // MARK: - DataTaskDelegate
       |  324|
       |  325|    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
      0|  326|        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
       |  327|
       |  328|        private var totalBytesReceived: Int64 = 0
       |  329|        private var mutableData: NSMutableData
      2|  330|        override var data: NSData? {
      0|  331|            if dataStream != nil {
      0|  332|                return nil
      2|  333|            } else {
      2|  334|                return mutableData
      2|  335|            }
      0|  336|        }
       |  337|
       |  338|        private var expectedContentLength: Int64?
       |  339|        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
       |  340|        private var dataStream: ((data: NSData) -> Void)?
       |  341|
      1|  342|        override init(task: NSURLSessionTask) {
      1|  343|            mutableData = NSMutableData()
      1|  344|            super.init(task: task)
      1|  345|        }
       |  346|
       |  347|        // MARK: - NSURLSessionDataDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  352|        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  353|        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  354|        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
       |  355|
       |  356|        // MARK: Delegate Methods
       |  357|
       |  358|        func URLSession(
       |  359|            session: NSURLSession,
       |  360|            dataTask: NSURLSessionDataTask,
       |  361|            didReceiveResponse response: NSURLResponse,
       |  362|            completionHandler: (NSURLSessionResponseDisposition -> Void))
      0|  363|        {
      0|  364|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  365|
      0|  366|            expectedContentLength = response.expectedContentLength
      0|  367|
      0|  368|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  369|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  370|            }
      0|  371|
      0|  372|            completionHandler(disposition)
      0|  373|        }
       |  374|
       |  375|        func URLSession(
       |  376|            session: NSURLSession,
       |  377|            dataTask: NSURLSessionDataTask,
       |  378|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  379|        {
      0|  380|            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
      0|  381|        }
       |  382|
      1|  383|        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  384|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  385|                dataTaskDidReceiveData(session, dataTask, data)
      1|  386|            } else {
      0|  387|                if let dataStream = dataStream {
      0|  388|                    dataStream(data: data)
      1|  389|                } else {
      1|  390|                    mutableData.appendData(data)
      1|  391|                }
      1|  392|
      1|  393|                totalBytesReceived += data.length
      0|  394|                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
      1|  395|
      1|  396|                progress.totalUnitCount = totalBytesExpected
      1|  397|                progress.completedUnitCount = totalBytesReceived
      1|  398|
      1|  399|                dataProgress?(
      1|  400|                    bytesReceived: Int64(data.length),
      1|  401|                    totalBytesReceived: totalBytesReceived,
      1|  402|                    totalBytesExpectedToReceive: totalBytesExpected
      1|  403|                )
      1|  404|            }
      1|  405|        }
       |  406|
       |  407|        func URLSession(
       |  408|            session: NSURLSession,
       |  409|            dataTask: NSURLSessionDataTask,
       |  410|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  411|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  412|        {
      0|  413|            var cachedResponse: NSCachedURLResponse? = proposedResponse
      0|  414|
      0|  415|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  416|                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
      0|  417|            }
      0|  418|
      0|  419|            completionHandler(cachedResponse)
      0|  420|        }
       |  421|    }
       |  422|}
       |  423|
       |  424|// MARK: - CustomStringConvertible
       |  425|
       |  426|extension Request: CustomStringConvertible {
       |  427|
       |  428|    /**
       |  429|        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
       |  430|        well as the response status code if a response has been received.
       |  431|    */
      0|  432|    public var description: String {
      0|  433|        var components: [String] = []
      0|  434|
      0|  435|        if let HTTPMethod = request?.HTTPMethod {
      0|  436|            components.append(HTTPMethod)
      0|  437|        }
      0|  438|
      0|  439|        if let URLString = request?.URL?.absoluteString {
      0|  440|            components.append(URLString)
      0|  441|        }
      0|  442|
      0|  443|        if let response = response {
      0|  444|            components.append("(\(response.statusCode))")
      0|  445|        }
      0|  446|
      0|  447|        return components.joinWithSeparator(" ")
      0|  448|    }
       |  449|}
       |  450|
       |  451|// MARK: - CustomDebugStringConvertible
       |  452|
       |  453|extension Request: CustomDebugStringConvertible {
      0|  454|    func cURLRepresentation() -> String {
      0|  455|        var components = ["$ curl -i"]
      0|  456|
      0|  457|        guard let request = self.request else {
      0|  458|            return "$ curl command could not be created"
      0|  459|        }
      0|  460|
      0|  461|        let URL = request.URL
      0|  462|
      0|  463|        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
      0|  464|            components.append("-X \(HTTPMethod)")
      0|  465|        }
      0|  466|
      0|  467|        if let credentialStorage = self.session.configuration.URLCredentialStorage {
      0|  468|            let protectionSpace = NSURLProtectionSpace(
      0|  469|                host: URL!.host!,
      0|  470|                port: URL!.port?.integerValue ?? 0,
      0|  471|                `protocol`: URL!.scheme,
      0|  472|                realm: URL!.host!,
      0|  473|                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
      0|  474|            )
      0|  475|
      0|  476|            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
      0|  477|                for credential in credentials {
      0|  478|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  479|                }
      0|  480|            } else {
      0|  481|                if let credential = delegate.credential {
      0|  482|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  483|                }
      0|  484|            }
      0|  485|        }
      0|  486|
      0|  487|        if session.configuration.HTTPShouldSetCookies {
      0|  488|            if let
      0|  489|                cookieStorage = session.configuration.HTTPCookieStorage,
      0|  490|                cookies = cookieStorage.cookiesForURL(URL!) where !cookies.isEmpty
      0|  491|            {
      0|  492|                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
      0|  493|                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
      0|  494|            }
      0|  495|        }
      0|  496|
      0|  497|        if let headerFields = request.allHTTPHeaderFields {
      0|  498|            for (field, value) in headerFields {
      0|  499|                switch field {
      0|  500|                case "Cookie":
      0|  501|                    continue
      0|  502|                default:
      0|  503|                    components.append("-H \"\(field): \(value)\"")
      0|  504|                }
      0|  505|            }
      0|  506|        }
      0|  507|
      0|  508|        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
      0|  509|            for (field, value) in additionalHeaders {
      0|  510|                switch field {
      0|  511|                case "Cookie":
      0|  512|                    continue
      0|  513|                default:
      0|  514|                    components.append("-H \"\(field): \(value)\"")
      0|  515|                }
      0|  516|            }
      0|  517|        }
      0|  518|
      0|  519|        if let
      0|  520|            HTTPBodyData = request.HTTPBody,
      0|  521|            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
      0|  522|        {
      0|  523|            let escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
      0|  524|            components.append("-d \"\(escapedBody)\"")
      0|  525|        }
      0|  526|
      0|  527|        components.append("\"\(URL!.absoluteString)\"")
      0|  528|
      0|  529|        return components.joinWithSeparator(" \\\n\t")
      0|  530|    }
       |  531|
       |  532|    /// The textual representation used when written to an output stream, in the form of a cURL command.
      0|  533|    public var debugDescription: String {
      0|  534|        return cURLRepresentation()
      0|  535|    }
       |  536|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Response.swift:
       |    1|// Response.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Used to store all response data returned from a completed `Request`.
       |   26|public struct Response<Value, Error: ErrorType> {
       |   27|    /// The URL request sent to the server.
       |   28|    public let request: NSURLRequest?
       |   29|
       |   30|    /// The server's response to the URL request.
       |   31|    public let response: NSHTTPURLResponse?
       |   32|
       |   33|    /// The data returned by the server.
       |   34|    public let data: NSData?
       |   35|
       |   36|    /// The result of response serialization.
       |   37|    public let result: Result<Value, Error>
       |   38|
       |   39|    /**
       |   40|        Initializes the `Response` instance with the specified URL request, URL response, server data and response
       |   41|        serialization result.
       |   42|    
       |   43|        - parameter request:  The URL request sent to the server.
       |   44|        - parameter response: The server's response to the URL request.
       |   45|        - parameter data:     The data returned by the server.
       |   46|        - parameter result:   The result of response serialization.
       |   47|    
       |   48|        - returns: the new `Response` instance.
       |   49|    */
      1|   50|    public init(request: NSURLRequest?, response: NSHTTPURLResponse?, data: NSData?, result: Result<Value, Error>) {
      1|   51|        self.request = request
      1|   52|        self.response = response
      1|   53|        self.data = data
      1|   54|        self.result = result
      1|   55|    }
       |   56|}
       |   57|
       |   58|// MARK: - CustomStringConvertible
       |   59|
       |   60|extension Response: CustomStringConvertible {
       |   61|    /// The textual representation used when written to an output stream, which includes whether the result was a
       |   62|    /// success or failure.
      0|   63|    public var description: String {
      0|   64|        return result.debugDescription
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - CustomDebugStringConvertible
       |   69|
       |   70|extension Response: CustomDebugStringConvertible {
       |   71|    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
       |   72|    /// response, the server data and the response serialization result.
      0|   73|    public var debugDescription: String {
      0|   74|        var output: [String] = []
      0|   75|
      0|   76|        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
      0|   77|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
      0|   78|        output.append("[Data]: \(data?.length ?? 0) bytes")
      0|   79|        output.append("[Result]: \(result.debugDescription)")
      0|   80|
      0|   81|        return output.joinWithSeparator("\n")
      0|   82|    }
       |   83|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ResponseSerialization.swift:
       |    1|// ResponseSerialization.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: ResponseSerializer
       |   26|
       |   27|/**
       |   28|    The type in which all response serializers must conform to in order to serialize a response.
       |   29|*/
       |   30|public protocol ResponseSerializerType {
       |   31|    /// The type of serialized object to be created by this `ResponseSerializerType`.
       |   32|    typealias SerializedObject
       |   33|
       |   34|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   35|    typealias ErrorObject: ErrorType
       |   36|
       |   37|    /**
       |   38|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   39|    */
       |   40|    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
       |   41|}
       |   42|
       |   43|// MARK: -
       |   44|
       |   45|/**
       |   46|    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
       |   47|*/
       |   48|public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
       |   49|    /// The type of serialized object to be created by this `ResponseSerializer`.
       |   50|    public typealias SerializedObject = Value
       |   51|
       |   52|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   53|    public typealias ErrorObject = Error
       |   54|
       |   55|    /**
       |   56|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   57|    */
       |   58|    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
       |   59|
       |   60|    /**
       |   61|        Initializes the `ResponseSerializer` instance with the given serialize response closure.
       |   62|
       |   63|        - parameter serializeResponse: The closure used to serialize the response.
       |   64|
       |   65|        - returns: The new generic response serializer instance.
       |   66|    */
      1|   67|    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
      1|   68|        self.serializeResponse = serializeResponse
      1|   69|    }
       |   70|}
       |   71|
       |   72|// MARK: - Default
       |   73|
       |   74|extension Request {
       |   75|
       |   76|    /**
       |   77|        Adds a handler to be called once the request has finished.
       |   78|
       |   79|        - parameter queue:             The queue on which the completion handler is dispatched.
       |   80|        - parameter completionHandler: The code to be executed once the request has finished.
       |   81|
       |   82|        - returns: The request.
       |   83|    */
       |   84|    public func response(
       |   85|        queue queue: dispatch_queue_t? = nil,
       |   86|        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
       |   87|        -> Self
      0|   88|    {
      0|   89|        delegate.queue.addOperationWithBlock {
      0|   90|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      0|   91|                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
      0|   92|            }
      0|   93|        }
      0|   94|
      0|   95|        return self
      0|   96|    }
       |   97|
       |   98|    /**
       |   99|        Adds a handler to be called once the request has finished.
       |  100|
       |  101|        - parameter queue:              The queue on which the completion handler is dispatched.
       |  102|        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
       |  103|                                        and data.
       |  104|        - parameter completionHandler:  The code to be executed once the request has finished.
       |  105|
       |  106|        - returns: The request.
       |  107|    */
       |  108|    public func response<T: ResponseSerializerType>(
       |  109|        queue queue: dispatch_queue_t? = nil,
       |  110|        responseSerializer: T,
       |  111|        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
       |  112|        -> Self
      1|  113|    {
      1|  114|        delegate.queue.addOperationWithBlock {
      1|  115|            let result = responseSerializer.serializeResponse(
      1|  116|                self.request,
      1|  117|                self.response,
      1|  118|                self.delegate.data,
      1|  119|                self.delegate.error
      1|  120|            )
      1|  121|
      1|  122|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      1|  123|                let response = Response<T.SerializedObject, T.ErrorObject>(
      1|  124|                    request: self.request,
      1|  125|                    response: self.response,
      1|  126|                    data: self.delegate.data,
      1|  127|                    result: result
      1|  128|                )
      1|  129|
      1|  130|                completionHandler(response)
      1|  131|            }
      1|  132|        }
      1|  133|
      1|  134|        return self
      1|  135|    }
       |  136|}
       |  137|
       |  138|// MARK: - Data
       |  139|
       |  140|extension Request {
       |  141|
       |  142|    /**
       |  143|        Creates a response serializer that returns the associated data as-is.
       |  144|
       |  145|        - returns: A data response serializer.
       |  146|    */
      0|  147|    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
      0|  148|        return ResponseSerializer { _, response, data, error in
      0|  149|            guard error == nil else { return .Failure(error!) }
      0|  150|
      0|  151|            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
      0|  152|
      0|  153|            guard let validData = data else {
      0|  154|                let failureReason = "Data could not be serialized. Input data was nil."
      0|  155|                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
      0|  156|                return .Failure(error)
      0|  157|            }
      0|  158|
      0|  159|            return .Success(validData)
      0|  160|        }
      0|  161|    }
       |  162|
       |  163|    /**
       |  164|        Adds a handler to be called once the request has finished.
       |  165|
       |  166|        - parameter completionHandler: The code to be executed once the request has finished.
       |  167|
       |  168|        - returns: The request.
       |  169|    */
      0|  170|    public func responseData(completionHandler: Response<NSData, NSError> -> Void) -> Self {
      0|  171|        return response(responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
      0|  172|    }
       |  173|}
       |  174|
       |  175|// MARK: - String
       |  176|
       |  177|extension Request {
       |  178|
       |  179|    /**
       |  180|        Creates a response serializer that returns a string initialized from the response data with the specified 
       |  181|        string encoding.
       |  182|
       |  183|        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
       |  184|                              response, falling back to the default HTTP default character set, ISO-8859-1.
       |  185|
       |  186|        - returns: A string response serializer.
       |  187|    */
       |  188|    public static func stringResponseSerializer(
       |  189|        var encoding encoding: NSStringEncoding? = nil)
       |  190|        -> ResponseSerializer<String, NSError>
      0|  191|    {
      0|  192|        return ResponseSerializer { _, response, data, error in
      0|  193|            guard error == nil else { return .Failure(error!) }
      0|  194|
      0|  195|            if let response = response where response.statusCode == 204 { return .Success("") }
      0|  196|
      0|  197|            guard let validData = data else {
      0|  198|                let failureReason = "String could not be serialized. Input data was nil."
      0|  199|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  200|                return .Failure(error)
      0|  201|            }
      0|  202|
      0|  203|            if let encodingName = response?.textEncodingName where encoding == nil {
      0|  204|                encoding = CFStringConvertEncodingToNSStringEncoding(
      0|  205|                    CFStringConvertIANACharSetNameToEncoding(encodingName)
      0|  206|                )
      0|  207|            }
      0|  208|
      0|  209|            let actualEncoding = encoding ?? NSISOLatin1StringEncoding
      0|  210|
      0|  211|            if let string = String(data: validData, encoding: actualEncoding) {
      0|  212|                return .Success(string)
      0|  213|            } else {
      0|  214|                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
      0|  215|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  216|                return .Failure(error)
      0|  217|            }
      0|  218|        }
      0|  219|    }
       |  220|
       |  221|    /**
       |  222|        Adds a handler to be called once the request has finished.
       |  223|
       |  224|        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
       |  225|                                       server response, falling back to the default HTTP default character set, 
       |  226|                                       ISO-8859-1.
       |  227|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  228|
       |  229|        - returns: The request.
       |  230|    */
       |  231|    public func responseString(
       |  232|        encoding encoding: NSStringEncoding? = nil,
       |  233|        completionHandler: Response<String, NSError> -> Void)
       |  234|        -> Self
      0|  235|    {
      0|  236|        return response(
      0|  237|            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
      0|  238|            completionHandler: completionHandler
      0|  239|        )
      0|  240|    }
       |  241|}
       |  242|
       |  243|// MARK: - JSON
       |  244|
       |  245|extension Request {
       |  246|
       |  247|    /**
       |  248|        Creates a response serializer that returns a JSON object constructed from the response data using 
       |  249|        `NSJSONSerialization` with the specified reading options.
       |  250|
       |  251|        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
       |  252|
       |  253|        - returns: A JSON object response serializer.
       |  254|    */
       |  255|    public static func JSONResponseSerializer(
       |  256|        options options: NSJSONReadingOptions = .AllowFragments)
       |  257|        -> ResponseSerializer<AnyObject, NSError>
      1|  258|    {
      1|  259|        return ResponseSerializer { _, response, data, error in
      0|  260|            guard error == nil else { return .Failure(error!) }
      1|  261|
      0|  262|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      1|  263|
      0|  264|            guard let validData = data where validData.length > 0 else {
      0|  265|                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
      0|  266|                let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
      0|  267|                return .Failure(error)
      0|  268|            }
      1|  269|
      1|  270|            do {
      1|  271|                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
      1|  272|                return .Success(JSON)
      1|  273|            } catch {
      1|  274|                return .Failure(error as NSError)
      1|  275|            }
      0|  276|        }
      1|  277|    }
       |  278|
       |  279|    /**
       |  280|        Adds a handler to be called once the request has finished.
       |  281|
       |  282|        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
       |  283|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  284|
       |  285|        - returns: The request.
       |  286|    */
       |  287|    public func responseJSON(
       |  288|        options options: NSJSONReadingOptions = .AllowFragments,
       |  289|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  290|        -> Self
      1|  291|    {
      1|  292|        return response(
      1|  293|            responseSerializer: Request.JSONResponseSerializer(options: options),
      1|  294|            completionHandler: completionHandler
      1|  295|        )
      1|  296|    }
       |  297|}
       |  298|
       |  299|// MARK: - Property List
       |  300|
       |  301|extension Request {
       |  302|
       |  303|    /**
       |  304|        Creates a response serializer that returns an object constructed from the response data using 
       |  305|        `NSPropertyListSerialization` with the specified reading options.
       |  306|
       |  307|        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
       |  308|
       |  309|        - returns: A property list object response serializer.
       |  310|    */
       |  311|    public static func propertyListResponseSerializer(
       |  312|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
       |  313|        -> ResponseSerializer<AnyObject, NSError>
      0|  314|    {
      0|  315|        return ResponseSerializer { _, response, data, error in
      0|  316|            guard error == nil else { return .Failure(error!) }
      0|  317|
      0|  318|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      0|  319|
      0|  320|            guard let validData = data where validData.length > 0 else {
      0|  321|                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
      0|  322|                let error = Error.errorWithCode(.PropertyListSerializationFailed, failureReason: failureReason)
      0|  323|                return .Failure(error)
      0|  324|            }
      0|  325|
      0|  326|            do {
      0|  327|                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
      0|  328|                return .Success(plist)
      0|  329|            } catch {
      0|  330|                return .Failure(error as NSError)
      0|  331|            }
      0|  332|        }
      0|  333|    }
       |  334|
       |  335|    /**
       |  336|        Adds a handler to be called once the request has finished.
       |  337|
       |  338|        - parameter options:           The property list reading options. `0` by default.
       |  339|        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
       |  340|                                       arguments: the URL request, the URL response, the server data and the result 
       |  341|                                       produced while creating the property list.
       |  342|
       |  343|        - returns: The request.
       |  344|    */
       |  345|    public func responsePropertyList(
       |  346|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
       |  347|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  348|        -> Self
      0|  349|    {
      0|  350|        return response(
      0|  351|            responseSerializer: Request.propertyListResponseSerializer(options: options),
      0|  352|            completionHandler: completionHandler
      0|  353|        )
      0|  354|    }
       |  355|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Result.swift:
       |    1|// Result.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Used to represent whether a request was successful or encountered an error.
       |   27|
       |   28|    - Success: The request and all post processing operations were successful resulting in the serialization of the 
       |   29|               provided associated value.
       |   30|    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
       |   31|               provided by the server as well as the error that caused the failure.
       |   32|*/
       |   33|public enum Result<Value, Error: ErrorType> {
       |   34|    case Success(Value)
       |   35|    case Failure(Error)
       |   36|
       |   37|    /// Returns `true` if the result is a success, `false` otherwise.
      0|   38|    public var isSuccess: Bool {
      0|   39|        switch self {
      0|   40|        case .Success:
      0|   41|            return true
      0|   42|        case .Failure:
      0|   43|            return false
      0|   44|        }
      0|   45|    }
       |   46|
       |   47|    /// Returns `true` if the result is a failure, `false` otherwise.
      0|   48|    public var isFailure: Bool {
      0|   49|        return !isSuccess
      0|   50|    }
       |   51|
       |   52|    /// Returns the associated value if the result is a success, `nil` otherwise.
      0|   53|    public var value: Value? {
      0|   54|        switch self {
      0|   55|        case .Success(let value):
      0|   56|            return value
      0|   57|        case .Failure:
      0|   58|            return nil
      0|   59|        }
      0|   60|    }
       |   61|
       |   62|    /// Returns the associated error value if the result is a failure, `nil` otherwise.
      0|   63|    public var error: Error? {
      0|   64|        switch self {
      0|   65|        case .Success:
      0|   66|            return nil
      0|   67|        case .Failure(let error):
      0|   68|            return error
      0|   69|        }
      0|   70|    }
       |   71|}
       |   72|
       |   73|// MARK: - CustomStringConvertible
       |   74|
       |   75|extension Result: CustomStringConvertible {
       |   76|    /// The textual representation used when written to an output stream, which includes whether the result was a 
       |   77|    /// success or failure.
      0|   78|    public var description: String {
      0|   79|        switch self {
      0|   80|        case .Success:
      0|   81|            return "SUCCESS"
      0|   82|        case .Failure:
      0|   83|            return "FAILURE"
      0|   84|        }
      0|   85|    }
       |   86|}
       |   87|
       |   88|// MARK: - CustomDebugStringConvertible
       |   89|
       |   90|extension Result: CustomDebugStringConvertible {
       |   91|    /// The debug textual representation used when written to an output stream, which includes whether the result was a
       |   92|    /// success or failure in addition to the value or error.
      1|   93|    public var debugDescription: String {
      1|   94|        switch self {
      0|   95|        case .Success(let value):
      0|   96|            return "SUCCESS: \(value)"
      1|   97|        case .Failure(let error):
      1|   98|            return "FAILURE: \(error)"
      1|   99|        }
      1|  100|    }
       |  101|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ServerTrustPolicy.swift:
       |    1|// ServerTrustPolicy.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
       |   26|public class ServerTrustPolicyManager {
       |   27|    /// The dictionary of policies mapped to a particular host.
       |   28|    public let policies: [String: ServerTrustPolicy]
       |   29|
       |   30|    /**
       |   31|        Initializes the `ServerTrustPolicyManager` instance with the given policies.
       |   32|
       |   33|        Since different servers and web services can have different leaf certificates, intermediate and even root 
       |   34|        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
       |   35|        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
       |   36|        pinning for host3 and disabling evaluation for host4.
       |   37|
       |   38|        - parameter policies: A dictionary of all policies mapped to a particular host.
       |   39|
       |   40|        - returns: The new `ServerTrustPolicyManager` instance.
       |   41|    */
      0|   42|    public init(policies: [String: ServerTrustPolicy]) {
      0|   43|        self.policies = policies
      0|   44|    }
       |   45|
       |   46|    /**
       |   47|        Returns the `ServerTrustPolicy` for the given host if applicable.
       |   48|
       |   49|        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
       |   50|        this method and implement more complex mapping implementations such as wildcards.
       |   51|
       |   52|        - parameter host: The host to use when searching for a matching policy.
       |   53|
       |   54|        - returns: The server trust policy for the given host if found.
       |   55|    */
      0|   56|    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
      0|   57|        return policies[host]
      0|   58|    }
       |   59|}
       |   60|
       |   61|// MARK: -
       |   62|
       |   63|extension NSURLSession {
       |   64|    private struct AssociatedKeys {
       |   65|        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
       |   66|    }
       |   67|
       |   68|    var serverTrustPolicyManager: ServerTrustPolicyManager? {
      1|   69|        get {
      1|   70|            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
      1|   71|        }
      1|   72|        set (manager) {
      1|   73|            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
      1|   74|        }
       |   75|    }
       |   76|}
       |   77|
       |   78|// MARK: - ServerTrustPolicy
       |   79|
       |   80|/**
       |   81|    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
       |   82|    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
       |   83|    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
       |   84|
       |   85|    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
       |   86|    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
       |   87|    to route all communication over an HTTPS connection with pinning enabled.
       |   88|
       |   89|    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
       |   90|                                validate the host provided by the challenge. Applications are encouraged to always 
       |   91|                                validate the host in production environments to guarantee the validity of the server's 
       |   92|                                certificate chain.
       |   93|
       |   94|    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
       |   95|                                considered valid if one of the pinned certificates match one of the server certificates. 
       |   96|                                By validating both the certificate chain and host, certificate pinning provides a very 
       |   97|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |   98|                                Applications are encouraged to always validate the host and require a valid certificate 
       |   99|                                chain in production environments.
       |  100|
       |  101|    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
       |  102|                                valid if one of the pinned public keys match one of the server certificate public keys. 
       |  103|                                By validating both the certificate chain and host, public key pinning provides a very 
       |  104|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |  105|                                Applications are encouraged to always validate the host and require a valid certificate 
       |  106|                                chain in production environments.
       |  107|
       |  108|    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
       |  109|
       |  110|    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
       |  111|*/
       |  112|public enum ServerTrustPolicy {
       |  113|    case PerformDefaultEvaluation(validateHost: Bool)
       |  114|    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
       |  115|    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
       |  116|    case DisableEvaluation
       |  117|    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
       |  118|
       |  119|    // MARK: - Bundle Location
       |  120|
       |  121|    /**
       |  122|        Returns all certificates within the given bundle with a `.cer` file extension.
       |  123|
       |  124|        - parameter bundle: The bundle to search for all `.cer` files.
       |  125|
       |  126|        - returns: All certificates within the given bundle.
       |  127|    */
      0|  128|    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
      0|  129|        var certificates: [SecCertificate] = []
      0|  130|
      0|  131|        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
      0|  132|            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
      0|  133|        }.flatten())
      0|  134|
      0|  135|        for path in paths {
      0|  136|            if let
      0|  137|                certificateData = NSData(contentsOfFile: path),
      0|  138|                certificate = SecCertificateCreateWithData(nil, certificateData)
      0|  139|            {
      0|  140|                certificates.append(certificate)
      0|  141|            }
       |  142|        }
       |  143|
       |  144|        return certificates
       |  145|    }
       |  146|
       |  147|    /**
       |  148|        Returns all public keys within the given bundle with a `.cer` file extension.
       |  149|
      0|  150|        - parameter bundle: The bundle to search for all `*.cer` files.
      0|  151|
      0|  152|        - returns: All public keys within the given bundle.
      0|  153|    */
      0|  154|    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
      0|  155|        var publicKeys: [SecKey] = []
      0|  156|
      0|  157|        for certificate in certificatesInBundle(bundle) {
      0|  158|            if let publicKey = publicKeyForCertificate(certificate) {
      0|  159|                publicKeys.append(publicKey)
      0|  160|            }
       |  161|        }
       |  162|
       |  163|        return publicKeys
       |  164|    }
       |  165|
       |  166|    // MARK: - Evaluation
       |  167|
       |  168|    /**
       |  169|        Evaluates whether the server trust is valid for the given host.
       |  170|
       |  171|        - parameter serverTrust: The server trust to evaluate.
      0|  172|        - parameter host:        The host of the challenge protection space.
      0|  173|
      0|  174|        - returns: Whether the server trust is valid.
      0|  175|    */
      0|  176|    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
      0|  177|        var serverTrustIsValid = false
      0|  178|
      0|  179|        switch self {
      0|  180|        case let .PerformDefaultEvaluation(validateHost):
      0|  181|            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  182|            SecTrustSetPolicies(serverTrust, [policy])
      0|  183|
      0|  184|            serverTrustIsValid = trustIsValid(serverTrust)
      0|  185|        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
      0|  186|            if validateCertificateChain {
      0|  187|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  188|                SecTrustSetPolicies(serverTrust, [policy])
      0|  189|
      0|  190|                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
      0|  191|                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
      0|  192|
      0|  193|                serverTrustIsValid = trustIsValid(serverTrust)
      0|  194|            } else {
      0|  195|                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
      0|  196|                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
      0|  197|
      0|  198|                outerLoop: for serverCertificateData in serverCertificatesDataArray {
      0|  199|                    for pinnedCertificateData in pinnedCertificatesDataArray {
      0|  200|                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
      0|  201|                            serverTrustIsValid = true
      0|  202|                            break outerLoop
      0|  203|                        }
      0|  204|                    }
      0|  205|                }
      0|  206|            }
      0|  207|        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
      0|  208|            var certificateChainEvaluationPassed = true
      0|  209|
      0|  210|            if validateCertificateChain {
      0|  211|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  212|                SecTrustSetPolicies(serverTrust, [policy])
      0|  213|
      0|  214|                certificateChainEvaluationPassed = trustIsValid(serverTrust)
      0|  215|            }
      0|  216|
      0|  217|            if certificateChainEvaluationPassed {
      0|  218|                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
      0|  219|                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
      0|  220|                        if serverPublicKey.isEqual(pinnedPublicKey) {
      0|  221|                            serverTrustIsValid = true
      0|  222|                            break outerLoop
      0|  223|                        }
      0|  224|                    }
      0|  225|                }
      0|  226|            }
      0|  227|        case .DisableEvaluation:
      0|  228|            serverTrustIsValid = true
      0|  229|        case let .CustomEvaluation(closure):
      0|  230|            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
      0|  231|        }
      0|  232|
      0|  233|        return serverTrustIsValid
      0|  234|    }
      0|  235|
      0|  236|    // MARK: - Private - Trust Validation
      0|  237|
       |  238|    private func trustIsValid(trust: SecTrust) -> Bool {
       |  239|        var isValid = false
       |  240|
      0|  241|        var result = SecTrustResultType(kSecTrustResultInvalid)
      0|  242|        let status = SecTrustEvaluate(trust, &result)
      0|  243|
      0|  244|        if status == errSecSuccess {
      0|  245|            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
      0|  246|            let proceed = SecTrustResultType(kSecTrustResultProceed)
      0|  247|
      0|  248|            isValid = result == unspecified || result == proceed
      0|  249|        }
      0|  250|
      0|  251|        return isValid
      0|  252|    }
      0|  253|
      0|  254|    // MARK: - Private - Certificate Data
      0|  255|
       |  256|    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
       |  257|        var certificates: [SecCertificate] = []
       |  258|
      0|  259|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  260|            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
      0|  261|                certificates.append(certificate)
      0|  262|            }
      0|  263|        }
      0|  264|
      0|  265|        return certificateDataForCertificates(certificates)
      0|  266|    }
      0|  267|
      0|  268|    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
      0|  269|        return certificates.map { SecCertificateCopyData($0) as NSData }
       |  270|    }
      0|  271|
      0|  272|    // MARK: - Private - Public Key Extraction
      0|  273|
       |  274|    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
       |  275|        var publicKeys: [SecKey] = []
       |  276|
      0|  277|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  278|            if let
      0|  279|                certificate = SecTrustGetCertificateAtIndex(trust, index),
      0|  280|                publicKey = publicKeyForCertificate(certificate)
      0|  281|            {
      0|  282|                publicKeys.append(publicKey)
      0|  283|            }
      0|  284|        }
      0|  285|
      0|  286|        return publicKeys
      0|  287|    }
      0|  288|
      0|  289|    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
      0|  290|        var publicKey: SecKey?
       |  291|
      0|  292|        let policy = SecPolicyCreateBasicX509()
      0|  293|        var trust: SecTrust?
      0|  294|        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
      0|  295|
      0|  296|        if let trust = trust where trustCreationStatus == errSecSuccess {
      0|  297|            publicKey = SecTrustCopyPublicKey(trust)
      0|  298|        }
      0|  299|
      0|  300|        return publicKey
      0|  301|    }
      0|  302|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Stream.swift:
       |    1|// Stream.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if !os(watchOS)
       |   26|
       |   27|@available(iOS 9.0, OSX 10.11, *)
       |   28|extension Manager {
       |   29|    private enum Streamable {
       |   30|        case Stream(String, Int)
       |   31|        case NetService(NSNetService)
       |   32|    }
       |   33|
      0|   34|    private func stream(streamable: Streamable) -> Request {
      0|   35|        var streamTask: NSURLSessionStreamTask!
      0|   36|
      0|   37|        switch streamable {
      0|   38|        case .Stream(let hostName, let port):
      0|   39|            dispatch_sync(queue) {
      0|   40|                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
      0|   41|            }
      0|   42|        case .NetService(let netService):
      0|   43|            dispatch_sync(queue) {
      0|   44|                streamTask = self.session.streamTaskWithNetService(netService)
      0|   45|            }
      0|   46|        }
      0|   47|
      0|   48|        let request = Request(session: session, task: streamTask)
      0|   49|
      0|   50|        delegate[request.delegate.task] = request.delegate
      0|   51|
      0|   52|        if startRequestsImmediately {
      0|   53|            request.resume()
      0|   54|        }
      0|   55|
      0|   56|        return request
      0|   57|    }
       |   58|
       |   59|    /**
       |   60|        Creates a request for bidirectional streaming with the given hostname and port.
       |   61|
       |   62|        - parameter hostName: The hostname of the server to connect to.
       |   63|        - parameter port:     The port of the server to connect to.
       |   64|
       |   65|        :returns: The created stream request.
       |   66|    */
      0|   67|    public func stream(hostName hostName: String, port: Int) -> Request {
      0|   68|        return stream(.Stream(hostName, port))
      0|   69|    }
       |   70|
       |   71|    /**
       |   72|        Creates a request for bidirectional streaming with the given `NSNetService`.
       |   73|
       |   74|        - parameter netService: The net service used to identify the endpoint.
       |   75|
       |   76|        - returns: The created stream request.
       |   77|    */
      0|   78|    public func stream(netService netService: NSNetService) -> Request {
      0|   79|        return stream(.NetService(netService))
      0|   80|    }
       |   81|}
       |   82|
       |   83|// MARK: -
       |   84|
       |   85|@available(iOS 9.0, OSX 10.11, *)
       |   86|extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
       |   87|
       |   88|    // MARK: Override Closures
       |   89|
       |   90|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
       |   91|    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|   92|        get {
      0|   93|            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|   94|        }
      0|   95|        set {
      0|   96|            _streamTaskReadClosed = newValue
      0|   97|        }
       |   98|    }
       |   99|
       |  100|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
       |  101|    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  102|        get {
      0|  103|            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  104|        }
      0|  105|        set {
      0|  106|            _streamTaskWriteClosed = newValue
      0|  107|        }
       |  108|    }
       |  109|
       |  110|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
       |  111|    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  112|        get {
      0|  113|            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  114|        }
      0|  115|        set {
      0|  116|            _streamTaskBetterRouteDiscovered = newValue
      0|  117|        }
       |  118|    }
       |  119|
       |  120|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
       |  121|    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
      0|  122|        get {
      0|  123|            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
      0|  124|        }
      0|  125|        set {
      0|  126|            _streamTaskDidBecomeInputStream = newValue
      0|  127|        }
       |  128|    }
       |  129|
       |  130|    // MARK: Delegate Methods
       |  131|
       |  132|    /**
       |  133|        Tells the delegate that the read side of the connection has been closed.
       |  134|
       |  135|        - parameter session:    The session.
       |  136|        - parameter streamTask: The stream task.
       |  137|    */
      0|  138|    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  139|        streamTaskReadClosed?(session, streamTask)
      0|  140|    }
       |  141|
       |  142|    /**
       |  143|        Tells the delegate that the write side of the connection has been closed.
       |  144|
       |  145|        - parameter session:    The session.
       |  146|        - parameter streamTask: The stream task.
       |  147|    */
      0|  148|    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  149|        streamTaskWriteClosed?(session, streamTask)
      0|  150|    }
       |  151|
       |  152|    /**
       |  153|        Tells the delegate that the system has determined that a better route to the host is available.
       |  154|
       |  155|        - parameter session:    The session.
       |  156|        - parameter streamTask: The stream task.
       |  157|    */
      0|  158|    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  159|        streamTaskBetterRouteDiscovered?(session, streamTask)
      0|  160|    }
       |  161|
       |  162|    /**
       |  163|        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
       |  164|
       |  165|        - parameter session:      The session.
       |  166|        - parameter streamTask:   The stream task.
       |  167|        - parameter inputStream:  The new input stream.
       |  168|        - parameter outputStream: The new output stream.
       |  169|    */
       |  170|    public func URLSession(
       |  171|        session: NSURLSession,
       |  172|        streamTask: NSURLSessionStreamTask,
       |  173|        didBecomeInputStream inputStream: NSInputStream,
       |  174|        outputStream: NSOutputStream)
      0|  175|    {
      0|  176|        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
      0|  177|    }
       |  178|}
       |  179|
       |  180|#endif

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Upload.swift:
       |    1|// Upload.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Uploadable {
       |   27|        case Data(NSURLRequest, NSData)
       |   28|        case File(NSURLRequest, NSURL)
       |   29|        case Stream(NSURLRequest, NSInputStream)
       |   30|    }
       |   31|
      0|   32|    private func upload(uploadable: Uploadable) -> Request {
      0|   33|        var uploadTask: NSURLSessionUploadTask!
      0|   34|        var HTTPBodyStream: NSInputStream?
      0|   35|
      0|   36|        switch uploadable {
      0|   37|        case .Data(let request, let data):
      0|   38|            dispatch_sync(queue) {
      0|   39|                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
      0|   40|            }
      0|   41|        case .File(let request, let fileURL):
      0|   42|            dispatch_sync(queue) {
      0|   43|                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
      0|   44|            }
      0|   45|        case .Stream(let request, let stream):
      0|   46|            dispatch_sync(queue) {
      0|   47|                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
      0|   48|            }
      0|   49|
      0|   50|            HTTPBodyStream = stream
      0|   51|        }
      0|   52|
      0|   53|        let request = Request(session: session, task: uploadTask)
      0|   54|
      0|   55|        if HTTPBodyStream != nil {
      0|   56|            request.delegate.taskNeedNewBodyStream = { _, _ in
      0|   57|                return HTTPBodyStream
      0|   58|            }
      0|   59|        }
      0|   60|
      0|   61|        delegate[request.delegate.task] = request.delegate
      0|   62|
      0|   63|        if startRequestsImmediately {
      0|   64|            request.resume()
      0|   65|        }
      0|   66|
      0|   67|        return request
      0|   68|    }
       |   69|
       |   70|    // MARK: File
       |   71|
       |   72|    /**
       |   73|        Creates a request for uploading a file to the specified URL request.
       |   74|
       |   75|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   76|
       |   77|        - parameter URLRequest: The URL request
       |   78|        - parameter file:       The file to upload
       |   79|
       |   80|        - returns: The created upload request.
       |   81|    */
      0|   82|    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|   83|        return upload(.File(URLRequest.URLRequest, file))
      0|   84|    }
       |   85|
       |   86|    /**
       |   87|        Creates a request for uploading a file to the specified URL request.
       |   88|
       |   89|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   90|
       |   91|        - parameter method:    The HTTP method.
       |   92|        - parameter URLString: The URL string.
       |   93|        - parameter headers:   The HTTP headers. `nil` by default.
       |   94|        - parameter file:      The file to upload
       |   95|
       |   96|        - returns: The created upload request.
       |   97|    */
       |   98|    public func upload(
       |   99|        method: Method,
       |  100|        _ URLString: URLStringConvertible,
       |  101|        headers: [String: String]? = nil,
       |  102|        file: NSURL)
       |  103|        -> Request
      0|  104|    {
      0|  105|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  106|        return upload(mutableURLRequest, file: file)
      0|  107|    }
       |  108|
       |  109|    // MARK: Data
       |  110|
       |  111|    /**
       |  112|        Creates a request for uploading data to the specified URL request.
       |  113|
       |  114|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  115|
       |  116|        - parameter URLRequest: The URL request.
       |  117|        - parameter data:       The data to upload.
       |  118|
       |  119|        - returns: The created upload request.
       |  120|    */
      0|  121|    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  122|        return upload(.Data(URLRequest.URLRequest, data))
      0|  123|    }
       |  124|
       |  125|    /**
       |  126|        Creates a request for uploading data to the specified URL request.
       |  127|
       |  128|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  129|
       |  130|        - parameter method:    The HTTP method.
       |  131|        - parameter URLString: The URL string.
       |  132|        - parameter headers:   The HTTP headers. `nil` by default.
       |  133|        - parameter data:      The data to upload
       |  134|
       |  135|        - returns: The created upload request.
       |  136|    */
       |  137|    public func upload(
       |  138|        method: Method,
       |  139|        _ URLString: URLStringConvertible,
       |  140|        headers: [String: String]? = nil,
       |  141|        data: NSData)
       |  142|        -> Request
      0|  143|    {
      0|  144|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  145|
      0|  146|        return upload(mutableURLRequest, data: data)
      0|  147|    }
       |  148|
       |  149|    // MARK: Stream
       |  150|
       |  151|    /**
       |  152|        Creates a request for uploading a stream to the specified URL request.
       |  153|
       |  154|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  155|
       |  156|        - parameter URLRequest: The URL request.
       |  157|        - parameter stream:     The stream to upload.
       |  158|
       |  159|        - returns: The created upload request.
       |  160|    */
      0|  161|    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  162|        return upload(.Stream(URLRequest.URLRequest, stream))
      0|  163|    }
       |  164|
       |  165|    /**
       |  166|        Creates a request for uploading a stream to the specified URL request.
       |  167|
       |  168|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  169|
       |  170|        - parameter method:    The HTTP method.
       |  171|        - parameter URLString: The URL string.
       |  172|        - parameter headers:   The HTTP headers. `nil` by default.
       |  173|        - parameter stream:    The stream to upload.
       |  174|
       |  175|        - returns: The created upload request.
       |  176|    */
       |  177|    public func upload(
       |  178|        method: Method,
       |  179|        _ URLString: URLStringConvertible,
       |  180|        headers: [String: String]? = nil,
       |  181|        stream: NSInputStream)
       |  182|        -> Request
      0|  183|    {
      0|  184|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  185|
      0|  186|        return upload(mutableURLRequest, stream: stream)
      0|  187|    }
       |  188|
       |  189|    // MARK: MultipartFormData
       |  190|
       |  191|    /// Default memory threshold used when encoding `MultipartFormData`.
       |  192|    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
       |  193|
       |  194|    /**
       |  195|        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
       |  196|        associated values.
       |  197|
       |  198|        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
       |  199|                   streaming information.
       |  200|        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
       |  201|                   error.
       |  202|    */
       |  203|    public enum MultipartFormDataEncodingResult {
       |  204|        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
       |  205|        case Failure(ErrorType)
       |  206|    }
       |  207|
       |  208|    /**
       |  209|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  210|
       |  211|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
       |  212|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
       |  213|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
       |  214|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
       |  215|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
       |  216|        used for larger payloads such as video content.
       |  217|
       |  218|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
       |  219|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  220|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
       |  221|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
       |  222|        technique was used.
       |  223|
       |  224|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  225|
       |  226|        - parameter method:                  The HTTP method.
       |  227|        - parameter URLString:               The URL string.
       |  228|        - parameter headers:                 The HTTP headers. `nil` by default.
       |  229|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  230|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  231|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  232|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  233|    */
       |  234|    public func upload(
       |  235|        method: Method,
       |  236|        _ URLString: URLStringConvertible,
       |  237|        headers: [String: String]? = nil,
       |  238|        multipartFormData: MultipartFormData -> Void,
       |  239|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  240|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  241|    {
      0|  242|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  243|
      0|  244|        return upload(
      0|  245|            mutableURLRequest,
      0|  246|            multipartFormData: multipartFormData,
      0|  247|            encodingMemoryThreshold: encodingMemoryThreshold,
      0|  248|            encodingCompletion: encodingCompletion
      0|  249|        )
      0|  250|    }
       |  251|
       |  252|    /**
       |  253|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  254|
       |  255|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
       |  256|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
       |  257|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
       |  258|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
       |  259|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
       |  260|        used for larger payloads such as video content.
       |  261|
       |  262|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
       |  263|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  264|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
       |  265|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
       |  266|        technique was used.
       |  267|
       |  268|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  269|
       |  270|        - parameter URLRequest:              The URL request.
       |  271|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  272|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  273|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  274|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  275|    */
       |  276|    public func upload(
       |  277|        URLRequest: URLRequestConvertible,
       |  278|        multipartFormData: MultipartFormData -> Void,
       |  279|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  280|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  281|    {
      0|  282|        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
      0|  283|            let formData = MultipartFormData()
      0|  284|            multipartFormData(formData)
      0|  285|
      0|  286|            let URLRequestWithContentType = URLRequest.URLRequest
      0|  287|            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
      0|  288|
      0|  289|            let isBackgroundSession = self.session.configuration.identifier != nil
      0|  290|
      0|  291|            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
      0|  292|                do {
      0|  293|                    let data = try formData.encode()
      0|  294|                    let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  295|                        request: self.upload(URLRequestWithContentType, data: data),
      0|  296|                        streamingFromDisk: false,
      0|  297|                        streamFileURL: nil
      0|  298|                    )
      0|  299|
      0|  300|                    dispatch_async(dispatch_get_main_queue()) {
      0|  301|                        encodingCompletion?(encodingResult)
      0|  302|                    }
      0|  303|                } catch {
      0|  304|                    dispatch_async(dispatch_get_main_queue()) {
      0|  305|                        encodingCompletion?(.Failure(error as NSError))
      0|  306|                    }
      0|  307|                }
      0|  308|            } else {
      0|  309|                let fileManager = NSFileManager.defaultManager()
      0|  310|                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
      0|  311|                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
      0|  312|                let fileName = NSUUID().UUIDString
      0|  313|                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
      0|  314|
      0|  315|                do {
      0|  316|                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
      0|  317|                    try formData.writeEncodedDataToDisk(fileURL)
      0|  318|
      0|  319|                    dispatch_async(dispatch_get_main_queue()) {
      0|  320|                        let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  321|                            request: self.upload(URLRequestWithContentType, file: fileURL),
      0|  322|                            streamingFromDisk: true,
      0|  323|                            streamFileURL: fileURL
      0|  324|                        )
      0|  325|                        encodingCompletion?(encodingResult)
      0|  326|                    }
      0|  327|                } catch {
      0|  328|                    dispatch_async(dispatch_get_main_queue()) {
      0|  329|                        encodingCompletion?(.Failure(error as NSError))
      0|  330|                    }
      0|  331|                }
      0|  332|            }
      0|  333|        }
      0|  334|    }
       |  335|}
       |  336|
       |  337|// MARK: -
       |  338|
       |  339|extension Request {
       |  340|
       |  341|    // MARK: - UploadTaskDelegate
       |  342|
       |  343|    class UploadTaskDelegate: DataTaskDelegate {
      0|  344|        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
       |  345|        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
       |  346|
       |  347|        // MARK: - NSURLSessionTaskDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  352|
       |  353|        // MARK: Delegate Methods
       |  354|
       |  355|        func URLSession(
       |  356|            session: NSURLSession,
       |  357|            task: NSURLSessionTask,
       |  358|            didSendBodyData bytesSent: Int64,
       |  359|            totalBytesSent: Int64,
       |  360|            totalBytesExpectedToSend: Int64)
      0|  361|        {
      0|  362|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  363|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  364|            } else {
      0|  365|                progress.totalUnitCount = totalBytesExpectedToSend
      0|  366|                progress.completedUnitCount = totalBytesSent
      0|  367|
      0|  368|                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  369|            }
      0|  370|        }
       |  371|    }
       |  372|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Validation.swift:
       |    1|// Validation.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Request {
       |   26|
       |   27|    /**
       |   28|        Used to represent whether validation was successful or encountered an error resulting in a failure.
       |   29|
       |   30|        - Success: The validation was successful.
       |   31|        - Failure: The validation failed encountering the provided error.
       |   32|    */
       |   33|    public enum ValidationResult {
       |   34|        case Success
       |   35|        case Failure(NSError)
       |   36|    }
       |   37|
       |   38|    /**
       |   39|        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
       |   40|        request was valid.
       |   41|    */
       |   42|    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
       |   43|
       |   44|    /**
       |   45|        Validates the request, using the specified closure.
       |   46|
       |   47|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   48|
       |   49|        - parameter validation: A closure to validate the request.
       |   50|
       |   51|        - returns: The request.
       |   52|    */
      0|   53|    public func validate(validation: Validation) -> Self {
      0|   54|        delegate.queue.addOperationWithBlock {
      0|   55|            if let
      0|   56|                response = self.response where self.delegate.error == nil,
      0|   57|                case let .Failure(error) = validation(self.request, response)
      0|   58|            {
      0|   59|                self.delegate.error = error
      0|   60|            }
      0|   61|        }
      0|   62|
      0|   63|        return self
      0|   64|    }
       |   65|
       |   66|    // MARK: - Status Code
       |   67|
       |   68|    /**
       |   69|        Validates that the response has a status code in the specified range.
       |   70|
       |   71|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   72|
       |   73|        - parameter range: The range of acceptable status codes.
       |   74|
       |   75|        - returns: The request.
       |   76|    */
      0|   77|    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
      0|   78|        return validate { _, response in
      0|   79|            if acceptableStatusCode.contains(response.statusCode) {
      0|   80|                return .Success
      0|   81|            } else {
      0|   82|                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
      0|   83|                return .Failure(Error.errorWithCode(.StatusCodeValidationFailed, failureReason: failureReason))
      0|   84|            }
      0|   85|        }
      0|   86|    }
       |   87|
       |   88|    // MARK: - Content-Type
       |   89|
       |   90|    private struct MIMEType {
       |   91|        let type: String
       |   92|        let subtype: String
       |   93|
      0|   94|        init?(_ string: String) {
      0|   95|            let components: [String] = {
      0|   96|                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
      0|   97|                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
      0|   98|                return split.componentsSeparatedByString("/")
      0|   99|            }()
      0|  100|
      0|  101|            if let
      0|  102|                type = components.first,
      0|  103|                subtype = components.last
      0|  104|            {
      0|  105|                self.type = type
      0|  106|                self.subtype = subtype
      0|  107|            } else {
      0|  108|                return nil
      0|  109|            }
      0|  110|        }
       |  111|
      0|  112|        func matches(MIME: MIMEType) -> Bool {
      0|  113|            switch (type, subtype) {
      0|  114|            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
      0|  115|                return true
      0|  116|            default:
      0|  117|                return false
      0|  118|            }
      0|  119|        }
       |  120|    }
       |  121|
       |  122|    /**
       |  123|        Validates that the response has a content type in the specified array.
       |  124|
       |  125|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  126|
       |  127|        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
       |  128|
       |  129|        - returns: The request.
       |  130|    */
      0|  131|    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
      0|  132|        return validate { _, response in
      0|  133|            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
      0|  134|
      0|  135|            if let
      0|  136|                responseContentType = response.MIMEType,
      0|  137|                responseMIMEType = MIMEType(responseContentType)
      0|  138|            {
      0|  139|                for contentType in acceptableContentTypes {
      0|  140|                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
      0|  141|                        return .Success
      0|  142|                    }
      0|  143|                }
      0|  144|            } else {
      0|  145|                for contentType in acceptableContentTypes {
      0|  146|                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
      0|  147|                        return .Success
      0|  148|                    }
      0|  149|                }
      0|  150|            }
      0|  151|
      0|  152|            let failureReason: String
      0|  153|
      0|  154|            if let responseContentType = response.MIMEType {
      0|  155|                failureReason = (
      0|  156|                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
      0|  157|                    "content types: \(acceptableContentTypes)"
      0|  158|                )
      0|  159|            } else {
      0|  160|                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
      0|  161|            }
      0|  162|
      0|  163|            return .Failure(Error.errorWithCode(.ContentTypeValidationFailed, failureReason: failureReason))
      0|  164|        }
      0|  165|    }
       |  166|
       |  167|    // MARK: - Automatic
       |  168|
       |  169|    /**
       |  170|        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
       |  171|        type matches any specified in the Accept HTTP header field.
       |  172|
       |  173|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  174|
       |  175|        - returns: The request.
       |  176|    */
      0|  177|    public func validate() -> Self {
      0|  178|        let acceptableStatusCodes: Range<Int> = 200..<300
      0|  179|        let acceptableContentTypes: [String] = {
      0|  180|            if let accept = request?.valueForHTTPHeaderField("Accept") {
      0|  181|                return accept.componentsSeparatedByString(",")
      0|  182|            }
      0|  183|
      0|  184|            return ["*/*"]
      0|  185|        }()
      0|  186|
      0|  187|        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
      0|  188|    }
       |  189|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Alamofire.swift:
       |    1|// Alamofire.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: - URLStringConvertible
       |   26|
       |   27|/**
       |   28|    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
       |   29|    construct URL requests.
       |   30|*/
       |   31|public protocol URLStringConvertible {
       |   32|    /**
       |   33|        A URL that conforms to RFC 2396.
       |   34|
       |   35|        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
       |   36|
       |   37|        See https://tools.ietf.org/html/rfc2396
       |   38|        See https://tools.ietf.org/html/rfc1738
       |   39|        See https://tools.ietf.org/html/rfc1808
       |   40|    */
       |   41|    var URLString: String { get }
       |   42|}
       |   43|
       |   44|extension String: URLStringConvertible {
      1|   45|    public var URLString: String {
      1|   46|        return self
      1|   47|    }
       |   48|}
       |   49|
       |   50|extension NSURL: URLStringConvertible {
      0|   51|    public var URLString: String {
      0|   52|        return absoluteString
      0|   53|    }
       |   54|}
       |   55|
       |   56|extension NSURLComponents: URLStringConvertible {
      0|   57|    public var URLString: String {
      0|   58|        return URL!.URLString
      0|   59|    }
       |   60|}
       |   61|
       |   62|extension NSURLRequest: URLStringConvertible {
      0|   63|    public var URLString: String {
      0|   64|        return URL!.URLString
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - URLRequestConvertible
       |   69|
       |   70|/**
       |   71|    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
       |   72|*/
       |   73|public protocol URLRequestConvertible {
       |   74|    /// The URL request.
       |   75|    var URLRequest: NSMutableURLRequest { get }
       |   76|}
       |   77|
       |   78|extension NSURLRequest: URLRequestConvertible {
      2|   79|    public var URLRequest: NSMutableURLRequest {
      2|   80|        return self.mutableCopy() as! NSMutableURLRequest
      2|   81|    }
       |   82|}
       |   83|
       |   84|// MARK: - Convenience
       |   85|
       |   86|func URLRequest(
       |   87|    method: Method,
       |   88|    _ URLString: URLStringConvertible,
       |   89|    headers: [String: String]? = nil)
       |   90|    -> NSMutableURLRequest
      1|   91|{
      1|   92|    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
      1|   93|    mutableURLRequest.HTTPMethod = method.rawValue
      1|   94|
      1|   95|    if let headers = headers {
      2|   96|        for (headerField, headerValue) in headers {
      2|   97|            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
      2|   98|        }
      1|   99|    }
      1|  100|
      1|  101|    return mutableURLRequest
      1|  102|}
       |  103|
       |  104|// MARK: - Request Methods
       |  105|
       |  106|/**
       |  107|    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
       |  108|    parameter encoding.
       |  109|
       |  110|    - parameter method:     The HTTP method.
       |  111|    - parameter URLString:  The URL string.
       |  112|    - parameter parameters: The parameters. `nil` by default.
       |  113|    - parameter encoding:   The parameter encoding. `.URL` by default.
       |  114|    - parameter headers:    The HTTP headers. `nil` by default.
       |  115|
       |  116|    - returns: The created request.
       |  117|*/
       |  118|public func request(
       |  119|    method: Method,
       |  120|    _ URLString: URLStringConvertible,
       |  121|    parameters: [String: AnyObject]? = nil,
       |  122|    encoding: ParameterEncoding = .URL,
       |  123|    headers: [String: String]? = nil)
       |  124|    -> Request
      1|  125|{
      1|  126|    return Manager.sharedInstance.request(
      1|  127|        method,
      1|  128|        URLString,
      1|  129|        parameters: parameters,
      1|  130|        encoding: encoding,
      1|  131|        headers: headers
      1|  132|    )
      1|  133|}
       |  134|
       |  135|/**
       |  136|    Creates a request using the shared manager instance for the specified URL request.
       |  137|
       |  138|    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  139|
       |  140|    - parameter URLRequest: The URL request
       |  141|
       |  142|    - returns: The created request.
       |  143|*/
      0|  144|public func request(URLRequest: URLRequestConvertible) -> Request {
      0|  145|    return Manager.sharedInstance.request(URLRequest.URLRequest)
      0|  146|}
       |  147|
       |  148|// MARK: - Upload Methods
       |  149|
       |  150|// MARK: File
       |  151|
       |  152|/**
       |  153|    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
       |  154|
       |  155|    - parameter method:    The HTTP method.
       |  156|    - parameter URLString: The URL string.
       |  157|    - parameter headers:   The HTTP headers. `nil` by default.
       |  158|    - parameter file:      The file to upload.
       |  159|
       |  160|    - returns: The created upload request.
       |  161|*/
       |  162|public func upload(
       |  163|    method: Method,
       |  164|    _ URLString: URLStringConvertible,
       |  165|    headers: [String: String]? = nil,
       |  166|    file: NSURL)
       |  167|    -> Request
      0|  168|{
      0|  169|    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
      0|  170|}
       |  171|
       |  172|/**
       |  173|    Creates an upload request using the shared manager instance for the specified URL request and file.
       |  174|
       |  175|    - parameter URLRequest: The URL request.
       |  176|    - parameter file:       The file to upload.
       |  177|
       |  178|    - returns: The created upload request.
       |  179|*/
      0|  180|public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|  181|    return Manager.sharedInstance.upload(URLRequest, file: file)
      0|  182|}
       |  183|
       |  184|// MARK: Data
       |  185|
       |  186|/**
       |  187|    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
       |  188|
       |  189|    - parameter method:    The HTTP method.
       |  190|    - parameter URLString: The URL string.
       |  191|    - parameter headers:   The HTTP headers. `nil` by default.
       |  192|    - parameter data:      The data to upload.
       |  193|
       |  194|    - returns: The created upload request.
       |  195|*/
       |  196|public func upload(
       |  197|    method: Method,
       |  198|    _ URLString: URLStringConvertible,
       |  199|    headers: [String: String]? = nil,
       |  200|    data: NSData)
       |  201|    -> Request
      0|  202|{
      0|  203|    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
      0|  204|}
       |  205|
       |  206|/**
       |  207|    Creates an upload request using the shared manager instance for the specified URL request and data.
       |  208|
       |  209|    - parameter URLRequest: The URL request.
       |  210|    - parameter data:       The data to upload.
       |  211|
       |  212|    - returns: The created upload request.
       |  213|*/
      0|  214|public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  215|    return Manager.sharedInstance.upload(URLRequest, data: data)
      0|  216|}
       |  217|
       |  218|// MARK: Stream
       |  219|
       |  220|/**
       |  221|    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
       |  222|
       |  223|    - parameter method:    The HTTP method.
       |  224|    - parameter URLString: The URL string.
       |  225|    - parameter headers:   The HTTP headers. `nil` by default.
       |  226|    - parameter stream:    The stream to upload.
       |  227|
       |  228|    - returns: The created upload request.
       |  229|*/
       |  230|public func upload(
       |  231|    method: Method,
       |  232|    _ URLString: URLStringConvertible,
       |  233|    headers: [String: String]? = nil,
       |  234|    stream: NSInputStream)
       |  235|    -> Request
      0|  236|{
      0|  237|    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
      0|  238|}
       |  239|
       |  240|/**
       |  241|    Creates an upload request using the shared manager instance for the specified URL request and stream.
       |  242|
       |  243|    - parameter URLRequest: The URL request.
       |  244|    - parameter stream:     The stream to upload.
       |  245|
       |  246|    - returns: The created upload request.
       |  247|*/
      0|  248|public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  249|    return Manager.sharedInstance.upload(URLRequest, stream: stream)
      0|  250|}
       |  251|
       |  252|// MARK: MultipartFormData
       |  253|
       |  254|/**
       |  255|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  256|
       |  257|    - parameter method:                  The HTTP method.
       |  258|    - parameter URLString:               The URL string.
       |  259|    - parameter headers:                 The HTTP headers. `nil` by default.
       |  260|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  261|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  262|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  263|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  264|*/
       |  265|public func upload(
       |  266|    method: Method,
       |  267|    _ URLString: URLStringConvertible,
       |  268|    headers: [String: String]? = nil,
       |  269|    multipartFormData: MultipartFormData -> Void,
       |  270|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  271|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  272|{
      0|  273|    return Manager.sharedInstance.upload(
      0|  274|        method,
      0|  275|        URLString,
      0|  276|        headers: headers,
      0|  277|        multipartFormData: multipartFormData,
      0|  278|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  279|        encodingCompletion: encodingCompletion
      0|  280|    )
      0|  281|}
       |  282|
       |  283|/**
       |  284|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  285|
       |  286|    - parameter URLRequest:              The URL request.
       |  287|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  288|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  289|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  290|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  291|*/
       |  292|public func upload(
       |  293|    URLRequest: URLRequestConvertible,
       |  294|    multipartFormData: MultipartFormData -> Void,
       |  295|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  296|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  297|{
      0|  298|    return Manager.sharedInstance.upload(
      0|  299|        URLRequest,
      0|  300|        multipartFormData: multipartFormData,
      0|  301|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  302|        encodingCompletion: encodingCompletion
      0|  303|    )
      0|  304|}
       |  305|
       |  306|// MARK: - Download Methods
       |  307|
       |  308|// MARK: URL Request
       |  309|
       |  310|/**
       |  311|    Creates a download request using the shared manager instance for the specified method and URL string.
       |  312|
       |  313|    - parameter method:      The HTTP method.
       |  314|    - parameter URLString:   The URL string.
       |  315|    - parameter parameters:  The parameters. `nil` by default.
       |  316|    - parameter encoding:    The parameter encoding. `.URL` by default.
       |  317|    - parameter headers:     The HTTP headers. `nil` by default.
       |  318|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  319|
       |  320|    - returns: The created download request.
       |  321|*/
       |  322|public func download(
       |  323|    method: Method,
       |  324|    _ URLString: URLStringConvertible,
       |  325|    parameters: [String: AnyObject]? = nil,
       |  326|    encoding: ParameterEncoding = .URL,
       |  327|    headers: [String: String]? = nil,
       |  328|    destination: Request.DownloadFileDestination)
       |  329|    -> Request
      0|  330|{
      0|  331|    return Manager.sharedInstance.download(
      0|  332|        method,
      0|  333|        URLString,
      0|  334|        parameters: parameters,
      0|  335|        encoding: encoding,
      0|  336|        headers: headers,
      0|  337|        destination: destination
      0|  338|    )
      0|  339|}
       |  340|
       |  341|/**
       |  342|    Creates a download request using the shared manager instance for the specified URL request.
       |  343|
       |  344|    - parameter URLRequest:  The URL request.
       |  345|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  346|
       |  347|    - returns: The created download request.
       |  348|*/
      0|  349|public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  350|    return Manager.sharedInstance.download(URLRequest, destination: destination)
      0|  351|}
       |  352|
       |  353|// MARK: Resume Data
       |  354|
       |  355|/**
       |  356|    Creates a request using the shared manager instance for downloading from the resume data produced from a 
       |  357|    previous request cancellation.
       |  358|
       |  359|    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
       |  360|                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
       |  361|                             information.
       |  362|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  363|
       |  364|    - returns: The created download request.
       |  365|*/
      0|  366|public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  367|    return Manager.sharedInstance.download(data, destination: destination)
      0|  368|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Download.swift:
       |    1|// Download.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Downloadable {
       |   27|        case Request(NSURLRequest)
       |   28|        case ResumeData(NSData)
       |   29|    }
       |   30|
      0|   31|    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
      0|   32|        var downloadTask: NSURLSessionDownloadTask!
      0|   33|
      0|   34|        switch downloadable {
      0|   35|        case .Request(let request):
      0|   36|            dispatch_sync(queue) {
      0|   37|                downloadTask = self.session.downloadTaskWithRequest(request)
      0|   38|            }
      0|   39|        case .ResumeData(let resumeData):
      0|   40|            dispatch_sync(queue) {
      0|   41|                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
      0|   42|            }
      0|   43|        }
      0|   44|
      0|   45|        let request = Request(session: session, task: downloadTask)
      0|   46|
      0|   47|        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
      0|   48|            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
      0|   49|                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
      0|   50|            }
      0|   51|        }
      0|   52|
      0|   53|        delegate[request.delegate.task] = request.delegate
      0|   54|
      0|   55|        if startRequestsImmediately {
      0|   56|            request.resume()
      0|   57|        }
      0|   58|
      0|   59|        return request
      0|   60|    }
       |   61|
       |   62|    // MARK: Request
       |   63|
       |   64|    /**
       |   65|        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
       |   66|        and destination.
       |   67|
       |   68|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   69|
       |   70|        - parameter method:      The HTTP method.
       |   71|        - parameter URLString:   The URL string.
       |   72|        - parameter parameters:  The parameters. `nil` by default.
       |   73|        - parameter encoding:    The parameter encoding. `.URL` by default.
       |   74|        - parameter headers:     The HTTP headers. `nil` by default.
       |   75|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |   76|
       |   77|        - returns: The created download request.
       |   78|    */
       |   79|    public func download(
       |   80|        method: Method,
       |   81|        _ URLString: URLStringConvertible,
       |   82|        parameters: [String: AnyObject]? = nil,
       |   83|        encoding: ParameterEncoding = .URL,
       |   84|        headers: [String: String]? = nil,
       |   85|        destination: Request.DownloadFileDestination)
       |   86|        -> Request
      0|   87|    {
      0|   88|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|   89|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      0|   90|
      0|   91|        return download(encodedURLRequest, destination: destination)
      0|   92|    }
       |   93|
       |   94|    /**
       |   95|        Creates a request for downloading from the specified URL request.
       |   96|
       |   97|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   98|
       |   99|        - parameter URLRequest:  The URL request
       |  100|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  101|
       |  102|        - returns: The created download request.
       |  103|    */
      0|  104|    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  105|        return download(.Request(URLRequest.URLRequest), destination: destination)
      0|  106|    }
       |  107|
       |  108|    // MARK: Resume Data
       |  109|
       |  110|    /**
       |  111|        Creates a request for downloading from the resume data produced from a previous request cancellation.
       |  112|
       |  113|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  114|
       |  115|        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
       |  116|                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
       |  117|                                 additional information.
       |  118|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  119|
       |  120|        - returns: The created download request.
       |  121|    */
      0|  122|    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  123|        return download(.ResumeData(resumeData), destination: destination)
      0|  124|    }
       |  125|}
       |  126|
       |  127|// MARK: -
       |  128|
       |  129|extension Request {
       |  130|    /**
       |  131|        A closure executed once a request has successfully completed in order to determine where to move the temporary 
       |  132|        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
       |  133|        response, and returns a single argument: the file URL where the temporary file should be moved.
       |  134|    */
       |  135|    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
       |  136|
       |  137|    /**
       |  138|        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
       |  139|        file URL in the first available directory with the specified search path directory and search path domain mask.
       |  140|
       |  141|        - parameter directory: The search path directory. `.DocumentDirectory` by default.
       |  142|        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
       |  143|
       |  144|        - returns: A download file destination closure.
       |  145|    */
       |  146|    public class func suggestedDownloadDestination(
       |  147|        directory directory: NSSearchPathDirectory = .DocumentDirectory,
       |  148|        domain: NSSearchPathDomainMask = .UserDomainMask)
       |  149|        -> DownloadFileDestination
      0|  150|    {
      0|  151|        return { temporaryURL, response -> NSURL in
      0|  152|            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
      0|  153|
      0|  154|            if !directoryURLs.isEmpty {
      0|  155|                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
      0|  156|            }
      0|  157|
      0|  158|            return temporaryURL
      0|  159|        }
      0|  160|    }
       |  161|
       |  162|    /// The resume data of the underlying download task if available after a failure.
      0|  163|    public var resumeData: NSData? {
      0|  164|        var data: NSData?
      0|  165|
      0|  166|        if let delegate = delegate as? DownloadTaskDelegate {
      0|  167|            data = delegate.resumeData
      0|  168|        }
      0|  169|
      0|  170|        return data
      0|  171|    }
       |  172|
       |  173|    // MARK: - DownloadTaskDelegate
       |  174|
       |  175|    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
      0|  176|        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
       |  177|        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
       |  178|
       |  179|        var resumeData: NSData?
      0|  180|        override var data: NSData? { return resumeData }
       |  181|
       |  182|        // MARK: - NSURLSessionDownloadDelegate
       |  183|
       |  184|        // MARK: Override Closures
       |  185|
       |  186|        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
       |  187|        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  188|        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  189|
       |  190|        // MARK: Delegate Methods
       |  191|
       |  192|        func URLSession(
       |  193|            session: NSURLSession,
       |  194|            downloadTask: NSURLSessionDownloadTask,
       |  195|            didFinishDownloadingToURL location: NSURL)
      0|  196|        {
      0|  197|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  198|                do {
      0|  199|                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  200|                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
      0|  201|                } catch {
      0|  202|                    self.error = error as NSError
      0|  203|                }
      0|  204|            }
      0|  205|        }
       |  206|
       |  207|        func URLSession(
       |  208|            session: NSURLSession,
       |  209|            downloadTask: NSURLSessionDownloadTask,
       |  210|            didWriteData bytesWritten: Int64,
       |  211|            totalBytesWritten: Int64,
       |  212|            totalBytesExpectedToWrite: Int64)
      0|  213|        {
      0|  214|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  215|                downloadTaskDidWriteData(
      0|  216|                    session,
      0|  217|                    downloadTask,
      0|  218|                    bytesWritten,
      0|  219|                    totalBytesWritten, 
      0|  220|                    totalBytesExpectedToWrite
      0|  221|                )
      0|  222|            } else {
      0|  223|                progress.totalUnitCount = totalBytesExpectedToWrite
      0|  224|                progress.completedUnitCount = totalBytesWritten
      0|  225|
      0|  226|                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  227|            }
      0|  228|        }
       |  229|
       |  230|        func URLSession(
       |  231|            session: NSURLSession,
       |  232|            downloadTask: NSURLSessionDownloadTask,
       |  233|            didResumeAtOffset fileOffset: Int64,
       |  234|            expectedTotalBytes: Int64)
      0|  235|        {
      0|  236|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  237|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  238|            } else {
      0|  239|                progress.totalUnitCount = expectedTotalBytes
      0|  240|                progress.completedUnitCount = fileOffset
      0|  241|            }
      0|  242|        }
       |  243|    }
       |  244|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Error.swift:
       |    1|// Error.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
       |   26|public struct Error {
       |   27|    /// The domain used for creating all Alamofire errors.
       |   28|    public static let Domain = "com.alamofire.error"
       |   29|
       |   30|    /// The custom error codes generated by Alamofire.
       |   31|    public enum Code: Int {
       |   32|        case InputStreamReadFailed           = -6000
       |   33|        case OutputStreamWriteFailed         = -6001
       |   34|        case ContentTypeValidationFailed     = -6002
       |   35|        case StatusCodeValidationFailed      = -6003
       |   36|        case DataSerializationFailed         = -6004
       |   37|        case StringSerializationFailed       = -6005
       |   38|        case JSONSerializationFailed         = -6006
       |   39|        case PropertyListSerializationFailed = -6007
       |   40|    }
       |   41|
       |   42|    /**
       |   43|        Creates an `NSError` with the given error code and failure reason.
       |   44|
       |   45|        - parameter code:          The error code.
       |   46|        - parameter failureReason: The failure reason.
       |   47|
       |   48|        - returns: An `NSError` with the given error code and failure reason.
       |   49|    */
      0|   50|    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
      0|   51|        return errorWithCode(code.rawValue, failureReason: failureReason)
      0|   52|    }
       |   53|
       |   54|    /**
       |   55|        Creates an `NSError` with the given error code and failure reason.
       |   56|
       |   57|        - parameter code:          The error code.
       |   58|        - parameter failureReason: The failure reason.
       |   59|
       |   60|        - returns: An `NSError` with the given error code and failure reason.
       |   61|    */
      0|   62|    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
      0|   63|        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
      0|   64|        return NSError(domain: Domain, code: code, userInfo: userInfo)
      0|   65|    }
       |   66|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Manager.swift:
       |    1|// Manager.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
       |   27|*/
       |   28|public class Manager {
       |   29|
       |   30|    // MARK: - Properties
       |   31|
       |   32|    /**
       |   33|        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
       |   34|        for any ad hoc requests.
       |   35|    */
       |   36|    public static let sharedInstance: Manager = {
       |   37|        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
       |   38|        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
       |   39|
       |   40|        return Manager(configuration: configuration)
       |   41|    }()
       |   42|
       |   43|    /**
       |   44|        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
       |   45|    */
       |   46|    public static let defaultHTTPHeaders: [String: String] = {
       |   47|        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
       |   48|        let acceptEncoding: String = "gzip;q=1.0,compress;q=0.5"
       |   49|
       |   50|        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
       |   51|        let acceptLanguage: String = {
       |   52|            var components: [String] = []
       |   53|            for (index, languageCode) in (NSLocale.preferredLanguages() as [String]).enumerate() {
       |   54|                let q = 1.0 - (Double(index) * 0.1)
       |   55|                components.append("\(languageCode);q=\(q)")
       |   56|                if q <= 0.5 {
       |   57|                    break
       |   58|                }
       |   59|            }
       |   60|
       |   61|            return components.joinWithSeparator(",")
       |   62|        }()
       |   63|
       |   64|        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
       |   65|        let userAgent: String = {
       |   66|            if let info = NSBundle.mainBundle().infoDictionary {
       |   67|                let executable: AnyObject = info[kCFBundleExecutableKey as String] ?? "Unknown"
       |   68|                let bundle: AnyObject = info[kCFBundleIdentifierKey as String] ?? "Unknown"
       |   69|                let version: AnyObject = info[kCFBundleVersionKey as String] ?? "Unknown"
       |   70|                let os: AnyObject = NSProcessInfo.processInfo().operatingSystemVersionString ?? "Unknown"
       |   71|
       |   72|                var mutableUserAgent = NSMutableString(string: "\(executable)/\(bundle) (\(version); OS \(os))") as CFMutableString
       |   73|                let transform = NSString(string: "Any-Latin; Latin-ASCII; [:^ASCII:] Remove") as CFString
       |   74|
       |   75|                if CFStringTransform(mutableUserAgent, UnsafeMutablePointer<CFRange>(nil), transform, false) {
       |   76|                    return mutableUserAgent as String
       |   77|                }
       |   78|            }
       |   79|
       |   80|            return "Alamofire"
       |   81|        }()
       |   82|
       |   83|        return [
       |   84|            "Accept-Encoding": acceptEncoding,
       |   85|            "Accept-Language": acceptLanguage,
       |   86|            "User-Agent": userAgent
       |   87|        ]
       |   88|    }()
       |   89|
       |   90|    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
       |   91|
       |   92|    /// The underlying session.
       |   93|    public let session: NSURLSession
       |   94|
       |   95|    /// The session delegate handling all the task and session delegate callbacks.
       |   96|    public let delegate: SessionDelegate
       |   97|
       |   98|    /// Whether to start requests immediately after being constructed. `true` by default.
       |   99|    public var startRequestsImmediately: Bool = true
       |  100|
       |  101|    /**
       |  102|        The background completion handler closure provided by the UIApplicationDelegate 
       |  103|        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
       |  104|        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
       |  105|        will automatically call the handler.
       |  106|    
       |  107|        If you need to handle your own events before the handler is called, then you need to override the 
       |  108|        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
       |  109|    
       |  110|        `nil` by default.
       |  111|    */
       |  112|    public var backgroundCompletionHandler: (() -> Void)?
       |  113|
       |  114|    // MARK: - Lifecycle
       |  115|
       |  116|    /**
       |  117|        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
       |  118|
       |  119|        - parameter configuration:            The configuration used to construct the managed session. 
       |  120|                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
       |  121|        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
       |  122|                                              default.
       |  123|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
       |  124|                                              challenges. `nil` by default.
       |  125|
       |  126|        - returns: The new `Manager` instance.
       |  127|    */
       |  128|    public init(
       |  129|        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
       |  130|        delegate: SessionDelegate = SessionDelegate(),
       |  131|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      1|  132|    {
      1|  133|        self.delegate = delegate
      1|  134|        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
      1|  135|
      1|  136|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      1|  137|    }
       |  138|
       |  139|    /**
       |  140|        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
       |  141|
       |  142|        - parameter session:                  The URL session.
       |  143|        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
       |  144|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
       |  145|                                              challenges. `nil` by default.
       |  146|
       |  147|        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
       |  148|    */
       |  149|    public init?(
       |  150|        session: NSURLSession,
       |  151|        delegate: SessionDelegate,
       |  152|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      0|  153|    {
      0|  154|        self.delegate = delegate
      0|  155|        self.session = session
      0|  156|
      0|  157|        guard delegate === session.delegate else { return nil }
      0|  158|
      0|  159|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      0|  160|    }
       |  161|
      1|  162|    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
      1|  163|        session.serverTrustPolicyManager = serverTrustPolicyManager
      1|  164|
      0|  165|        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
      0|  166|            guard let strongSelf = self else { return }
      0|  167|            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
      0|  168|        }
      1|  169|    }
       |  170|
      0|  171|    deinit {
      0|  172|        session.invalidateAndCancel()
      0|  173|    }
       |  174|
       |  175|    // MARK: - Request
       |  176|
       |  177|    /**
       |  178|        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
       |  179|
       |  180|        - parameter method:     The HTTP method.
       |  181|        - parameter URLString:  The URL string.
       |  182|        - parameter parameters: The parameters. `nil` by default.
       |  183|        - parameter encoding:   The parameter encoding. `.URL` by default.
       |  184|        - parameter headers:    The HTTP headers. `nil` by default.
       |  185|
       |  186|        - returns: The created request.
       |  187|    */
       |  188|    public func request(
       |  189|        method: Method,
       |  190|        _ URLString: URLStringConvertible,
       |  191|        parameters: [String: AnyObject]? = nil,
       |  192|        encoding: ParameterEncoding = .URL,
       |  193|        headers: [String: String]? = nil)
       |  194|        -> Request
      1|  195|    {
      1|  196|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      1|  197|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      1|  198|        return request(encodedURLRequest)
      1|  199|    }
       |  200|
       |  201|    /**
       |  202|        Creates a request for the specified URL request.
       |  203|
       |  204|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  205|
       |  206|        - parameter URLRequest: The URL request
       |  207|
       |  208|        - returns: The created request.
       |  209|    */
      1|  210|    public func request(URLRequest: URLRequestConvertible) -> Request {
      1|  211|        var dataTask: NSURLSessionDataTask!
      1|  212|        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
      1|  213|
      1|  214|        let request = Request(session: session, task: dataTask)
      1|  215|        delegate[request.delegate.task] = request.delegate
      1|  216|
      1|  217|        if startRequestsImmediately {
      1|  218|            request.resume()
      1|  219|        }
      1|  220|
      1|  221|        return request
      1|  222|    }
      1|  223|
      1|  224|    // MARK: - SessionDelegate
      1|  225|
       |  226|    /**
       |  227|        Responsible for handling all delegate callbacks for the underlying session.
       |  228|    */
       |  229|    public final class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
       |  230|        private var subdelegates: [Int: Request.TaskDelegate] = [:]
       |  231|        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
       |  232|
       |  233|        subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
       |  234|            get {
       |  235|                var subdelegate: Request.TaskDelegate?
       |  236|                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
      4|  237|
      4|  238|                return subdelegate
      4|  239|            }
      4|  240|
      4|  241|            set {
      4|  242|                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
      4|  243|            }
      4|  244|        }
       |  245|
      2|  246|        /**
      2|  247|            Initializes the `SessionDelegate` instance.
      2|  248|
      2|  249|            - returns: The new `SessionDelegate` instance.
      2|  250|        */
       |  251|        public override init() {
       |  252|            super.init()
       |  253|        }
       |  254|
       |  255|        // MARK: - NSURLSessionDelegate
       |  256|
       |  257|        // MARK: Override Closures
      1|  258|
      1|  259|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
      1|  260|        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
       |  261|
       |  262|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
       |  263|        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  264|
       |  265|        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
       |  266|        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
       |  267|
       |  268|        // MARK: Delegate Methods
       |  269|
       |  270|        /**
       |  271|            Tells the delegate that the session has been invalidated.
       |  272|
       |  273|            - parameter session: The session object that was invalidated.
       |  274|            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
       |  275|        */
       |  276|        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
       |  277|            sessionDidBecomeInvalidWithError?(session, error)
       |  278|        }
       |  279|
       |  280|        /**
       |  281|            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
       |  282|
      0|  283|            - parameter session:           The session containing the task that requested authentication.
      0|  284|            - parameter challenge:         An object that contains the request for authentication.
      0|  285|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  286|        */
       |  287|        public func URLSession(
       |  288|            session: NSURLSession,
       |  289|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  290|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
       |  291|        {
       |  292|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
       |  293|            var credential: NSURLCredential?
       |  294|
       |  295|            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
       |  296|                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
       |  297|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      0|  298|                let host = challenge.protectionSpace.host
      0|  299|
      0|  300|                if let
      0|  301|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      0|  302|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  303|                {
      0|  304|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  305|                        disposition = .UseCredential
      0|  306|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  307|                    } else {
      0|  308|                        disposition = .CancelAuthenticationChallenge
      0|  309|                    }
      0|  310|                }
      0|  311|            }
      0|  312|
      0|  313|            completionHandler(disposition, credential)
      0|  314|        }
      0|  315|
      0|  316|        /**
      0|  317|            Tells the delegate that all messages enqueued for a session have been delivered.
      0|  318|
      0|  319|            - parameter session: The session that no longer has any outstanding requests.
      0|  320|        */
      0|  321|        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
       |  322|            sessionDidFinishEventsForBackgroundURLSession?(session)
       |  323|        }
       |  324|
       |  325|        // MARK: - NSURLSessionTaskDelegate
       |  326|
       |  327|        // MARK: Override Closures
      0|  328|
      0|  329|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
      0|  330|        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  331|
       |  332|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
       |  333|        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  334|
       |  335|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
       |  336|        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream!)?
       |  337|
       |  338|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
       |  339|        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  340|
       |  341|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
       |  342|        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  343|
       |  344|        // MARK: Delegate Methods
       |  345|
       |  346|        /**
       |  347|            Tells the delegate that the remote server requested an HTTP redirect.
       |  348|
       |  349|            - parameter session:           The session containing the task whose request resulted in a redirect.
       |  350|            - parameter task:              The task whose request resulted in a redirect.
       |  351|            - parameter response:          An object containing the server’s response to the original request.
       |  352|            - parameter request:           A URL request object filled out with the new location.
       |  353|            - parameter completionHandler: A closure that your handler should call with either the value of the request 
       |  354|                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
       |  355|                                           return the body of the redirect response.
       |  356|        */
       |  357|        public func URLSession(
       |  358|            session: NSURLSession,
       |  359|            task: NSURLSessionTask,
       |  360|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  361|            newRequest request: NSURLRequest,
       |  362|            completionHandler: ((NSURLRequest?) -> Void))
       |  363|        {
       |  364|            var redirectRequest: NSURLRequest? = request
       |  365|
       |  366|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
       |  367|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
       |  368|            }
       |  369|
      0|  370|            completionHandler(redirectRequest)
      0|  371|        }
      0|  372|
      0|  373|        /**
      0|  374|            Requests credentials from the delegate in response to an authentication request from the remote server.
      0|  375|
      0|  376|            - parameter session:           The session containing the task whose request requires authentication.
      0|  377|            - parameter task:              The task whose request requires authentication.
      0|  378|            - parameter challenge:         An object that contains the request for authentication.
       |  379|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  380|        */
       |  381|        public func URLSession(
       |  382|            session: NSURLSession,
       |  383|            task: NSURLSessionTask,
       |  384|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  385|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
       |  386|        {
       |  387|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
       |  388|                completionHandler(taskDidReceiveChallenge(session, task, challenge))
       |  389|            } else if let delegate = self[task] {
       |  390|                delegate.URLSession(
       |  391|                    session,
       |  392|                    task: task,
      1|  393|                    didReceiveChallenge: challenge,
      0|  394|                    completionHandler: completionHandler
      0|  395|                )
      1|  396|            } else {
      1|  397|                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
      1|  398|            }
      1|  399|        }
      1|  400|
      1|  401|        /**
      1|  402|            Tells the delegate when a task requires a new request body stream to send to the remote server.
      0|  403|
      0|  404|            - parameter session:           The session containing the task that needs a new body stream.
      0|  405|            - parameter task:              The task that needs a new body stream.
      1|  406|            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
       |  407|        */
       |  408|        public func URLSession(
       |  409|            session: NSURLSession,
       |  410|            task: NSURLSessionTask,
       |  411|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
       |  412|        {
       |  413|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
       |  414|                completionHandler(taskNeedNewBodyStream(session, task))
       |  415|            } else if let delegate = self[task] {
       |  416|                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
       |  417|            }
       |  418|        }
      0|  419|
      0|  420|        /**
      0|  421|            Periodically informs the delegate of the progress of sending body content to the server.
      0|  422|
      0|  423|            - parameter session:                  The session containing the data task.
      0|  424|            - parameter task:                     The data task.
      0|  425|            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
       |  426|            - parameter totalBytesSent:           The total number of bytes sent so far.
       |  427|            - parameter totalBytesExpectedToSend: The expected length of the body data.
       |  428|        */
       |  429|        public func URLSession(
       |  430|            session: NSURLSession,
       |  431|            task: NSURLSessionTask,
       |  432|            didSendBodyData bytesSent: Int64,
       |  433|            totalBytesSent: Int64,
       |  434|            totalBytesExpectedToSend: Int64)
       |  435|        {
       |  436|            if let taskDidSendBodyData = taskDidSendBodyData {
       |  437|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
       |  438|            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
       |  439|                delegate.URLSession(
       |  440|                    session,
       |  441|                    task: task,
      1|  442|                    didSendBodyData: bytesSent,
      0|  443|                    totalBytesSent: totalBytesSent,
      0|  444|                    totalBytesExpectedToSend: totalBytesExpectedToSend
      0|  445|                )
      0|  446|            }
      0|  447|        }
      0|  448|
      0|  449|        /**
      0|  450|            Tells the delegate that the task finished transferring data.
      0|  451|
      0|  452|            - parameter session: The session containing the task whose request finished transferring data.
      0|  453|            - parameter task:    The task whose request finished transferring data.
      1|  454|            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
       |  455|        */
       |  456|        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
       |  457|            if let taskDidComplete = taskDidComplete {
       |  458|                taskDidComplete(session, task, error)
       |  459|            } else if let delegate = self[task] {
       |  460|                delegate.URLSession(session, task: task, didCompleteWithError: error)
       |  461|            }
       |  462|
      1|  463|            self[task] = nil
      0|  464|        }
      0|  465|
      1|  466|        // MARK: - NSURLSessionDataDelegate
      1|  467|
      1|  468|        // MARK: Override Closures
      1|  469|
      1|  470|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
      1|  471|        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  472|
       |  473|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
       |  474|        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  475|
       |  476|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
       |  477|        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  478|
       |  479|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
       |  480|        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse!)?
       |  481|
       |  482|        // MARK: Delegate Methods
       |  483|
       |  484|        /**
       |  485|            Tells the delegate that the data task received the initial reply (headers) from the server.
       |  486|
       |  487|            - parameter session:           The session containing the data task that received an initial reply.
       |  488|            - parameter dataTask:          The data task that received an initial reply.
       |  489|            - parameter response:          A URL response object populated with headers.
       |  490|            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
       |  491|                                           constant to indicate whether the transfer should continue as a data task or 
       |  492|                                           should become a download task.
       |  493|        */
       |  494|        public func URLSession(
       |  495|            session: NSURLSession,
       |  496|            dataTask: NSURLSessionDataTask,
       |  497|            didReceiveResponse response: NSURLResponse,
       |  498|            completionHandler: ((NSURLSessionResponseDisposition) -> Void))
       |  499|        {
       |  500|            var disposition: NSURLSessionResponseDisposition = .Allow
       |  501|
       |  502|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
       |  503|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
       |  504|            }
       |  505|
      0|  506|            completionHandler(disposition)
      0|  507|        }
      0|  508|
      0|  509|        /**
      0|  510|            Tells the delegate that the data task was changed to a download task.
      0|  511|
      0|  512|            - parameter session:      The session containing the task that was replaced by a download task.
      0|  513|            - parameter dataTask:     The data task that was replaced by a download task.
      0|  514|            - parameter downloadTask: The new download task that replaced the data task.
       |  515|        */
       |  516|        public func URLSession(
       |  517|            session: NSURLSession,
       |  518|            dataTask: NSURLSessionDataTask,
       |  519|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
       |  520|        {
       |  521|            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
       |  522|                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
       |  523|            } else {
       |  524|                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
       |  525|                self[downloadTask] = downloadDelegate
       |  526|            }
      0|  527|        }
      0|  528|
      0|  529|        /**
      0|  530|            Tells the delegate that the data task has received some of the expected data.
      0|  531|
      0|  532|            - parameter session:  The session containing the data task that provided data.
      0|  533|            - parameter dataTask: The data task that provided data.
      0|  534|            - parameter data:     A data object containing the transferred data.
       |  535|        */
       |  536|        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
       |  537|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
       |  538|                dataTaskDidReceiveData(session, dataTask, data)
       |  539|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
       |  540|                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
       |  541|            }
       |  542|        }
      1|  543|
      0|  544|        /**
      0|  545|            Asks the delegate whether the data (or upload) task should store the response in the cache.
      1|  546|
      1|  547|            - parameter session:           The session containing the data (or upload) task.
      1|  548|            - parameter dataTask:          The data (or upload) task.
      1|  549|            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
       |  550|                                           caching policy and the values of certain received headers, such as the Pragma 
       |  551|                                           and Cache-Control headers.
       |  552|            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
       |  553|                                           response, a modified version of that response, or NULL to prevent caching the 
       |  554|                                           response. If your delegate implements this method, it must call this completion 
       |  555|                                           handler; otherwise, your app leaks memory.
       |  556|        */
       |  557|        public func URLSession(
       |  558|            session: NSURLSession,
       |  559|            dataTask: NSURLSessionDataTask,
       |  560|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  561|            completionHandler: ((NSCachedURLResponse?) -> Void))
       |  562|        {
       |  563|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
       |  564|                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
       |  565|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
       |  566|                delegate.URLSession(
       |  567|                    session,
       |  568|                    dataTask: dataTask,
      0|  569|                    willCacheResponse: proposedResponse,
      0|  570|                    completionHandler: completionHandler
      0|  571|                )
      0|  572|            } else {
      0|  573|                completionHandler(proposedResponse)
      0|  574|            }
      0|  575|        }
      0|  576|
      0|  577|        // MARK: - NSURLSessionDownloadDelegate
      0|  578|
      0|  579|        // MARK: Override Closures
      0|  580|
      0|  581|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
      0|  582|        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
       |  583|
       |  584|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
       |  585|        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  586|
       |  587|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
       |  588|        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  589|
       |  590|        // MARK: Delegate Methods
       |  591|
       |  592|        /**
       |  593|            Tells the delegate that a download task has finished downloading.
       |  594|
       |  595|            - parameter session:      The session containing the download task that finished.
       |  596|            - parameter downloadTask: The download task that finished.
       |  597|            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
       |  598|                                      open the file for reading or move it to a permanent location in your app’s sandbox 
       |  599|                                      container directory before returning from this delegate method.
       |  600|        */
       |  601|        public func URLSession(
       |  602|            session: NSURLSession,
       |  603|            downloadTask: NSURLSessionDownloadTask,
       |  604|            didFinishDownloadingToURL location: NSURL)
       |  605|        {
       |  606|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
       |  607|                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
       |  608|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  609|                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
       |  610|            }
       |  611|        }
      0|  612|
      0|  613|        /**
      0|  614|            Periodically informs the delegate about the download’s progress.
      0|  615|
      0|  616|            - parameter session:                   The session containing the download task.
      0|  617|            - parameter downloadTask:              The download task.
      0|  618|            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
       |  619|                                                   method was called.
       |  620|            - parameter totalBytesWritten:         The total number of bytes transferred so far.
       |  621|            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
       |  622|                                                   header. If this header was not provided, the value is 
       |  623|                                                   `NSURLSessionTransferSizeUnknown`.
       |  624|        */
       |  625|        public func URLSession(
       |  626|            session: NSURLSession,
       |  627|            downloadTask: NSURLSessionDownloadTask,
       |  628|            didWriteData bytesWritten: Int64,
       |  629|            totalBytesWritten: Int64,
       |  630|            totalBytesExpectedToWrite: Int64)
       |  631|        {
       |  632|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
       |  633|                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
       |  634|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  635|                delegate.URLSession(
       |  636|                    session,
       |  637|                    downloadTask: downloadTask,
      0|  638|                    didWriteData: bytesWritten,
      0|  639|                    totalBytesWritten: totalBytesWritten,
      0|  640|                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
      0|  641|                )
      0|  642|            }
      0|  643|        }
      0|  644|
      0|  645|        /**
      0|  646|            Tells the delegate that the download task has resumed downloading.
      0|  647|
      0|  648|            - parameter session:            The session containing the download task that finished.
      0|  649|            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
      0|  650|            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
       |  651|                                            existing content, then this value is zero. Otherwise, this value is an 
       |  652|                                            integer representing the number of bytes on disk that do not need to be 
       |  653|                                            retrieved again.
       |  654|            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
       |  655|                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
       |  656|        */
       |  657|        public func URLSession(
       |  658|            session: NSURLSession,
       |  659|            downloadTask: NSURLSessionDownloadTask,
       |  660|            didResumeAtOffset fileOffset: Int64,
       |  661|            expectedTotalBytes: Int64)
       |  662|        {
       |  663|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
       |  664|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
       |  665|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
       |  666|                delegate.URLSession(
       |  667|                    session,
       |  668|                    downloadTask: downloadTask,
      0|  669|                    didResumeAtOffset: fileOffset,
      0|  670|                    expectedTotalBytes: expectedTotalBytes
      0|  671|                )
      0|  672|            }
      0|  673|        }
      0|  674|
      0|  675|        // MARK: - NSURLSessionStreamDelegate
      0|  676|
      0|  677|        var _streamTaskReadClosed: Any?
      0|  678|        var _streamTaskWriteClosed: Any?
      0|  679|        var _streamTaskBetterRouteDiscovered: Any?
      0|  680|        var _streamTaskDidBecomeInputStream: Any?
       |  681|
       |  682|        // MARK: - NSObject
       |  683|
       |  684|        public override func respondsToSelector(selector: Selector) -> Bool {
       |  685|            switch selector {
       |  686|            case "URLSession:didBecomeInvalidWithError:":
       |  687|                return sessionDidBecomeInvalidWithError != nil
       |  688|            case "URLSession:didReceiveChallenge:completionHandler:":
       |  689|                return sessionDidReceiveChallenge != nil
       |  690|            case "URLSessionDidFinishEventsForBackgroundURLSession:":
     11|  691|                return sessionDidFinishEventsForBackgroundURLSession != nil
     11|  692|            case "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:":
      0|  693|                return taskWillPerformHTTPRedirection != nil
      0|  694|            case "URLSession:dataTask:didReceiveResponse:completionHandler:":
      1|  695|                return dataTaskDidReceiveResponse != nil
      1|  696|            default:
      0|  697|                return self.dynamicType.instancesRespondToSelector(selector)
      0|  698|            }
      0|  699|        }
      0|  700|    }
      1|  701|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/MultipartFormData.swift:
       |    1|// MultipartFormData.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if os(iOS) || os(watchOS) || os(tvOS)
       |   26|import MobileCoreServices
       |   27|#elseif os(OSX)
       |   28|import CoreServices
       |   29|#endif
       |   30|
       |   31|/**
       |   32|    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
       |   33|    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
       |   34|    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
       |   35|    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
       |   36|    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
       |   37|
       |   38|    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
       |   39|    and the w3 form documentation.
       |   40|
       |   41|    - https://www.ietf.org/rfc/rfc2388.txt
       |   42|    - https://www.ietf.org/rfc/rfc2045.txt
       |   43|    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
       |   44|*/
       |   45|public class MultipartFormData {
       |   46|
       |   47|    // MARK: - Helper Types
       |   48|
       |   49|    struct EncodingCharacters {
       |   50|        static let CRLF = "\r\n"
       |   51|    }
       |   52|
       |   53|    struct BoundaryGenerator {
       |   54|        enum BoundaryType {
       |   55|            case Initial, Encapsulated, Final
       |   56|        }
       |   57|
      0|   58|        static func randomBoundary() -> String {
      0|   59|            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
      0|   60|        }
       |   61|
      0|   62|        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
      0|   63|            let boundaryText: String
      0|   64|
      0|   65|            switch boundaryType {
      0|   66|            case .Initial:
      0|   67|                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
      0|   68|            case .Encapsulated:
      0|   69|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
      0|   70|            case .Final:
      0|   71|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
      0|   72|            }
      0|   73|
      0|   74|            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|   75|        }
       |   76|    }
       |   77|
       |   78|    class BodyPart {
       |   79|        let headers: [String: String]
       |   80|        let bodyStream: NSInputStream
       |   81|        let bodyContentLength: UInt64
       |   82|        var hasInitialBoundary = false
       |   83|        var hasFinalBoundary = false
       |   84|
      0|   85|        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
      0|   86|            self.headers = headers
      0|   87|            self.bodyStream = bodyStream
      0|   88|            self.bodyContentLength = bodyContentLength
      0|   89|        }
       |   90|    }
       |   91|
       |   92|    // MARK: - Properties
       |   93|
       |   94|    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
      0|   95|    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
       |   96|
       |   97|    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
      0|   98|    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
       |   99|
       |  100|    /// The boundary used to separate the body parts in the encoded form data.
       |  101|    public let boundary: String
       |  102|
       |  103|    private var bodyParts: [BodyPart]
       |  104|    private var bodyPartError: NSError?
       |  105|    private let streamBufferSize: Int
       |  106|
       |  107|    // MARK: - Lifecycle
       |  108|
       |  109|    /**
       |  110|        Creates a multipart form data object.
       |  111|
       |  112|        - returns: The multipart form data object.
       |  113|    */
      0|  114|    public init() {
      0|  115|        self.boundary = BoundaryGenerator.randomBoundary()
      0|  116|        self.bodyParts = []
      0|  117|
      0|  118|        /**
      0|  119|         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
      0|  120|         *  information, please refer to the following article:
      0|  121|         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
      0|  122|         */
      0|  123|
      0|  124|        self.streamBufferSize = 1024
      0|  125|    }
       |  126|
       |  127|    // MARK: - Body Parts
       |  128|
       |  129|    /**
       |  130|        Creates a body part from the data and appends it to the multipart form data object.
       |  131|
       |  132|        The body part data will be encoded using the following format:
       |  133|
       |  134|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  135|        - Encoded data
       |  136|        - Multipart form boundary
       |  137|
       |  138|        - parameter data: The data to encode into the multipart form data.
       |  139|        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
       |  140|    */
      0|  141|    public func appendBodyPart(data data: NSData, name: String) {
      0|  142|        let headers = contentHeaders(name: name)
      0|  143|        let stream = NSInputStream(data: data)
      0|  144|        let length = UInt64(data.length)
      0|  145|
      0|  146|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  147|    }
       |  148|
       |  149|    /**
       |  150|        Creates a body part from the data and appends it to the multipart form data object.
       |  151|
       |  152|        The body part data will be encoded using the following format:
       |  153|
       |  154|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  155|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  156|        - Encoded data
       |  157|        - Multipart form boundary
       |  158|
       |  159|        - parameter data:     The data to encode into the multipart form data.
       |  160|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  161|        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
       |  162|    */
      0|  163|    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
      0|  164|        let headers = contentHeaders(name: name, mimeType: mimeType)
      0|  165|        let stream = NSInputStream(data: data)
      0|  166|        let length = UInt64(data.length)
      0|  167|
      0|  168|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  169|    }
       |  170|
       |  171|    /**
       |  172|        Creates a body part from the data and appends it to the multipart form data object.
       |  173|
       |  174|        The body part data will be encoded using the following format:
       |  175|
       |  176|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  177|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  178|        - Encoded file data
       |  179|        - Multipart form boundary
       |  180|
       |  181|        - parameter data:     The data to encode into the multipart form data.
       |  182|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  183|        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
       |  184|        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
       |  185|    */
      0|  186|    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
      0|  187|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  188|        let stream = NSInputStream(data: data)
      0|  189|        let length = UInt64(data.length)
      0|  190|
      0|  191|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Creates a body part from the file and appends it to the multipart form data object.
       |  196|
       |  197|        The body part data will be encoded using the following format:
       |  198|
       |  199|        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
       |  200|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  201|        - Encoded file data
       |  202|        - Multipart form boundary
       |  203|
       |  204|        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
       |  205|        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
       |  206|        system associated MIME type.
       |  207|
       |  208|        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
       |  209|        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  210|    */
      0|  211|    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
      0|  212|        if let
      0|  213|            fileName = fileURL.lastPathComponent,
      0|  214|            pathExtension = fileURL.pathExtension
      0|  215|        {
      0|  216|            let mimeType = mimeTypeForPathExtension(pathExtension)
      0|  217|            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
      0|  218|        } else {
      0|  219|            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
      0|  220|            setBodyPartError(Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason))
      0|  221|        }
      0|  222|    }
       |  223|
       |  224|    /**
       |  225|        Creates a body part from the file and appends it to the multipart form data object.
       |  226|
       |  227|        The body part data will be encoded using the following format:
       |  228|
       |  229|        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
       |  230|        - Content-Type: #{mimeType} (HTTP Header)
       |  231|        - Encoded file data
       |  232|        - Multipart form boundary
       |  233|
       |  234|        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
       |  235|        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  236|        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
       |  237|        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
       |  238|    */
      0|  239|    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
      0|  240|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  241|
      0|  242|        //============================================================
      0|  243|        //                 Check 1 - is file URL?
      0|  244|        //============================================================
      0|  245|
      0|  246|        guard fileURL.fileURL else {
      0|  247|            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
      0|  248|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  249|            setBodyPartError(error)
      0|  250|            return
      0|  251|        }
      0|  252|
      0|  253|        //============================================================
      0|  254|        //              Check 2 - is file URL reachable?
      0|  255|        //============================================================
      0|  256|
      0|  257|        var isReachable = true
      0|  258|
      0|  259|        if #available(OSX 10.10, *) {
      0|  260|            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
      0|  261|        }
      0|  262|
      0|  263|        guard isReachable else {
      0|  264|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
      0|  265|            setBodyPartError(error)
      0|  266|            return
      0|  267|        }
      0|  268|
      0|  269|        //============================================================
      0|  270|        //            Check 3 - is file URL a directory?
      0|  271|        //============================================================
      0|  272|
      0|  273|        var isDirectory: ObjCBool = false
      0|  274|
      0|  275|        guard let
      0|  276|            path = fileURL.path
      0|  277|            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
      0|  278|        {
      0|  279|            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
      0|  280|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  281|            setBodyPartError(error)
      0|  282|            return
      0|  283|        }
      0|  284|
      0|  285|        //============================================================
      0|  286|        //          Check 4 - can the file size be extracted?
      0|  287|        //============================================================
      0|  288|
      0|  289|        var bodyContentLength: UInt64?
      0|  290|
      0|  291|        do {
      0|  292|            if let
      0|  293|                path = fileURL.path,
      0|  294|                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
      0|  295|            {
      0|  296|                bodyContentLength = fileSize.unsignedLongLongValue
      0|  297|            }
      0|  298|        } catch {
      0|  299|            // No-op
      0|  300|        }
      0|  301|
      0|  302|        guard let length = bodyContentLength else {
      0|  303|            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
      0|  304|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  305|            setBodyPartError(error)
      0|  306|            return
      0|  307|        }
      0|  308|
      0|  309|        //============================================================
      0|  310|        //       Check 5 - can a stream be created from file URL?
      0|  311|        //============================================================
      0|  312|
      0|  313|        guard let stream = NSInputStream(URL: fileURL) else {
      0|  314|            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
      0|  315|            let error = Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  316|            setBodyPartError(error)
      0|  317|            return
      0|  318|        }
      0|  319|
      0|  320|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  321|    }
       |  322|
       |  323|    /**
       |  324|        Creates a body part from the stream and appends it to the multipart form data object.
       |  325|
       |  326|        The body part data will be encoded using the following format:
       |  327|
       |  328|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  329|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  330|        - Encoded stream data
       |  331|        - Multipart form boundary
       |  332|
       |  333|        - parameter stream:   The input stream to encode in the multipart form data.
       |  334|        - parameter length:   The content length of the stream.
       |  335|        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
       |  336|        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
       |  337|        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
       |  338|    */
       |  339|    public func appendBodyPart(
       |  340|        stream stream: NSInputStream,
       |  341|        length: UInt64,
       |  342|        name: String,
       |  343|        fileName: String,
       |  344|        mimeType: String)
      0|  345|    {
      0|  346|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  347|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  348|    }
       |  349|
       |  350|    /**
       |  351|        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
       |  352|
       |  353|        The body part data will be encoded using the following format:
       |  354|
       |  355|        - HTTP headers
       |  356|        - Encoded stream data
       |  357|        - Multipart form boundary
       |  358|
       |  359|        - parameter stream:  The input stream to encode in the multipart form data.
       |  360|        - parameter length:  The content length of the stream.
       |  361|        - parameter headers: The HTTP headers for the body part.
       |  362|    */
      0|  363|    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
      0|  364|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
      0|  365|        bodyParts.append(bodyPart)
      0|  366|    }
       |  367|
       |  368|    // MARK: - Data Encoding
       |  369|
       |  370|    /**
       |  371|        Encodes all the appended body parts into a single `NSData` object.
       |  372|
       |  373|        It is important to note that this method will load all the appended body parts into memory all at the same 
       |  374|        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
       |  375|        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
       |  376|
       |  377|        - throws: An `NSError` if encoding encounters an error.
       |  378|
       |  379|        - returns: The encoded `NSData` if encoding is successful.
       |  380|    */
      0|  381|    public func encode() throws -> NSData {
      0|  382|        if let bodyPartError = bodyPartError {
      0|  383|            throw bodyPartError
      0|  384|        }
      0|  385|
      0|  386|        let encoded = NSMutableData()
      0|  387|
      0|  388|        bodyParts.first?.hasInitialBoundary = true
      0|  389|        bodyParts.last?.hasFinalBoundary = true
      0|  390|
      0|  391|        for bodyPart in bodyParts {
      0|  392|            let encodedData = try encodeBodyPart(bodyPart)
      0|  393|            encoded.appendData(encodedData)
      0|  394|        }
      0|  395|
      0|  396|        return encoded
      0|  397|    }
       |  398|
       |  399|    /**
       |  400|        Writes the appended body parts into the given file URL.
       |  401|
       |  402|        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
       |  403|        this approach is very memory efficient and should be used for large body part data.
       |  404|
       |  405|        - parameter fileURL: The file URL to write the multipart form data into.
       |  406|
       |  407|        - throws: An `NSError` if encoding encounters an error.
       |  408|    */
      0|  409|    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
      0|  410|        if let bodyPartError = bodyPartError {
      0|  411|            throw bodyPartError
      0|  412|        }
      0|  413|
      0|  414|        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
      0|  415|            let failureReason = "A file already exists at the given file URL: \(fileURL)"
      0|  416|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  417|        } else if !fileURL.fileURL {
      0|  418|            let failureReason = "The URL does not point to a valid file: \(fileURL)"
      0|  419|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  420|        }
      0|  421|
      0|  422|        let outputStream: NSOutputStream
      0|  423|
      0|  424|        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
      0|  425|            outputStream = possibleOutputStream
      0|  426|        } else {
      0|  427|            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
      0|  428|            throw Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  429|        }
      0|  430|
      0|  431|        outputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  432|        outputStream.open()
      0|  433|
      0|  434|        self.bodyParts.first?.hasInitialBoundary = true
      0|  435|        self.bodyParts.last?.hasFinalBoundary = true
      0|  436|
      0|  437|        for bodyPart in self.bodyParts {
      0|  438|            try writeBodyPart(bodyPart, toOutputStream: outputStream)
      0|  439|        }
      0|  440|
      0|  441|        outputStream.close()
      0|  442|        outputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  443|    }
       |  444|
       |  445|    // MARK: - Private - Body Part Encoding
       |  446|
      0|  447|    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  448|        let encoded = NSMutableData()
      0|  449|
      0|  450|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  451|        encoded.appendData(initialData)
      0|  452|
      0|  453|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  454|        encoded.appendData(headerData)
      0|  455|
      0|  456|        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
      0|  457|        encoded.appendData(bodyStreamData)
      0|  458|
      0|  459|        if bodyPart.hasFinalBoundary {
      0|  460|            encoded.appendData(finalBoundaryData())
      0|  461|        }
      0|  462|
      0|  463|        return encoded
      0|  464|    }
       |  465|
      0|  466|    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
      0|  467|        var headerText = ""
      0|  468|
      0|  469|        for (key, value) in bodyPart.headers {
      0|  470|            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
      0|  471|        }
      0|  472|        headerText += EncodingCharacters.CRLF
      0|  473|
      0|  474|        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|  475|    }
       |  476|
      0|  477|    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  478|        let inputStream = bodyPart.bodyStream
      0|  479|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  480|        inputStream.open()
      0|  481|
      0|  482|        var error: NSError?
      0|  483|        let encoded = NSMutableData()
      0|  484|
      0|  485|        while inputStream.hasBytesAvailable {
      0|  486|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  487|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  488|
      0|  489|            if inputStream.streamError != nil {
      0|  490|                error = inputStream.streamError
      0|  491|                break
      0|  492|            }
      0|  493|
      0|  494|            if bytesRead > 0 {
      0|  495|                encoded.appendBytes(buffer, length: bytesRead)
      0|  496|            } else if bytesRead < 0 {
      0|  497|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  498|                error = Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  499|                break
      0|  500|            } else {
      0|  501|                break
      0|  502|            }
      0|  503|        }
      0|  504|
      0|  505|        inputStream.close()
      0|  506|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  507|
      0|  508|        if let error = error {
      0|  509|            throw error
      0|  510|        }
      0|  511|
      0|  512|        return encoded
      0|  513|    }
       |  514|
       |  515|    // MARK: - Private - Writing Body Part to Output Stream
       |  516|
      0|  517|    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  518|        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  519|        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  520|        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  521|        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  522|    }
       |  523|
       |  524|    private func writeInitialBoundaryDataForBodyPart(
       |  525|        bodyPart: BodyPart,
       |  526|        toOutputStream outputStream: NSOutputStream)
       |  527|        throws
      0|  528|    {
      0|  529|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  530|        return try writeData(initialData, toOutputStream: outputStream)
      0|  531|    }
       |  532|
      0|  533|    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  534|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  535|        return try writeData(headerData, toOutputStream: outputStream)
      0|  536|    }
       |  537|
      0|  538|    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  539|        let inputStream = bodyPart.bodyStream
      0|  540|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  541|        inputStream.open()
      0|  542|
      0|  543|        while inputStream.hasBytesAvailable {
      0|  544|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  545|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  546|
      0|  547|            if let streamError = inputStream.streamError {
      0|  548|                throw streamError
      0|  549|            }
      0|  550|
      0|  551|            if bytesRead > 0 {
      0|  552|                if buffer.count != bytesRead {
      0|  553|                    buffer = Array(buffer[0..<bytesRead])
      0|  554|                }
      0|  555|
      0|  556|                try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  557|            } else if bytesRead < 0 {
      0|  558|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  559|                throw Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  560|            } else {
      0|  561|                break
      0|  562|            }
      0|  563|        }
      0|  564|
      0|  565|        inputStream.close()
      0|  566|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  567|    }
       |  568|
       |  569|    private func writeFinalBoundaryDataForBodyPart(
       |  570|        bodyPart: BodyPart,
       |  571|        toOutputStream outputStream: NSOutputStream)
       |  572|        throws
      0|  573|    {
      0|  574|        if bodyPart.hasFinalBoundary {
      0|  575|            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
      0|  576|        }
      0|  577|    }
       |  578|
       |  579|    // MARK: - Private - Writing Buffered Data to Output Stream
       |  580|
      0|  581|    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
      0|  582|        var buffer = [UInt8](count: data.length, repeatedValue: 0)
      0|  583|        data.getBytes(&buffer, length: data.length)
      0|  584|
      0|  585|        return try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  586|    }
       |  587|
      0|  588|    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
      0|  589|        var bytesToWrite = buffer.count
      0|  590|
      0|  591|        while bytesToWrite > 0 {
      0|  592|            if outputStream.hasSpaceAvailable {
      0|  593|                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
      0|  594|
      0|  595|                if let streamError = outputStream.streamError {
      0|  596|                    throw streamError
      0|  597|                }
      0|  598|
      0|  599|                if bytesWritten < 0 {
      0|  600|                    let failureReason = "Failed to write to output stream: \(outputStream)"
      0|  601|                    throw Error.errorWithCode(.OutputStreamWriteFailed, failureReason: failureReason)
      0|  602|                }
      0|  603|
      0|  604|                bytesToWrite -= bytesWritten
      0|  605|
      0|  606|                if bytesToWrite > 0 {
      0|  607|                    buffer = Array(buffer[bytesWritten..<buffer.count])
      0|  608|                }
      0|  609|            } else if let streamError = outputStream.streamError {
      0|  610|                throw streamError
      0|  611|            }
      0|  612|        }
      0|  613|    }
       |  614|
       |  615|    // MARK: - Private - Mime Type
       |  616|
      0|  617|    private func mimeTypeForPathExtension(pathExtension: String) -> String {
      0|  618|        if let
      0|  619|            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
      0|  620|            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
      0|  621|        {
      0|  622|            return contentType as String
      0|  623|        }
      0|  624|
      0|  625|        return "application/octet-stream"
      0|  626|    }
       |  627|
       |  628|    // MARK: - Private - Content Headers
       |  629|
      0|  630|    private func contentHeaders(name name: String) -> [String: String] {
      0|  631|        return ["Content-Disposition": "form-data; name=\"\(name)\""]
      0|  632|    }
       |  633|
      0|  634|    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
      0|  635|        return [
      0|  636|            "Content-Disposition": "form-data; name=\"\(name)\"",
      0|  637|            "Content-Type": "\(mimeType)"
      0|  638|        ]
      0|  639|    }
       |  640|
      0|  641|    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
      0|  642|        return [
      0|  643|            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
      0|  644|            "Content-Type": "\(mimeType)"
      0|  645|        ]
      0|  646|    }
       |  647|
       |  648|    // MARK: - Private - Boundary Encoding
       |  649|
      0|  650|    private func initialBoundaryData() -> NSData {
      0|  651|        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
      0|  652|    }
       |  653|
      0|  654|    private func encapsulatedBoundaryData() -> NSData {
      0|  655|        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
      0|  656|    }
       |  657|
      0|  658|    private func finalBoundaryData() -> NSData {
      0|  659|        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
      0|  660|    }
       |  661|
       |  662|    // MARK: - Private - Errors
       |  663|
      0|  664|    private func setBodyPartError(error: NSError) {
      0|  665|        if bodyPartError == nil {
      0|  666|            bodyPartError = error
      0|  667|        }
      0|  668|    }
       |  669|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ParameterEncoding.swift:
       |    1|// ParameterEncoding.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    HTTP method definitions.
       |   27|
       |   28|    See https://tools.ietf.org/html/rfc7231#section-4.3
       |   29|*/
       |   30|public enum Method: String {
       |   31|    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
       |   32|}
       |   33|
       |   34|// MARK: ParameterEncoding
       |   35|
       |   36|/**
       |   37|    Used to specify the way in which a set of parameters are applied to a URL request.
       |   38|
       |   39|    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
       |   40|                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
       |   41|                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
       |   42|                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
       |   43|                         for how to encode collection types, the convention of appending `[]` to the key for array
       |   44|                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
       |   45|                         dictionary values (`foo[bar]=baz`).
       |   46|
       |   47|    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
       |   48|                         implementation as the `.URL` case, but always applies the encoded result to the URL.
       |   49|
       |   50|    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
       |   51|                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
       |   52|                         set to `application/json`.
       |   53|
       |   54|    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
       |   55|                         according to the associated format and write options values, which is set as the body of the
       |   56|                         request. The `Content-Type` HTTP header field of an encoded request is set to
       |   57|                         `application/x-plist`.
       |   58|
       |   59|    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
       |   60|                         parameters.
       |   61|*/
       |   62|public enum ParameterEncoding {
       |   63|    case URL
       |   64|    case URLEncodedInURL
       |   65|    case JSON
       |   66|    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
       |   67|    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
       |   68|
       |   69|    /**
       |   70|        Creates a URL request by encoding parameters and applying them onto an existing request.
       |   71|
       |   72|        - parameter URLRequest: The request to have parameters applied
       |   73|        - parameter parameters: The parameters to apply
       |   74|
       |   75|        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
       |   76|                   if any.
       |   77|    */
       |   78|    public func encode(
       |   79|        URLRequest: URLRequestConvertible,
       |   80|        parameters: [String: AnyObject]?)
       |   81|        -> (NSMutableURLRequest, NSError?)
      1|   82|    {
      1|   83|        var mutableURLRequest = URLRequest.URLRequest
      1|   84|
      0|   85|        guard let parameters = parameters where !parameters.isEmpty else {
      0|   86|            return (mutableURLRequest, nil)
      0|   87|        }
      1|   88|
      1|   89|        var encodingError: NSError? = nil
      1|   90|
      1|   91|        switch self {
      0|   92|        case .URL, .URLEncodedInURL:
      0|   93|            func query(parameters: [String: AnyObject]) -> String {
      0|   94|                var components: [(String, String)] = []
      0|   95|
      0|   96|                for key in parameters.keys.sort(<) {
      0|   97|                    let value = parameters[key]!
      0|   98|                    components += queryComponents(key, value)
      0|   99|                }
      0|  100|
      0|  101|                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
      0|  102|            }
      0|  103|
      0|  104|            func encodesParametersInURL(method: Method) -> Bool {
      0|  105|                switch self {
      0|  106|                case .URLEncodedInURL:
      0|  107|                    return true
      0|  108|                default:
      0|  109|                    break
      0|  110|                }
      0|  111|
      0|  112|                switch method {
      0|  113|                case .GET, .HEAD, .DELETE:
      0|  114|                    return true
      0|  115|                default:
      0|  116|                    return false
      0|  117|                }
      0|  118|            }
      0|  119|
      0|  120|            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
      0|  121|                if let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false) {
      0|  122|                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
      0|  123|                    URLComponents.percentEncodedQuery = percentEncodedQuery
      0|  124|                    mutableURLRequest.URL = URLComponents.URL
      0|  125|                }
      0|  126|            } else {
      0|  127|                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
      0|  128|                    mutableURLRequest.setValue(
      0|  129|                        "application/x-www-form-urlencoded; charset=utf-8",
      0|  130|                        forHTTPHeaderField: "Content-Type"
      0|  131|                    )
      0|  132|                }
      0|  133|
      0|  134|                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
      0|  135|                    NSUTF8StringEncoding,
      0|  136|                    allowLossyConversion: false
      0|  137|                )
      0|  138|            }
      1|  139|        case .JSON:
      1|  140|            do {
      1|  141|                let options = NSJSONWritingOptions()
      1|  142|                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
      1|  143|
      1|  144|                mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
      1|  145|                mutableURLRequest.HTTPBody = data
      0|  146|            } catch {
      0|  147|                encodingError = error as NSError
      0|  148|            }
      0|  149|        case .PropertyList(let format, let options):
      0|  150|            do {
      0|  151|                let data = try NSPropertyListSerialization.dataWithPropertyList(
      0|  152|                    parameters,
      0|  153|                    format: format,
      0|  154|                    options: options
      0|  155|                )
      0|  156|                mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
      0|  157|                mutableURLRequest.HTTPBody = data
      0|  158|            } catch {
      0|  159|                encodingError = error as NSError
      0|  160|            }
      0|  161|        case .Custom(let closure):
      0|  162|            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
      1|  163|        }
      1|  164|
      1|  165|        return (mutableURLRequest, encodingError)
      1|  166|    }
       |  167|
       |  168|    /**
       |  169|        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
       |  170|
       |  171|        - parameter key:   The key of the query component.
       |  172|        - parameter value: The value of the query component.
       |  173|
       |  174|        - returns: The percent-escaped, URL encoded query string components.
       |  175|    */
      0|  176|    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
      0|  177|        var components: [(String, String)] = []
      0|  178|
      0|  179|        if let dictionary = value as? [String: AnyObject] {
      0|  180|            for (nestedKey, value) in dictionary {
      0|  181|                components += queryComponents("\(key)[\(nestedKey)]", value)
      0|  182|            }
      0|  183|        } else if let array = value as? [AnyObject] {
      0|  184|            for value in array {
      0|  185|                components += queryComponents("\(key)[]", value)
      0|  186|            }
      0|  187|        } else {
      0|  188|            components.append((escape(key), escape("\(value)")))
      0|  189|        }
      0|  190|
      0|  191|        return components
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Returns a percent-escaped string following RFC 3986 for a query string key or value.
       |  196|
       |  197|        RFC 3986 states that the following characters are "reserved" characters.
       |  198|
       |  199|        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
       |  200|        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
       |  201|
       |  202|        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
       |  203|        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
       |  204|        should be percent-escaped in the query string.
       |  205|
       |  206|        - parameter string: The string to be percent-escaped.
       |  207|
       |  208|        - returns: The percent-escaped string.
       |  209|    */
      0|  210|    public func escape(string: String) -> String {
      0|  211|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
      0|  212|        let subDelimitersToEncode = "!$&'()*+,;="
      0|  213|
      0|  214|        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
      0|  215|        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
      0|  216|
      0|  217|        var escaped = ""
      0|  218|
      0|  219|        //==========================================================================================================
      0|  220|        //
      0|  221|        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
      0|  222|        //  hundred Chinense characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
      0|  223|        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
      0|  224|        //  info, please refer to:
      0|  225|        //
      0|  226|        //      - https://github.com/Alamofire/Alamofire/issues/206
      0|  227|        //
      0|  228|        //==========================================================================================================
      0|  229|
      0|  230|        if #available(iOS 8.3, OSX 10.10, *) {
      0|  231|            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
      0|  232|        } else {
      0|  233|            let batchSize = 50
      0|  234|            var index = string.startIndex
      0|  235|
      0|  236|            while index != string.endIndex {
      0|  237|                let startIndex = index
      0|  238|                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
      0|  239|                let range = Range(start: startIndex, end: endIndex)
      0|  240|
      0|  241|                let substring = string.substringWithRange(range)
      0|  242|
      0|  243|                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
      0|  244|
      0|  245|                index = endIndex
      0|  246|            }
      0|  247|        }
      0|  248|
      0|  249|        return escaped
      0|  250|    }
       |  251|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Request.swift:
       |    1|// Request.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for sending a request and receiving the response and associated data from the server, as well as 
       |   27|    managing its underlying `NSURLSessionTask`.
       |   28|*/
       |   29|public class Request {
       |   30|
       |   31|    // MARK: - Properties
       |   32|
       |   33|    /// The delegate for the underlying task.
       |   34|    public let delegate: TaskDelegate
       |   35|
       |   36|    /// The underlying task.
      5|   37|    public var task: NSURLSessionTask { return delegate.task }
       |   38|
       |   39|    /// The session belonging to the underlying task.
       |   40|    public let session: NSURLSession
       |   41|
       |   42|    /// The request sent or to be sent to the server.
      2|   43|    public var request: NSURLRequest? { return task.originalRequest }
       |   44|
       |   45|    /// The response received from the server, if any.
      2|   46|    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
       |   47|
       |   48|    /// The progress of the request lifecycle.
      0|   49|    public var progress: NSProgress { return delegate.progress }
       |   50|
       |   51|    // MARK: - Lifecycle
       |   52|
      1|   53|    init(session: NSURLSession, task: NSURLSessionTask) {
      1|   54|        self.session = session
      1|   55|
      1|   56|        switch task {
      0|   57|        case is NSURLSessionUploadTask:
      0|   58|            self.delegate = UploadTaskDelegate(task: task)
      1|   59|        case is NSURLSessionDataTask:
      1|   60|            self.delegate = DataTaskDelegate(task: task)
      0|   61|        case is NSURLSessionDownloadTask:
      0|   62|            self.delegate = DownloadTaskDelegate(task: task)
      0|   63|        default:
      0|   64|            self.delegate = TaskDelegate(task: task)
      1|   65|        }
      1|   66|    }
       |   67|
       |   68|    // MARK: - Authentication
       |   69|
       |   70|    /**
       |   71|        Associates an HTTP Basic credential with the request.
       |   72|
       |   73|        - parameter user:        The user.
       |   74|        - parameter password:    The password.
       |   75|        - parameter persistence: The URL credential persistence. `.ForSession` by default.
       |   76|
       |   77|        - returns: The request.
       |   78|    */
       |   79|    public func authenticate(
       |   80|        user user: String,
       |   81|        password: String,
       |   82|        persistence: NSURLCredentialPersistence = .ForSession)
       |   83|        -> Self
      0|   84|    {
      0|   85|        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
      0|   86|
      0|   87|        return authenticate(usingCredential: credential)
      0|   88|    }
       |   89|
       |   90|    /**
       |   91|        Associates a specified credential with the request.
       |   92|
       |   93|        - parameter credential: The credential.
       |   94|
       |   95|        - returns: The request.
       |   96|    */
      0|   97|    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
      0|   98|        delegate.credential = credential
      0|   99|
      0|  100|        return self
      0|  101|    }
       |  102|
       |  103|    // MARK: - Progress
       |  104|
       |  105|    /**
       |  106|        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
       |  107|        from the server.
       |  108|
       |  109|        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
       |  110|          to write.
       |  111|        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
       |  112|          expected to read.
       |  113|
       |  114|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  115|
       |  116|        - returns: The request.
       |  117|    */
      0|  118|    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
      0|  119|        if let uploadDelegate = delegate as? UploadTaskDelegate {
      0|  120|            uploadDelegate.uploadProgress = closure
      0|  121|        } else if let dataDelegate = delegate as? DataTaskDelegate {
      0|  122|            dataDelegate.dataProgress = closure
      0|  123|        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
      0|  124|            downloadDelegate.downloadProgress = closure
      0|  125|        }
      0|  126|
      0|  127|        return self
      0|  128|    }
       |  129|
       |  130|    /**
       |  131|        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
       |  132|
       |  133|        This closure returns the bytes most recently received from the server, not including data from previous calls. 
       |  134|        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
       |  135|        also important to note that the `response` closure will be called with nil `responseData`.
       |  136|
       |  137|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  138|
       |  139|        - returns: The request.
       |  140|    */
      0|  141|    public func stream(closure: (NSData -> Void)? = nil) -> Self {
      0|  142|        if let dataDelegate = delegate as? DataTaskDelegate {
      0|  143|            dataDelegate.dataStream = closure
      0|  144|        }
      0|  145|
      0|  146|        return self
      0|  147|    }
       |  148|
       |  149|    // MARK: - State
       |  150|
       |  151|    /**
       |  152|        Suspends the request.
       |  153|    */
      0|  154|    public func suspend() {
      0|  155|        task.suspend()
      0|  156|    }
       |  157|
       |  158|    /**
       |  159|        Resumes the request.
       |  160|    */
      1|  161|    public func resume() {
      1|  162|        task.resume()
      1|  163|    }
       |  164|
       |  165|    /**
       |  166|        Cancels the request.
       |  167|    */
      0|  168|    public func cancel() {
      0|  169|        if let
      0|  170|            downloadDelegate = delegate as? DownloadTaskDelegate,
      0|  171|            downloadTask = downloadDelegate.downloadTask
      0|  172|        {
      0|  173|            downloadTask.cancelByProducingResumeData { data in
      0|  174|                downloadDelegate.resumeData = data
      0|  175|            }
      0|  176|        } else {
      0|  177|            task.cancel()
      0|  178|        }
      0|  179|    }
       |  180|
       |  181|    // MARK: - TaskDelegate
       |  182|
       |  183|    /**
       |  184|        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
       |  185|        executing all operations attached to the serial operation queue upon task completion.
       |  186|    */
       |  187|    public class TaskDelegate: NSObject {
       |  188|
       |  189|        /// The serial operation queue used to execute all operations after the task completes.
       |  190|        public let queue: NSOperationQueue
       |  191|
       |  192|        let task: NSURLSessionTask
       |  193|        let progress: NSProgress
       |  194|
      0|  195|        var data: NSData? { return nil }
       |  196|        var error: NSError?
       |  197|
       |  198|        var credential: NSURLCredential?
       |  199|
      1|  200|        init(task: NSURLSessionTask) {
      1|  201|            self.task = task
      1|  202|            self.progress = NSProgress(totalUnitCount: 0)
      1|  203|            self.queue = {
      1|  204|                let operationQueue = NSOperationQueue()
      1|  205|                operationQueue.maxConcurrentOperationCount = 1
      1|  206|                operationQueue.suspended = true
      1|  207|
      1|  208|                if #available(OSX 10.10, *) {
      1|  209|                    operationQueue.qualityOfService = NSQualityOfService.Utility
      1|  210|                }
      1|  211|
      1|  212|                return operationQueue
      1|  213|            }()
      1|  214|        }
       |  215|
      0|  216|        deinit {
      0|  217|            queue.cancelAllOperations()
      0|  218|            queue.suspended = false
      0|  219|        }
       |  220|
       |  221|        // MARK: - NSURLSessionTaskDelegate
       |  222|
       |  223|        // MARK: Override Closures
       |  224|
       |  225|        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  226|        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  227|        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
       |  228|        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  229|
       |  230|        // MARK: Delegate Methods
       |  231|
       |  232|        func URLSession(
       |  233|            session: NSURLSession,
       |  234|            task: NSURLSessionTask,
       |  235|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  236|            newRequest request: NSURLRequest,
       |  237|            completionHandler: ((NSURLRequest?) -> Void))
      0|  238|        {
      0|  239|            var redirectRequest: NSURLRequest? = request
      0|  240|
      0|  241|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  242|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  243|            }
      0|  244|
      0|  245|            completionHandler(redirectRequest)
      0|  246|        }
       |  247|
       |  248|        func URLSession(
       |  249|            session: NSURLSession,
       |  250|            task: NSURLSessionTask,
       |  251|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  252|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  253|        {
      1|  254|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      1|  255|            var credential: NSURLCredential?
      1|  256|
      0|  257|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  258|                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
      1|  259|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      1|  260|                let host = challenge.protectionSpace.host
      1|  261|
      1|  262|                if let
      1|  263|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      1|  264|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  265|                {
      0|  266|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  267|                        disposition = .UseCredential
      0|  268|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  269|                    } else {
      0|  270|                        disposition = .CancelAuthenticationChallenge
      0|  271|                    }
      0|  272|                }
      0|  273|            } else {
      0|  274|                if challenge.previousFailureCount > 0 {
      0|  275|                    disposition = .CancelAuthenticationChallenge
      0|  276|                } else {
      0|  277|                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
      0|  278|
      0|  279|                    if credential != nil {
      0|  280|                        disposition = .UseCredential
      0|  281|                    }
      0|  282|                }
      0|  283|            }
      1|  284|
      1|  285|            completionHandler(disposition, credential)
      1|  286|        }
       |  287|
       |  288|        func URLSession(
       |  289|            session: NSURLSession,
       |  290|            task: NSURLSessionTask,
       |  291|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  292|        {
      0|  293|            var bodyStream: NSInputStream?
      0|  294|
      0|  295|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  296|                bodyStream = taskNeedNewBodyStream(session, task)
      0|  297|            }
      0|  298|
      0|  299|            completionHandler(bodyStream)
      0|  300|        }
       |  301|
      1|  302|        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  303|            if let taskDidCompleteWithError = taskDidCompleteWithError {
      0|  304|                taskDidCompleteWithError(session, task, error)
      1|  305|            } else {
      0|  306|                if let error = error {
      0|  307|                    self.error = error
      0|  308|
      0|  309|                    if let
      0|  310|                        downloadDelegate = self as? DownloadTaskDelegate,
      0|  311|                        userInfo = error.userInfo as? [String: AnyObject],
      0|  312|                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
      0|  313|                    {
      0|  314|                        downloadDelegate.resumeData = resumeData
      0|  315|                    }
      0|  316|                }
      1|  317|
      1|  318|                queue.suspended = false
      1|  319|            }
      1|  320|        }
       |  321|    }
       |  322|
       |  323|    // MARK: - DataTaskDelegate
       |  324|
       |  325|    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
      0|  326|        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
       |  327|
       |  328|        private var totalBytesReceived: Int64 = 0
       |  329|        private var mutableData: NSMutableData
      2|  330|        override var data: NSData? {
      0|  331|            if dataStream != nil {
      0|  332|                return nil
      2|  333|            } else {
      2|  334|                return mutableData
      2|  335|            }
      0|  336|        }
       |  337|
       |  338|        private var expectedContentLength: Int64?
       |  339|        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
       |  340|        private var dataStream: ((data: NSData) -> Void)?
       |  341|
      1|  342|        override init(task: NSURLSessionTask) {
      1|  343|            mutableData = NSMutableData()
      1|  344|            super.init(task: task)
      1|  345|        }
       |  346|
       |  347|        // MARK: - NSURLSessionDataDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  352|        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  353|        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  354|        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
       |  355|
       |  356|        // MARK: Delegate Methods
       |  357|
       |  358|        func URLSession(
       |  359|            session: NSURLSession,
       |  360|            dataTask: NSURLSessionDataTask,
       |  361|            didReceiveResponse response: NSURLResponse,
       |  362|            completionHandler: (NSURLSessionResponseDisposition -> Void))
      0|  363|        {
      0|  364|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  365|
      0|  366|            expectedContentLength = response.expectedContentLength
      0|  367|
      0|  368|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  369|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  370|            }
      0|  371|
      0|  372|            completionHandler(disposition)
      0|  373|        }
       |  374|
       |  375|        func URLSession(
       |  376|            session: NSURLSession,
       |  377|            dataTask: NSURLSessionDataTask,
       |  378|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  379|        {
      0|  380|            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
      0|  381|        }
       |  382|
      1|  383|        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  384|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  385|                dataTaskDidReceiveData(session, dataTask, data)
      1|  386|            } else {
      0|  387|                if let dataStream = dataStream {
      0|  388|                    dataStream(data: data)
      1|  389|                } else {
      1|  390|                    mutableData.appendData(data)
      1|  391|                }
      1|  392|
      1|  393|                totalBytesReceived += data.length
      0|  394|                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
      1|  395|
      1|  396|                progress.totalUnitCount = totalBytesExpected
      1|  397|                progress.completedUnitCount = totalBytesReceived
      1|  398|
      1|  399|                dataProgress?(
      1|  400|                    bytesReceived: Int64(data.length),
      1|  401|                    totalBytesReceived: totalBytesReceived,
      1|  402|                    totalBytesExpectedToReceive: totalBytesExpected
      1|  403|                )
      1|  404|            }
      1|  405|        }
       |  406|
       |  407|        func URLSession(
       |  408|            session: NSURLSession,
       |  409|            dataTask: NSURLSessionDataTask,
       |  410|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  411|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  412|        {
      0|  413|            var cachedResponse: NSCachedURLResponse? = proposedResponse
      0|  414|
      0|  415|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  416|                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
      0|  417|            }
      0|  418|
      0|  419|            completionHandler(cachedResponse)
      0|  420|        }
       |  421|    }
       |  422|}
       |  423|
       |  424|// MARK: - CustomStringConvertible
       |  425|
       |  426|extension Request: CustomStringConvertible {
       |  427|
       |  428|    /**
       |  429|        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
       |  430|        well as the response status code if a response has been received.
       |  431|    */
      0|  432|    public var description: String {
      0|  433|        var components: [String] = []
      0|  434|
      0|  435|        if let HTTPMethod = request?.HTTPMethod {
      0|  436|            components.append(HTTPMethod)
      0|  437|        }
      0|  438|
      0|  439|        if let URLString = request?.URL?.absoluteString {
      0|  440|            components.append(URLString)
      0|  441|        }
      0|  442|
      0|  443|        if let response = response {
      0|  444|            components.append("(\(response.statusCode))")
      0|  445|        }
      0|  446|
      0|  447|        return components.joinWithSeparator(" ")
      0|  448|    }
       |  449|}
       |  450|
       |  451|// MARK: - CustomDebugStringConvertible
       |  452|
       |  453|extension Request: CustomDebugStringConvertible {
      0|  454|    func cURLRepresentation() -> String {
      0|  455|        var components = ["$ curl -i"]
      0|  456|
      0|  457|        guard let request = self.request else {
      0|  458|            return "$ curl command could not be created"
      0|  459|        }
      0|  460|
      0|  461|        let URL = request.URL
      0|  462|
      0|  463|        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
      0|  464|            components.append("-X \(HTTPMethod)")
      0|  465|        }
      0|  466|
      0|  467|        if let credentialStorage = self.session.configuration.URLCredentialStorage {
      0|  468|            let protectionSpace = NSURLProtectionSpace(
      0|  469|                host: URL!.host!,
      0|  470|                port: URL!.port?.integerValue ?? 0,
      0|  471|                `protocol`: URL!.scheme,
      0|  472|                realm: URL!.host!,
      0|  473|                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
      0|  474|            )
      0|  475|
      0|  476|            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
      0|  477|                for credential in credentials {
      0|  478|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  479|                }
      0|  480|            } else {
      0|  481|                if let credential = delegate.credential {
      0|  482|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  483|                }
      0|  484|            }
      0|  485|        }
      0|  486|
      0|  487|        if session.configuration.HTTPShouldSetCookies {
      0|  488|            if let
      0|  489|                cookieStorage = session.configuration.HTTPCookieStorage,
      0|  490|                cookies = cookieStorage.cookiesForURL(URL!) where !cookies.isEmpty
      0|  491|            {
      0|  492|                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
      0|  493|                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
      0|  494|            }
      0|  495|        }
      0|  496|
      0|  497|        if let headerFields = request.allHTTPHeaderFields {
      0|  498|            for (field, value) in headerFields {
      0|  499|                switch field {
      0|  500|                case "Cookie":
      0|  501|                    continue
      0|  502|                default:
      0|  503|                    components.append("-H \"\(field): \(value)\"")
      0|  504|                }
      0|  505|            }
      0|  506|        }
      0|  507|
      0|  508|        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
      0|  509|            for (field, value) in additionalHeaders {
      0|  510|                switch field {
      0|  511|                case "Cookie":
      0|  512|                    continue
      0|  513|                default:
      0|  514|                    components.append("-H \"\(field): \(value)\"")
      0|  515|                }
      0|  516|            }
      0|  517|        }
      0|  518|
      0|  519|        if let
      0|  520|            HTTPBodyData = request.HTTPBody,
      0|  521|            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
      0|  522|        {
      0|  523|            let escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
      0|  524|            components.append("-d \"\(escapedBody)\"")
      0|  525|        }
      0|  526|
      0|  527|        components.append("\"\(URL!.absoluteString)\"")
      0|  528|
      0|  529|        return components.joinWithSeparator(" \\\n\t")
      0|  530|    }
       |  531|
       |  532|    /// The textual representation used when written to an output stream, in the form of a cURL command.
      0|  533|    public var debugDescription: String {
      0|  534|        return cURLRepresentation()
      0|  535|    }
       |  536|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Response.swift:
       |    1|// Response.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Used to store all response data returned from a completed `Request`.
       |   26|public struct Response<Value, Error: ErrorType> {
       |   27|    /// The URL request sent to the server.
       |   28|    public let request: NSURLRequest?
       |   29|
       |   30|    /// The server's response to the URL request.
       |   31|    public let response: NSHTTPURLResponse?
       |   32|
       |   33|    /// The data returned by the server.
       |   34|    public let data: NSData?
       |   35|
       |   36|    /// The result of response serialization.
       |   37|    public let result: Result<Value, Error>
       |   38|
       |   39|    /**
       |   40|        Initializes the `Response` instance with the specified URL request, URL response, server data and response
       |   41|        serialization result.
       |   42|    
       |   43|        - parameter request:  The URL request sent to the server.
       |   44|        - parameter response: The server's response to the URL request.
       |   45|        - parameter data:     The data returned by the server.
       |   46|        - parameter result:   The result of response serialization.
       |   47|    
       |   48|        - returns: the new `Response` instance.
       |   49|    */
      1|   50|    public init(request: NSURLRequest?, response: NSHTTPURLResponse?, data: NSData?, result: Result<Value, Error>) {
      1|   51|        self.request = request
      1|   52|        self.response = response
      1|   53|        self.data = data
      1|   54|        self.result = result
      1|   55|    }
       |   56|}
       |   57|
       |   58|// MARK: - CustomStringConvertible
       |   59|
       |   60|extension Response: CustomStringConvertible {
       |   61|    /// The textual representation used when written to an output stream, which includes whether the result was a
       |   62|    /// success or failure.
      0|   63|    public var description: String {
      0|   64|        return result.debugDescription
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - CustomDebugStringConvertible
       |   69|
       |   70|extension Response: CustomDebugStringConvertible {
       |   71|    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
       |   72|    /// response, the server data and the response serialization result.
      0|   73|    public var debugDescription: String {
      0|   74|        var output: [String] = []
      0|   75|
      0|   76|        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
      0|   77|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
      0|   78|        output.append("[Data]: \(data?.length ?? 0) bytes")
      0|   79|        output.append("[Result]: \(result.debugDescription)")
      0|   80|
      0|   81|        return output.joinWithSeparator("\n")
      0|   82|    }
       |   83|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ResponseSerialization.swift:
       |    1|// ResponseSerialization.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: ResponseSerializer
       |   26|
       |   27|/**
       |   28|    The type in which all response serializers must conform to in order to serialize a response.
       |   29|*/
       |   30|public protocol ResponseSerializerType {
       |   31|    /// The type of serialized object to be created by this `ResponseSerializerType`.
       |   32|    typealias SerializedObject
       |   33|
       |   34|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   35|    typealias ErrorObject: ErrorType
       |   36|
       |   37|    /**
       |   38|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   39|    */
       |   40|    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
       |   41|}
       |   42|
       |   43|// MARK: -
       |   44|
       |   45|/**
       |   46|    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
       |   47|*/
       |   48|public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
       |   49|    /// The type of serialized object to be created by this `ResponseSerializer`.
       |   50|    public typealias SerializedObject = Value
       |   51|
       |   52|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   53|    public typealias ErrorObject = Error
       |   54|
       |   55|    /**
       |   56|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   57|    */
       |   58|    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
       |   59|
       |   60|    /**
       |   61|        Initializes the `ResponseSerializer` instance with the given serialize response closure.
       |   62|
       |   63|        - parameter serializeResponse: The closure used to serialize the response.
       |   64|
       |   65|        - returns: The new generic response serializer instance.
       |   66|    */
      1|   67|    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
      1|   68|        self.serializeResponse = serializeResponse
      1|   69|    }
       |   70|}
       |   71|
       |   72|// MARK: - Default
       |   73|
       |   74|extension Request {
       |   75|
       |   76|    /**
       |   77|        Adds a handler to be called once the request has finished.
       |   78|
       |   79|        - parameter queue:             The queue on which the completion handler is dispatched.
       |   80|        - parameter completionHandler: The code to be executed once the request has finished.
       |   81|
       |   82|        - returns: The request.
       |   83|    */
       |   84|    public func response(
       |   85|        queue queue: dispatch_queue_t? = nil,
       |   86|        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
       |   87|        -> Self
      0|   88|    {
      0|   89|        delegate.queue.addOperationWithBlock {
      0|   90|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      0|   91|                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
      0|   92|            }
      0|   93|        }
      0|   94|
      0|   95|        return self
      0|   96|    }
       |   97|
       |   98|    /**
       |   99|        Adds a handler to be called once the request has finished.
       |  100|
       |  101|        - parameter queue:              The queue on which the completion handler is dispatched.
       |  102|        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
       |  103|                                        and data.
       |  104|        - parameter completionHandler:  The code to be executed once the request has finished.
       |  105|
       |  106|        - returns: The request.
       |  107|    */
       |  108|    public func response<T: ResponseSerializerType>(
       |  109|        queue queue: dispatch_queue_t? = nil,
       |  110|        responseSerializer: T,
       |  111|        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
       |  112|        -> Self
      1|  113|    {
      1|  114|        delegate.queue.addOperationWithBlock {
      1|  115|            let result = responseSerializer.serializeResponse(
      1|  116|                self.request,
      1|  117|                self.response,
      1|  118|                self.delegate.data,
      1|  119|                self.delegate.error
      1|  120|            )
      1|  121|
      1|  122|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      1|  123|                let response = Response<T.SerializedObject, T.ErrorObject>(
      1|  124|                    request: self.request,
      1|  125|                    response: self.response,
      1|  126|                    data: self.delegate.data,
      1|  127|                    result: result
      1|  128|                )
      1|  129|
      1|  130|                completionHandler(response)
      1|  131|            }
      1|  132|        }
      1|  133|
      1|  134|        return self
      1|  135|    }
       |  136|}
       |  137|
       |  138|// MARK: - Data
       |  139|
       |  140|extension Request {
       |  141|
       |  142|    /**
       |  143|        Creates a response serializer that returns the associated data as-is.
       |  144|
       |  145|        - returns: A data response serializer.
       |  146|    */
      0|  147|    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
      0|  148|        return ResponseSerializer { _, response, data, error in
      0|  149|            guard error == nil else { return .Failure(error!) }
      0|  150|
      0|  151|            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
      0|  152|
      0|  153|            guard let validData = data else {
      0|  154|                let failureReason = "Data could not be serialized. Input data was nil."
      0|  155|                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
      0|  156|                return .Failure(error)
      0|  157|            }
      0|  158|
      0|  159|            return .Success(validData)
      0|  160|        }
      0|  161|    }
       |  162|
       |  163|    /**
       |  164|        Adds a handler to be called once the request has finished.
       |  165|
       |  166|        - parameter completionHandler: The code to be executed once the request has finished.
       |  167|
       |  168|        - returns: The request.
       |  169|    */
      0|  170|    public func responseData(completionHandler: Response<NSData, NSError> -> Void) -> Self {
      0|  171|        return response(responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
      0|  172|    }
       |  173|}
       |  174|
       |  175|// MARK: - String
       |  176|
       |  177|extension Request {
       |  178|
       |  179|    /**
       |  180|        Creates a response serializer that returns a string initialized from the response data with the specified 
       |  181|        string encoding.
       |  182|
       |  183|        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
       |  184|                              response, falling back to the default HTTP default character set, ISO-8859-1.
       |  185|
       |  186|        - returns: A string response serializer.
       |  187|    */
       |  188|    public static func stringResponseSerializer(
       |  189|        var encoding encoding: NSStringEncoding? = nil)
       |  190|        -> ResponseSerializer<String, NSError>
      0|  191|    {
      0|  192|        return ResponseSerializer { _, response, data, error in
      0|  193|            guard error == nil else { return .Failure(error!) }
      0|  194|
      0|  195|            if let response = response where response.statusCode == 204 { return .Success("") }
      0|  196|
      0|  197|            guard let validData = data else {
      0|  198|                let failureReason = "String could not be serialized. Input data was nil."
      0|  199|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  200|                return .Failure(error)
      0|  201|            }
      0|  202|
      0|  203|            if let encodingName = response?.textEncodingName where encoding == nil {
      0|  204|                encoding = CFStringConvertEncodingToNSStringEncoding(
      0|  205|                    CFStringConvertIANACharSetNameToEncoding(encodingName)
      0|  206|                )
      0|  207|            }
      0|  208|
      0|  209|            let actualEncoding = encoding ?? NSISOLatin1StringEncoding
      0|  210|
      0|  211|            if let string = String(data: validData, encoding: actualEncoding) {
      0|  212|                return .Success(string)
      0|  213|            } else {
      0|  214|                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
      0|  215|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  216|                return .Failure(error)
      0|  217|            }
      0|  218|        }
      0|  219|    }
       |  220|
       |  221|    /**
       |  222|        Adds a handler to be called once the request has finished.
       |  223|
       |  224|        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
       |  225|                                       server response, falling back to the default HTTP default character set, 
       |  226|                                       ISO-8859-1.
       |  227|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  228|
       |  229|        - returns: The request.
       |  230|    */
       |  231|    public func responseString(
       |  232|        encoding encoding: NSStringEncoding? = nil,
       |  233|        completionHandler: Response<String, NSError> -> Void)
       |  234|        -> Self
      0|  235|    {
      0|  236|        return response(
      0|  237|            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
      0|  238|            completionHandler: completionHandler
      0|  239|        )
      0|  240|    }
       |  241|}
       |  242|
       |  243|// MARK: - JSON
       |  244|
       |  245|extension Request {
       |  246|
       |  247|    /**
       |  248|        Creates a response serializer that returns a JSON object constructed from the response data using 
       |  249|        `NSJSONSerialization` with the specified reading options.
       |  250|
       |  251|        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
       |  252|
       |  253|        - returns: A JSON object response serializer.
       |  254|    */
       |  255|    public static func JSONResponseSerializer(
       |  256|        options options: NSJSONReadingOptions = .AllowFragments)
       |  257|        -> ResponseSerializer<AnyObject, NSError>
      1|  258|    {
      1|  259|        return ResponseSerializer { _, response, data, error in
      0|  260|            guard error == nil else { return .Failure(error!) }
      1|  261|
      0|  262|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      1|  263|
      0|  264|            guard let validData = data where validData.length > 0 else {
      0|  265|                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
      0|  266|                let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
      0|  267|                return .Failure(error)
      0|  268|            }
      1|  269|
      1|  270|            do {
      1|  271|                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
      1|  272|                return .Success(JSON)
      1|  273|            } catch {
      1|  274|                return .Failure(error as NSError)
      1|  275|            }
      0|  276|        }
      1|  277|    }
       |  278|
       |  279|    /**
       |  280|        Adds a handler to be called once the request has finished.
       |  281|
       |  282|        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
       |  283|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  284|
       |  285|        - returns: The request.
       |  286|    */
       |  287|    public func responseJSON(
       |  288|        options options: NSJSONReadingOptions = .AllowFragments,
       |  289|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  290|        -> Self
      1|  291|    {
      1|  292|        return response(
      1|  293|            responseSerializer: Request.JSONResponseSerializer(options: options),
      1|  294|            completionHandler: completionHandler
      1|  295|        )
      1|  296|    }
       |  297|}
       |  298|
       |  299|// MARK: - Property List
       |  300|
       |  301|extension Request {
       |  302|
       |  303|    /**
       |  304|        Creates a response serializer that returns an object constructed from the response data using 
       |  305|        `NSPropertyListSerialization` with the specified reading options.
       |  306|
       |  307|        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
       |  308|
       |  309|        - returns: A property list object response serializer.
       |  310|    */
       |  311|    public static func propertyListResponseSerializer(
       |  312|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
       |  313|        -> ResponseSerializer<AnyObject, NSError>
      0|  314|    {
      0|  315|        return ResponseSerializer { _, response, data, error in
      0|  316|            guard error == nil else { return .Failure(error!) }
      0|  317|
      0|  318|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      0|  319|
      0|  320|            guard let validData = data where validData.length > 0 else {
      0|  321|                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
      0|  322|                let error = Error.errorWithCode(.PropertyListSerializationFailed, failureReason: failureReason)
      0|  323|                return .Failure(error)
      0|  324|            }
      0|  325|
      0|  326|            do {
      0|  327|                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
      0|  328|                return .Success(plist)
      0|  329|            } catch {
      0|  330|                return .Failure(error as NSError)
      0|  331|            }
      0|  332|        }
      0|  333|    }
       |  334|
       |  335|    /**
       |  336|        Adds a handler to be called once the request has finished.
       |  337|
       |  338|        - parameter options:           The property list reading options. `0` by default.
       |  339|        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
       |  340|                                       arguments: the URL request, the URL response, the server data and the result 
       |  341|                                       produced while creating the property list.
       |  342|
       |  343|        - returns: The request.
       |  344|    */
       |  345|    public func responsePropertyList(
       |  346|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
       |  347|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  348|        -> Self
      0|  349|    {
      0|  350|        return response(
      0|  351|            responseSerializer: Request.propertyListResponseSerializer(options: options),
      0|  352|            completionHandler: completionHandler
      0|  353|        )
      0|  354|    }
       |  355|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Result.swift:
       |    1|// Result.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Used to represent whether a request was successful or encountered an error.
       |   27|
       |   28|    - Success: The request and all post processing operations were successful resulting in the serialization of the 
       |   29|               provided associated value.
       |   30|    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
       |   31|               provided by the server as well as the error that caused the failure.
       |   32|*/
       |   33|public enum Result<Value, Error: ErrorType> {
       |   34|    case Success(Value)
       |   35|    case Failure(Error)
       |   36|
       |   37|    /// Returns `true` if the result is a success, `false` otherwise.
      0|   38|    public var isSuccess: Bool {
      0|   39|        switch self {
      0|   40|        case .Success:
      0|   41|            return true
      0|   42|        case .Failure:
      0|   43|            return false
      0|   44|        }
      0|   45|    }
       |   46|
       |   47|    /// Returns `true` if the result is a failure, `false` otherwise.
      0|   48|    public var isFailure: Bool {
      0|   49|        return !isSuccess
      0|   50|    }
       |   51|
       |   52|    /// Returns the associated value if the result is a success, `nil` otherwise.
      0|   53|    public var value: Value? {
      0|   54|        switch self {
      0|   55|        case .Success(let value):
      0|   56|            return value
      0|   57|        case .Failure:
      0|   58|            return nil
      0|   59|        }
      0|   60|    }
       |   61|
       |   62|    /// Returns the associated error value if the result is a failure, `nil` otherwise.
      0|   63|    public var error: Error? {
      0|   64|        switch self {
      0|   65|        case .Success:
      0|   66|            return nil
      0|   67|        case .Failure(let error):
      0|   68|            return error
      0|   69|        }
      0|   70|    }
       |   71|}
       |   72|
       |   73|// MARK: - CustomStringConvertible
       |   74|
       |   75|extension Result: CustomStringConvertible {
       |   76|    /// The textual representation used when written to an output stream, which includes whether the result was a 
       |   77|    /// success or failure.
      0|   78|    public var description: String {
      0|   79|        switch self {
      0|   80|        case .Success:
      0|   81|            return "SUCCESS"
      0|   82|        case .Failure:
      0|   83|            return "FAILURE"
      0|   84|        }
      0|   85|    }
       |   86|}
       |   87|
       |   88|// MARK: - CustomDebugStringConvertible
       |   89|
       |   90|extension Result: CustomDebugStringConvertible {
       |   91|    /// The debug textual representation used when written to an output stream, which includes whether the result was a
       |   92|    /// success or failure in addition to the value or error.
      1|   93|    public var debugDescription: String {
      1|   94|        switch self {
      0|   95|        case .Success(let value):
      0|   96|            return "SUCCESS: \(value)"
      1|   97|        case .Failure(let error):
      1|   98|            return "FAILURE: \(error)"
      1|   99|        }
      1|  100|    }
       |  101|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ServerTrustPolicy.swift:
       |    1|// ServerTrustPolicy.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
       |   26|public class ServerTrustPolicyManager {
       |   27|    /// The dictionary of policies mapped to a particular host.
       |   28|    public let policies: [String: ServerTrustPolicy]
       |   29|
       |   30|    /**
       |   31|        Initializes the `ServerTrustPolicyManager` instance with the given policies.
       |   32|
       |   33|        Since different servers and web services can have different leaf certificates, intermediate and even root 
       |   34|        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
       |   35|        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
       |   36|        pinning for host3 and disabling evaluation for host4.
       |   37|
       |   38|        - parameter policies: A dictionary of all policies mapped to a particular host.
       |   39|
       |   40|        - returns: The new `ServerTrustPolicyManager` instance.
       |   41|    */
      0|   42|    public init(policies: [String: ServerTrustPolicy]) {
      0|   43|        self.policies = policies
      0|   44|    }
       |   45|
       |   46|    /**
       |   47|        Returns the `ServerTrustPolicy` for the given host if applicable.
       |   48|
       |   49|        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
       |   50|        this method and implement more complex mapping implementations such as wildcards.
       |   51|
       |   52|        - parameter host: The host to use when searching for a matching policy.
       |   53|
       |   54|        - returns: The server trust policy for the given host if found.
       |   55|    */
      0|   56|    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
      0|   57|        return policies[host]
      0|   58|    }
       |   59|}
       |   60|
       |   61|// MARK: -
       |   62|
       |   63|extension NSURLSession {
       |   64|    private struct AssociatedKeys {
       |   65|        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
       |   66|    }
       |   67|
       |   68|    var serverTrustPolicyManager: ServerTrustPolicyManager? {
      1|   69|        get {
      1|   70|            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
      1|   71|        }
      1|   72|        set (manager) {
      1|   73|            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
      1|   74|        }
       |   75|    }
       |   76|}
       |   77|
       |   78|// MARK: - ServerTrustPolicy
       |   79|
       |   80|/**
       |   81|    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
       |   82|    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
       |   83|    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
       |   84|
       |   85|    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
       |   86|    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
       |   87|    to route all communication over an HTTPS connection with pinning enabled.
       |   88|
       |   89|    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
       |   90|                                validate the host provided by the challenge. Applications are encouraged to always 
       |   91|                                validate the host in production environments to guarantee the validity of the server's 
       |   92|                                certificate chain.
       |   93|
       |   94|    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
       |   95|                                considered valid if one of the pinned certificates match one of the server certificates. 
       |   96|                                By validating both the certificate chain and host, certificate pinning provides a very 
       |   97|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |   98|                                Applications are encouraged to always validate the host and require a valid certificate 
       |   99|                                chain in production environments.
       |  100|
       |  101|    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
       |  102|                                valid if one of the pinned public keys match one of the server certificate public keys. 
       |  103|                                By validating both the certificate chain and host, public key pinning provides a very 
       |  104|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |  105|                                Applications are encouraged to always validate the host and require a valid certificate 
       |  106|                                chain in production environments.
       |  107|
       |  108|    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
       |  109|
       |  110|    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
       |  111|*/
       |  112|public enum ServerTrustPolicy {
       |  113|    case PerformDefaultEvaluation(validateHost: Bool)
       |  114|    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
       |  115|    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
       |  116|    case DisableEvaluation
       |  117|    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
       |  118|
       |  119|    // MARK: - Bundle Location
       |  120|
       |  121|    /**
       |  122|        Returns all certificates within the given bundle with a `.cer` file extension.
       |  123|
       |  124|        - parameter bundle: The bundle to search for all `.cer` files.
       |  125|
       |  126|        - returns: All certificates within the given bundle.
       |  127|    */
      0|  128|    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
      0|  129|        var certificates: [SecCertificate] = []
      0|  130|
      0|  131|        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
      0|  132|            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
      0|  133|        }.flatten())
      0|  134|
      0|  135|        for path in paths {
      0|  136|            if let
      0|  137|                certificateData = NSData(contentsOfFile: path),
      0|  138|                certificate = SecCertificateCreateWithData(nil, certificateData)
      0|  139|            {
      0|  140|                certificates.append(certificate)
      0|  141|            }
       |  142|        }
       |  143|
       |  144|        return certificates
       |  145|    }
       |  146|
       |  147|    /**
       |  148|        Returns all public keys within the given bundle with a `.cer` file extension.
       |  149|
      0|  150|        - parameter bundle: The bundle to search for all `*.cer` files.
      0|  151|
      0|  152|        - returns: All public keys within the given bundle.
      0|  153|    */
      0|  154|    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
      0|  155|        var publicKeys: [SecKey] = []
      0|  156|
      0|  157|        for certificate in certificatesInBundle(bundle) {
      0|  158|            if let publicKey = publicKeyForCertificate(certificate) {
      0|  159|                publicKeys.append(publicKey)
      0|  160|            }
       |  161|        }
       |  162|
       |  163|        return publicKeys
       |  164|    }
       |  165|
       |  166|    // MARK: - Evaluation
       |  167|
       |  168|    /**
       |  169|        Evaluates whether the server trust is valid for the given host.
       |  170|
       |  171|        - parameter serverTrust: The server trust to evaluate.
      0|  172|        - parameter host:        The host of the challenge protection space.
      0|  173|
      0|  174|        - returns: Whether the server trust is valid.
      0|  175|    */
      0|  176|    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
      0|  177|        var serverTrustIsValid = false
      0|  178|
      0|  179|        switch self {
      0|  180|        case let .PerformDefaultEvaluation(validateHost):
      0|  181|            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  182|            SecTrustSetPolicies(serverTrust, [policy])
      0|  183|
      0|  184|            serverTrustIsValid = trustIsValid(serverTrust)
      0|  185|        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
      0|  186|            if validateCertificateChain {
      0|  187|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  188|                SecTrustSetPolicies(serverTrust, [policy])
      0|  189|
      0|  190|                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
      0|  191|                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
      0|  192|
      0|  193|                serverTrustIsValid = trustIsValid(serverTrust)
      0|  194|            } else {
      0|  195|                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
      0|  196|                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
      0|  197|
      0|  198|                outerLoop: for serverCertificateData in serverCertificatesDataArray {
      0|  199|                    for pinnedCertificateData in pinnedCertificatesDataArray {
      0|  200|                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
      0|  201|                            serverTrustIsValid = true
      0|  202|                            break outerLoop
      0|  203|                        }
      0|  204|                    }
      0|  205|                }
      0|  206|            }
      0|  207|        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
      0|  208|            var certificateChainEvaluationPassed = true
      0|  209|
      0|  210|            if validateCertificateChain {
      0|  211|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  212|                SecTrustSetPolicies(serverTrust, [policy])
      0|  213|
      0|  214|                certificateChainEvaluationPassed = trustIsValid(serverTrust)
      0|  215|            }
      0|  216|
      0|  217|            if certificateChainEvaluationPassed {
      0|  218|                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
      0|  219|                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
      0|  220|                        if serverPublicKey.isEqual(pinnedPublicKey) {
      0|  221|                            serverTrustIsValid = true
      0|  222|                            break outerLoop
      0|  223|                        }
      0|  224|                    }
      0|  225|                }
      0|  226|            }
      0|  227|        case .DisableEvaluation:
      0|  228|            serverTrustIsValid = true
      0|  229|        case let .CustomEvaluation(closure):
      0|  230|            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
      0|  231|        }
      0|  232|
      0|  233|        return serverTrustIsValid
      0|  234|    }
      0|  235|
      0|  236|    // MARK: - Private - Trust Validation
      0|  237|
       |  238|    private func trustIsValid(trust: SecTrust) -> Bool {
       |  239|        var isValid = false
       |  240|
      0|  241|        var result = SecTrustResultType(kSecTrustResultInvalid)
      0|  242|        let status = SecTrustEvaluate(trust, &result)
      0|  243|
      0|  244|        if status == errSecSuccess {
      0|  245|            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
      0|  246|            let proceed = SecTrustResultType(kSecTrustResultProceed)
      0|  247|
      0|  248|            isValid = result == unspecified || result == proceed
      0|  249|        }
      0|  250|
      0|  251|        return isValid
      0|  252|    }
      0|  253|
      0|  254|    // MARK: - Private - Certificate Data
      0|  255|
       |  256|    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
       |  257|        var certificates: [SecCertificate] = []
       |  258|
      0|  259|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  260|            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
      0|  261|                certificates.append(certificate)
      0|  262|            }
      0|  263|        }
      0|  264|
      0|  265|        return certificateDataForCertificates(certificates)
      0|  266|    }
      0|  267|
      0|  268|    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
      0|  269|        return certificates.map { SecCertificateCopyData($0) as NSData }
       |  270|    }
      0|  271|
      0|  272|    // MARK: - Private - Public Key Extraction
      0|  273|
       |  274|    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
       |  275|        var publicKeys: [SecKey] = []
       |  276|
      0|  277|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  278|            if let
      0|  279|                certificate = SecTrustGetCertificateAtIndex(trust, index),
      0|  280|                publicKey = publicKeyForCertificate(certificate)
      0|  281|            {
      0|  282|                publicKeys.append(publicKey)
      0|  283|            }
      0|  284|        }
      0|  285|
      0|  286|        return publicKeys
      0|  287|    }
      0|  288|
      0|  289|    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
      0|  290|        var publicKey: SecKey?
       |  291|
      0|  292|        let policy = SecPolicyCreateBasicX509()
      0|  293|        var trust: SecTrust?
      0|  294|        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
      0|  295|
      0|  296|        if let trust = trust where trustCreationStatus == errSecSuccess {
      0|  297|            publicKey = SecTrustCopyPublicKey(trust)
      0|  298|        }
      0|  299|
      0|  300|        return publicKey
      0|  301|    }
      0|  302|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Stream.swift:
       |    1|// Stream.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if !os(watchOS)
       |   26|
       |   27|@available(iOS 9.0, OSX 10.11, *)
       |   28|extension Manager {
       |   29|    private enum Streamable {
       |   30|        case Stream(String, Int)
       |   31|        case NetService(NSNetService)
       |   32|    }
       |   33|
      0|   34|    private func stream(streamable: Streamable) -> Request {
      0|   35|        var streamTask: NSURLSessionStreamTask!
      0|   36|
      0|   37|        switch streamable {
      0|   38|        case .Stream(let hostName, let port):
      0|   39|            dispatch_sync(queue) {
      0|   40|                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
      0|   41|            }
      0|   42|        case .NetService(let netService):
      0|   43|            dispatch_sync(queue) {
      0|   44|                streamTask = self.session.streamTaskWithNetService(netService)
      0|   45|            }
      0|   46|        }
      0|   47|
      0|   48|        let request = Request(session: session, task: streamTask)
      0|   49|
      0|   50|        delegate[request.delegate.task] = request.delegate
      0|   51|
      0|   52|        if startRequestsImmediately {
      0|   53|            request.resume()
      0|   54|        }
      0|   55|
      0|   56|        return request
      0|   57|    }
       |   58|
       |   59|    /**
       |   60|        Creates a request for bidirectional streaming with the given hostname and port.
       |   61|
       |   62|        - parameter hostName: The hostname of the server to connect to.
       |   63|        - parameter port:     The port of the server to connect to.
       |   64|
       |   65|        :returns: The created stream request.
       |   66|    */
      0|   67|    public func stream(hostName hostName: String, port: Int) -> Request {
      0|   68|        return stream(.Stream(hostName, port))
      0|   69|    }
       |   70|
       |   71|    /**
       |   72|        Creates a request for bidirectional streaming with the given `NSNetService`.
       |   73|
       |   74|        - parameter netService: The net service used to identify the endpoint.
       |   75|
       |   76|        - returns: The created stream request.
       |   77|    */
      0|   78|    public func stream(netService netService: NSNetService) -> Request {
      0|   79|        return stream(.NetService(netService))
      0|   80|    }
       |   81|}
       |   82|
       |   83|// MARK: -
       |   84|
       |   85|@available(iOS 9.0, OSX 10.11, *)
       |   86|extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
       |   87|
       |   88|    // MARK: Override Closures
       |   89|
       |   90|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
       |   91|    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|   92|        get {
      0|   93|            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|   94|        }
      0|   95|        set {
      0|   96|            _streamTaskReadClosed = newValue
      0|   97|        }
       |   98|    }
       |   99|
       |  100|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
       |  101|    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  102|        get {
      0|  103|            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  104|        }
      0|  105|        set {
      0|  106|            _streamTaskWriteClosed = newValue
      0|  107|        }
       |  108|    }
       |  109|
       |  110|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
       |  111|    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  112|        get {
      0|  113|            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  114|        }
      0|  115|        set {
      0|  116|            _streamTaskBetterRouteDiscovered = newValue
      0|  117|        }
       |  118|    }
       |  119|
       |  120|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
       |  121|    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
      0|  122|        get {
      0|  123|            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
      0|  124|        }
      0|  125|        set {
      0|  126|            _streamTaskDidBecomeInputStream = newValue
      0|  127|        }
       |  128|    }
       |  129|
       |  130|    // MARK: Delegate Methods
       |  131|
       |  132|    /**
       |  133|        Tells the delegate that the read side of the connection has been closed.
       |  134|
       |  135|        - parameter session:    The session.
       |  136|        - parameter streamTask: The stream task.
       |  137|    */
      0|  138|    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  139|        streamTaskReadClosed?(session, streamTask)
      0|  140|    }
       |  141|
       |  142|    /**
       |  143|        Tells the delegate that the write side of the connection has been closed.
       |  144|
       |  145|        - parameter session:    The session.
       |  146|        - parameter streamTask: The stream task.
       |  147|    */
      0|  148|    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  149|        streamTaskWriteClosed?(session, streamTask)
      0|  150|    }
       |  151|
       |  152|    /**
       |  153|        Tells the delegate that the system has determined that a better route to the host is available.
       |  154|
       |  155|        - parameter session:    The session.
       |  156|        - parameter streamTask: The stream task.
       |  157|    */
      0|  158|    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  159|        streamTaskBetterRouteDiscovered?(session, streamTask)
      0|  160|    }
       |  161|
       |  162|    /**
       |  163|        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
       |  164|
       |  165|        - parameter session:      The session.
       |  166|        - parameter streamTask:   The stream task.
       |  167|        - parameter inputStream:  The new input stream.
       |  168|        - parameter outputStream: The new output stream.
       |  169|    */
       |  170|    public func URLSession(
       |  171|        session: NSURLSession,
       |  172|        streamTask: NSURLSessionStreamTask,
       |  173|        didBecomeInputStream inputStream: NSInputStream,
       |  174|        outputStream: NSOutputStream)
      0|  175|    {
      0|  176|        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
      0|  177|    }
       |  178|}
       |  179|
       |  180|#endif

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Upload.swift:
       |    1|// Upload.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Uploadable {
       |   27|        case Data(NSURLRequest, NSData)
       |   28|        case File(NSURLRequest, NSURL)
       |   29|        case Stream(NSURLRequest, NSInputStream)
       |   30|    }
       |   31|
      0|   32|    private func upload(uploadable: Uploadable) -> Request {
      0|   33|        var uploadTask: NSURLSessionUploadTask!
      0|   34|        var HTTPBodyStream: NSInputStream?
      0|   35|
      0|   36|        switch uploadable {
      0|   37|        case .Data(let request, let data):
      0|   38|            dispatch_sync(queue) {
      0|   39|                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
      0|   40|            }
      0|   41|        case .File(let request, let fileURL):
      0|   42|            dispatch_sync(queue) {
      0|   43|                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
      0|   44|            }
      0|   45|        case .Stream(let request, let stream):
      0|   46|            dispatch_sync(queue) {
      0|   47|                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
      0|   48|            }
      0|   49|
      0|   50|            HTTPBodyStream = stream
      0|   51|        }
      0|   52|
      0|   53|        let request = Request(session: session, task: uploadTask)
      0|   54|
      0|   55|        if HTTPBodyStream != nil {
      0|   56|            request.delegate.taskNeedNewBodyStream = { _, _ in
      0|   57|                return HTTPBodyStream
      0|   58|            }
      0|   59|        }
      0|   60|
      0|   61|        delegate[request.delegate.task] = request.delegate
      0|   62|
      0|   63|        if startRequestsImmediately {
      0|   64|            request.resume()
      0|   65|        }
      0|   66|
      0|   67|        return request
      0|   68|    }
       |   69|
       |   70|    // MARK: File
       |   71|
       |   72|    /**
       |   73|        Creates a request for uploading a file to the specified URL request.
       |   74|
       |   75|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   76|
       |   77|        - parameter URLRequest: The URL request
       |   78|        - parameter file:       The file to upload
       |   79|
       |   80|        - returns: The created upload request.
       |   81|    */
      0|   82|    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|   83|        return upload(.File(URLRequest.URLRequest, file))
      0|   84|    }
       |   85|
       |   86|    /**
       |   87|        Creates a request for uploading a file to the specified URL request.
       |   88|
       |   89|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   90|
       |   91|        - parameter method:    The HTTP method.
       |   92|        - parameter URLString: The URL string.
       |   93|        - parameter headers:   The HTTP headers. `nil` by default.
       |   94|        - parameter file:      The file to upload
       |   95|
       |   96|        - returns: The created upload request.
       |   97|    */
       |   98|    public func upload(
       |   99|        method: Method,
       |  100|        _ URLString: URLStringConvertible,
       |  101|        headers: [String: String]? = nil,
       |  102|        file: NSURL)
       |  103|        -> Request
      0|  104|    {
      0|  105|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  106|        return upload(mutableURLRequest, file: file)
      0|  107|    }
       |  108|
       |  109|    // MARK: Data
       |  110|
       |  111|    /**
       |  112|        Creates a request for uploading data to the specified URL request.
       |  113|
       |  114|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  115|
       |  116|        - parameter URLRequest: The URL request.
       |  117|        - parameter data:       The data to upload.
       |  118|
       |  119|        - returns: The created upload request.
       |  120|    */
      0|  121|    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  122|        return upload(.Data(URLRequest.URLRequest, data))
      0|  123|    }
       |  124|
       |  125|    /**
       |  126|        Creates a request for uploading data to the specified URL request.
       |  127|
       |  128|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  129|
       |  130|        - parameter method:    The HTTP method.
       |  131|        - parameter URLString: The URL string.
       |  132|        - parameter headers:   The HTTP headers. `nil` by default.
       |  133|        - parameter data:      The data to upload
       |  134|
       |  135|        - returns: The created upload request.
       |  136|    */
       |  137|    public func upload(
       |  138|        method: Method,
       |  139|        _ URLString: URLStringConvertible,
       |  140|        headers: [String: String]? = nil,
       |  141|        data: NSData)
       |  142|        -> Request
      0|  143|    {
      0|  144|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  145|
      0|  146|        return upload(mutableURLRequest, data: data)
      0|  147|    }
       |  148|
       |  149|    // MARK: Stream
       |  150|
       |  151|    /**
       |  152|        Creates a request for uploading a stream to the specified URL request.
       |  153|
       |  154|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  155|
       |  156|        - parameter URLRequest: The URL request.
       |  157|        - parameter stream:     The stream to upload.
       |  158|
       |  159|        - returns: The created upload request.
       |  160|    */
      0|  161|    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  162|        return upload(.Stream(URLRequest.URLRequest, stream))
      0|  163|    }
       |  164|
       |  165|    /**
       |  166|        Creates a request for uploading a stream to the specified URL request.
       |  167|
       |  168|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  169|
       |  170|        - parameter method:    The HTTP method.
       |  171|        - parameter URLString: The URL string.
       |  172|        - parameter headers:   The HTTP headers. `nil` by default.
       |  173|        - parameter stream:    The stream to upload.
       |  174|
       |  175|        - returns: The created upload request.
       |  176|    */
       |  177|    public func upload(
       |  178|        method: Method,
       |  179|        _ URLString: URLStringConvertible,
       |  180|        headers: [String: String]? = nil,
       |  181|        stream: NSInputStream)
       |  182|        -> Request
      0|  183|    {
      0|  184|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  185|
      0|  186|        return upload(mutableURLRequest, stream: stream)
      0|  187|    }
       |  188|
       |  189|    // MARK: MultipartFormData
       |  190|
       |  191|    /// Default memory threshold used when encoding `MultipartFormData`.
       |  192|    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
       |  193|
       |  194|    /**
       |  195|        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
       |  196|        associated values.
       |  197|
       |  198|        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
       |  199|                   streaming information.
       |  200|        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
       |  201|                   error.
       |  202|    */
       |  203|    public enum MultipartFormDataEncodingResult {
       |  204|        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
       |  205|        case Failure(ErrorType)
       |  206|    }
       |  207|
       |  208|    /**
       |  209|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  210|
       |  211|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
       |  212|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
       |  213|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
       |  214|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
       |  215|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
       |  216|        used for larger payloads such as video content.
       |  217|
       |  218|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
       |  219|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  220|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
       |  221|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
       |  222|        technique was used.
       |  223|
       |  224|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  225|
       |  226|        - parameter method:                  The HTTP method.
       |  227|        - parameter URLString:               The URL string.
       |  228|        - parameter headers:                 The HTTP headers. `nil` by default.
       |  229|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  230|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  231|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  232|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  233|    */
       |  234|    public func upload(
       |  235|        method: Method,
       |  236|        _ URLString: URLStringConvertible,
       |  237|        headers: [String: String]? = nil,
       |  238|        multipartFormData: MultipartFormData -> Void,
       |  239|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  240|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  241|    {
      0|  242|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  243|
      0|  244|        return upload(
      0|  245|            mutableURLRequest,
      0|  246|            multipartFormData: multipartFormData,
      0|  247|            encodingMemoryThreshold: encodingMemoryThreshold,
      0|  248|            encodingCompletion: encodingCompletion
      0|  249|        )
      0|  250|    }
       |  251|
       |  252|    /**
       |  253|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  254|
       |  255|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
       |  256|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
       |  257|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
       |  258|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
       |  259|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
       |  260|        used for larger payloads such as video content.
       |  261|
       |  262|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
       |  263|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  264|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
       |  265|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
       |  266|        technique was used.
       |  267|
       |  268|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  269|
       |  270|        - parameter URLRequest:              The URL request.
       |  271|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  272|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  273|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  274|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  275|    */
       |  276|    public func upload(
       |  277|        URLRequest: URLRequestConvertible,
       |  278|        multipartFormData: MultipartFormData -> Void,
       |  279|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  280|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  281|    {
      0|  282|        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
      0|  283|            let formData = MultipartFormData()
      0|  284|            multipartFormData(formData)
      0|  285|
      0|  286|            let URLRequestWithContentType = URLRequest.URLRequest
      0|  287|            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
      0|  288|
      0|  289|            let isBackgroundSession = self.session.configuration.identifier != nil
      0|  290|
      0|  291|            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
      0|  292|                do {
      0|  293|                    let data = try formData.encode()
      0|  294|                    let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  295|                        request: self.upload(URLRequestWithContentType, data: data),
      0|  296|                        streamingFromDisk: false,
      0|  297|                        streamFileURL: nil
      0|  298|                    )
      0|  299|
      0|  300|                    dispatch_async(dispatch_get_main_queue()) {
      0|  301|                        encodingCompletion?(encodingResult)
      0|  302|                    }
      0|  303|                } catch {
      0|  304|                    dispatch_async(dispatch_get_main_queue()) {
      0|  305|                        encodingCompletion?(.Failure(error as NSError))
      0|  306|                    }
      0|  307|                }
      0|  308|            } else {
      0|  309|                let fileManager = NSFileManager.defaultManager()
      0|  310|                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
      0|  311|                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
      0|  312|                let fileName = NSUUID().UUIDString
      0|  313|                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
      0|  314|
      0|  315|                do {
      0|  316|                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
      0|  317|                    try formData.writeEncodedDataToDisk(fileURL)
      0|  318|
      0|  319|                    dispatch_async(dispatch_get_main_queue()) {
      0|  320|                        let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  321|                            request: self.upload(URLRequestWithContentType, file: fileURL),
      0|  322|                            streamingFromDisk: true,
      0|  323|                            streamFileURL: fileURL
      0|  324|                        )
      0|  325|                        encodingCompletion?(encodingResult)
      0|  326|                    }
      0|  327|                } catch {
      0|  328|                    dispatch_async(dispatch_get_main_queue()) {
      0|  329|                        encodingCompletion?(.Failure(error as NSError))
      0|  330|                    }
      0|  331|                }
      0|  332|            }
      0|  333|        }
      0|  334|    }
       |  335|}
       |  336|
       |  337|// MARK: -
       |  338|
       |  339|extension Request {
       |  340|
       |  341|    // MARK: - UploadTaskDelegate
       |  342|
       |  343|    class UploadTaskDelegate: DataTaskDelegate {
      0|  344|        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
       |  345|        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
       |  346|
       |  347|        // MARK: - NSURLSessionTaskDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  352|
       |  353|        // MARK: Delegate Methods
       |  354|
       |  355|        func URLSession(
       |  356|            session: NSURLSession,
       |  357|            task: NSURLSessionTask,
       |  358|            didSendBodyData bytesSent: Int64,
       |  359|            totalBytesSent: Int64,
       |  360|            totalBytesExpectedToSend: Int64)
      0|  361|        {
      0|  362|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  363|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  364|            } else {
      0|  365|                progress.totalUnitCount = totalBytesExpectedToSend
      0|  366|                progress.completedUnitCount = totalBytesSent
      0|  367|
      0|  368|                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  369|            }
      0|  370|        }
       |  371|    }
       |  372|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Validation.swift:
       |    1|// Validation.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Request {
       |   26|
       |   27|    /**
       |   28|        Used to represent whether validation was successful or encountered an error resulting in a failure.
       |   29|
       |   30|        - Success: The validation was successful.
       |   31|        - Failure: The validation failed encountering the provided error.
       |   32|    */
       |   33|    public enum ValidationResult {
       |   34|        case Success
       |   35|        case Failure(NSError)
       |   36|    }
       |   37|
       |   38|    /**
       |   39|        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
       |   40|        request was valid.
       |   41|    */
       |   42|    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
       |   43|
       |   44|    /**
       |   45|        Validates the request, using the specified closure.
       |   46|
       |   47|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   48|
       |   49|        - parameter validation: A closure to validate the request.
       |   50|
       |   51|        - returns: The request.
       |   52|    */
      0|   53|    public func validate(validation: Validation) -> Self {
      0|   54|        delegate.queue.addOperationWithBlock {
      0|   55|            if let
      0|   56|                response = self.response where self.delegate.error == nil,
      0|   57|                case let .Failure(error) = validation(self.request, response)
      0|   58|            {
      0|   59|                self.delegate.error = error
      0|   60|            }
      0|   61|        }
      0|   62|
      0|   63|        return self
      0|   64|    }
       |   65|
       |   66|    // MARK: - Status Code
       |   67|
       |   68|    /**
       |   69|        Validates that the response has a status code in the specified range.
       |   70|
       |   71|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   72|
       |   73|        - parameter range: The range of acceptable status codes.
       |   74|
       |   75|        - returns: The request.
       |   76|    */
      0|   77|    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
      0|   78|        return validate { _, response in
      0|   79|            if acceptableStatusCode.contains(response.statusCode) {
      0|   80|                return .Success
      0|   81|            } else {
      0|   82|                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
      0|   83|                return .Failure(Error.errorWithCode(.StatusCodeValidationFailed, failureReason: failureReason))
      0|   84|            }
      0|   85|        }
      0|   86|    }
       |   87|
       |   88|    // MARK: - Content-Type
       |   89|
       |   90|    private struct MIMEType {
       |   91|        let type: String
       |   92|        let subtype: String
       |   93|
      0|   94|        init?(_ string: String) {
      0|   95|            let components: [String] = {
      0|   96|                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
      0|   97|                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
      0|   98|                return split.componentsSeparatedByString("/")
      0|   99|            }()
      0|  100|
      0|  101|            if let
      0|  102|                type = components.first,
      0|  103|                subtype = components.last
      0|  104|            {
      0|  105|                self.type = type
      0|  106|                self.subtype = subtype
      0|  107|            } else {
      0|  108|                return nil
      0|  109|            }
      0|  110|        }
       |  111|
      0|  112|        func matches(MIME: MIMEType) -> Bool {
      0|  113|            switch (type, subtype) {
      0|  114|            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
      0|  115|                return true
      0|  116|            default:
      0|  117|                return false
      0|  118|            }
      0|  119|        }
       |  120|    }
       |  121|
       |  122|    /**
       |  123|        Validates that the response has a content type in the specified array.
       |  124|
       |  125|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  126|
       |  127|        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
       |  128|
       |  129|        - returns: The request.
       |  130|    */
      0|  131|    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
      0|  132|        return validate { _, response in
      0|  133|            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
      0|  134|
      0|  135|            if let
      0|  136|                responseContentType = response.MIMEType,
      0|  137|                responseMIMEType = MIMEType(responseContentType)
      0|  138|            {
      0|  139|                for contentType in acceptableContentTypes {
      0|  140|                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
      0|  141|                        return .Success
      0|  142|                    }
      0|  143|                }
      0|  144|            } else {
      0|  145|                for contentType in acceptableContentTypes {
      0|  146|                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
      0|  147|                        return .Success
      0|  148|                    }
      0|  149|                }
      0|  150|            }
      0|  151|
      0|  152|            let failureReason: String
      0|  153|
      0|  154|            if let responseContentType = response.MIMEType {
      0|  155|                failureReason = (
      0|  156|                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
      0|  157|                    "content types: \(acceptableContentTypes)"
      0|  158|                )
      0|  159|            } else {
      0|  160|                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
      0|  161|            }
      0|  162|
      0|  163|            return .Failure(Error.errorWithCode(.ContentTypeValidationFailed, failureReason: failureReason))
      0|  164|        }
      0|  165|    }
       |  166|
       |  167|    // MARK: - Automatic
       |  168|
       |  169|    /**
       |  170|        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
       |  171|        type matches any specified in the Accept HTTP header field.
       |  172|
       |  173|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  174|
       |  175|        - returns: The request.
       |  176|    */
      0|  177|    public func validate() -> Self {
      0|  178|        let acceptableStatusCodes: Range<Int> = 200..<300
      0|  179|        let acceptableContentTypes: [String] = {
      0|  180|            if let accept = request?.valueForHTTPHeaderField("Accept") {
      0|  181|                return accept.componentsSeparatedByString(",")
      0|  182|            }
      0|  183|
      0|  184|            return ["*/*"]
      0|  185|        }()
      0|  186|
      0|  187|        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
      0|  188|    }
       |  189|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Alamofire.swift:
       |    1|// Alamofire.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: - URLStringConvertible
       |   26|
       |   27|/**
       |   28|    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
       |   29|    construct URL requests.
       |   30|*/
       |   31|public protocol URLStringConvertible {
       |   32|    /**
       |   33|        A URL that conforms to RFC 2396.
       |   34|
       |   35|        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
       |   36|
       |   37|        See https://tools.ietf.org/html/rfc2396
       |   38|        See https://tools.ietf.org/html/rfc1738
       |   39|        See https://tools.ietf.org/html/rfc1808
       |   40|    */
       |   41|    var URLString: String { get }
       |   42|}
       |   43|
       |   44|extension String: URLStringConvertible {
      1|   45|    public var URLString: String {
      1|   46|        return self
      1|   47|    }
       |   48|}
       |   49|
       |   50|extension NSURL: URLStringConvertible {
      0|   51|    public var URLString: String {
      0|   52|        return absoluteString
      0|   53|    }
       |   54|}
       |   55|
       |   56|extension NSURLComponents: URLStringConvertible {
      0|   57|    public var URLString: String {
      0|   58|        return URL!.URLString
      0|   59|    }
       |   60|}
       |   61|
       |   62|extension NSURLRequest: URLStringConvertible {
      0|   63|    public var URLString: String {
      0|   64|        return URL!.URLString
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - URLRequestConvertible
       |   69|
       |   70|/**
       |   71|    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
       |   72|*/
       |   73|public protocol URLRequestConvertible {
       |   74|    /// The URL request.
       |   75|    var URLRequest: NSMutableURLRequest { get }
       |   76|}
       |   77|
       |   78|extension NSURLRequest: URLRequestConvertible {
      2|   79|    public var URLRequest: NSMutableURLRequest {
      2|   80|        return self.mutableCopy() as! NSMutableURLRequest
      2|   81|    }
       |   82|}
       |   83|
       |   84|// MARK: - Convenience
       |   85|
       |   86|func URLRequest(
       |   87|    method: Method,
       |   88|    _ URLString: URLStringConvertible,
       |   89|    headers: [String: String]? = nil)
       |   90|    -> NSMutableURLRequest
      1|   91|{
      1|   92|    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
      1|   93|    mutableURLRequest.HTTPMethod = method.rawValue
      1|   94|
      1|   95|    if let headers = headers {
      2|   96|        for (headerField, headerValue) in headers {
      2|   97|            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
      2|   98|        }
      1|   99|    }
      1|  100|
      1|  101|    return mutableURLRequest
      1|  102|}
       |  103|
       |  104|// MARK: - Request Methods
       |  105|
       |  106|/**
       |  107|    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
       |  108|    parameter encoding.
       |  109|
       |  110|    - parameter method:     The HTTP method.
       |  111|    - parameter URLString:  The URL string.
       |  112|    - parameter parameters: The parameters. `nil` by default.
       |  113|    - parameter encoding:   The parameter encoding. `.URL` by default.
       |  114|    - parameter headers:    The HTTP headers. `nil` by default.
       |  115|
       |  116|    - returns: The created request.
       |  117|*/
       |  118|public func request(
       |  119|    method: Method,
       |  120|    _ URLString: URLStringConvertible,
       |  121|    parameters: [String: AnyObject]? = nil,
       |  122|    encoding: ParameterEncoding = .URL,
       |  123|    headers: [String: String]? = nil)
       |  124|    -> Request
      1|  125|{
      1|  126|    return Manager.sharedInstance.request(
      1|  127|        method,
      1|  128|        URLString,
      1|  129|        parameters: parameters,
      1|  130|        encoding: encoding,
      1|  131|        headers: headers
      1|  132|    )
      1|  133|}
       |  134|
       |  135|/**
       |  136|    Creates a request using the shared manager instance for the specified URL request.
       |  137|
       |  138|    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  139|
       |  140|    - parameter URLRequest: The URL request
       |  141|
       |  142|    - returns: The created request.
       |  143|*/
      0|  144|public func request(URLRequest: URLRequestConvertible) -> Request {
      0|  145|    return Manager.sharedInstance.request(URLRequest.URLRequest)
      0|  146|}
       |  147|
       |  148|// MARK: - Upload Methods
       |  149|
       |  150|// MARK: File
       |  151|
       |  152|/**
       |  153|    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
       |  154|
       |  155|    - parameter method:    The HTTP method.
       |  156|    - parameter URLString: The URL string.
       |  157|    - parameter headers:   The HTTP headers. `nil` by default.
       |  158|    - parameter file:      The file to upload.
       |  159|
       |  160|    - returns: The created upload request.
       |  161|*/
       |  162|public func upload(
       |  163|    method: Method,
       |  164|    _ URLString: URLStringConvertible,
       |  165|    headers: [String: String]? = nil,
       |  166|    file: NSURL)
       |  167|    -> Request
      0|  168|{
      0|  169|    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
      0|  170|}
       |  171|
       |  172|/**
       |  173|    Creates an upload request using the shared manager instance for the specified URL request and file.
       |  174|
       |  175|    - parameter URLRequest: The URL request.
       |  176|    - parameter file:       The file to upload.
       |  177|
       |  178|    - returns: The created upload request.
       |  179|*/
      0|  180|public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|  181|    return Manager.sharedInstance.upload(URLRequest, file: file)
      0|  182|}
       |  183|
       |  184|// MARK: Data
       |  185|
       |  186|/**
       |  187|    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
       |  188|
       |  189|    - parameter method:    The HTTP method.
       |  190|    - parameter URLString: The URL string.
       |  191|    - parameter headers:   The HTTP headers. `nil` by default.
       |  192|    - parameter data:      The data to upload.
       |  193|
       |  194|    - returns: The created upload request.
       |  195|*/
       |  196|public func upload(
       |  197|    method: Method,
       |  198|    _ URLString: URLStringConvertible,
       |  199|    headers: [String: String]? = nil,
       |  200|    data: NSData)
       |  201|    -> Request
      0|  202|{
      0|  203|    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
      0|  204|}
       |  205|
       |  206|/**
       |  207|    Creates an upload request using the shared manager instance for the specified URL request and data.
       |  208|
       |  209|    - parameter URLRequest: The URL request.
       |  210|    - parameter data:       The data to upload.
       |  211|
       |  212|    - returns: The created upload request.
       |  213|*/
      0|  214|public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  215|    return Manager.sharedInstance.upload(URLRequest, data: data)
      0|  216|}
       |  217|
       |  218|// MARK: Stream
       |  219|
       |  220|/**
       |  221|    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
       |  222|
       |  223|    - parameter method:    The HTTP method.
       |  224|    - parameter URLString: The URL string.
       |  225|    - parameter headers:   The HTTP headers. `nil` by default.
       |  226|    - parameter stream:    The stream to upload.
       |  227|
       |  228|    - returns: The created upload request.
       |  229|*/
       |  230|public func upload(
       |  231|    method: Method,
       |  232|    _ URLString: URLStringConvertible,
       |  233|    headers: [String: String]? = nil,
       |  234|    stream: NSInputStream)
       |  235|    -> Request
      0|  236|{
      0|  237|    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
      0|  238|}
       |  239|
       |  240|/**
       |  241|    Creates an upload request using the shared manager instance for the specified URL request and stream.
       |  242|
       |  243|    - parameter URLRequest: The URL request.
       |  244|    - parameter stream:     The stream to upload.
       |  245|
       |  246|    - returns: The created upload request.
       |  247|*/
      0|  248|public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  249|    return Manager.sharedInstance.upload(URLRequest, stream: stream)
      0|  250|}
       |  251|
       |  252|// MARK: MultipartFormData
       |  253|
       |  254|/**
       |  255|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  256|
       |  257|    - parameter method:                  The HTTP method.
       |  258|    - parameter URLString:               The URL string.
       |  259|    - parameter headers:                 The HTTP headers. `nil` by default.
       |  260|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  261|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  262|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  263|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  264|*/
       |  265|public func upload(
       |  266|    method: Method,
       |  267|    _ URLString: URLStringConvertible,
       |  268|    headers: [String: String]? = nil,
       |  269|    multipartFormData: MultipartFormData -> Void,
       |  270|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  271|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  272|{
      0|  273|    return Manager.sharedInstance.upload(
      0|  274|        method,
      0|  275|        URLString,
      0|  276|        headers: headers,
      0|  277|        multipartFormData: multipartFormData,
      0|  278|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  279|        encodingCompletion: encodingCompletion
      0|  280|    )
      0|  281|}
       |  282|
       |  283|/**
       |  284|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  285|
       |  286|    - parameter URLRequest:              The URL request.
       |  287|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  288|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  289|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  290|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  291|*/
       |  292|public func upload(
       |  293|    URLRequest: URLRequestConvertible,
       |  294|    multipartFormData: MultipartFormData -> Void,
       |  295|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  296|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  297|{
      0|  298|    return Manager.sharedInstance.upload(
      0|  299|        URLRequest,
      0|  300|        multipartFormData: multipartFormData,
      0|  301|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  302|        encodingCompletion: encodingCompletion
      0|  303|    )
      0|  304|}
       |  305|
       |  306|// MARK: - Download Methods
       |  307|
       |  308|// MARK: URL Request
       |  309|
       |  310|/**
       |  311|    Creates a download request using the shared manager instance for the specified method and URL string.
       |  312|
       |  313|    - parameter method:      The HTTP method.
       |  314|    - parameter URLString:   The URL string.
       |  315|    - parameter parameters:  The parameters. `nil` by default.
       |  316|    - parameter encoding:    The parameter encoding. `.URL` by default.
       |  317|    - parameter headers:     The HTTP headers. `nil` by default.
       |  318|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  319|
       |  320|    - returns: The created download request.
       |  321|*/
       |  322|public func download(
       |  323|    method: Method,
       |  324|    _ URLString: URLStringConvertible,
       |  325|    parameters: [String: AnyObject]? = nil,
       |  326|    encoding: ParameterEncoding = .URL,
       |  327|    headers: [String: String]? = nil,
       |  328|    destination: Request.DownloadFileDestination)
       |  329|    -> Request
      0|  330|{
      0|  331|    return Manager.sharedInstance.download(
      0|  332|        method,
      0|  333|        URLString,
      0|  334|        parameters: parameters,
      0|  335|        encoding: encoding,
      0|  336|        headers: headers,
      0|  337|        destination: destination
      0|  338|    )
      0|  339|}
       |  340|
       |  341|/**
       |  342|    Creates a download request using the shared manager instance for the specified URL request.
       |  343|
       |  344|    - parameter URLRequest:  The URL request.
       |  345|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  346|
       |  347|    - returns: The created download request.
       |  348|*/
      0|  349|public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  350|    return Manager.sharedInstance.download(URLRequest, destination: destination)
      0|  351|}
       |  352|
       |  353|// MARK: Resume Data
       |  354|
       |  355|/**
       |  356|    Creates a request using the shared manager instance for downloading from the resume data produced from a 
       |  357|    previous request cancellation.
       |  358|
       |  359|    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
       |  360|                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
       |  361|                             information.
       |  362|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  363|
       |  364|    - returns: The created download request.
       |  365|*/
      0|  366|public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  367|    return Manager.sharedInstance.download(data, destination: destination)
      0|  368|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Download.swift:
       |    1|// Download.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Downloadable {
       |   27|        case Request(NSURLRequest)
       |   28|        case ResumeData(NSData)
       |   29|    }
       |   30|
      0|   31|    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
      0|   32|        var downloadTask: NSURLSessionDownloadTask!
      0|   33|
      0|   34|        switch downloadable {
      0|   35|        case .Request(let request):
      0|   36|            dispatch_sync(queue) {
      0|   37|                downloadTask = self.session.downloadTaskWithRequest(request)
      0|   38|            }
      0|   39|        case .ResumeData(let resumeData):
      0|   40|            dispatch_sync(queue) {
      0|   41|                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
      0|   42|            }
      0|   43|        }
      0|   44|
      0|   45|        let request = Request(session: session, task: downloadTask)
      0|   46|
      0|   47|        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
      0|   48|            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
      0|   49|                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
      0|   50|            }
      0|   51|        }
      0|   52|
      0|   53|        delegate[request.delegate.task] = request.delegate
      0|   54|
      0|   55|        if startRequestsImmediately {
      0|   56|            request.resume()
      0|   57|        }
      0|   58|
      0|   59|        return request
      0|   60|    }
       |   61|
       |   62|    // MARK: Request
       |   63|
       |   64|    /**
       |   65|        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
       |   66|        and destination.
       |   67|
       |   68|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   69|
       |   70|        - parameter method:      The HTTP method.
       |   71|        - parameter URLString:   The URL string.
       |   72|        - parameter parameters:  The parameters. `nil` by default.
       |   73|        - parameter encoding:    The parameter encoding. `.URL` by default.
       |   74|        - parameter headers:     The HTTP headers. `nil` by default.
       |   75|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |   76|
       |   77|        - returns: The created download request.
       |   78|    */
       |   79|    public func download(
       |   80|        method: Method,
       |   81|        _ URLString: URLStringConvertible,
       |   82|        parameters: [String: AnyObject]? = nil,
       |   83|        encoding: ParameterEncoding = .URL,
       |   84|        headers: [String: String]? = nil,
       |   85|        destination: Request.DownloadFileDestination)
       |   86|        -> Request
      0|   87|    {
      0|   88|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|   89|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      0|   90|
      0|   91|        return download(encodedURLRequest, destination: destination)
      0|   92|    }
       |   93|
       |   94|    /**
       |   95|        Creates a request for downloading from the specified URL request.
       |   96|
       |   97|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   98|
       |   99|        - parameter URLRequest:  The URL request
       |  100|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  101|
       |  102|        - returns: The created download request.
       |  103|    */
      0|  104|    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  105|        return download(.Request(URLRequest.URLRequest), destination: destination)
      0|  106|    }
       |  107|
       |  108|    // MARK: Resume Data
       |  109|
       |  110|    /**
       |  111|        Creates a request for downloading from the resume data produced from a previous request cancellation.
       |  112|
       |  113|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  114|
       |  115|        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
       |  116|                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
       |  117|                                 additional information.
       |  118|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  119|
       |  120|        - returns: The created download request.
       |  121|    */
      0|  122|    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  123|        return download(.ResumeData(resumeData), destination: destination)
      0|  124|    }
       |  125|}
       |  126|
       |  127|// MARK: -
       |  128|
       |  129|extension Request {
       |  130|    /**
       |  131|        A closure executed once a request has successfully completed in order to determine where to move the temporary 
       |  132|        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
       |  133|        response, and returns a single argument: the file URL where the temporary file should be moved.
       |  134|    */
       |  135|    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
       |  136|
       |  137|    /**
       |  138|        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
       |  139|        file URL in the first available directory with the specified search path directory and search path domain mask.
       |  140|
       |  141|        - parameter directory: The search path directory. `.DocumentDirectory` by default.
       |  142|        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
       |  143|
       |  144|        - returns: A download file destination closure.
       |  145|    */
       |  146|    public class func suggestedDownloadDestination(
       |  147|        directory directory: NSSearchPathDirectory = .DocumentDirectory,
       |  148|        domain: NSSearchPathDomainMask = .UserDomainMask)
       |  149|        -> DownloadFileDestination
      0|  150|    {
      0|  151|        return { temporaryURL, response -> NSURL in
      0|  152|            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
      0|  153|
      0|  154|            if !directoryURLs.isEmpty {
      0|  155|                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
      0|  156|            }
      0|  157|
      0|  158|            return temporaryURL
      0|  159|        }
      0|  160|    }
       |  161|
       |  162|    /// The resume data of the underlying download task if available after a failure.
      0|  163|    public var resumeData: NSData? {
      0|  164|        var data: NSData?
      0|  165|
      0|  166|        if let delegate = delegate as? DownloadTaskDelegate {
      0|  167|            data = delegate.resumeData
      0|  168|        }
      0|  169|
      0|  170|        return data
      0|  171|    }
       |  172|
       |  173|    // MARK: - DownloadTaskDelegate
       |  174|
       |  175|    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
      0|  176|        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
       |  177|        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
       |  178|
       |  179|        var resumeData: NSData?
      0|  180|        override var data: NSData? { return resumeData }
       |  181|
       |  182|        // MARK: - NSURLSessionDownloadDelegate
       |  183|
       |  184|        // MARK: Override Closures
       |  185|
       |  186|        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
       |  187|        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  188|        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  189|
       |  190|        // MARK: Delegate Methods
       |  191|
       |  192|        func URLSession(
       |  193|            session: NSURLSession,
       |  194|            downloadTask: NSURLSessionDownloadTask,
       |  195|            didFinishDownloadingToURL location: NSURL)
      0|  196|        {
      0|  197|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  198|                do {
      0|  199|                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  200|                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
      0|  201|                } catch {
      0|  202|                    self.error = error as NSError
      0|  203|                }
      0|  204|            }
      0|  205|        }
       |  206|
       |  207|        func URLSession(
       |  208|            session: NSURLSession,
       |  209|            downloadTask: NSURLSessionDownloadTask,
       |  210|            didWriteData bytesWritten: Int64,
       |  211|            totalBytesWritten: Int64,
       |  212|            totalBytesExpectedToWrite: Int64)
      0|  213|        {
      0|  214|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  215|                downloadTaskDidWriteData(
      0|  216|                    session,
      0|  217|                    downloadTask,
      0|  218|                    bytesWritten,
      0|  219|                    totalBytesWritten, 
      0|  220|                    totalBytesExpectedToWrite
      0|  221|                )
      0|  222|            } else {
      0|  223|                progress.totalUnitCount = totalBytesExpectedToWrite
      0|  224|                progress.completedUnitCount = totalBytesWritten
      0|  225|
      0|  226|                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  227|            }
      0|  228|        }
       |  229|
       |  230|        func URLSession(
       |  231|            session: NSURLSession,
       |  232|            downloadTask: NSURLSessionDownloadTask,
       |  233|            didResumeAtOffset fileOffset: Int64,
       |  234|            expectedTotalBytes: Int64)
      0|  235|        {
      0|  236|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  237|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  238|            } else {
      0|  239|                progress.totalUnitCount = expectedTotalBytes
      0|  240|                progress.completedUnitCount = fileOffset
      0|  241|            }
      0|  242|        }
       |  243|    }
       |  244|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Error.swift:
       |    1|// Error.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
       |   26|public struct Error {
       |   27|    /// The domain used for creating all Alamofire errors.
       |   28|    public static let Domain = "com.alamofire.error"
       |   29|
       |   30|    /// The custom error codes generated by Alamofire.
       |   31|    public enum Code: Int {
       |   32|        case InputStreamReadFailed           = -6000
       |   33|        case OutputStreamWriteFailed         = -6001
       |   34|        case ContentTypeValidationFailed     = -6002
       |   35|        case StatusCodeValidationFailed      = -6003
       |   36|        case DataSerializationFailed         = -6004
       |   37|        case StringSerializationFailed       = -6005
       |   38|        case JSONSerializationFailed         = -6006
       |   39|        case PropertyListSerializationFailed = -6007
       |   40|    }
       |   41|
       |   42|    /**
       |   43|        Creates an `NSError` with the given error code and failure reason.
       |   44|
       |   45|        - parameter code:          The error code.
       |   46|        - parameter failureReason: The failure reason.
       |   47|
       |   48|        - returns: An `NSError` with the given error code and failure reason.
       |   49|    */
      0|   50|    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
      0|   51|        return errorWithCode(code.rawValue, failureReason: failureReason)
      0|   52|    }
       |   53|
       |   54|    /**
       |   55|        Creates an `NSError` with the given error code and failure reason.
       |   56|
       |   57|        - parameter code:          The error code.
       |   58|        - parameter failureReason: The failure reason.
       |   59|
       |   60|        - returns: An `NSError` with the given error code and failure reason.
       |   61|    */
      0|   62|    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
      0|   63|        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
      0|   64|        return NSError(domain: Domain, code: code, userInfo: userInfo)
      0|   65|    }
       |   66|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Manager.swift:
       |    1|// Manager.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
       |   27|*/
       |   28|public class Manager {
       |   29|
       |   30|    // MARK: - Properties
       |   31|
       |   32|    /**
       |   33|        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
       |   34|        for any ad hoc requests.
       |   35|    */
       |   36|    public static let sharedInstance: Manager = {
       |   37|        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
       |   38|        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
       |   39|
       |   40|        return Manager(configuration: configuration)
       |   41|    }()
       |   42|
       |   43|    /**
       |   44|        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
       |   45|    */
       |   46|    public static let defaultHTTPHeaders: [String: String] = {
       |   47|        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
       |   48|        let acceptEncoding: String = "gzip;q=1.0,compress;q=0.5"
       |   49|
       |   50|        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
       |   51|        let acceptLanguage: String = {
       |   52|            var components: [String] = []
       |   53|            for (index, languageCode) in (NSLocale.preferredLanguages() as [String]).enumerate() {
       |   54|                let q = 1.0 - (Double(index) * 0.1)
       |   55|                components.append("\(languageCode);q=\(q)")
       |   56|                if q <= 0.5 {
       |   57|                    break
       |   58|                }
       |   59|            }
       |   60|
       |   61|            return components.joinWithSeparator(",")
       |   62|        }()
       |   63|
       |   64|        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
       |   65|        let userAgent: String = {
       |   66|            if let info = NSBundle.mainBundle().infoDictionary {
       |   67|                let executable: AnyObject = info[kCFBundleExecutableKey as String] ?? "Unknown"
       |   68|                let bundle: AnyObject = info[kCFBundleIdentifierKey as String] ?? "Unknown"
       |   69|                let version: AnyObject = info[kCFBundleVersionKey as String] ?? "Unknown"
       |   70|                let os: AnyObject = NSProcessInfo.processInfo().operatingSystemVersionString ?? "Unknown"
       |   71|
       |   72|                var mutableUserAgent = NSMutableString(string: "\(executable)/\(bundle) (\(version); OS \(os))") as CFMutableString
       |   73|                let transform = NSString(string: "Any-Latin; Latin-ASCII; [:^ASCII:] Remove") as CFString
       |   74|
       |   75|                if CFStringTransform(mutableUserAgent, UnsafeMutablePointer<CFRange>(nil), transform, false) {
       |   76|                    return mutableUserAgent as String
       |   77|                }
       |   78|            }
       |   79|
       |   80|            return "Alamofire"
       |   81|        }()
       |   82|
       |   83|        return [
       |   84|            "Accept-Encoding": acceptEncoding,
       |   85|            "Accept-Language": acceptLanguage,
       |   86|            "User-Agent": userAgent
       |   87|        ]
       |   88|    }()
       |   89|
       |   90|    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
       |   91|
       |   92|    /// The underlying session.
       |   93|    public let session: NSURLSession
       |   94|
       |   95|    /// The session delegate handling all the task and session delegate callbacks.
       |   96|    public let delegate: SessionDelegate
       |   97|
       |   98|    /// Whether to start requests immediately after being constructed. `true` by default.
       |   99|    public var startRequestsImmediately: Bool = true
       |  100|
       |  101|    /**
       |  102|        The background completion handler closure provided by the UIApplicationDelegate 
       |  103|        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
       |  104|        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
       |  105|        will automatically call the handler.
       |  106|    
       |  107|        If you need to handle your own events before the handler is called, then you need to override the 
       |  108|        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
       |  109|    
       |  110|        `nil` by default.
       |  111|    */
       |  112|    public var backgroundCompletionHandler: (() -> Void)?
       |  113|
       |  114|    // MARK: - Lifecycle
       |  115|
       |  116|    /**
       |  117|        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
       |  118|
       |  119|        - parameter configuration:            The configuration used to construct the managed session. 
       |  120|                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
       |  121|        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
       |  122|                                              default.
       |  123|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
       |  124|                                              challenges. `nil` by default.
       |  125|
       |  126|        - returns: The new `Manager` instance.
       |  127|    */
       |  128|    public init(
       |  129|        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
       |  130|        delegate: SessionDelegate = SessionDelegate(),
       |  131|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      1|  132|    {
      1|  133|        self.delegate = delegate
      1|  134|        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
      1|  135|
      1|  136|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      1|  137|    }
       |  138|
       |  139|    /**
       |  140|        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
       |  141|
       |  142|        - parameter session:                  The URL session.
       |  143|        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
       |  144|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
       |  145|                                              challenges. `nil` by default.
       |  146|
       |  147|        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
       |  148|    */
       |  149|    public init?(
       |  150|        session: NSURLSession,
       |  151|        delegate: SessionDelegate,
       |  152|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      0|  153|    {
      0|  154|        self.delegate = delegate
      0|  155|        self.session = session
      0|  156|
      0|  157|        guard delegate === session.delegate else { return nil }
      0|  158|
      0|  159|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      0|  160|    }
       |  161|
      1|  162|    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
      1|  163|        session.serverTrustPolicyManager = serverTrustPolicyManager
      1|  164|
      0|  165|        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
      0|  166|            guard let strongSelf = self else { return }
      0|  167|            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
      0|  168|        }
      1|  169|    }
       |  170|
      0|  171|    deinit {
      0|  172|        session.invalidateAndCancel()
      0|  173|    }
       |  174|
       |  175|    // MARK: - Request
       |  176|
       |  177|    /**
       |  178|        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
       |  179|
       |  180|        - parameter method:     The HTTP method.
       |  181|        - parameter URLString:  The URL string.
       |  182|        - parameter parameters: The parameters. `nil` by default.
       |  183|        - parameter encoding:   The parameter encoding. `.URL` by default.
       |  184|        - parameter headers:    The HTTP headers. `nil` by default.
       |  185|
       |  186|        - returns: The created request.
       |  187|    */
       |  188|    public func request(
       |  189|        method: Method,
       |  190|        _ URLString: URLStringConvertible,
       |  191|        parameters: [String: AnyObject]? = nil,
       |  192|        encoding: ParameterEncoding = .URL,
       |  193|        headers: [String: String]? = nil)
       |  194|        -> Request
      1|  195|    {
      1|  196|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      1|  197|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      1|  198|        return request(encodedURLRequest)
      1|  199|    }
       |  200|
       |  201|    /**
       |  202|        Creates a request for the specified URL request.
       |  203|
       |  204|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  205|
       |  206|        - parameter URLRequest: The URL request
       |  207|
       |  208|        - returns: The created request.
       |  209|    */
      1|  210|    public func request(URLRequest: URLRequestConvertible) -> Request {
      1|  211|        var dataTask: NSURLSessionDataTask!
      1|  212|        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
      1|  213|
      1|  214|        let request = Request(session: session, task: dataTask)
      1|  215|        delegate[request.delegate.task] = request.delegate
      1|  216|
      1|  217|        if startRequestsImmediately {
      1|  218|            request.resume()
      1|  219|        }
      1|  220|
      1|  221|        return request
      1|  222|    }
       |  223|
       |  224|    // MARK: - SessionDelegate
       |  225|
       |  226|    /**
       |  227|        Responsible for handling all delegate callbacks for the underlying session.
       |  228|    */
       |  229|    public final class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
       |  230|        private var subdelegates: [Int: Request.TaskDelegate] = [:]
       |  231|        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
       |  232|
       |  233|        subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
      4|  234|            get {
      4|  235|                var subdelegate: Request.TaskDelegate?
      4|  236|                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
      4|  237|
      4|  238|                return subdelegate
      4|  239|            }
       |  240|
      2|  241|            set {
      2|  242|                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
      2|  243|            }
       |  244|        }
       |  245|
       |  246|        /**
       |  247|            Initializes the `SessionDelegate` instance.
       |  248|
       |  249|            - returns: The new `SessionDelegate` instance.
       |  250|        */
      1|  251|        public override init() {
      1|  252|            super.init()
      1|  253|        }
       |  254|
       |  255|        // MARK: - NSURLSessionDelegate
       |  256|
       |  257|        // MARK: Override Closures
       |  258|
       |  259|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
       |  260|        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
       |  261|
       |  262|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
       |  263|        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  264|
       |  265|        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
       |  266|        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
       |  267|
       |  268|        // MARK: Delegate Methods
       |  269|
       |  270|        /**
       |  271|            Tells the delegate that the session has been invalidated.
       |  272|
       |  273|            - parameter session: The session object that was invalidated.
       |  274|            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
       |  275|        */
      0|  276|        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
      0|  277|            sessionDidBecomeInvalidWithError?(session, error)
      0|  278|        }
       |  279|
       |  280|        /**
       |  281|            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
       |  282|
       |  283|            - parameter session:           The session containing the task that requested authentication.
       |  284|            - parameter challenge:         An object that contains the request for authentication.
       |  285|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  286|        */
       |  287|        public func URLSession(
       |  288|            session: NSURLSession,
       |  289|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  290|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      0|  291|        {
      0|  292|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      0|  293|            var credential: NSURLCredential?
      0|  294|
      0|  295|            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
      0|  296|                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
      0|  297|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      0|  298|                let host = challenge.protectionSpace.host
      0|  299|
      0|  300|                if let
      0|  301|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      0|  302|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  303|                {
      0|  304|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  305|                        disposition = .UseCredential
      0|  306|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  307|                    } else {
      0|  308|                        disposition = .CancelAuthenticationChallenge
      0|  309|                    }
      0|  310|                }
      0|  311|            }
      0|  312|
      0|  313|            completionHandler(disposition, credential)
      0|  314|        }
       |  315|
       |  316|        /**
       |  317|            Tells the delegate that all messages enqueued for a session have been delivered.
       |  318|
       |  319|            - parameter session: The session that no longer has any outstanding requests.
       |  320|        */
      0|  321|        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
      0|  322|            sessionDidFinishEventsForBackgroundURLSession?(session)
      0|  323|        }
       |  324|
       |  325|        // MARK: - NSURLSessionTaskDelegate
       |  326|
       |  327|        // MARK: Override Closures
       |  328|
       |  329|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
       |  330|        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  331|
       |  332|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
       |  333|        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  334|
       |  335|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
       |  336|        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream!)?
       |  337|
       |  338|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
       |  339|        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  340|
       |  341|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
       |  342|        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  343|
       |  344|        // MARK: Delegate Methods
       |  345|
       |  346|        /**
       |  347|            Tells the delegate that the remote server requested an HTTP redirect.
       |  348|
       |  349|            - parameter session:           The session containing the task whose request resulted in a redirect.
       |  350|            - parameter task:              The task whose request resulted in a redirect.
       |  351|            - parameter response:          An object containing the server’s response to the original request.
       |  352|            - parameter request:           A URL request object filled out with the new location.
       |  353|            - parameter completionHandler: A closure that your handler should call with either the value of the request 
       |  354|                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
       |  355|                                           return the body of the redirect response.
       |  356|        */
       |  357|        public func URLSession(
       |  358|            session: NSURLSession,
       |  359|            task: NSURLSessionTask,
       |  360|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  361|            newRequest request: NSURLRequest,
       |  362|            completionHandler: ((NSURLRequest?) -> Void))
      0|  363|        {
      0|  364|            var redirectRequest: NSURLRequest? = request
      0|  365|
      0|  366|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  367|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  368|            }
      0|  369|
      0|  370|            completionHandler(redirectRequest)
      0|  371|        }
       |  372|
       |  373|        /**
       |  374|            Requests credentials from the delegate in response to an authentication request from the remote server.
       |  375|
       |  376|            - parameter session:           The session containing the task whose request requires authentication.
       |  377|            - parameter task:              The task whose request requires authentication.
       |  378|            - parameter challenge:         An object that contains the request for authentication.
       |  379|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  380|        */
       |  381|        public func URLSession(
       |  382|            session: NSURLSession,
       |  383|            task: NSURLSessionTask,
       |  384|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  385|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  386|        {
      0|  387|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  388|                completionHandler(taskDidReceiveChallenge(session, task, challenge))
      1|  389|            } else if let delegate = self[task] {
      1|  390|                delegate.URLSession(
      1|  391|                    session,
      1|  392|                    task: task,
      1|  393|                    didReceiveChallenge: challenge,
      1|  394|                    completionHandler: completionHandler
      1|  395|                )
      0|  396|            } else {
      0|  397|                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
      0|  398|            }
      1|  399|        }
       |  400|
       |  401|        /**
       |  402|            Tells the delegate when a task requires a new request body stream to send to the remote server.
       |  403|
       |  404|            - parameter session:           The session containing the task that needs a new body stream.
       |  405|            - parameter task:              The task that needs a new body stream.
       |  406|            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
       |  407|        */
       |  408|        public func URLSession(
       |  409|            session: NSURLSession,
       |  410|            task: NSURLSessionTask,
       |  411|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  412|        {
      0|  413|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  414|                completionHandler(taskNeedNewBodyStream(session, task))
      0|  415|            } else if let delegate = self[task] {
      0|  416|                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
      0|  417|            }
      0|  418|        }
       |  419|
       |  420|        /**
       |  421|            Periodically informs the delegate of the progress of sending body content to the server.
       |  422|
       |  423|            - parameter session:                  The session containing the data task.
       |  424|            - parameter task:                     The data task.
       |  425|            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
       |  426|            - parameter totalBytesSent:           The total number of bytes sent so far.
       |  427|            - parameter totalBytesExpectedToSend: The expected length of the body data.
       |  428|        */
       |  429|        public func URLSession(
       |  430|            session: NSURLSession,
       |  431|            task: NSURLSessionTask,
       |  432|            didSendBodyData bytesSent: Int64,
       |  433|            totalBytesSent: Int64,
       |  434|            totalBytesExpectedToSend: Int64)
      1|  435|        {
      0|  436|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  437|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  438|            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
      0|  439|                delegate.URLSession(
      0|  440|                    session,
      0|  441|                    task: task,
      0|  442|                    didSendBodyData: bytesSent,
      0|  443|                    totalBytesSent: totalBytesSent,
      0|  444|                    totalBytesExpectedToSend: totalBytesExpectedToSend
      0|  445|                )
      0|  446|            }
      1|  447|        }
       |  448|
       |  449|        /**
       |  450|            Tells the delegate that the task finished transferring data.
       |  451|
       |  452|            - parameter session: The session containing the task whose request finished transferring data.
       |  453|            - parameter task:    The task whose request finished transferring data.
       |  454|            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
       |  455|        */
      1|  456|        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  457|            if let taskDidComplete = taskDidComplete {
      0|  458|                taskDidComplete(session, task, error)
      1|  459|            } else if let delegate = self[task] {
      1|  460|                delegate.URLSession(session, task: task, didCompleteWithError: error)
      1|  461|            }
      1|  462|
      1|  463|            self[task] = nil
      1|  464|        }
       |  465|
       |  466|        // MARK: - NSURLSessionDataDelegate
       |  467|
       |  468|        // MARK: Override Closures
       |  469|
       |  470|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
       |  471|        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  472|
       |  473|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
       |  474|        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  475|
       |  476|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
       |  477|        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  478|
       |  479|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
       |  480|        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse!)?
       |  481|
       |  482|        // MARK: Delegate Methods
       |  483|
       |  484|        /**
       |  485|            Tells the delegate that the data task received the initial reply (headers) from the server.
       |  486|
       |  487|            - parameter session:           The session containing the data task that received an initial reply.
       |  488|            - parameter dataTask:          The data task that received an initial reply.
       |  489|            - parameter response:          A URL response object populated with headers.
       |  490|            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
       |  491|                                           constant to indicate whether the transfer should continue as a data task or 
       |  492|                                           should become a download task.
       |  493|        */
       |  494|        public func URLSession(
       |  495|            session: NSURLSession,
       |  496|            dataTask: NSURLSessionDataTask,
       |  497|            didReceiveResponse response: NSURLResponse,
       |  498|            completionHandler: ((NSURLSessionResponseDisposition) -> Void))
      0|  499|        {
      0|  500|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  501|
      0|  502|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  503|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  504|            }
      0|  505|
      0|  506|            completionHandler(disposition)
      0|  507|        }
       |  508|
       |  509|        /**
       |  510|            Tells the delegate that the data task was changed to a download task.
       |  511|
       |  512|            - parameter session:      The session containing the task that was replaced by a download task.
       |  513|            - parameter dataTask:     The data task that was replaced by a download task.
       |  514|            - parameter downloadTask: The new download task that replaced the data task.
       |  515|        */
       |  516|        public func URLSession(
       |  517|            session: NSURLSession,
       |  518|            dataTask: NSURLSessionDataTask,
       |  519|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  520|        {
      0|  521|            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
      0|  522|                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
      0|  523|            } else {
      0|  524|                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
      0|  525|                self[downloadTask] = downloadDelegate
      0|  526|            }
      0|  527|        }
       |  528|
       |  529|        /**
       |  530|            Tells the delegate that the data task has received some of the expected data.
       |  531|
       |  532|            - parameter session:  The session containing the data task that provided data.
       |  533|            - parameter dataTask: The data task that provided data.
       |  534|            - parameter data:     A data object containing the transferred data.
       |  535|        */
      1|  536|        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  537|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  538|                dataTaskDidReceiveData(session, dataTask, data)
      1|  539|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      1|  540|                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
      1|  541|            }
      1|  542|        }
       |  543|
       |  544|        /**
       |  545|            Asks the delegate whether the data (or upload) task should store the response in the cache.
       |  546|
       |  547|            - parameter session:           The session containing the data (or upload) task.
       |  548|            - parameter dataTask:          The data (or upload) task.
       |  549|            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
       |  550|                                           caching policy and the values of certain received headers, such as the Pragma 
       |  551|                                           and Cache-Control headers.
       |  552|            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
       |  553|                                           response, a modified version of that response, or NULL to prevent caching the 
       |  554|                                           response. If your delegate implements this method, it must call this completion 
       |  555|                                           handler; otherwise, your app leaks memory.
       |  556|        */
       |  557|        public func URLSession(
       |  558|            session: NSURLSession,
       |  559|            dataTask: NSURLSessionDataTask,
       |  560|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  561|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  562|        {
      0|  563|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  564|                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
      0|  565|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      0|  566|                delegate.URLSession(
      0|  567|                    session,
      0|  568|                    dataTask: dataTask,
      0|  569|                    willCacheResponse: proposedResponse,
      0|  570|                    completionHandler: completionHandler
      0|  571|                )
      0|  572|            } else {
      0|  573|                completionHandler(proposedResponse)
      0|  574|            }
      0|  575|        }
       |  576|
       |  577|        // MARK: - NSURLSessionDownloadDelegate
       |  578|
       |  579|        // MARK: Override Closures
       |  580|
       |  581|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
       |  582|        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
       |  583|
       |  584|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
       |  585|        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  586|
       |  587|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
       |  588|        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  589|
       |  590|        // MARK: Delegate Methods
       |  591|
       |  592|        /**
       |  593|            Tells the delegate that a download task has finished downloading.
       |  594|
       |  595|            - parameter session:      The session containing the download task that finished.
       |  596|            - parameter downloadTask: The download task that finished.
       |  597|            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
       |  598|                                      open the file for reading or move it to a permanent location in your app’s sandbox 
       |  599|                                      container directory before returning from this delegate method.
       |  600|        */
       |  601|        public func URLSession(
       |  602|            session: NSURLSession,
       |  603|            downloadTask: NSURLSessionDownloadTask,
       |  604|            didFinishDownloadingToURL location: NSURL)
      0|  605|        {
      0|  606|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  607|                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  608|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  609|                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
      0|  610|            }
      0|  611|        }
       |  612|
       |  613|        /**
       |  614|            Periodically informs the delegate about the download’s progress.
       |  615|
       |  616|            - parameter session:                   The session containing the download task.
       |  617|            - parameter downloadTask:              The download task.
       |  618|            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
       |  619|                                                   method was called.
       |  620|            - parameter totalBytesWritten:         The total number of bytes transferred so far.
       |  621|            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
       |  622|                                                   header. If this header was not provided, the value is 
       |  623|                                                   `NSURLSessionTransferSizeUnknown`.
       |  624|        */
       |  625|        public func URLSession(
       |  626|            session: NSURLSession,
       |  627|            downloadTask: NSURLSessionDownloadTask,
       |  628|            didWriteData bytesWritten: Int64,
       |  629|            totalBytesWritten: Int64,
       |  630|            totalBytesExpectedToWrite: Int64)
      0|  631|        {
      0|  632|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  633|                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  634|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  635|                delegate.URLSession(
      0|  636|                    session,
      0|  637|                    downloadTask: downloadTask,
      0|  638|                    didWriteData: bytesWritten,
      0|  639|                    totalBytesWritten: totalBytesWritten,
      0|  640|                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
      0|  641|                )
      0|  642|            }
      0|  643|        }
       |  644|
       |  645|        /**
       |  646|            Tells the delegate that the download task has resumed downloading.
       |  647|
       |  648|            - parameter session:            The session containing the download task that finished.
       |  649|            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
       |  650|            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
       |  651|                                            existing content, then this value is zero. Otherwise, this value is an 
       |  652|                                            integer representing the number of bytes on disk that do not need to be 
       |  653|                                            retrieved again.
       |  654|            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
       |  655|                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
       |  656|        */
       |  657|        public func URLSession(
       |  658|            session: NSURLSession,
       |  659|            downloadTask: NSURLSessionDownloadTask,
       |  660|            didResumeAtOffset fileOffset: Int64,
       |  661|            expectedTotalBytes: Int64)
      0|  662|        {
      0|  663|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  664|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  665|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  666|                delegate.URLSession(
      0|  667|                    session,
      0|  668|                    downloadTask: downloadTask,
      0|  669|                    didResumeAtOffset: fileOffset,
      0|  670|                    expectedTotalBytes: expectedTotalBytes
      0|  671|                )
      0|  672|            }
      0|  673|        }
       |  674|
       |  675|        // MARK: - NSURLSessionStreamDelegate
       |  676|
       |  677|        var _streamTaskReadClosed: Any?
       |  678|        var _streamTaskWriteClosed: Any?
       |  679|        var _streamTaskBetterRouteDiscovered: Any?
       |  680|        var _streamTaskDidBecomeInputStream: Any?
       |  681|
       |  682|        // MARK: - NSObject
       |  683|
     11|  684|        public override func respondsToSelector(selector: Selector) -> Bool {
     11|  685|            switch selector {
      0|  686|            case "URLSession:didBecomeInvalidWithError:":
      0|  687|                return sessionDidBecomeInvalidWithError != nil
      1|  688|            case "URLSession:didReceiveChallenge:completionHandler:":
      1|  689|                return sessionDidReceiveChallenge != nil
      0|  690|            case "URLSessionDidFinishEventsForBackgroundURLSession:":
      0|  691|                return sessionDidFinishEventsForBackgroundURLSession != nil
      0|  692|            case "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:":
      0|  693|                return taskWillPerformHTTPRedirection != nil
      1|  694|            case "URLSession:dataTask:didReceiveResponse:completionHandler:":
      1|  695|                return dataTaskDidReceiveResponse != nil
      9|  696|            default:
      9|  697|                return self.dynamicType.instancesRespondToSelector(selector)
     11|  698|            }
     11|  699|        }
       |  700|    }
       |  701|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/MultipartFormData.swift:
       |    1|// MultipartFormData.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if os(iOS) || os(watchOS) || os(tvOS)
       |   26|import MobileCoreServices
       |   27|#elseif os(OSX)
       |   28|import CoreServices
       |   29|#endif
       |   30|
       |   31|/**
       |   32|    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
       |   33|    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
       |   34|    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
       |   35|    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
       |   36|    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
       |   37|
       |   38|    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
       |   39|    and the w3 form documentation.
       |   40|
       |   41|    - https://www.ietf.org/rfc/rfc2388.txt
       |   42|    - https://www.ietf.org/rfc/rfc2045.txt
       |   43|    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
       |   44|*/
       |   45|public class MultipartFormData {
       |   46|
       |   47|    // MARK: - Helper Types
       |   48|
       |   49|    struct EncodingCharacters {
       |   50|        static let CRLF = "\r\n"
       |   51|    }
       |   52|
       |   53|    struct BoundaryGenerator {
       |   54|        enum BoundaryType {
       |   55|            case Initial, Encapsulated, Final
       |   56|        }
       |   57|
      0|   58|        static func randomBoundary() -> String {
      0|   59|            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
      0|   60|        }
       |   61|
      0|   62|        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
      0|   63|            let boundaryText: String
      0|   64|
      0|   65|            switch boundaryType {
      0|   66|            case .Initial:
      0|   67|                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
      0|   68|            case .Encapsulated:
      0|   69|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
      0|   70|            case .Final:
      0|   71|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
      0|   72|            }
      0|   73|
      0|   74|            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|   75|        }
       |   76|    }
       |   77|
       |   78|    class BodyPart {
       |   79|        let headers: [String: String]
       |   80|        let bodyStream: NSInputStream
       |   81|        let bodyContentLength: UInt64
       |   82|        var hasInitialBoundary = false
       |   83|        var hasFinalBoundary = false
       |   84|
      0|   85|        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
      0|   86|            self.headers = headers
      0|   87|            self.bodyStream = bodyStream
      0|   88|            self.bodyContentLength = bodyContentLength
      0|   89|        }
       |   90|    }
       |   91|
       |   92|    // MARK: - Properties
       |   93|
       |   94|    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
      0|   95|    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
       |   96|
       |   97|    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
      0|   98|    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
       |   99|
       |  100|    /// The boundary used to separate the body parts in the encoded form data.
       |  101|    public let boundary: String
       |  102|
       |  103|    private var bodyParts: [BodyPart]
       |  104|    private var bodyPartError: NSError?
       |  105|    private let streamBufferSize: Int
       |  106|
       |  107|    // MARK: - Lifecycle
       |  108|
       |  109|    /**
       |  110|        Creates a multipart form data object.
       |  111|
       |  112|        - returns: The multipart form data object.
       |  113|    */
      0|  114|    public init() {
      0|  115|        self.boundary = BoundaryGenerator.randomBoundary()
      0|  116|        self.bodyParts = []
      0|  117|
      0|  118|        /**
      0|  119|         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
      0|  120|         *  information, please refer to the following article:
      0|  121|         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
      0|  122|         */
      0|  123|
      0|  124|        self.streamBufferSize = 1024
      0|  125|    }
       |  126|
       |  127|    // MARK: - Body Parts
       |  128|
       |  129|    /**
       |  130|        Creates a body part from the data and appends it to the multipart form data object.
       |  131|
       |  132|        The body part data will be encoded using the following format:
       |  133|
       |  134|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  135|        - Encoded data
       |  136|        - Multipart form boundary
       |  137|
       |  138|        - parameter data: The data to encode into the multipart form data.
       |  139|        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
       |  140|    */
      0|  141|    public func appendBodyPart(data data: NSData, name: String) {
      0|  142|        let headers = contentHeaders(name: name)
      0|  143|        let stream = NSInputStream(data: data)
      0|  144|        let length = UInt64(data.length)
      0|  145|
      0|  146|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  147|    }
       |  148|
       |  149|    /**
       |  150|        Creates a body part from the data and appends it to the multipart form data object.
       |  151|
       |  152|        The body part data will be encoded using the following format:
       |  153|
       |  154|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  155|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  156|        - Encoded data
       |  157|        - Multipart form boundary
       |  158|
       |  159|        - parameter data:     The data to encode into the multipart form data.
       |  160|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  161|        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
       |  162|    */
      0|  163|    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
      0|  164|        let headers = contentHeaders(name: name, mimeType: mimeType)
      0|  165|        let stream = NSInputStream(data: data)
      0|  166|        let length = UInt64(data.length)
      0|  167|
      0|  168|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  169|    }
       |  170|
       |  171|    /**
       |  172|        Creates a body part from the data and appends it to the multipart form data object.
       |  173|
       |  174|        The body part data will be encoded using the following format:
       |  175|
       |  176|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  177|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  178|        - Encoded file data
       |  179|        - Multipart form boundary
       |  180|
       |  181|        - parameter data:     The data to encode into the multipart form data.
       |  182|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  183|        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
       |  184|        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
       |  185|    */
      0|  186|    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
      0|  187|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  188|        let stream = NSInputStream(data: data)
      0|  189|        let length = UInt64(data.length)
      0|  190|
      0|  191|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Creates a body part from the file and appends it to the multipart form data object.
       |  196|
       |  197|        The body part data will be encoded using the following format:
       |  198|
       |  199|        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
       |  200|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  201|        - Encoded file data
       |  202|        - Multipart form boundary
       |  203|
       |  204|        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
       |  205|        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
       |  206|        system associated MIME type.
       |  207|
       |  208|        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
       |  209|        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  210|    */
      0|  211|    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
      0|  212|        if let
      0|  213|            fileName = fileURL.lastPathComponent,
      0|  214|            pathExtension = fileURL.pathExtension
      0|  215|        {
      0|  216|            let mimeType = mimeTypeForPathExtension(pathExtension)
      0|  217|            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
      0|  218|        } else {
      0|  219|            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
      0|  220|            setBodyPartError(Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason))
      0|  221|        }
      0|  222|    }
       |  223|
       |  224|    /**
       |  225|        Creates a body part from the file and appends it to the multipart form data object.
       |  226|
       |  227|        The body part data will be encoded using the following format:
       |  228|
       |  229|        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
       |  230|        - Content-Type: #{mimeType} (HTTP Header)
       |  231|        - Encoded file data
       |  232|        - Multipart form boundary
       |  233|
       |  234|        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
       |  235|        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  236|        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
       |  237|        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
       |  238|    */
      0|  239|    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
      0|  240|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  241|
      0|  242|        //============================================================
      0|  243|        //                 Check 1 - is file URL?
      0|  244|        //============================================================
      0|  245|
      0|  246|        guard fileURL.fileURL else {
      0|  247|            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
      0|  248|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  249|            setBodyPartError(error)
      0|  250|            return
      0|  251|        }
      0|  252|
      0|  253|        //============================================================
      0|  254|        //              Check 2 - is file URL reachable?
      0|  255|        //============================================================
      0|  256|
      0|  257|        var isReachable = true
      0|  258|
      0|  259|        if #available(OSX 10.10, *) {
      0|  260|            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
      0|  261|        }
      0|  262|
      0|  263|        guard isReachable else {
      0|  264|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
      0|  265|            setBodyPartError(error)
      0|  266|            return
      0|  267|        }
      0|  268|
      0|  269|        //============================================================
      0|  270|        //            Check 3 - is file URL a directory?
      0|  271|        //============================================================
      0|  272|
      0|  273|        var isDirectory: ObjCBool = false
      0|  274|
      0|  275|        guard let
      0|  276|            path = fileURL.path
      0|  277|            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
      0|  278|        {
      0|  279|            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
      0|  280|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  281|            setBodyPartError(error)
      0|  282|            return
      0|  283|        }
      0|  284|
      0|  285|        //============================================================
      0|  286|        //          Check 4 - can the file size be extracted?
      0|  287|        //============================================================
      0|  288|
      0|  289|        var bodyContentLength: UInt64?
      0|  290|
      0|  291|        do {
      0|  292|            if let
      0|  293|                path = fileURL.path,
      0|  294|                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
      0|  295|            {
      0|  296|                bodyContentLength = fileSize.unsignedLongLongValue
      0|  297|            }
      0|  298|        } catch {
      0|  299|            // No-op
      0|  300|        }
      0|  301|
      0|  302|        guard let length = bodyContentLength else {
      0|  303|            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
      0|  304|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  305|            setBodyPartError(error)
      0|  306|            return
      0|  307|        }
      0|  308|
      0|  309|        //============================================================
      0|  310|        //       Check 5 - can a stream be created from file URL?
      0|  311|        //============================================================
      0|  312|
      0|  313|        guard let stream = NSInputStream(URL: fileURL) else {
      0|  314|            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
      0|  315|            let error = Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  316|            setBodyPartError(error)
      0|  317|            return
      0|  318|        }
      0|  319|
      0|  320|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  321|    }
       |  322|
       |  323|    /**
       |  324|        Creates a body part from the stream and appends it to the multipart form data object.
       |  325|
       |  326|        The body part data will be encoded using the following format:
       |  327|
       |  328|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  329|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  330|        - Encoded stream data
       |  331|        - Multipart form boundary
       |  332|
       |  333|        - parameter stream:   The input stream to encode in the multipart form data.
       |  334|        - parameter length:   The content length of the stream.
       |  335|        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
       |  336|        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
       |  337|        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
       |  338|    */
       |  339|    public func appendBodyPart(
       |  340|        stream stream: NSInputStream,
       |  341|        length: UInt64,
       |  342|        name: String,
       |  343|        fileName: String,
       |  344|        mimeType: String)
      0|  345|    {
      0|  346|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  347|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  348|    }
       |  349|
       |  350|    /**
       |  351|        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
       |  352|
       |  353|        The body part data will be encoded using the following format:
       |  354|
       |  355|        - HTTP headers
       |  356|        - Encoded stream data
       |  357|        - Multipart form boundary
       |  358|
       |  359|        - parameter stream:  The input stream to encode in the multipart form data.
       |  360|        - parameter length:  The content length of the stream.
       |  361|        - parameter headers: The HTTP headers for the body part.
       |  362|    */
      0|  363|    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
      0|  364|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
      0|  365|        bodyParts.append(bodyPart)
      0|  366|    }
       |  367|
       |  368|    // MARK: - Data Encoding
       |  369|
       |  370|    /**
       |  371|        Encodes all the appended body parts into a single `NSData` object.
       |  372|
       |  373|        It is important to note that this method will load all the appended body parts into memory all at the same 
       |  374|        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
       |  375|        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
       |  376|
       |  377|        - throws: An `NSError` if encoding encounters an error.
       |  378|
       |  379|        - returns: The encoded `NSData` if encoding is successful.
       |  380|    */
      0|  381|    public func encode() throws -> NSData {
      0|  382|        if let bodyPartError = bodyPartError {
      0|  383|            throw bodyPartError
      0|  384|        }
      0|  385|
      0|  386|        let encoded = NSMutableData()
      0|  387|
      0|  388|        bodyParts.first?.hasInitialBoundary = true
      0|  389|        bodyParts.last?.hasFinalBoundary = true
      0|  390|
      0|  391|        for bodyPart in bodyParts {
      0|  392|            let encodedData = try encodeBodyPart(bodyPart)
      0|  393|            encoded.appendData(encodedData)
      0|  394|        }
      0|  395|
      0|  396|        return encoded
      0|  397|    }
       |  398|
       |  399|    /**
       |  400|        Writes the appended body parts into the given file URL.
       |  401|
       |  402|        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
       |  403|        this approach is very memory efficient and should be used for large body part data.
       |  404|
       |  405|        - parameter fileURL: The file URL to write the multipart form data into.
       |  406|
       |  407|        - throws: An `NSError` if encoding encounters an error.
       |  408|    */
      0|  409|    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
      0|  410|        if let bodyPartError = bodyPartError {
      0|  411|            throw bodyPartError
      0|  412|        }
      0|  413|
      0|  414|        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
      0|  415|            let failureReason = "A file already exists at the given file URL: \(fileURL)"
      0|  416|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  417|        } else if !fileURL.fileURL {
      0|  418|            let failureReason = "The URL does not point to a valid file: \(fileURL)"
      0|  419|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  420|        }
      0|  421|
      0|  422|        let outputStream: NSOutputStream
      0|  423|
      0|  424|        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
      0|  425|            outputStream = possibleOutputStream
      0|  426|        } else {
      0|  427|            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
      0|  428|            throw Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  429|        }
      0|  430|
      0|  431|        outputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  432|        outputStream.open()
      0|  433|
      0|  434|        self.bodyParts.first?.hasInitialBoundary = true
      0|  435|        self.bodyParts.last?.hasFinalBoundary = true
      0|  436|
      0|  437|        for bodyPart in self.bodyParts {
      0|  438|            try writeBodyPart(bodyPart, toOutputStream: outputStream)
      0|  439|        }
      0|  440|
      0|  441|        outputStream.close()
      0|  442|        outputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  443|    }
       |  444|
       |  445|    // MARK: - Private - Body Part Encoding
       |  446|
      0|  447|    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  448|        let encoded = NSMutableData()
      0|  449|
      0|  450|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  451|        encoded.appendData(initialData)
      0|  452|
      0|  453|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  454|        encoded.appendData(headerData)
      0|  455|
      0|  456|        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
      0|  457|        encoded.appendData(bodyStreamData)
      0|  458|
      0|  459|        if bodyPart.hasFinalBoundary {
      0|  460|            encoded.appendData(finalBoundaryData())
      0|  461|        }
      0|  462|
      0|  463|        return encoded
      0|  464|    }
       |  465|
      0|  466|    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
      0|  467|        var headerText = ""
      0|  468|
      0|  469|        for (key, value) in bodyPart.headers {
      0|  470|            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
      0|  471|        }
      0|  472|        headerText += EncodingCharacters.CRLF
      0|  473|
      0|  474|        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|  475|    }
       |  476|
      0|  477|    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  478|        let inputStream = bodyPart.bodyStream
      0|  479|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  480|        inputStream.open()
      0|  481|
      0|  482|        var error: NSError?
      0|  483|        let encoded = NSMutableData()
      0|  484|
      0|  485|        while inputStream.hasBytesAvailable {
      0|  486|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  487|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  488|
      0|  489|            if inputStream.streamError != nil {
      0|  490|                error = inputStream.streamError
      0|  491|                break
      0|  492|            }
      0|  493|
      0|  494|            if bytesRead > 0 {
      0|  495|                encoded.appendBytes(buffer, length: bytesRead)
      0|  496|            } else if bytesRead < 0 {
      0|  497|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  498|                error = Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  499|                break
      0|  500|            } else {
      0|  501|                break
      0|  502|            }
      0|  503|        }
      0|  504|
      0|  505|        inputStream.close()
      0|  506|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  507|
      0|  508|        if let error = error {
      0|  509|            throw error
      0|  510|        }
      0|  511|
      0|  512|        return encoded
      0|  513|    }
       |  514|
       |  515|    // MARK: - Private - Writing Body Part to Output Stream
       |  516|
      0|  517|    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  518|        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  519|        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  520|        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  521|        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  522|    }
       |  523|
       |  524|    private func writeInitialBoundaryDataForBodyPart(
       |  525|        bodyPart: BodyPart,
       |  526|        toOutputStream outputStream: NSOutputStream)
       |  527|        throws
      0|  528|    {
      0|  529|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  530|        return try writeData(initialData, toOutputStream: outputStream)
      0|  531|    }
       |  532|
      0|  533|    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  534|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  535|        return try writeData(headerData, toOutputStream: outputStream)
      0|  536|    }
       |  537|
      0|  538|    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  539|        let inputStream = bodyPart.bodyStream
      0|  540|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  541|        inputStream.open()
      0|  542|
      0|  543|        while inputStream.hasBytesAvailable {
      0|  544|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  545|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  546|
      0|  547|            if let streamError = inputStream.streamError {
      0|  548|                throw streamError
      0|  549|            }
      0|  550|
      0|  551|            if bytesRead > 0 {
      0|  552|                if buffer.count != bytesRead {
      0|  553|                    buffer = Array(buffer[0..<bytesRead])
      0|  554|                }
      0|  555|
      0|  556|                try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  557|            } else if bytesRead < 0 {
      0|  558|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  559|                throw Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  560|            } else {
      0|  561|                break
      0|  562|            }
      0|  563|        }
      0|  564|
      0|  565|        inputStream.close()
      0|  566|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  567|    }
       |  568|
       |  569|    private func writeFinalBoundaryDataForBodyPart(
       |  570|        bodyPart: BodyPart,
       |  571|        toOutputStream outputStream: NSOutputStream)
       |  572|        throws
      0|  573|    {
      0|  574|        if bodyPart.hasFinalBoundary {
      0|  575|            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
      0|  576|        }
      0|  577|    }
       |  578|
       |  579|    // MARK: - Private - Writing Buffered Data to Output Stream
       |  580|
      0|  581|    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
      0|  582|        var buffer = [UInt8](count: data.length, repeatedValue: 0)
      0|  583|        data.getBytes(&buffer, length: data.length)
      0|  584|
      0|  585|        return try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  586|    }
       |  587|
      0|  588|    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
      0|  589|        var bytesToWrite = buffer.count
      0|  590|
      0|  591|        while bytesToWrite > 0 {
      0|  592|            if outputStream.hasSpaceAvailable {
      0|  593|                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
      0|  594|
      0|  595|                if let streamError = outputStream.streamError {
      0|  596|                    throw streamError
      0|  597|                }
      0|  598|
      0|  599|                if bytesWritten < 0 {
      0|  600|                    let failureReason = "Failed to write to output stream: \(outputStream)"
      0|  601|                    throw Error.errorWithCode(.OutputStreamWriteFailed, failureReason: failureReason)
      0|  602|                }
      0|  603|
      0|  604|                bytesToWrite -= bytesWritten
      0|  605|
      0|  606|                if bytesToWrite > 0 {
      0|  607|                    buffer = Array(buffer[bytesWritten..<buffer.count])
      0|  608|                }
      0|  609|            } else if let streamError = outputStream.streamError {
      0|  610|                throw streamError
      0|  611|            }
      0|  612|        }
      0|  613|    }
       |  614|
       |  615|    // MARK: - Private - Mime Type
       |  616|
      0|  617|    private func mimeTypeForPathExtension(pathExtension: String) -> String {
      0|  618|        if let
      0|  619|            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
      0|  620|            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
      0|  621|        {
      0|  622|            return contentType as String
      0|  623|        }
      0|  624|
      0|  625|        return "application/octet-stream"
      0|  626|    }
       |  627|
       |  628|    // MARK: - Private - Content Headers
       |  629|
      0|  630|    private func contentHeaders(name name: String) -> [String: String] {
      0|  631|        return ["Content-Disposition": "form-data; name=\"\(name)\""]
      0|  632|    }
       |  633|
      0|  634|    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
      0|  635|        return [
      0|  636|            "Content-Disposition": "form-data; name=\"\(name)\"",
      0|  637|            "Content-Type": "\(mimeType)"
      0|  638|        ]
      0|  639|    }
       |  640|
      0|  641|    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
      0|  642|        return [
      0|  643|            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
      0|  644|            "Content-Type": "\(mimeType)"
      0|  645|        ]
      0|  646|    }
       |  647|
       |  648|    // MARK: - Private - Boundary Encoding
       |  649|
      0|  650|    private func initialBoundaryData() -> NSData {
      0|  651|        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
      0|  652|    }
       |  653|
      0|  654|    private func encapsulatedBoundaryData() -> NSData {
      0|  655|        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
      0|  656|    }
       |  657|
      0|  658|    private func finalBoundaryData() -> NSData {
      0|  659|        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
      0|  660|    }
       |  661|
       |  662|    // MARK: - Private - Errors
       |  663|
      0|  664|    private func setBodyPartError(error: NSError) {
      0|  665|        if bodyPartError == nil {
      0|  666|            bodyPartError = error
      0|  667|        }
      0|  668|    }
       |  669|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ParameterEncoding.swift:
       |    1|// ParameterEncoding.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    HTTP method definitions.
       |   27|
       |   28|    See https://tools.ietf.org/html/rfc7231#section-4.3
       |   29|*/
       |   30|public enum Method: String {
       |   31|    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
       |   32|}
       |   33|
       |   34|// MARK: ParameterEncoding
       |   35|
       |   36|/**
       |   37|    Used to specify the way in which a set of parameters are applied to a URL request.
       |   38|
       |   39|    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
       |   40|                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
       |   41|                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
       |   42|                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
       |   43|                         for how to encode collection types, the convention of appending `[]` to the key for array
       |   44|                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
       |   45|                         dictionary values (`foo[bar]=baz`).
       |   46|
       |   47|    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
       |   48|                         implementation as the `.URL` case, but always applies the encoded result to the URL.
       |   49|
       |   50|    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
       |   51|                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
       |   52|                         set to `application/json`.
       |   53|
       |   54|    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
       |   55|                         according to the associated format and write options values, which is set as the body of the
       |   56|                         request. The `Content-Type` HTTP header field of an encoded request is set to
       |   57|                         `application/x-plist`.
       |   58|
       |   59|    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
       |   60|                         parameters.
       |   61|*/
       |   62|public enum ParameterEncoding {
       |   63|    case URL
       |   64|    case URLEncodedInURL
       |   65|    case JSON
       |   66|    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
       |   67|    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
       |   68|
       |   69|    /**
       |   70|        Creates a URL request by encoding parameters and applying them onto an existing request.
       |   71|
       |   72|        - parameter URLRequest: The request to have parameters applied
       |   73|        - parameter parameters: The parameters to apply
       |   74|
       |   75|        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
       |   76|                   if any.
       |   77|    */
       |   78|    public func encode(
       |   79|        URLRequest: URLRequestConvertible,
       |   80|        parameters: [String: AnyObject]?)
       |   81|        -> (NSMutableURLRequest, NSError?)
      1|   82|    {
      1|   83|        var mutableURLRequest = URLRequest.URLRequest
      1|   84|
      0|   85|        guard let parameters = parameters where !parameters.isEmpty else {
      0|   86|            return (mutableURLRequest, nil)
      0|   87|        }
      1|   88|
      1|   89|        var encodingError: NSError? = nil
      1|   90|
      1|   91|        switch self {
      0|   92|        case .URL, .URLEncodedInURL:
      0|   93|            func query(parameters: [String: AnyObject]) -> String {
      0|   94|                var components: [(String, String)] = []
      0|   95|
      0|   96|                for key in parameters.keys.sort(<) {
      0|   97|                    let value = parameters[key]!
      0|   98|                    components += queryComponents(key, value)
      0|   99|                }
      0|  100|
      0|  101|                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
      0|  102|            }
      0|  103|
      0|  104|            func encodesParametersInURL(method: Method) -> Bool {
      0|  105|                switch self {
      0|  106|                case .URLEncodedInURL:
      0|  107|                    return true
      0|  108|                default:
      0|  109|                    break
      0|  110|                }
      0|  111|
      0|  112|                switch method {
      0|  113|                case .GET, .HEAD, .DELETE:
      0|  114|                    return true
      0|  115|                default:
      0|  116|                    return false
      0|  117|                }
      0|  118|            }
      0|  119|
      0|  120|            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
      0|  121|                if let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false) {
      0|  122|                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
      0|  123|                    URLComponents.percentEncodedQuery = percentEncodedQuery
      0|  124|                    mutableURLRequest.URL = URLComponents.URL
      0|  125|                }
      0|  126|            } else {
      0|  127|                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
      0|  128|                    mutableURLRequest.setValue(
      0|  129|                        "application/x-www-form-urlencoded; charset=utf-8",
      0|  130|                        forHTTPHeaderField: "Content-Type"
      0|  131|                    )
      0|  132|                }
      0|  133|
      0|  134|                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
      0|  135|                    NSUTF8StringEncoding,
      0|  136|                    allowLossyConversion: false
      0|  137|                )
      0|  138|            }
      1|  139|        case .JSON:
      1|  140|            do {
      1|  141|                let options = NSJSONWritingOptions()
      1|  142|                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
      1|  143|
      1|  144|                mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
      1|  145|                mutableURLRequest.HTTPBody = data
      0|  146|            } catch {
      0|  147|                encodingError = error as NSError
      0|  148|            }
      0|  149|        case .PropertyList(let format, let options):
      0|  150|            do {
      0|  151|                let data = try NSPropertyListSerialization.dataWithPropertyList(
      0|  152|                    parameters,
      0|  153|                    format: format,
      0|  154|                    options: options
      0|  155|                )
      0|  156|                mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
      0|  157|                mutableURLRequest.HTTPBody = data
      0|  158|            } catch {
      0|  159|                encodingError = error as NSError
      0|  160|            }
      0|  161|        case .Custom(let closure):
      0|  162|            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
      1|  163|        }
      1|  164|
      1|  165|        return (mutableURLRequest, encodingError)
      1|  166|    }
       |  167|
       |  168|    /**
       |  169|        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
       |  170|
       |  171|        - parameter key:   The key of the query component.
       |  172|        - parameter value: The value of the query component.
       |  173|
       |  174|        - returns: The percent-escaped, URL encoded query string components.
       |  175|    */
      0|  176|    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
      0|  177|        var components: [(String, String)] = []
      0|  178|
      0|  179|        if let dictionary = value as? [String: AnyObject] {
      0|  180|            for (nestedKey, value) in dictionary {
      0|  181|                components += queryComponents("\(key)[\(nestedKey)]", value)
      0|  182|            }
      0|  183|        } else if let array = value as? [AnyObject] {
      0|  184|            for value in array {
      0|  185|                components += queryComponents("\(key)[]", value)
      0|  186|            }
      0|  187|        } else {
      0|  188|            components.append((escape(key), escape("\(value)")))
      0|  189|        }
      0|  190|
      0|  191|        return components
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Returns a percent-escaped string following RFC 3986 for a query string key or value.
       |  196|
       |  197|        RFC 3986 states that the following characters are "reserved" characters.
       |  198|
       |  199|        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
       |  200|        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
       |  201|
       |  202|        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
       |  203|        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
       |  204|        should be percent-escaped in the query string.
       |  205|
       |  206|        - parameter string: The string to be percent-escaped.
       |  207|
       |  208|        - returns: The percent-escaped string.
       |  209|    */
      0|  210|    public func escape(string: String) -> String {
      0|  211|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
      0|  212|        let subDelimitersToEncode = "!$&'()*+,;="
      0|  213|
      0|  214|        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
      0|  215|        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
      0|  216|
      0|  217|        var escaped = ""
      0|  218|
      0|  219|        //==========================================================================================================
      0|  220|        //
      0|  221|        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
      0|  222|        //  hundred Chinense characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
      0|  223|        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
      0|  224|        //  info, please refer to:
      0|  225|        //
      0|  226|        //      - https://github.com/Alamofire/Alamofire/issues/206
      0|  227|        //
      0|  228|        //==========================================================================================================
      0|  229|
      0|  230|        if #available(iOS 8.3, OSX 10.10, *) {
      0|  231|            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
      0|  232|        } else {
      0|  233|            let batchSize = 50
      0|  234|            var index = string.startIndex
      0|  235|
      0|  236|            while index != string.endIndex {
      0|  237|                let startIndex = index
      0|  238|                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
      0|  239|                let range = Range(start: startIndex, end: endIndex)
      0|  240|
      0|  241|                let substring = string.substringWithRange(range)
      0|  242|
      0|  243|                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
      0|  244|
      0|  245|                index = endIndex
      0|  246|            }
      0|  247|        }
      0|  248|
      0|  249|        return escaped
      0|  250|    }
       |  251|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Request.swift:
       |    1|// Request.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for sending a request and receiving the response and associated data from the server, as well as 
       |   27|    managing its underlying `NSURLSessionTask`.
       |   28|*/
       |   29|public class Request {
       |   30|
       |   31|    // MARK: - Properties
       |   32|
       |   33|    /// The delegate for the underlying task.
       |   34|    public let delegate: TaskDelegate
       |   35|
       |   36|    /// The underlying task.
      5|   37|    public var task: NSURLSessionTask { return delegate.task }
       |   38|
       |   39|    /// The session belonging to the underlying task.
       |   40|    public let session: NSURLSession
       |   41|
       |   42|    /// The request sent or to be sent to the server.
      2|   43|    public var request: NSURLRequest? { return task.originalRequest }
       |   44|
       |   45|    /// The response received from the server, if any.
      2|   46|    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
       |   47|
       |   48|    /// The progress of the request lifecycle.
      0|   49|    public var progress: NSProgress { return delegate.progress }
       |   50|
       |   51|    // MARK: - Lifecycle
       |   52|
      1|   53|    init(session: NSURLSession, task: NSURLSessionTask) {
      1|   54|        self.session = session
      1|   55|
      1|   56|        switch task {
      0|   57|        case is NSURLSessionUploadTask:
      0|   58|            self.delegate = UploadTaskDelegate(task: task)
      1|   59|        case is NSURLSessionDataTask:
      1|   60|            self.delegate = DataTaskDelegate(task: task)
      0|   61|        case is NSURLSessionDownloadTask:
      0|   62|            self.delegate = DownloadTaskDelegate(task: task)
      0|   63|        default:
      0|   64|            self.delegate = TaskDelegate(task: task)
      1|   65|        }
      1|   66|    }
       |   67|
       |   68|    // MARK: - Authentication
       |   69|
       |   70|    /**
       |   71|        Associates an HTTP Basic credential with the request.
       |   72|
       |   73|        - parameter user:        The user.
       |   74|        - parameter password:    The password.
       |   75|        - parameter persistence: The URL credential persistence. `.ForSession` by default.
       |   76|
       |   77|        - returns: The request.
       |   78|    */
       |   79|    public func authenticate(
       |   80|        user user: String,
       |   81|        password: String,
       |   82|        persistence: NSURLCredentialPersistence = .ForSession)
       |   83|        -> Self
      0|   84|    {
      0|   85|        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
      0|   86|
      0|   87|        return authenticate(usingCredential: credential)
      0|   88|    }
       |   89|
       |   90|    /**
       |   91|        Associates a specified credential with the request.
       |   92|
       |   93|        - parameter credential: The credential.
       |   94|
       |   95|        - returns: The request.
       |   96|    */
      0|   97|    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
      0|   98|        delegate.credential = credential
      0|   99|
      0|  100|        return self
      0|  101|    }
       |  102|
       |  103|    // MARK: - Progress
       |  104|
       |  105|    /**
       |  106|        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
       |  107|        from the server.
       |  108|
       |  109|        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
       |  110|          to write.
       |  111|        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
       |  112|          expected to read.
       |  113|
       |  114|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  115|
       |  116|        - returns: The request.
       |  117|    */
      0|  118|    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
      0|  119|        if let uploadDelegate = delegate as? UploadTaskDelegate {
      0|  120|            uploadDelegate.uploadProgress = closure
      0|  121|        } else if let dataDelegate = delegate as? DataTaskDelegate {
      0|  122|            dataDelegate.dataProgress = closure
      0|  123|        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
      0|  124|            downloadDelegate.downloadProgress = closure
      0|  125|        }
      0|  126|
      0|  127|        return self
      0|  128|    }
       |  129|
       |  130|    /**
       |  131|        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
       |  132|
       |  133|        This closure returns the bytes most recently received from the server, not including data from previous calls. 
       |  134|        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
       |  135|        also important to note that the `response` closure will be called with nil `responseData`.
       |  136|
       |  137|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  138|
       |  139|        - returns: The request.
       |  140|    */
      0|  141|    public func stream(closure: (NSData -> Void)? = nil) -> Self {
      0|  142|        if let dataDelegate = delegate as? DataTaskDelegate {
      0|  143|            dataDelegate.dataStream = closure
      0|  144|        }
      0|  145|
      0|  146|        return self
      0|  147|    }
       |  148|
       |  149|    // MARK: - State
       |  150|
       |  151|    /**
       |  152|        Suspends the request.
       |  153|    */
      0|  154|    public func suspend() {
      0|  155|        task.suspend()
      0|  156|    }
       |  157|
       |  158|    /**
       |  159|        Resumes the request.
       |  160|    */
      1|  161|    public func resume() {
      1|  162|        task.resume()
      1|  163|    }
       |  164|
       |  165|    /**
       |  166|        Cancels the request.
       |  167|    */
      0|  168|    public func cancel() {
      0|  169|        if let
      0|  170|            downloadDelegate = delegate as? DownloadTaskDelegate,
      0|  171|            downloadTask = downloadDelegate.downloadTask
      0|  172|        {
      0|  173|            downloadTask.cancelByProducingResumeData { data in
      0|  174|                downloadDelegate.resumeData = data
      0|  175|            }
      0|  176|        } else {
      0|  177|            task.cancel()
      0|  178|        }
      0|  179|    }
       |  180|
       |  181|    // MARK: - TaskDelegate
       |  182|
       |  183|    /**
       |  184|        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
       |  185|        executing all operations attached to the serial operation queue upon task completion.
       |  186|    */
       |  187|    public class TaskDelegate: NSObject {
       |  188|
       |  189|        /// The serial operation queue used to execute all operations after the task completes.
       |  190|        public let queue: NSOperationQueue
       |  191|
       |  192|        let task: NSURLSessionTask
       |  193|        let progress: NSProgress
       |  194|
      0|  195|        var data: NSData? { return nil }
       |  196|        var error: NSError?
       |  197|
       |  198|        var credential: NSURLCredential?
       |  199|
      1|  200|        init(task: NSURLSessionTask) {
      1|  201|            self.task = task
      1|  202|            self.progress = NSProgress(totalUnitCount: 0)
      1|  203|            self.queue = {
      1|  204|                let operationQueue = NSOperationQueue()
      1|  205|                operationQueue.maxConcurrentOperationCount = 1
      1|  206|                operationQueue.suspended = true
      1|  207|
      1|  208|                if #available(OSX 10.10, *) {
      1|  209|                    operationQueue.qualityOfService = NSQualityOfService.Utility
      1|  210|                }
      1|  211|
      1|  212|                return operationQueue
      1|  213|            }()
      1|  214|        }
       |  215|
      0|  216|        deinit {
      0|  217|            queue.cancelAllOperations()
      0|  218|            queue.suspended = false
      0|  219|        }
       |  220|
       |  221|        // MARK: - NSURLSessionTaskDelegate
       |  222|
       |  223|        // MARK: Override Closures
       |  224|
       |  225|        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  226|        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  227|        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
       |  228|        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  229|
       |  230|        // MARK: Delegate Methods
       |  231|
       |  232|        func URLSession(
       |  233|            session: NSURLSession,
       |  234|            task: NSURLSessionTask,
       |  235|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  236|            newRequest request: NSURLRequest,
       |  237|            completionHandler: ((NSURLRequest?) -> Void))
      0|  238|        {
      0|  239|            var redirectRequest: NSURLRequest? = request
      0|  240|
      0|  241|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  242|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  243|            }
      0|  244|
      0|  245|            completionHandler(redirectRequest)
      0|  246|        }
       |  247|
       |  248|        func URLSession(
       |  249|            session: NSURLSession,
       |  250|            task: NSURLSessionTask,
       |  251|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  252|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  253|        {
      1|  254|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      1|  255|            var credential: NSURLCredential?
      1|  256|
      0|  257|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  258|                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
      1|  259|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      1|  260|                let host = challenge.protectionSpace.host
      1|  261|
      1|  262|                if let
      1|  263|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      1|  264|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  265|                {
      0|  266|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  267|                        disposition = .UseCredential
      0|  268|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  269|                    } else {
      0|  270|                        disposition = .CancelAuthenticationChallenge
      0|  271|                    }
      0|  272|                }
      0|  273|            } else {
      0|  274|                if challenge.previousFailureCount > 0 {
      0|  275|                    disposition = .CancelAuthenticationChallenge
      0|  276|                } else {
      0|  277|                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
      0|  278|
      0|  279|                    if credential != nil {
      0|  280|                        disposition = .UseCredential
      0|  281|                    }
      0|  282|                }
      0|  283|            }
      1|  284|
      1|  285|            completionHandler(disposition, credential)
      1|  286|        }
       |  287|
       |  288|        func URLSession(
       |  289|            session: NSURLSession,
       |  290|            task: NSURLSessionTask,
       |  291|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  292|        {
      0|  293|            var bodyStream: NSInputStream?
      0|  294|
      0|  295|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  296|                bodyStream = taskNeedNewBodyStream(session, task)
      0|  297|            }
      0|  298|
      0|  299|            completionHandler(bodyStream)
      0|  300|        }
       |  301|
      1|  302|        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  303|            if let taskDidCompleteWithError = taskDidCompleteWithError {
      0|  304|                taskDidCompleteWithError(session, task, error)
      1|  305|            } else {
      0|  306|                if let error = error {
      0|  307|                    self.error = error
      0|  308|
      0|  309|                    if let
      0|  310|                        downloadDelegate = self as? DownloadTaskDelegate,
      0|  311|                        userInfo = error.userInfo as? [String: AnyObject],
      0|  312|                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
      0|  313|                    {
      0|  314|                        downloadDelegate.resumeData = resumeData
      0|  315|                    }
      0|  316|                }
      1|  317|
      1|  318|                queue.suspended = false
      1|  319|            }
      1|  320|        }
       |  321|    }
       |  322|
       |  323|    // MARK: - DataTaskDelegate
       |  324|
       |  325|    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
      0|  326|        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
       |  327|
       |  328|        private var totalBytesReceived: Int64 = 0
       |  329|        private var mutableData: NSMutableData
      2|  330|        override var data: NSData? {
      0|  331|            if dataStream != nil {
      0|  332|                return nil
      2|  333|            } else {
      2|  334|                return mutableData
      2|  335|            }
      0|  336|        }
       |  337|
       |  338|        private var expectedContentLength: Int64?
       |  339|        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
       |  340|        private var dataStream: ((data: NSData) -> Void)?
       |  341|
      1|  342|        override init(task: NSURLSessionTask) {
      1|  343|            mutableData = NSMutableData()
      1|  344|            super.init(task: task)
      1|  345|        }
       |  346|
       |  347|        // MARK: - NSURLSessionDataDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  352|        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  353|        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  354|        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
       |  355|
       |  356|        // MARK: Delegate Methods
       |  357|
       |  358|        func URLSession(
       |  359|            session: NSURLSession,
       |  360|            dataTask: NSURLSessionDataTask,
       |  361|            didReceiveResponse response: NSURLResponse,
       |  362|            completionHandler: (NSURLSessionResponseDisposition -> Void))
      0|  363|        {
      0|  364|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  365|
      0|  366|            expectedContentLength = response.expectedContentLength
      0|  367|
      0|  368|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  369|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  370|            }
      0|  371|
      0|  372|            completionHandler(disposition)
      0|  373|        }
       |  374|
       |  375|        func URLSession(
       |  376|            session: NSURLSession,
       |  377|            dataTask: NSURLSessionDataTask,
       |  378|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  379|        {
      0|  380|            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
      0|  381|        }
       |  382|
      1|  383|        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  384|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  385|                dataTaskDidReceiveData(session, dataTask, data)
      1|  386|            } else {
      0|  387|                if let dataStream = dataStream {
      0|  388|                    dataStream(data: data)
      1|  389|                } else {
      1|  390|                    mutableData.appendData(data)
      1|  391|                }
      1|  392|
      1|  393|                totalBytesReceived += data.length
      0|  394|                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
      1|  395|
      1|  396|                progress.totalUnitCount = totalBytesExpected
      1|  397|                progress.completedUnitCount = totalBytesReceived
      1|  398|
      1|  399|                dataProgress?(
      1|  400|                    bytesReceived: Int64(data.length),
      1|  401|                    totalBytesReceived: totalBytesReceived,
      1|  402|                    totalBytesExpectedToReceive: totalBytesExpected
      1|  403|                )
      1|  404|            }
      1|  405|        }
       |  406|
       |  407|        func URLSession(
       |  408|            session: NSURLSession,
       |  409|            dataTask: NSURLSessionDataTask,
       |  410|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  411|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  412|        {
      0|  413|            var cachedResponse: NSCachedURLResponse? = proposedResponse
      0|  414|
      0|  415|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  416|                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
      0|  417|            }
      0|  418|
      0|  419|            completionHandler(cachedResponse)
      0|  420|        }
       |  421|    }
       |  422|}
       |  423|
       |  424|// MARK: - CustomStringConvertible
       |  425|
       |  426|extension Request: CustomStringConvertible {
       |  427|
       |  428|    /**
       |  429|        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
       |  430|        well as the response status code if a response has been received.
       |  431|    */
      0|  432|    public var description: String {
      0|  433|        var components: [String] = []
      0|  434|
      0|  435|        if let HTTPMethod = request?.HTTPMethod {
      0|  436|            components.append(HTTPMethod)
      0|  437|        }
      0|  438|
      0|  439|        if let URLString = request?.URL?.absoluteString {
      0|  440|            components.append(URLString)
      0|  441|        }
      0|  442|
      0|  443|        if let response = response {
      0|  444|            components.append("(\(response.statusCode))")
      0|  445|        }
      0|  446|
      0|  447|        return components.joinWithSeparator(" ")
      0|  448|    }
       |  449|}
       |  450|
       |  451|// MARK: - CustomDebugStringConvertible
       |  452|
       |  453|extension Request: CustomDebugStringConvertible {
      0|  454|    func cURLRepresentation() -> String {
      0|  455|        var components = ["$ curl -i"]
      0|  456|
      0|  457|        guard let request = self.request else {
      0|  458|            return "$ curl command could not be created"
      0|  459|        }
      0|  460|
      0|  461|        let URL = request.URL
      0|  462|
      0|  463|        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
      0|  464|            components.append("-X \(HTTPMethod)")
      0|  465|        }
      0|  466|
      0|  467|        if let credentialStorage = self.session.configuration.URLCredentialStorage {
      0|  468|            let protectionSpace = NSURLProtectionSpace(
      0|  469|                host: URL!.host!,
      0|  470|                port: URL!.port?.integerValue ?? 0,
      0|  471|                `protocol`: URL!.scheme,
      0|  472|                realm: URL!.host!,
      0|  473|                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
      0|  474|            )
      0|  475|
      0|  476|            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
      0|  477|                for credential in credentials {
      0|  478|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  479|                }
      0|  480|            } else {
      0|  481|                if let credential = delegate.credential {
      0|  482|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  483|                }
      0|  484|            }
      0|  485|        }
      0|  486|
      0|  487|        if session.configuration.HTTPShouldSetCookies {
      0|  488|            if let
      0|  489|                cookieStorage = session.configuration.HTTPCookieStorage,
      0|  490|                cookies = cookieStorage.cookiesForURL(URL!) where !cookies.isEmpty
      0|  491|            {
      0|  492|                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
      0|  493|                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
      0|  494|            }
      0|  495|        }
      0|  496|
      0|  497|        if let headerFields = request.allHTTPHeaderFields {
      0|  498|            for (field, value) in headerFields {
      0|  499|                switch field {
      0|  500|                case "Cookie":
      0|  501|                    continue
      0|  502|                default:
      0|  503|                    components.append("-H \"\(field): \(value)\"")
      0|  504|                }
      0|  505|            }
      0|  506|        }
      0|  507|
      0|  508|        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
      0|  509|            for (field, value) in additionalHeaders {
      0|  510|                switch field {
      0|  511|                case "Cookie":
      0|  512|                    continue
      0|  513|                default:
      0|  514|                    components.append("-H \"\(field): \(value)\"")
      0|  515|                }
      0|  516|            }
      0|  517|        }
      0|  518|
      0|  519|        if let
      0|  520|            HTTPBodyData = request.HTTPBody,
      0|  521|            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
      0|  522|        {
      0|  523|            let escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
      0|  524|            components.append("-d \"\(escapedBody)\"")
      0|  525|        }
      0|  526|
      0|  527|        components.append("\"\(URL!.absoluteString)\"")
      0|  528|
      0|  529|        return components.joinWithSeparator(" \\\n\t")
      0|  530|    }
       |  531|
       |  532|    /// The textual representation used when written to an output stream, in the form of a cURL command.
      0|  533|    public var debugDescription: String {
      0|  534|        return cURLRepresentation()
      0|  535|    }
       |  536|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Response.swift:
       |    1|// Response.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Used to store all response data returned from a completed `Request`.
       |   26|public struct Response<Value, Error: ErrorType> {
       |   27|    /// The URL request sent to the server.
       |   28|    public let request: NSURLRequest?
       |   29|
       |   30|    /// The server's response to the URL request.
       |   31|    public let response: NSHTTPURLResponse?
       |   32|
       |   33|    /// The data returned by the server.
       |   34|    public let data: NSData?
       |   35|
       |   36|    /// The result of response serialization.
       |   37|    public let result: Result<Value, Error>
       |   38|
       |   39|    /**
       |   40|        Initializes the `Response` instance with the specified URL request, URL response, server data and response
       |   41|        serialization result.
       |   42|    
       |   43|        - parameter request:  The URL request sent to the server.
       |   44|        - parameter response: The server's response to the URL request.
       |   45|        - parameter data:     The data returned by the server.
       |   46|        - parameter result:   The result of response serialization.
       |   47|    
       |   48|        - returns: the new `Response` instance.
       |   49|    */
      1|   50|    public init(request: NSURLRequest?, response: NSHTTPURLResponse?, data: NSData?, result: Result<Value, Error>) {
      1|   51|        self.request = request
      1|   52|        self.response = response
      1|   53|        self.data = data
      1|   54|        self.result = result
      1|   55|    }
       |   56|}
       |   57|
       |   58|// MARK: - CustomStringConvertible
       |   59|
       |   60|extension Response: CustomStringConvertible {
       |   61|    /// The textual representation used when written to an output stream, which includes whether the result was a
       |   62|    /// success or failure.
      0|   63|    public var description: String {
      0|   64|        return result.debugDescription
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - CustomDebugStringConvertible
       |   69|
       |   70|extension Response: CustomDebugStringConvertible {
       |   71|    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
       |   72|    /// response, the server data and the response serialization result.
      0|   73|    public var debugDescription: String {
      0|   74|        var output: [String] = []
      0|   75|
      0|   76|        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
      0|   77|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
      0|   78|        output.append("[Data]: \(data?.length ?? 0) bytes")
      0|   79|        output.append("[Result]: \(result.debugDescription)")
      0|   80|
      0|   81|        return output.joinWithSeparator("\n")
      0|   82|    }
       |   83|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ResponseSerialization.swift:
       |    1|// ResponseSerialization.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: ResponseSerializer
       |   26|
       |   27|/**
       |   28|    The type in which all response serializers must conform to in order to serialize a response.
       |   29|*/
       |   30|public protocol ResponseSerializerType {
       |   31|    /// The type of serialized object to be created by this `ResponseSerializerType`.
       |   32|    typealias SerializedObject
       |   33|
       |   34|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   35|    typealias ErrorObject: ErrorType
       |   36|
       |   37|    /**
       |   38|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   39|    */
       |   40|    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
       |   41|}
       |   42|
       |   43|// MARK: -
       |   44|
       |   45|/**
       |   46|    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
       |   47|*/
       |   48|public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
       |   49|    /// The type of serialized object to be created by this `ResponseSerializer`.
       |   50|    public typealias SerializedObject = Value
       |   51|
       |   52|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   53|    public typealias ErrorObject = Error
       |   54|
       |   55|    /**
       |   56|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   57|    */
       |   58|    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
       |   59|
       |   60|    /**
       |   61|        Initializes the `ResponseSerializer` instance with the given serialize response closure.
       |   62|
       |   63|        - parameter serializeResponse: The closure used to serialize the response.
       |   64|
       |   65|        - returns: The new generic response serializer instance.
       |   66|    */
      1|   67|    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
      1|   68|        self.serializeResponse = serializeResponse
      1|   69|    }
       |   70|}
       |   71|
       |   72|// MARK: - Default
       |   73|
       |   74|extension Request {
       |   75|
       |   76|    /**
       |   77|        Adds a handler to be called once the request has finished.
       |   78|
       |   79|        - parameter queue:             The queue on which the completion handler is dispatched.
       |   80|        - parameter completionHandler: The code to be executed once the request has finished.
       |   81|
       |   82|        - returns: The request.
       |   83|    */
       |   84|    public func response(
       |   85|        queue queue: dispatch_queue_t? = nil,
       |   86|        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
       |   87|        -> Self
      0|   88|    {
      0|   89|        delegate.queue.addOperationWithBlock {
      0|   90|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      0|   91|                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
      0|   92|            }
      0|   93|        }
      0|   94|
      0|   95|        return self
      0|   96|    }
       |   97|
       |   98|    /**
       |   99|        Adds a handler to be called once the request has finished.
       |  100|
       |  101|        - parameter queue:              The queue on which the completion handler is dispatched.
       |  102|        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
       |  103|                                        and data.
       |  104|        - parameter completionHandler:  The code to be executed once the request has finished.
       |  105|
       |  106|        - returns: The request.
       |  107|    */
       |  108|    public func response<T: ResponseSerializerType>(
       |  109|        queue queue: dispatch_queue_t? = nil,
       |  110|        responseSerializer: T,
       |  111|        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
       |  112|        -> Self
      1|  113|    {
      1|  114|        delegate.queue.addOperationWithBlock {
      1|  115|            let result = responseSerializer.serializeResponse(
      1|  116|                self.request,
      1|  117|                self.response,
      1|  118|                self.delegate.data,
      1|  119|                self.delegate.error
      1|  120|            )
      1|  121|
      1|  122|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      1|  123|                let response = Response<T.SerializedObject, T.ErrorObject>(
      1|  124|                    request: self.request,
      1|  125|                    response: self.response,
      1|  126|                    data: self.delegate.data,
      1|  127|                    result: result
      1|  128|                )
      1|  129|
      1|  130|                completionHandler(response)
      1|  131|            }
      1|  132|        }
      1|  133|
      1|  134|        return self
      1|  135|    }
       |  136|}
       |  137|
       |  138|// MARK: - Data
       |  139|
       |  140|extension Request {
       |  141|
       |  142|    /**
       |  143|        Creates a response serializer that returns the associated data as-is.
       |  144|
       |  145|        - returns: A data response serializer.
       |  146|    */
      0|  147|    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
      0|  148|        return ResponseSerializer { _, response, data, error in
      0|  149|            guard error == nil else { return .Failure(error!) }
      0|  150|
      0|  151|            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
      0|  152|
      0|  153|            guard let validData = data else {
      0|  154|                let failureReason = "Data could not be serialized. Input data was nil."
      0|  155|                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
      0|  156|                return .Failure(error)
      0|  157|            }
      0|  158|
      0|  159|            return .Success(validData)
      0|  160|        }
      0|  161|    }
       |  162|
       |  163|    /**
       |  164|        Adds a handler to be called once the request has finished.
       |  165|
       |  166|        - parameter completionHandler: The code to be executed once the request has finished.
       |  167|
       |  168|        - returns: The request.
       |  169|    */
      0|  170|    public func responseData(completionHandler: Response<NSData, NSError> -> Void) -> Self {
      0|  171|        return response(responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
      0|  172|    }
       |  173|}
       |  174|
       |  175|// MARK: - String
       |  176|
       |  177|extension Request {
       |  178|
       |  179|    /**
       |  180|        Creates a response serializer that returns a string initialized from the response data with the specified 
       |  181|        string encoding.
       |  182|
       |  183|        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
       |  184|                              response, falling back to the default HTTP default character set, ISO-8859-1.
       |  185|
       |  186|        - returns: A string response serializer.
       |  187|    */
       |  188|    public static func stringResponseSerializer(
       |  189|        var encoding encoding: NSStringEncoding? = nil)
       |  190|        -> ResponseSerializer<String, NSError>
      0|  191|    {
      0|  192|        return ResponseSerializer { _, response, data, error in
      0|  193|            guard error == nil else { return .Failure(error!) }
      0|  194|
      0|  195|            if let response = response where response.statusCode == 204 { return .Success("") }
      0|  196|
      0|  197|            guard let validData = data else {
      0|  198|                let failureReason = "String could not be serialized. Input data was nil."
      0|  199|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  200|                return .Failure(error)
      0|  201|            }
      0|  202|
      0|  203|            if let encodingName = response?.textEncodingName where encoding == nil {
      0|  204|                encoding = CFStringConvertEncodingToNSStringEncoding(
      0|  205|                    CFStringConvertIANACharSetNameToEncoding(encodingName)
      0|  206|                )
      0|  207|            }
      0|  208|
      0|  209|            let actualEncoding = encoding ?? NSISOLatin1StringEncoding
      0|  210|
      0|  211|            if let string = String(data: validData, encoding: actualEncoding) {
      0|  212|                return .Success(string)
      0|  213|            } else {
      0|  214|                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
      0|  215|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  216|                return .Failure(error)
      0|  217|            }
      0|  218|        }
      0|  219|    }
       |  220|
       |  221|    /**
       |  222|        Adds a handler to be called once the request has finished.
       |  223|
       |  224|        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
       |  225|                                       server response, falling back to the default HTTP default character set, 
       |  226|                                       ISO-8859-1.
       |  227|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  228|
       |  229|        - returns: The request.
       |  230|    */
       |  231|    public func responseString(
       |  232|        encoding encoding: NSStringEncoding? = nil,
       |  233|        completionHandler: Response<String, NSError> -> Void)
       |  234|        -> Self
      0|  235|    {
      0|  236|        return response(
      0|  237|            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
      0|  238|            completionHandler: completionHandler
      0|  239|        )
      0|  240|    }
       |  241|}
       |  242|
       |  243|// MARK: - JSON
       |  244|
       |  245|extension Request {
       |  246|
       |  247|    /**
       |  248|        Creates a response serializer that returns a JSON object constructed from the response data using 
       |  249|        `NSJSONSerialization` with the specified reading options.
       |  250|
       |  251|        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
       |  252|
       |  253|        - returns: A JSON object response serializer.
       |  254|    */
       |  255|    public static func JSONResponseSerializer(
       |  256|        options options: NSJSONReadingOptions = .AllowFragments)
       |  257|        -> ResponseSerializer<AnyObject, NSError>
      1|  258|    {
      1|  259|        return ResponseSerializer { _, response, data, error in
      0|  260|            guard error == nil else { return .Failure(error!) }
      1|  261|
      0|  262|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      1|  263|
      0|  264|            guard let validData = data where validData.length > 0 else {
      0|  265|                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
      0|  266|                let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
      0|  267|                return .Failure(error)
      0|  268|            }
      1|  269|
      1|  270|            do {
      1|  271|                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
      1|  272|                return .Success(JSON)
      1|  273|            } catch {
      1|  274|                return .Failure(error as NSError)
      1|  275|            }
      0|  276|        }
      1|  277|    }
       |  278|
       |  279|    /**
       |  280|        Adds a handler to be called once the request has finished.
       |  281|
       |  282|        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
       |  283|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  284|
       |  285|        - returns: The request.
       |  286|    */
       |  287|    public func responseJSON(
       |  288|        options options: NSJSONReadingOptions = .AllowFragments,
       |  289|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  290|        -> Self
      1|  291|    {
      1|  292|        return response(
      1|  293|            responseSerializer: Request.JSONResponseSerializer(options: options),
      1|  294|            completionHandler: completionHandler
      1|  295|        )
      1|  296|    }
       |  297|}
       |  298|
       |  299|// MARK: - Property List
       |  300|
       |  301|extension Request {
       |  302|
       |  303|    /**
       |  304|        Creates a response serializer that returns an object constructed from the response data using 
       |  305|        `NSPropertyListSerialization` with the specified reading options.
       |  306|
       |  307|        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
       |  308|
       |  309|        - returns: A property list object response serializer.
       |  310|    */
       |  311|    public static func propertyListResponseSerializer(
       |  312|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
       |  313|        -> ResponseSerializer<AnyObject, NSError>
      0|  314|    {
      0|  315|        return ResponseSerializer { _, response, data, error in
      0|  316|            guard error == nil else { return .Failure(error!) }
      0|  317|
      0|  318|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      0|  319|
      0|  320|            guard let validData = data where validData.length > 0 else {
      0|  321|                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
      0|  322|                let error = Error.errorWithCode(.PropertyListSerializationFailed, failureReason: failureReason)
      0|  323|                return .Failure(error)
      0|  324|            }
      0|  325|
      0|  326|            do {
      0|  327|                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
      0|  328|                return .Success(plist)
      0|  329|            } catch {
      0|  330|                return .Failure(error as NSError)
      0|  331|            }
      0|  332|        }
      0|  333|    }
       |  334|
       |  335|    /**
       |  336|        Adds a handler to be called once the request has finished.
       |  337|
       |  338|        - parameter options:           The property list reading options. `0` by default.
       |  339|        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
       |  340|                                       arguments: the URL request, the URL response, the server data and the result 
       |  341|                                       produced while creating the property list.
       |  342|
       |  343|        - returns: The request.
       |  344|    */
       |  345|    public func responsePropertyList(
       |  346|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
       |  347|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  348|        -> Self
      0|  349|    {
      0|  350|        return response(
      0|  351|            responseSerializer: Request.propertyListResponseSerializer(options: options),
      0|  352|            completionHandler: completionHandler
      0|  353|        )
      0|  354|    }
       |  355|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Result.swift:
       |    1|// Result.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Used to represent whether a request was successful or encountered an error.
       |   27|
       |   28|    - Success: The request and all post processing operations were successful resulting in the serialization of the 
       |   29|               provided associated value.
       |   30|    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
       |   31|               provided by the server as well as the error that caused the failure.
       |   32|*/
       |   33|public enum Result<Value, Error: ErrorType> {
       |   34|    case Success(Value)
       |   35|    case Failure(Error)
       |   36|
       |   37|    /// Returns `true` if the result is a success, `false` otherwise.
      0|   38|    public var isSuccess: Bool {
      0|   39|        switch self {
      0|   40|        case .Success:
      0|   41|            return true
      0|   42|        case .Failure:
      0|   43|            return false
      0|   44|        }
      0|   45|    }
       |   46|
       |   47|    /// Returns `true` if the result is a failure, `false` otherwise.
      0|   48|    public var isFailure: Bool {
      0|   49|        return !isSuccess
      0|   50|    }
       |   51|
       |   52|    /// Returns the associated value if the result is a success, `nil` otherwise.
      0|   53|    public var value: Value? {
      0|   54|        switch self {
      0|   55|        case .Success(let value):
      0|   56|            return value
      0|   57|        case .Failure:
      0|   58|            return nil
      0|   59|        }
      0|   60|    }
       |   61|
       |   62|    /// Returns the associated error value if the result is a failure, `nil` otherwise.
      0|   63|    public var error: Error? {
      0|   64|        switch self {
      0|   65|        case .Success:
      0|   66|            return nil
      0|   67|        case .Failure(let error):
      0|   68|            return error
      0|   69|        }
      0|   70|    }
       |   71|}
       |   72|
       |   73|// MARK: - CustomStringConvertible
       |   74|
       |   75|extension Result: CustomStringConvertible {
       |   76|    /// The textual representation used when written to an output stream, which includes whether the result was a 
       |   77|    /// success or failure.
      0|   78|    public var description: String {
      0|   79|        switch self {
      0|   80|        case .Success:
      0|   81|            return "SUCCESS"
      0|   82|        case .Failure:
      0|   83|            return "FAILURE"
      0|   84|        }
      0|   85|    }
       |   86|}
       |   87|
       |   88|// MARK: - CustomDebugStringConvertible
       |   89|
       |   90|extension Result: CustomDebugStringConvertible {
       |   91|    /// The debug textual representation used when written to an output stream, which includes whether the result was a
       |   92|    /// success or failure in addition to the value or error.
      1|   93|    public var debugDescription: String {
      1|   94|        switch self {
      0|   95|        case .Success(let value):
      0|   96|            return "SUCCESS: \(value)"
      1|   97|        case .Failure(let error):
      1|   98|            return "FAILURE: \(error)"
      1|   99|        }
      1|  100|    }
       |  101|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ServerTrustPolicy.swift:
       |    1|// ServerTrustPolicy.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
       |   26|public class ServerTrustPolicyManager {
       |   27|    /// The dictionary of policies mapped to a particular host.
       |   28|    public let policies: [String: ServerTrustPolicy]
       |   29|
       |   30|    /**
       |   31|        Initializes the `ServerTrustPolicyManager` instance with the given policies.
       |   32|
       |   33|        Since different servers and web services can have different leaf certificates, intermediate and even root 
       |   34|        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
       |   35|        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
       |   36|        pinning for host3 and disabling evaluation for host4.
       |   37|
       |   38|        - parameter policies: A dictionary of all policies mapped to a particular host.
       |   39|
       |   40|        - returns: The new `ServerTrustPolicyManager` instance.
       |   41|    */
      0|   42|    public init(policies: [String: ServerTrustPolicy]) {
      0|   43|        self.policies = policies
      0|   44|    }
       |   45|
       |   46|    /**
       |   47|        Returns the `ServerTrustPolicy` for the given host if applicable.
       |   48|
       |   49|        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
       |   50|        this method and implement more complex mapping implementations such as wildcards.
       |   51|
       |   52|        - parameter host: The host to use when searching for a matching policy.
       |   53|
       |   54|        - returns: The server trust policy for the given host if found.
       |   55|    */
      0|   56|    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
      0|   57|        return policies[host]
      0|   58|    }
       |   59|}
       |   60|
       |   61|// MARK: -
       |   62|
       |   63|extension NSURLSession {
       |   64|    private struct AssociatedKeys {
       |   65|        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
       |   66|    }
       |   67|
       |   68|    var serverTrustPolicyManager: ServerTrustPolicyManager? {
      1|   69|        get {
      1|   70|            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
      1|   71|        }
      1|   72|        set (manager) {
      1|   73|            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
      1|   74|        }
       |   75|    }
       |   76|}
       |   77|
       |   78|// MARK: - ServerTrustPolicy
       |   79|
       |   80|/**
       |   81|    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
       |   82|    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
       |   83|    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
       |   84|
       |   85|    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
       |   86|    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
       |   87|    to route all communication over an HTTPS connection with pinning enabled.
       |   88|
       |   89|    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
       |   90|                                validate the host provided by the challenge. Applications are encouraged to always 
       |   91|                                validate the host in production environments to guarantee the validity of the server's 
       |   92|                                certificate chain.
       |   93|
       |   94|    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
       |   95|                                considered valid if one of the pinned certificates match one of the server certificates. 
       |   96|                                By validating both the certificate chain and host, certificate pinning provides a very 
       |   97|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |   98|                                Applications are encouraged to always validate the host and require a valid certificate 
       |   99|                                chain in production environments.
       |  100|
       |  101|    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
       |  102|                                valid if one of the pinned public keys match one of the server certificate public keys. 
       |  103|                                By validating both the certificate chain and host, public key pinning provides a very 
       |  104|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |  105|                                Applications are encouraged to always validate the host and require a valid certificate 
       |  106|                                chain in production environments.
       |  107|
       |  108|    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
       |  109|
       |  110|    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
       |  111|*/
       |  112|public enum ServerTrustPolicy {
       |  113|    case PerformDefaultEvaluation(validateHost: Bool)
       |  114|    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
       |  115|    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
       |  116|    case DisableEvaluation
       |  117|    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
       |  118|
       |  119|    // MARK: - Bundle Location
       |  120|
       |  121|    /**
       |  122|        Returns all certificates within the given bundle with a `.cer` file extension.
       |  123|
       |  124|        - parameter bundle: The bundle to search for all `.cer` files.
       |  125|
       |  126|        - returns: All certificates within the given bundle.
       |  127|    */
      0|  128|    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
      0|  129|        var certificates: [SecCertificate] = []
      0|  130|
      0|  131|        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
      0|  132|            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
      0|  133|        }.flatten())
      0|  134|
      0|  135|        for path in paths {
      0|  136|            if let
      0|  137|                certificateData = NSData(contentsOfFile: path),
      0|  138|                certificate = SecCertificateCreateWithData(nil, certificateData)
      0|  139|            {
      0|  140|                certificates.append(certificate)
      0|  141|            }
      0|  142|        }
      0|  143|
      0|  144|        return certificates
      0|  145|    }
       |  146|
       |  147|    /**
       |  148|        Returns all public keys within the given bundle with a `.cer` file extension.
       |  149|
       |  150|        - parameter bundle: The bundle to search for all `*.cer` files.
       |  151|
       |  152|        - returns: All public keys within the given bundle.
       |  153|    */
      0|  154|    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
      0|  155|        var publicKeys: [SecKey] = []
      0|  156|
      0|  157|        for certificate in certificatesInBundle(bundle) {
      0|  158|            if let publicKey = publicKeyForCertificate(certificate) {
      0|  159|                publicKeys.append(publicKey)
      0|  160|            }
      0|  161|        }
      0|  162|
      0|  163|        return publicKeys
      0|  164|    }
       |  165|
       |  166|    // MARK: - Evaluation
       |  167|
       |  168|    /**
       |  169|        Evaluates whether the server trust is valid for the given host.
       |  170|
       |  171|        - parameter serverTrust: The server trust to evaluate.
       |  172|        - parameter host:        The host of the challenge protection space.
       |  173|
       |  174|        - returns: Whether the server trust is valid.
       |  175|    */
      0|  176|    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
      0|  177|        var serverTrustIsValid = false
      0|  178|
      0|  179|        switch self {
      0|  180|        case let .PerformDefaultEvaluation(validateHost):
      0|  181|            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  182|            SecTrustSetPolicies(serverTrust, [policy])
      0|  183|
      0|  184|            serverTrustIsValid = trustIsValid(serverTrust)
      0|  185|        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
      0|  186|            if validateCertificateChain {
      0|  187|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  188|                SecTrustSetPolicies(serverTrust, [policy])
      0|  189|
      0|  190|                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
      0|  191|                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
      0|  192|
      0|  193|                serverTrustIsValid = trustIsValid(serverTrust)
      0|  194|            } else {
      0|  195|                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
      0|  196|                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
      0|  197|
      0|  198|                outerLoop: for serverCertificateData in serverCertificatesDataArray {
      0|  199|                    for pinnedCertificateData in pinnedCertificatesDataArray {
      0|  200|                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
      0|  201|                            serverTrustIsValid = true
      0|  202|                            break outerLoop
      0|  203|                        }
      0|  204|                    }
      0|  205|                }
      0|  206|            }
      0|  207|        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
      0|  208|            var certificateChainEvaluationPassed = true
      0|  209|
      0|  210|            if validateCertificateChain {
      0|  211|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  212|                SecTrustSetPolicies(serverTrust, [policy])
      0|  213|
      0|  214|                certificateChainEvaluationPassed = trustIsValid(serverTrust)
      0|  215|            }
      0|  216|
      0|  217|            if certificateChainEvaluationPassed {
      0|  218|                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
      0|  219|                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
      0|  220|                        if serverPublicKey.isEqual(pinnedPublicKey) {
      0|  221|                            serverTrustIsValid = true
      0|  222|                            break outerLoop
      0|  223|                        }
      0|  224|                    }
      0|  225|                }
      0|  226|            }
      0|  227|        case .DisableEvaluation:
      0|  228|            serverTrustIsValid = true
      0|  229|        case let .CustomEvaluation(closure):
      0|  230|            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
      0|  231|        }
      0|  232|
      0|  233|        return serverTrustIsValid
      0|  234|    }
       |  235|
       |  236|    // MARK: - Private - Trust Validation
       |  237|
      0|  238|    private func trustIsValid(trust: SecTrust) -> Bool {
      0|  239|        var isValid = false
      0|  240|
      0|  241|        var result = SecTrustResultType(kSecTrustResultInvalid)
      0|  242|        let status = SecTrustEvaluate(trust, &result)
      0|  243|
      0|  244|        if status == errSecSuccess {
      0|  245|            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
      0|  246|            let proceed = SecTrustResultType(kSecTrustResultProceed)
      0|  247|
      0|  248|            isValid = result == unspecified || result == proceed
      0|  249|        }
      0|  250|
      0|  251|        return isValid
      0|  252|    }
       |  253|
       |  254|    // MARK: - Private - Certificate Data
       |  255|
      0|  256|    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
      0|  257|        var certificates: [SecCertificate] = []
      0|  258|
      0|  259|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  260|            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
      0|  261|                certificates.append(certificate)
      0|  262|            }
      0|  263|        }
      0|  264|
      0|  265|        return certificateDataForCertificates(certificates)
      0|  266|    }
       |  267|
      0|  268|    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
      0|  269|        return certificates.map { SecCertificateCopyData($0) as NSData }
      0|  270|    }
       |  271|
       |  272|    // MARK: - Private - Public Key Extraction
       |  273|
      0|  274|    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
      0|  275|        var publicKeys: [SecKey] = []
      0|  276|
      0|  277|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  278|            if let
      0|  279|                certificate = SecTrustGetCertificateAtIndex(trust, index),
      0|  280|                publicKey = publicKeyForCertificate(certificate)
      0|  281|            {
      0|  282|                publicKeys.append(publicKey)
      0|  283|            }
      0|  284|        }
      0|  285|
      0|  286|        return publicKeys
      0|  287|    }
       |  288|
      0|  289|    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
      0|  290|        var publicKey: SecKey?
      0|  291|
      0|  292|        let policy = SecPolicyCreateBasicX509()
      0|  293|        var trust: SecTrust?
      0|  294|        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
      0|  295|
      0|  296|        if let trust = trust where trustCreationStatus == errSecSuccess {
      0|  297|            publicKey = SecTrustCopyPublicKey(trust)
      0|  298|        }
      0|  299|
      0|  300|        return publicKey
      0|  301|    }
       |  302|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Stream.swift:
       |    1|// Stream.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if !os(watchOS)
       |   26|
       |   27|@available(iOS 9.0, OSX 10.11, *)
       |   28|extension Manager {
       |   29|    private enum Streamable {
       |   30|        case Stream(String, Int)
       |   31|        case NetService(NSNetService)
       |   32|    }
       |   33|
      0|   34|    private func stream(streamable: Streamable) -> Request {
      0|   35|        var streamTask: NSURLSessionStreamTask!
      0|   36|
      0|   37|        switch streamable {
      0|   38|        case .Stream(let hostName, let port):
      0|   39|            dispatch_sync(queue) {
      0|   40|                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
      0|   41|            }
      0|   42|        case .NetService(let netService):
      0|   43|            dispatch_sync(queue) {
      0|   44|                streamTask = self.session.streamTaskWithNetService(netService)
      0|   45|            }
      0|   46|        }
      0|   47|
      0|   48|        let request = Request(session: session, task: streamTask)
      0|   49|
      0|   50|        delegate[request.delegate.task] = request.delegate
      0|   51|
      0|   52|        if startRequestsImmediately {
      0|   53|            request.resume()
      0|   54|        }
      0|   55|
      0|   56|        return request
      0|   57|    }
       |   58|
       |   59|    /**
       |   60|        Creates a request for bidirectional streaming with the given hostname and port.
       |   61|
       |   62|        - parameter hostName: The hostname of the server to connect to.
       |   63|        - parameter port:     The port of the server to connect to.
       |   64|
       |   65|        :returns: The created stream request.
       |   66|    */
      0|   67|    public func stream(hostName hostName: String, port: Int) -> Request {
      0|   68|        return stream(.Stream(hostName, port))
      0|   69|    }
       |   70|
       |   71|    /**
       |   72|        Creates a request for bidirectional streaming with the given `NSNetService`.
       |   73|
       |   74|        - parameter netService: The net service used to identify the endpoint.
       |   75|
       |   76|        - returns: The created stream request.
       |   77|    */
      0|   78|    public func stream(netService netService: NSNetService) -> Request {
      0|   79|        return stream(.NetService(netService))
      0|   80|    }
       |   81|}
       |   82|
       |   83|// MARK: -
       |   84|
       |   85|@available(iOS 9.0, OSX 10.11, *)
       |   86|extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
       |   87|
       |   88|    // MARK: Override Closures
       |   89|
       |   90|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
       |   91|    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|   92|        get {
      0|   93|            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|   94|        }
      0|   95|        set {
      0|   96|            _streamTaskReadClosed = newValue
      0|   97|        }
       |   98|    }
       |   99|
       |  100|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
       |  101|    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  102|        get {
      0|  103|            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  104|        }
      0|  105|        set {
      0|  106|            _streamTaskWriteClosed = newValue
      0|  107|        }
       |  108|    }
       |  109|
       |  110|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
       |  111|    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  112|        get {
      0|  113|            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  114|        }
      0|  115|        set {
      0|  116|            _streamTaskBetterRouteDiscovered = newValue
      0|  117|        }
       |  118|    }
       |  119|
       |  120|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
       |  121|    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
      0|  122|        get {
      0|  123|            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
      0|  124|        }
      0|  125|        set {
      0|  126|            _streamTaskDidBecomeInputStream = newValue
      0|  127|        }
       |  128|    }
       |  129|
       |  130|    // MARK: Delegate Methods
       |  131|
       |  132|    /**
       |  133|        Tells the delegate that the read side of the connection has been closed.
       |  134|
       |  135|        - parameter session:    The session.
       |  136|        - parameter streamTask: The stream task.
       |  137|    */
      0|  138|    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  139|        streamTaskReadClosed?(session, streamTask)
      0|  140|    }
       |  141|
       |  142|    /**
       |  143|        Tells the delegate that the write side of the connection has been closed.
       |  144|
       |  145|        - parameter session:    The session.
       |  146|        - parameter streamTask: The stream task.
       |  147|    */
      0|  148|    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  149|        streamTaskWriteClosed?(session, streamTask)
      0|  150|    }
       |  151|
       |  152|    /**
       |  153|        Tells the delegate that the system has determined that a better route to the host is available.
       |  154|
       |  155|        - parameter session:    The session.
       |  156|        - parameter streamTask: The stream task.
       |  157|    */
      0|  158|    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  159|        streamTaskBetterRouteDiscovered?(session, streamTask)
      0|  160|    }
       |  161|
       |  162|    /**
       |  163|        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
       |  164|
       |  165|        - parameter session:      The session.
       |  166|        - parameter streamTask:   The stream task.
       |  167|        - parameter inputStream:  The new input stream.
       |  168|        - parameter outputStream: The new output stream.
       |  169|    */
       |  170|    public func URLSession(
       |  171|        session: NSURLSession,
       |  172|        streamTask: NSURLSessionStreamTask,
       |  173|        didBecomeInputStream inputStream: NSInputStream,
       |  174|        outputStream: NSOutputStream)
      0|  175|    {
      0|  176|        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
      0|  177|    }
       |  178|}
       |  179|
       |  180|#endif

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Upload.swift:
       |    1|// Upload.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Uploadable {
       |   27|        case Data(NSURLRequest, NSData)
       |   28|        case File(NSURLRequest, NSURL)
       |   29|        case Stream(NSURLRequest, NSInputStream)
       |   30|    }
       |   31|
      0|   32|    private func upload(uploadable: Uploadable) -> Request {
      0|   33|        var uploadTask: NSURLSessionUploadTask!
      0|   34|        var HTTPBodyStream: NSInputStream?
      0|   35|
      0|   36|        switch uploadable {
      0|   37|        case .Data(let request, let data):
      0|   38|            dispatch_sync(queue) {
      0|   39|                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
      0|   40|            }
      0|   41|        case .File(let request, let fileURL):
      0|   42|            dispatch_sync(queue) {
      0|   43|                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
      0|   44|            }
      0|   45|        case .Stream(let request, let stream):
      0|   46|            dispatch_sync(queue) {
      0|   47|                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
      0|   48|            }
      0|   49|
      0|   50|            HTTPBodyStream = stream
      0|   51|        }
      0|   52|
      0|   53|        let request = Request(session: session, task: uploadTask)
      0|   54|
      0|   55|        if HTTPBodyStream != nil {
      0|   56|            request.delegate.taskNeedNewBodyStream = { _, _ in
      0|   57|                return HTTPBodyStream
      0|   58|            }
      0|   59|        }
      0|   60|
      0|   61|        delegate[request.delegate.task] = request.delegate
      0|   62|
      0|   63|        if startRequestsImmediately {
      0|   64|            request.resume()
      0|   65|        }
      0|   66|
      0|   67|        return request
      0|   68|    }
       |   69|
       |   70|    // MARK: File
       |   71|
       |   72|    /**
       |   73|        Creates a request for uploading a file to the specified URL request.
       |   74|
       |   75|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   76|
       |   77|        - parameter URLRequest: The URL request
       |   78|        - parameter file:       The file to upload
       |   79|
       |   80|        - returns: The created upload request.
       |   81|    */
      0|   82|    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|   83|        return upload(.File(URLRequest.URLRequest, file))
      0|   84|    }
       |   85|
       |   86|    /**
       |   87|        Creates a request for uploading a file to the specified URL request.
       |   88|
       |   89|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   90|
       |   91|        - parameter method:    The HTTP method.
       |   92|        - parameter URLString: The URL string.
       |   93|        - parameter headers:   The HTTP headers. `nil` by default.
       |   94|        - parameter file:      The file to upload
       |   95|
       |   96|        - returns: The created upload request.
       |   97|    */
       |   98|    public func upload(
       |   99|        method: Method,
       |  100|        _ URLString: URLStringConvertible,
       |  101|        headers: [String: String]? = nil,
       |  102|        file: NSURL)
       |  103|        -> Request
      0|  104|    {
      0|  105|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  106|        return upload(mutableURLRequest, file: file)
      0|  107|    }
       |  108|
       |  109|    // MARK: Data
       |  110|
       |  111|    /**
       |  112|        Creates a request for uploading data to the specified URL request.
       |  113|
       |  114|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  115|
       |  116|        - parameter URLRequest: The URL request.
       |  117|        - parameter data:       The data to upload.
       |  118|
       |  119|        - returns: The created upload request.
       |  120|    */
      0|  121|    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  122|        return upload(.Data(URLRequest.URLRequest, data))
      0|  123|    }
       |  124|
       |  125|    /**
       |  126|        Creates a request for uploading data to the specified URL request.
       |  127|
       |  128|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  129|
       |  130|        - parameter method:    The HTTP method.
       |  131|        - parameter URLString: The URL string.
       |  132|        - parameter headers:   The HTTP headers. `nil` by default.
       |  133|        - parameter data:      The data to upload
       |  134|
       |  135|        - returns: The created upload request.
       |  136|    */
       |  137|    public func upload(
       |  138|        method: Method,
       |  139|        _ URLString: URLStringConvertible,
       |  140|        headers: [String: String]? = nil,
       |  141|        data: NSData)
       |  142|        -> Request
      0|  143|    {
      0|  144|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  145|
      0|  146|        return upload(mutableURLRequest, data: data)
      0|  147|    }
       |  148|
       |  149|    // MARK: Stream
       |  150|
       |  151|    /**
       |  152|        Creates a request for uploading a stream to the specified URL request.
       |  153|
       |  154|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  155|
       |  156|        - parameter URLRequest: The URL request.
       |  157|        - parameter stream:     The stream to upload.
       |  158|
       |  159|        - returns: The created upload request.
       |  160|    */
      0|  161|    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  162|        return upload(.Stream(URLRequest.URLRequest, stream))
      0|  163|    }
       |  164|
       |  165|    /**
       |  166|        Creates a request for uploading a stream to the specified URL request.
       |  167|
       |  168|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  169|
       |  170|        - parameter method:    The HTTP method.
       |  171|        - parameter URLString: The URL string.
       |  172|        - parameter headers:   The HTTP headers. `nil` by default.
       |  173|        - parameter stream:    The stream to upload.
       |  174|
       |  175|        - returns: The created upload request.
       |  176|    */
       |  177|    public func upload(
       |  178|        method: Method,
       |  179|        _ URLString: URLStringConvertible,
       |  180|        headers: [String: String]? = nil,
       |  181|        stream: NSInputStream)
       |  182|        -> Request
      0|  183|    {
      0|  184|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  185|
      0|  186|        return upload(mutableURLRequest, stream: stream)
      0|  187|    }
       |  188|
       |  189|    // MARK: MultipartFormData
       |  190|
       |  191|    /// Default memory threshold used when encoding `MultipartFormData`.
       |  192|    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
       |  193|
       |  194|    /**
       |  195|        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
       |  196|        associated values.
       |  197|
       |  198|        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
       |  199|                   streaming information.
       |  200|        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
       |  201|                   error.
       |  202|    */
       |  203|    public enum MultipartFormDataEncodingResult {
       |  204|        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
       |  205|        case Failure(ErrorType)
       |  206|    }
       |  207|
       |  208|    /**
       |  209|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  210|
       |  211|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
       |  212|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
       |  213|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
       |  214|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
       |  215|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
       |  216|        used for larger payloads such as video content.
       |  217|
       |  218|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
       |  219|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  220|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
       |  221|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
       |  222|        technique was used.
       |  223|
       |  224|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  225|
       |  226|        - parameter method:                  The HTTP method.
       |  227|        - parameter URLString:               The URL string.
       |  228|        - parameter headers:                 The HTTP headers. `nil` by default.
       |  229|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  230|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  231|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  232|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  233|    */
       |  234|    public func upload(
       |  235|        method: Method,
       |  236|        _ URLString: URLStringConvertible,
       |  237|        headers: [String: String]? = nil,
       |  238|        multipartFormData: MultipartFormData -> Void,
       |  239|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  240|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  241|    {
      0|  242|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  243|
      0|  244|        return upload(
      0|  245|            mutableURLRequest,
      0|  246|            multipartFormData: multipartFormData,
      0|  247|            encodingMemoryThreshold: encodingMemoryThreshold,
      0|  248|            encodingCompletion: encodingCompletion
      0|  249|        )
      0|  250|    }
       |  251|
       |  252|    /**
       |  253|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  254|
       |  255|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
       |  256|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
       |  257|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
       |  258|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
       |  259|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
       |  260|        used for larger payloads such as video content.
       |  261|
       |  262|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
       |  263|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  264|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
       |  265|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
       |  266|        technique was used.
       |  267|
       |  268|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  269|
       |  270|        - parameter URLRequest:              The URL request.
       |  271|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  272|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  273|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  274|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  275|    */
       |  276|    public func upload(
       |  277|        URLRequest: URLRequestConvertible,
       |  278|        multipartFormData: MultipartFormData -> Void,
       |  279|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  280|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  281|    {
      0|  282|        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
      0|  283|            let formData = MultipartFormData()
      0|  284|            multipartFormData(formData)
      0|  285|
      0|  286|            let URLRequestWithContentType = URLRequest.URLRequest
      0|  287|            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
      0|  288|
      0|  289|            let isBackgroundSession = self.session.configuration.identifier != nil
      0|  290|
      0|  291|            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
      0|  292|                do {
      0|  293|                    let data = try formData.encode()
      0|  294|                    let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  295|                        request: self.upload(URLRequestWithContentType, data: data),
      0|  296|                        streamingFromDisk: false,
      0|  297|                        streamFileURL: nil
      0|  298|                    )
      0|  299|
      0|  300|                    dispatch_async(dispatch_get_main_queue()) {
      0|  301|                        encodingCompletion?(encodingResult)
      0|  302|                    }
      0|  303|                } catch {
      0|  304|                    dispatch_async(dispatch_get_main_queue()) {
      0|  305|                        encodingCompletion?(.Failure(error as NSError))
      0|  306|                    }
      0|  307|                }
      0|  308|            } else {
      0|  309|                let fileManager = NSFileManager.defaultManager()
      0|  310|                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
      0|  311|                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
      0|  312|                let fileName = NSUUID().UUIDString
      0|  313|                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
      0|  314|
      0|  315|                do {
      0|  316|                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
      0|  317|                    try formData.writeEncodedDataToDisk(fileURL)
      0|  318|
      0|  319|                    dispatch_async(dispatch_get_main_queue()) {
      0|  320|                        let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  321|                            request: self.upload(URLRequestWithContentType, file: fileURL),
      0|  322|                            streamingFromDisk: true,
      0|  323|                            streamFileURL: fileURL
      0|  324|                        )
      0|  325|                        encodingCompletion?(encodingResult)
      0|  326|                    }
      0|  327|                } catch {
      0|  328|                    dispatch_async(dispatch_get_main_queue()) {
      0|  329|                        encodingCompletion?(.Failure(error as NSError))
      0|  330|                    }
      0|  331|                }
      0|  332|            }
      0|  333|        }
      0|  334|    }
       |  335|}
       |  336|
       |  337|// MARK: -
       |  338|
       |  339|extension Request {
       |  340|
       |  341|    // MARK: - UploadTaskDelegate
       |  342|
       |  343|    class UploadTaskDelegate: DataTaskDelegate {
      0|  344|        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
       |  345|        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
       |  346|
       |  347|        // MARK: - NSURLSessionTaskDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  352|
       |  353|        // MARK: Delegate Methods
       |  354|
       |  355|        func URLSession(
       |  356|            session: NSURLSession,
       |  357|            task: NSURLSessionTask,
       |  358|            didSendBodyData bytesSent: Int64,
       |  359|            totalBytesSent: Int64,
       |  360|            totalBytesExpectedToSend: Int64)
      0|  361|        {
      0|  362|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  363|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  364|            } else {
      0|  365|                progress.totalUnitCount = totalBytesExpectedToSend
      0|  366|                progress.completedUnitCount = totalBytesSent
      0|  367|
      0|  368|                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  369|            }
      0|  370|        }
       |  371|    }
       |  372|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Validation.swift:
       |    1|// Validation.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Request {
       |   26|
       |   27|    /**
       |   28|        Used to represent whether validation was successful or encountered an error resulting in a failure.
       |   29|
       |   30|        - Success: The validation was successful.
       |   31|        - Failure: The validation failed encountering the provided error.
       |   32|    */
       |   33|    public enum ValidationResult {
       |   34|        case Success
       |   35|        case Failure(NSError)
       |   36|    }
       |   37|
       |   38|    /**
       |   39|        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
       |   40|        request was valid.
       |   41|    */
       |   42|    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
       |   43|
       |   44|    /**
       |   45|        Validates the request, using the specified closure.
       |   46|
       |   47|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   48|
       |   49|        - parameter validation: A closure to validate the request.
       |   50|
       |   51|        - returns: The request.
       |   52|    */
      0|   53|    public func validate(validation: Validation) -> Self {
      0|   54|        delegate.queue.addOperationWithBlock {
      0|   55|            if let
      0|   56|                response = self.response where self.delegate.error == nil,
      0|   57|                case let .Failure(error) = validation(self.request, response)
      0|   58|            {
      0|   59|                self.delegate.error = error
      0|   60|            }
      0|   61|        }
      0|   62|
      0|   63|        return self
      0|   64|    }
       |   65|
       |   66|    // MARK: - Status Code
       |   67|
       |   68|    /**
       |   69|        Validates that the response has a status code in the specified range.
       |   70|
       |   71|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   72|
       |   73|        - parameter range: The range of acceptable status codes.
       |   74|
       |   75|        - returns: The request.
       |   76|    */
      0|   77|    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
      0|   78|        return validate { _, response in
      0|   79|            if acceptableStatusCode.contains(response.statusCode) {
      0|   80|                return .Success
      0|   81|            } else {
      0|   82|                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
      0|   83|                return .Failure(Error.errorWithCode(.StatusCodeValidationFailed, failureReason: failureReason))
      0|   84|            }
      0|   85|        }
      0|   86|    }
       |   87|
       |   88|    // MARK: - Content-Type
       |   89|
       |   90|    private struct MIMEType {
       |   91|        let type: String
       |   92|        let subtype: String
       |   93|
      0|   94|        init?(_ string: String) {
      0|   95|            let components: [String] = {
      0|   96|                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
      0|   97|                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
      0|   98|                return split.componentsSeparatedByString("/")
      0|   99|            }()
      0|  100|
      0|  101|            if let
      0|  102|                type = components.first,
      0|  103|                subtype = components.last
      0|  104|            {
      0|  105|                self.type = type
      0|  106|                self.subtype = subtype
      0|  107|            } else {
      0|  108|                return nil
      0|  109|            }
      0|  110|        }
       |  111|
      0|  112|        func matches(MIME: MIMEType) -> Bool {
      0|  113|            switch (type, subtype) {
      0|  114|            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
      0|  115|                return true
      0|  116|            default:
      0|  117|                return false
      0|  118|            }
      0|  119|        }
       |  120|    }
       |  121|
       |  122|    /**
       |  123|        Validates that the response has a content type in the specified array.
       |  124|
       |  125|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  126|
       |  127|        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
       |  128|
       |  129|        - returns: The request.
       |  130|    */
      0|  131|    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
      0|  132|        return validate { _, response in
      0|  133|            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
      0|  134|
      0|  135|            if let
      0|  136|                responseContentType = response.MIMEType,
      0|  137|                responseMIMEType = MIMEType(responseContentType)
      0|  138|            {
      0|  139|                for contentType in acceptableContentTypes {
      0|  140|                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
      0|  141|                        return .Success
      0|  142|                    }
      0|  143|                }
      0|  144|            } else {
      0|  145|                for contentType in acceptableContentTypes {
      0|  146|                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
      0|  147|                        return .Success
      0|  148|                    }
      0|  149|                }
      0|  150|            }
      0|  151|
      0|  152|            let failureReason: String
      0|  153|
      0|  154|            if let responseContentType = response.MIMEType {
      0|  155|                failureReason = (
      0|  156|                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
      0|  157|                    "content types: \(acceptableContentTypes)"
      0|  158|                )
      0|  159|            } else {
      0|  160|                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
      0|  161|            }
      0|  162|
      0|  163|            return .Failure(Error.errorWithCode(.ContentTypeValidationFailed, failureReason: failureReason))
      0|  164|        }
      0|  165|    }
       |  166|
       |  167|    // MARK: - Automatic
       |  168|
       |  169|    /**
       |  170|        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
       |  171|        type matches any specified in the Accept HTTP header field.
       |  172|
       |  173|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  174|
       |  175|        - returns: The request.
       |  176|    */
      0|  177|    public func validate() -> Self {
      0|  178|        let acceptableStatusCodes: Range<Int> = 200..<300
      0|  179|        let acceptableContentTypes: [String] = {
      0|  180|            if let accept = request?.valueForHTTPHeaderField("Accept") {
      0|  181|                return accept.componentsSeparatedByString(",")
      0|  182|            }
      0|  183|
      0|  184|            return ["*/*"]
      0|  185|        }()
      0|  186|
      0|  187|        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
      0|  188|    }
       |  189|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Alamofire.swift:
       |    1|// Alamofire.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: - URLStringConvertible
       |   26|
       |   27|/**
       |   28|    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
       |   29|    construct URL requests.
       |   30|*/
       |   31|public protocol URLStringConvertible {
       |   32|    /**
       |   33|        A URL that conforms to RFC 2396.
       |   34|
       |   35|        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
       |   36|
       |   37|        See https://tools.ietf.org/html/rfc2396
       |   38|        See https://tools.ietf.org/html/rfc1738
       |   39|        See https://tools.ietf.org/html/rfc1808
       |   40|    */
       |   41|    var URLString: String { get }
       |   42|}
       |   43|
       |   44|extension String: URLStringConvertible {
      1|   45|    public var URLString: String {
      1|   46|        return self
      1|   47|    }
       |   48|}
       |   49|
       |   50|extension NSURL: URLStringConvertible {
      0|   51|    public var URLString: String {
      0|   52|        return absoluteString
      0|   53|    }
       |   54|}
       |   55|
       |   56|extension NSURLComponents: URLStringConvertible {
      0|   57|    public var URLString: String {
      0|   58|        return URL!.URLString
      0|   59|    }
       |   60|}
       |   61|
       |   62|extension NSURLRequest: URLStringConvertible {
      0|   63|    public var URLString: String {
      0|   64|        return URL!.URLString
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - URLRequestConvertible
       |   69|
       |   70|/**
       |   71|    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
       |   72|*/
       |   73|public protocol URLRequestConvertible {
       |   74|    /// The URL request.
       |   75|    var URLRequest: NSMutableURLRequest { get }
       |   76|}
       |   77|
       |   78|extension NSURLRequest: URLRequestConvertible {
      2|   79|    public var URLRequest: NSMutableURLRequest {
      2|   80|        return self.mutableCopy() as! NSMutableURLRequest
      2|   81|    }
       |   82|}
       |   83|
       |   84|// MARK: - Convenience
       |   85|
       |   86|func URLRequest(
       |   87|    method: Method,
       |   88|    _ URLString: URLStringConvertible,
       |   89|    headers: [String: String]? = nil)
       |   90|    -> NSMutableURLRequest
      1|   91|{
      1|   92|    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
      1|   93|    mutableURLRequest.HTTPMethod = method.rawValue
      1|   94|
      1|   95|    if let headers = headers {
      2|   96|        for (headerField, headerValue) in headers {
      2|   97|            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
      2|   98|        }
      1|   99|    }
      1|  100|
      1|  101|    return mutableURLRequest
      1|  102|}
       |  103|
       |  104|// MARK: - Request Methods
       |  105|
       |  106|/**
       |  107|    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
       |  108|    parameter encoding.
       |  109|
       |  110|    - parameter method:     The HTTP method.
       |  111|    - parameter URLString:  The URL string.
       |  112|    - parameter parameters: The parameters. `nil` by default.
       |  113|    - parameter encoding:   The parameter encoding. `.URL` by default.
       |  114|    - parameter headers:    The HTTP headers. `nil` by default.
       |  115|
       |  116|    - returns: The created request.
       |  117|*/
       |  118|public func request(
       |  119|    method: Method,
       |  120|    _ URLString: URLStringConvertible,
       |  121|    parameters: [String: AnyObject]? = nil,
       |  122|    encoding: ParameterEncoding = .URL,
       |  123|    headers: [String: String]? = nil)
       |  124|    -> Request
      1|  125|{
      1|  126|    return Manager.sharedInstance.request(
      1|  127|        method,
      1|  128|        URLString,
      1|  129|        parameters: parameters,
      1|  130|        encoding: encoding,
      1|  131|        headers: headers
      1|  132|    )
      1|  133|}
       |  134|
       |  135|/**
       |  136|    Creates a request using the shared manager instance for the specified URL request.
       |  137|
       |  138|    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  139|
       |  140|    - parameter URLRequest: The URL request
       |  141|
       |  142|    - returns: The created request.
       |  143|*/
      0|  144|public func request(URLRequest: URLRequestConvertible) -> Request {
      0|  145|    return Manager.sharedInstance.request(URLRequest.URLRequest)
      0|  146|}
       |  147|
       |  148|// MARK: - Upload Methods
       |  149|
       |  150|// MARK: File
       |  151|
       |  152|/**
       |  153|    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
       |  154|
       |  155|    - parameter method:    The HTTP method.
       |  156|    - parameter URLString: The URL string.
       |  157|    - parameter headers:   The HTTP headers. `nil` by default.
       |  158|    - parameter file:      The file to upload.
       |  159|
       |  160|    - returns: The created upload request.
       |  161|*/
       |  162|public func upload(
       |  163|    method: Method,
       |  164|    _ URLString: URLStringConvertible,
       |  165|    headers: [String: String]? = nil,
       |  166|    file: NSURL)
       |  167|    -> Request
      0|  168|{
      0|  169|    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
      0|  170|}
       |  171|
       |  172|/**
       |  173|    Creates an upload request using the shared manager instance for the specified URL request and file.
       |  174|
       |  175|    - parameter URLRequest: The URL request.
       |  176|    - parameter file:       The file to upload.
       |  177|
       |  178|    - returns: The created upload request.
       |  179|*/
      0|  180|public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|  181|    return Manager.sharedInstance.upload(URLRequest, file: file)
      0|  182|}
       |  183|
       |  184|// MARK: Data
       |  185|
       |  186|/**
       |  187|    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
       |  188|
       |  189|    - parameter method:    The HTTP method.
       |  190|    - parameter URLString: The URL string.
       |  191|    - parameter headers:   The HTTP headers. `nil` by default.
       |  192|    - parameter data:      The data to upload.
       |  193|
       |  194|    - returns: The created upload request.
       |  195|*/
       |  196|public func upload(
       |  197|    method: Method,
       |  198|    _ URLString: URLStringConvertible,
       |  199|    headers: [String: String]? = nil,
       |  200|    data: NSData)
       |  201|    -> Request
      0|  202|{
      0|  203|    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
      0|  204|}
       |  205|
       |  206|/**
       |  207|    Creates an upload request using the shared manager instance for the specified URL request and data.
       |  208|
       |  209|    - parameter URLRequest: The URL request.
       |  210|    - parameter data:       The data to upload.
       |  211|
       |  212|    - returns: The created upload request.
       |  213|*/
      0|  214|public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  215|    return Manager.sharedInstance.upload(URLRequest, data: data)
      0|  216|}
       |  217|
       |  218|// MARK: Stream
       |  219|
       |  220|/**
       |  221|    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
       |  222|
       |  223|    - parameter method:    The HTTP method.
       |  224|    - parameter URLString: The URL string.
       |  225|    - parameter headers:   The HTTP headers. `nil` by default.
       |  226|    - parameter stream:    The stream to upload.
       |  227|
       |  228|    - returns: The created upload request.
       |  229|*/
       |  230|public func upload(
       |  231|    method: Method,
       |  232|    _ URLString: URLStringConvertible,
       |  233|    headers: [String: String]? = nil,
       |  234|    stream: NSInputStream)
       |  235|    -> Request
      0|  236|{
      0|  237|    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
      0|  238|}
       |  239|
       |  240|/**
       |  241|    Creates an upload request using the shared manager instance for the specified URL request and stream.
       |  242|
       |  243|    - parameter URLRequest: The URL request.
       |  244|    - parameter stream:     The stream to upload.
       |  245|
       |  246|    - returns: The created upload request.
       |  247|*/
      0|  248|public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  249|    return Manager.sharedInstance.upload(URLRequest, stream: stream)
      0|  250|}
       |  251|
       |  252|// MARK: MultipartFormData
       |  253|
       |  254|/**
       |  255|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  256|
       |  257|    - parameter method:                  The HTTP method.
       |  258|    - parameter URLString:               The URL string.
       |  259|    - parameter headers:                 The HTTP headers. `nil` by default.
       |  260|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  261|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  262|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  263|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  264|*/
       |  265|public func upload(
       |  266|    method: Method,
       |  267|    _ URLString: URLStringConvertible,
       |  268|    headers: [String: String]? = nil,
       |  269|    multipartFormData: MultipartFormData -> Void,
       |  270|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  271|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  272|{
      0|  273|    return Manager.sharedInstance.upload(
      0|  274|        method,
      0|  275|        URLString,
      0|  276|        headers: headers,
      0|  277|        multipartFormData: multipartFormData,
      0|  278|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  279|        encodingCompletion: encodingCompletion
      0|  280|    )
      0|  281|}
       |  282|
       |  283|/**
       |  284|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  285|
       |  286|    - parameter URLRequest:              The URL request.
       |  287|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  288|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  289|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  290|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  291|*/
       |  292|public func upload(
       |  293|    URLRequest: URLRequestConvertible,
       |  294|    multipartFormData: MultipartFormData -> Void,
       |  295|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  296|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  297|{
      0|  298|    return Manager.sharedInstance.upload(
      0|  299|        URLRequest,
      0|  300|        multipartFormData: multipartFormData,
      0|  301|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  302|        encodingCompletion: encodingCompletion
      0|  303|    )
      0|  304|}
       |  305|
       |  306|// MARK: - Download Methods
       |  307|
       |  308|// MARK: URL Request
       |  309|
       |  310|/**
       |  311|    Creates a download request using the shared manager instance for the specified method and URL string.
       |  312|
       |  313|    - parameter method:      The HTTP method.
       |  314|    - parameter URLString:   The URL string.
       |  315|    - parameter parameters:  The parameters. `nil` by default.
       |  316|    - parameter encoding:    The parameter encoding. `.URL` by default.
       |  317|    - parameter headers:     The HTTP headers. `nil` by default.
       |  318|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  319|
       |  320|    - returns: The created download request.
       |  321|*/
       |  322|public func download(
       |  323|    method: Method,
       |  324|    _ URLString: URLStringConvertible,
       |  325|    parameters: [String: AnyObject]? = nil,
       |  326|    encoding: ParameterEncoding = .URL,
       |  327|    headers: [String: String]? = nil,
       |  328|    destination: Request.DownloadFileDestination)
       |  329|    -> Request
      0|  330|{
      0|  331|    return Manager.sharedInstance.download(
      0|  332|        method,
      0|  333|        URLString,
      0|  334|        parameters: parameters,
      0|  335|        encoding: encoding,
      0|  336|        headers: headers,
      0|  337|        destination: destination
      0|  338|    )
      0|  339|}
       |  340|
       |  341|/**
       |  342|    Creates a download request using the shared manager instance for the specified URL request.
       |  343|
       |  344|    - parameter URLRequest:  The URL request.
       |  345|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  346|
       |  347|    - returns: The created download request.
       |  348|*/
      0|  349|public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  350|    return Manager.sharedInstance.download(URLRequest, destination: destination)
      0|  351|}
       |  352|
       |  353|// MARK: Resume Data
       |  354|
       |  355|/**
       |  356|    Creates a request using the shared manager instance for downloading from the resume data produced from a 
       |  357|    previous request cancellation.
       |  358|
       |  359|    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
       |  360|                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
       |  361|                             information.
       |  362|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  363|
       |  364|    - returns: The created download request.
       |  365|*/
      0|  366|public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  367|    return Manager.sharedInstance.download(data, destination: destination)
      0|  368|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Download.swift:
       |    1|// Download.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Downloadable {
       |   27|        case Request(NSURLRequest)
       |   28|        case ResumeData(NSData)
       |   29|    }
       |   30|
      0|   31|    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
      0|   32|        var downloadTask: NSURLSessionDownloadTask!
      0|   33|
      0|   34|        switch downloadable {
      0|   35|        case .Request(let request):
      0|   36|            dispatch_sync(queue) {
      0|   37|                downloadTask = self.session.downloadTaskWithRequest(request)
      0|   38|            }
      0|   39|        case .ResumeData(let resumeData):
      0|   40|            dispatch_sync(queue) {
      0|   41|                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
      0|   42|            }
      0|   43|        }
      0|   44|
      0|   45|        let request = Request(session: session, task: downloadTask)
      0|   46|
      0|   47|        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
      0|   48|            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
      0|   49|                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
      0|   50|            }
      0|   51|        }
      0|   52|
      0|   53|        delegate[request.delegate.task] = request.delegate
      0|   54|
      0|   55|        if startRequestsImmediately {
      0|   56|            request.resume()
      0|   57|        }
      0|   58|
      0|   59|        return request
      0|   60|    }
       |   61|
       |   62|    // MARK: Request
       |   63|
       |   64|    /**
       |   65|        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
       |   66|        and destination.
       |   67|
       |   68|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   69|
       |   70|        - parameter method:      The HTTP method.
       |   71|        - parameter URLString:   The URL string.
       |   72|        - parameter parameters:  The parameters. `nil` by default.
       |   73|        - parameter encoding:    The parameter encoding. `.URL` by default.
       |   74|        - parameter headers:     The HTTP headers. `nil` by default.
       |   75|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |   76|
       |   77|        - returns: The created download request.
       |   78|    */
       |   79|    public func download(
       |   80|        method: Method,
       |   81|        _ URLString: URLStringConvertible,
       |   82|        parameters: [String: AnyObject]? = nil,
       |   83|        encoding: ParameterEncoding = .URL,
       |   84|        headers: [String: String]? = nil,
       |   85|        destination: Request.DownloadFileDestination)
       |   86|        -> Request
      0|   87|    {
      0|   88|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|   89|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      0|   90|
      0|   91|        return download(encodedURLRequest, destination: destination)
      0|   92|    }
       |   93|
       |   94|    /**
       |   95|        Creates a request for downloading from the specified URL request.
       |   96|
       |   97|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   98|
       |   99|        - parameter URLRequest:  The URL request
       |  100|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  101|
       |  102|        - returns: The created download request.
       |  103|    */
      0|  104|    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  105|        return download(.Request(URLRequest.URLRequest), destination: destination)
      0|  106|    }
       |  107|
       |  108|    // MARK: Resume Data
       |  109|
       |  110|    /**
       |  111|        Creates a request for downloading from the resume data produced from a previous request cancellation.
       |  112|
       |  113|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  114|
       |  115|        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
       |  116|                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
       |  117|                                 additional information.
       |  118|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  119|
       |  120|        - returns: The created download request.
       |  121|    */
      0|  122|    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  123|        return download(.ResumeData(resumeData), destination: destination)
      0|  124|    }
       |  125|}
       |  126|
       |  127|// MARK: -
       |  128|
       |  129|extension Request {
       |  130|    /**
       |  131|        A closure executed once a request has successfully completed in order to determine where to move the temporary 
       |  132|        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
       |  133|        response, and returns a single argument: the file URL where the temporary file should be moved.
       |  134|    */
       |  135|    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
       |  136|
       |  137|    /**
       |  138|        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
       |  139|        file URL in the first available directory with the specified search path directory and search path domain mask.
       |  140|
       |  141|        - parameter directory: The search path directory. `.DocumentDirectory` by default.
       |  142|        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
       |  143|
       |  144|        - returns: A download file destination closure.
       |  145|    */
       |  146|    public class func suggestedDownloadDestination(
       |  147|        directory directory: NSSearchPathDirectory = .DocumentDirectory,
       |  148|        domain: NSSearchPathDomainMask = .UserDomainMask)
       |  149|        -> DownloadFileDestination
      0|  150|    {
      0|  151|        return { temporaryURL, response -> NSURL in
      0|  152|            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
      0|  153|
      0|  154|            if !directoryURLs.isEmpty {
      0|  155|                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
      0|  156|            }
      0|  157|
      0|  158|            return temporaryURL
      0|  159|        }
      0|  160|    }
       |  161|
       |  162|    /// The resume data of the underlying download task if available after a failure.
      0|  163|    public var resumeData: NSData? {
      0|  164|        var data: NSData?
      0|  165|
      0|  166|        if let delegate = delegate as? DownloadTaskDelegate {
      0|  167|            data = delegate.resumeData
      0|  168|        }
      0|  169|
      0|  170|        return data
      0|  171|    }
       |  172|
       |  173|    // MARK: - DownloadTaskDelegate
       |  174|
       |  175|    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
      0|  176|        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
       |  177|        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
       |  178|
       |  179|        var resumeData: NSData?
      0|  180|        override var data: NSData? { return resumeData }
       |  181|
       |  182|        // MARK: - NSURLSessionDownloadDelegate
       |  183|
       |  184|        // MARK: Override Closures
       |  185|
       |  186|        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
       |  187|        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  188|        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  189|
       |  190|        // MARK: Delegate Methods
       |  191|
       |  192|        func URLSession(
       |  193|            session: NSURLSession,
       |  194|            downloadTask: NSURLSessionDownloadTask,
       |  195|            didFinishDownloadingToURL location: NSURL)
      0|  196|        {
      0|  197|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  198|                do {
      0|  199|                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  200|                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
      0|  201|                } catch {
      0|  202|                    self.error = error as NSError
      0|  203|                }
      0|  204|            }
      0|  205|        }
       |  206|
       |  207|        func URLSession(
       |  208|            session: NSURLSession,
       |  209|            downloadTask: NSURLSessionDownloadTask,
       |  210|            didWriteData bytesWritten: Int64,
       |  211|            totalBytesWritten: Int64,
       |  212|            totalBytesExpectedToWrite: Int64)
      0|  213|        {
      0|  214|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  215|                downloadTaskDidWriteData(
      0|  216|                    session,
      0|  217|                    downloadTask,
      0|  218|                    bytesWritten,
      0|  219|                    totalBytesWritten, 
      0|  220|                    totalBytesExpectedToWrite
      0|  221|                )
      0|  222|            } else {
      0|  223|                progress.totalUnitCount = totalBytesExpectedToWrite
      0|  224|                progress.completedUnitCount = totalBytesWritten
      0|  225|
      0|  226|                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  227|            }
      0|  228|        }
       |  229|
       |  230|        func URLSession(
       |  231|            session: NSURLSession,
       |  232|            downloadTask: NSURLSessionDownloadTask,
       |  233|            didResumeAtOffset fileOffset: Int64,
       |  234|            expectedTotalBytes: Int64)
      0|  235|        {
      0|  236|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  237|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  238|            } else {
      0|  239|                progress.totalUnitCount = expectedTotalBytes
      0|  240|                progress.completedUnitCount = fileOffset
      0|  241|            }
      0|  242|        }
       |  243|    }
       |  244|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Error.swift:
       |    1|// Error.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
       |   26|public struct Error {
       |   27|    /// The domain used for creating all Alamofire errors.
       |   28|    public static let Domain = "com.alamofire.error"
       |   29|
       |   30|    /// The custom error codes generated by Alamofire.
       |   31|    public enum Code: Int {
       |   32|        case InputStreamReadFailed           = -6000
       |   33|        case OutputStreamWriteFailed         = -6001
       |   34|        case ContentTypeValidationFailed     = -6002
       |   35|        case StatusCodeValidationFailed      = -6003
       |   36|        case DataSerializationFailed         = -6004
       |   37|        case StringSerializationFailed       = -6005
       |   38|        case JSONSerializationFailed         = -6006
       |   39|        case PropertyListSerializationFailed = -6007
       |   40|    }
       |   41|
       |   42|    /**
       |   43|        Creates an `NSError` with the given error code and failure reason.
       |   44|
       |   45|        - parameter code:          The error code.
       |   46|        - parameter failureReason: The failure reason.
       |   47|
       |   48|        - returns: An `NSError` with the given error code and failure reason.
       |   49|    */
      0|   50|    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
      0|   51|        return errorWithCode(code.rawValue, failureReason: failureReason)
      0|   52|    }
       |   53|
       |   54|    /**
       |   55|        Creates an `NSError` with the given error code and failure reason.
       |   56|
       |   57|        - parameter code:          The error code.
       |   58|        - parameter failureReason: The failure reason.
       |   59|
       |   60|        - returns: An `NSError` with the given error code and failure reason.
       |   61|    */
      0|   62|    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
      0|   63|        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
      0|   64|        return NSError(domain: Domain, code: code, userInfo: userInfo)
      0|   65|    }
       |   66|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Manager.swift:
       |    1|// Manager.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
       |   27|*/
       |   28|public class Manager {
       |   29|
       |   30|    // MARK: - Properties
       |   31|
       |   32|    /**
       |   33|        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
       |   34|        for any ad hoc requests.
       |   35|    */
       |   36|    public static let sharedInstance: Manager = {
       |   37|        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
       |   38|        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
       |   39|
       |   40|        return Manager(configuration: configuration)
       |   41|    }()
       |   42|
       |   43|    /**
       |   44|        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
       |   45|    */
       |   46|    public static let defaultHTTPHeaders: [String: String] = {
       |   47|        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
       |   48|        let acceptEncoding: String = "gzip;q=1.0,compress;q=0.5"
       |   49|
       |   50|        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
       |   51|        let acceptLanguage: String = {
       |   52|            var components: [String] = []
       |   53|            for (index, languageCode) in (NSLocale.preferredLanguages() as [String]).enumerate() {
       |   54|                let q = 1.0 - (Double(index) * 0.1)
       |   55|                components.append("\(languageCode);q=\(q)")
       |   56|                if q <= 0.5 {
       |   57|                    break
       |   58|                }
       |   59|            }
       |   60|
       |   61|            return components.joinWithSeparator(",")
       |   62|        }()
       |   63|
       |   64|        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
       |   65|        let userAgent: String = {
       |   66|            if let info = NSBundle.mainBundle().infoDictionary {
       |   67|                let executable: AnyObject = info[kCFBundleExecutableKey as String] ?? "Unknown"
       |   68|                let bundle: AnyObject = info[kCFBundleIdentifierKey as String] ?? "Unknown"
       |   69|                let version: AnyObject = info[kCFBundleVersionKey as String] ?? "Unknown"
       |   70|                let os: AnyObject = NSProcessInfo.processInfo().operatingSystemVersionString ?? "Unknown"
       |   71|
       |   72|                var mutableUserAgent = NSMutableString(string: "\(executable)/\(bundle) (\(version); OS \(os))") as CFMutableString
       |   73|                let transform = NSString(string: "Any-Latin; Latin-ASCII; [:^ASCII:] Remove") as CFString
       |   74|
       |   75|                if CFStringTransform(mutableUserAgent, UnsafeMutablePointer<CFRange>(nil), transform, false) {
       |   76|                    return mutableUserAgent as String
       |   77|                }
       |   78|            }
       |   79|
       |   80|            return "Alamofire"
       |   81|        }()
       |   82|
       |   83|        return [
       |   84|            "Accept-Encoding": acceptEncoding,
       |   85|            "Accept-Language": acceptLanguage,
       |   86|            "User-Agent": userAgent
       |   87|        ]
       |   88|    }()
       |   89|
       |   90|    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
       |   91|
       |   92|    /// The underlying session.
       |   93|    public let session: NSURLSession
       |   94|
       |   95|    /// The session delegate handling all the task and session delegate callbacks.
       |   96|    public let delegate: SessionDelegate
       |   97|
       |   98|    /// Whether to start requests immediately after being constructed. `true` by default.
       |   99|    public var startRequestsImmediately: Bool = true
       |  100|
       |  101|    /**
       |  102|        The background completion handler closure provided by the UIApplicationDelegate 
       |  103|        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
       |  104|        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
       |  105|        will automatically call the handler.
       |  106|    
       |  107|        If you need to handle your own events before the handler is called, then you need to override the 
       |  108|        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
       |  109|    
       |  110|        `nil` by default.
       |  111|    */
       |  112|    public var backgroundCompletionHandler: (() -> Void)?
       |  113|
       |  114|    // MARK: - Lifecycle
       |  115|
       |  116|    /**
       |  117|        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
       |  118|
       |  119|        - parameter configuration:            The configuration used to construct the managed session. 
       |  120|                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
       |  121|        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
       |  122|                                              default.
       |  123|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
       |  124|                                              challenges. `nil` by default.
       |  125|
       |  126|        - returns: The new `Manager` instance.
       |  127|    */
       |  128|    public init(
       |  129|        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
       |  130|        delegate: SessionDelegate = SessionDelegate(),
       |  131|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      1|  132|    {
      1|  133|        self.delegate = delegate
      1|  134|        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
      1|  135|
      1|  136|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      1|  137|    }
       |  138|
       |  139|    /**
       |  140|        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
       |  141|
       |  142|        - parameter session:                  The URL session.
       |  143|        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
       |  144|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
       |  145|                                              challenges. `nil` by default.
       |  146|
       |  147|        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
       |  148|    */
       |  149|    public init?(
       |  150|        session: NSURLSession,
       |  151|        delegate: SessionDelegate,
       |  152|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      0|  153|    {
      0|  154|        self.delegate = delegate
      0|  155|        self.session = session
      0|  156|
      0|  157|        guard delegate === session.delegate else { return nil }
      0|  158|
      0|  159|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      0|  160|    }
       |  161|
      1|  162|    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
      1|  163|        session.serverTrustPolicyManager = serverTrustPolicyManager
      1|  164|
      0|  165|        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
      0|  166|            guard let strongSelf = self else { return }
      0|  167|            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
      0|  168|        }
      1|  169|    }
       |  170|
      0|  171|    deinit {
      0|  172|        session.invalidateAndCancel()
      0|  173|    }
       |  174|
       |  175|    // MARK: - Request
       |  176|
       |  177|    /**
       |  178|        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
       |  179|
       |  180|        - parameter method:     The HTTP method.
       |  181|        - parameter URLString:  The URL string.
       |  182|        - parameter parameters: The parameters. `nil` by default.
       |  183|        - parameter encoding:   The parameter encoding. `.URL` by default.
       |  184|        - parameter headers:    The HTTP headers. `nil` by default.
       |  185|
       |  186|        - returns: The created request.
       |  187|    */
       |  188|    public func request(
       |  189|        method: Method,
       |  190|        _ URLString: URLStringConvertible,
       |  191|        parameters: [String: AnyObject]? = nil,
       |  192|        encoding: ParameterEncoding = .URL,
       |  193|        headers: [String: String]? = nil)
       |  194|        -> Request
      1|  195|    {
      1|  196|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      1|  197|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      1|  198|        return request(encodedURLRequest)
      1|  199|    }
       |  200|
       |  201|    /**
       |  202|        Creates a request for the specified URL request.
       |  203|
       |  204|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  205|
       |  206|        - parameter URLRequest: The URL request
       |  207|
       |  208|        - returns: The created request.
       |  209|    */
      1|  210|    public func request(URLRequest: URLRequestConvertible) -> Request {
      1|  211|        var dataTask: NSURLSessionDataTask!
      1|  212|        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
      1|  213|
      1|  214|        let request = Request(session: session, task: dataTask)
      1|  215|        delegate[request.delegate.task] = request.delegate
      1|  216|
      1|  217|        if startRequestsImmediately {
      1|  218|            request.resume()
      1|  219|        }
      1|  220|
      1|  221|        return request
      1|  222|    }
       |  223|
       |  224|    // MARK: - SessionDelegate
       |  225|
       |  226|    /**
       |  227|        Responsible for handling all delegate callbacks for the underlying session.
       |  228|    */
       |  229|    public final class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
       |  230|        private var subdelegates: [Int: Request.TaskDelegate] = [:]
       |  231|        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
       |  232|
       |  233|        subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
      4|  234|            get {
      4|  235|                var subdelegate: Request.TaskDelegate?
      4|  236|                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
      4|  237|
      4|  238|                return subdelegate
      4|  239|            }
       |  240|
      2|  241|            set {
      2|  242|                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
      2|  243|            }
       |  244|        }
       |  245|
       |  246|        /**
       |  247|            Initializes the `SessionDelegate` instance.
       |  248|
       |  249|            - returns: The new `SessionDelegate` instance.
       |  250|        */
      1|  251|        public override init() {
      1|  252|            super.init()
      1|  253|        }
       |  254|
       |  255|        // MARK: - NSURLSessionDelegate
       |  256|
       |  257|        // MARK: Override Closures
       |  258|
       |  259|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
       |  260|        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
       |  261|
       |  262|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
       |  263|        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  264|
       |  265|        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
       |  266|        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
       |  267|
       |  268|        // MARK: Delegate Methods
       |  269|
       |  270|        /**
       |  271|            Tells the delegate that the session has been invalidated.
       |  272|
       |  273|            - parameter session: The session object that was invalidated.
       |  274|            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
       |  275|        */
      0|  276|        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
      0|  277|            sessionDidBecomeInvalidWithError?(session, error)
      0|  278|        }
       |  279|
       |  280|        /**
       |  281|            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
       |  282|
       |  283|            - parameter session:           The session containing the task that requested authentication.
       |  284|            - parameter challenge:         An object that contains the request for authentication.
       |  285|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  286|        */
       |  287|        public func URLSession(
       |  288|            session: NSURLSession,
       |  289|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  290|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      0|  291|        {
      0|  292|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      0|  293|            var credential: NSURLCredential?
      0|  294|
      0|  295|            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
      0|  296|                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
      0|  297|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      0|  298|                let host = challenge.protectionSpace.host
      0|  299|
      0|  300|                if let
      0|  301|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      0|  302|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  303|                {
      0|  304|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  305|                        disposition = .UseCredential
      0|  306|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  307|                    } else {
      0|  308|                        disposition = .CancelAuthenticationChallenge
      0|  309|                    }
      0|  310|                }
      0|  311|            }
      0|  312|
      0|  313|            completionHandler(disposition, credential)
      0|  314|        }
       |  315|
       |  316|        /**
       |  317|            Tells the delegate that all messages enqueued for a session have been delivered.
       |  318|
       |  319|            - parameter session: The session that no longer has any outstanding requests.
       |  320|        */
      0|  321|        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
      0|  322|            sessionDidFinishEventsForBackgroundURLSession?(session)
      0|  323|        }
       |  324|
       |  325|        // MARK: - NSURLSessionTaskDelegate
       |  326|
       |  327|        // MARK: Override Closures
       |  328|
       |  329|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
       |  330|        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  331|
       |  332|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
       |  333|        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  334|
       |  335|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
       |  336|        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream!)?
       |  337|
       |  338|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
       |  339|        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  340|
       |  341|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
       |  342|        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  343|
       |  344|        // MARK: Delegate Methods
       |  345|
       |  346|        /**
       |  347|            Tells the delegate that the remote server requested an HTTP redirect.
       |  348|
       |  349|            - parameter session:           The session containing the task whose request resulted in a redirect.
       |  350|            - parameter task:              The task whose request resulted in a redirect.
       |  351|            - parameter response:          An object containing the server’s response to the original request.
       |  352|            - parameter request:           A URL request object filled out with the new location.
       |  353|            - parameter completionHandler: A closure that your handler should call with either the value of the request 
       |  354|                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
       |  355|                                           return the body of the redirect response.
       |  356|        */
       |  357|        public func URLSession(
       |  358|            session: NSURLSession,
       |  359|            task: NSURLSessionTask,
       |  360|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  361|            newRequest request: NSURLRequest,
       |  362|            completionHandler: ((NSURLRequest?) -> Void))
      0|  363|        {
      0|  364|            var redirectRequest: NSURLRequest? = request
      0|  365|
      0|  366|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  367|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  368|            }
      0|  369|
      0|  370|            completionHandler(redirectRequest)
      0|  371|        }
       |  372|
       |  373|        /**
       |  374|            Requests credentials from the delegate in response to an authentication request from the remote server.
       |  375|
       |  376|            - parameter session:           The session containing the task whose request requires authentication.
       |  377|            - parameter task:              The task whose request requires authentication.
       |  378|            - parameter challenge:         An object that contains the request for authentication.
       |  379|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  380|        */
       |  381|        public func URLSession(
       |  382|            session: NSURLSession,
       |  383|            task: NSURLSessionTask,
       |  384|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  385|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  386|        {
      0|  387|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  388|                completionHandler(taskDidReceiveChallenge(session, task, challenge))
      1|  389|            } else if let delegate = self[task] {
      1|  390|                delegate.URLSession(
      1|  391|                    session,
      1|  392|                    task: task,
      1|  393|                    didReceiveChallenge: challenge,
      1|  394|                    completionHandler: completionHandler
      1|  395|                )
      0|  396|            } else {
      0|  397|                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
      0|  398|            }
      1|  399|        }
       |  400|
       |  401|        /**
       |  402|            Tells the delegate when a task requires a new request body stream to send to the remote server.
       |  403|
       |  404|            - parameter session:           The session containing the task that needs a new body stream.
       |  405|            - parameter task:              The task that needs a new body stream.
       |  406|            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
       |  407|        */
       |  408|        public func URLSession(
       |  409|            session: NSURLSession,
       |  410|            task: NSURLSessionTask,
       |  411|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  412|        {
      0|  413|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  414|                completionHandler(taskNeedNewBodyStream(session, task))
      0|  415|            } else if let delegate = self[task] {
      0|  416|                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
      0|  417|            }
      0|  418|        }
       |  419|
       |  420|        /**
       |  421|            Periodically informs the delegate of the progress of sending body content to the server.
       |  422|
       |  423|            - parameter session:                  The session containing the data task.
       |  424|            - parameter task:                     The data task.
       |  425|            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
       |  426|            - parameter totalBytesSent:           The total number of bytes sent so far.
       |  427|            - parameter totalBytesExpectedToSend: The expected length of the body data.
       |  428|        */
       |  429|        public func URLSession(
       |  430|            session: NSURLSession,
       |  431|            task: NSURLSessionTask,
       |  432|            didSendBodyData bytesSent: Int64,
       |  433|            totalBytesSent: Int64,
       |  434|            totalBytesExpectedToSend: Int64)
      1|  435|        {
      0|  436|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  437|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  438|            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
      0|  439|                delegate.URLSession(
      0|  440|                    session,
      0|  441|                    task: task,
      0|  442|                    didSendBodyData: bytesSent,
      0|  443|                    totalBytesSent: totalBytesSent,
      0|  444|                    totalBytesExpectedToSend: totalBytesExpectedToSend
      0|  445|                )
      0|  446|            }
      1|  447|        }
       |  448|
       |  449|        /**
       |  450|            Tells the delegate that the task finished transferring data.
       |  451|
       |  452|            - parameter session: The session containing the task whose request finished transferring data.
       |  453|            - parameter task:    The task whose request finished transferring data.
       |  454|            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
       |  455|        */
      1|  456|        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  457|            if let taskDidComplete = taskDidComplete {
      0|  458|                taskDidComplete(session, task, error)
      1|  459|            } else if let delegate = self[task] {
      1|  460|                delegate.URLSession(session, task: task, didCompleteWithError: error)
      1|  461|            }
      1|  462|
      1|  463|            self[task] = nil
      1|  464|        }
       |  465|
       |  466|        // MARK: - NSURLSessionDataDelegate
       |  467|
       |  468|        // MARK: Override Closures
       |  469|
       |  470|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
       |  471|        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  472|
       |  473|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
       |  474|        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  475|
       |  476|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
       |  477|        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  478|
       |  479|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
       |  480|        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse!)?
       |  481|
       |  482|        // MARK: Delegate Methods
       |  483|
       |  484|        /**
       |  485|            Tells the delegate that the data task received the initial reply (headers) from the server.
       |  486|
       |  487|            - parameter session:           The session containing the data task that received an initial reply.
       |  488|            - parameter dataTask:          The data task that received an initial reply.
       |  489|            - parameter response:          A URL response object populated with headers.
       |  490|            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
       |  491|                                           constant to indicate whether the transfer should continue as a data task or 
       |  492|                                           should become a download task.
       |  493|        */
       |  494|        public func URLSession(
       |  495|            session: NSURLSession,
       |  496|            dataTask: NSURLSessionDataTask,
       |  497|            didReceiveResponse response: NSURLResponse,
       |  498|            completionHandler: ((NSURLSessionResponseDisposition) -> Void))
      0|  499|        {
      0|  500|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  501|
      0|  502|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  503|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  504|            }
      0|  505|
      0|  506|            completionHandler(disposition)
      0|  507|        }
       |  508|
       |  509|        /**
       |  510|            Tells the delegate that the data task was changed to a download task.
       |  511|
       |  512|            - parameter session:      The session containing the task that was replaced by a download task.
       |  513|            - parameter dataTask:     The data task that was replaced by a download task.
       |  514|            - parameter downloadTask: The new download task that replaced the data task.
       |  515|        */
       |  516|        public func URLSession(
       |  517|            session: NSURLSession,
       |  518|            dataTask: NSURLSessionDataTask,
       |  519|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  520|        {
      0|  521|            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
      0|  522|                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
      0|  523|            } else {
      0|  524|                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
      0|  525|                self[downloadTask] = downloadDelegate
      0|  526|            }
      0|  527|        }
       |  528|
       |  529|        /**
       |  530|            Tells the delegate that the data task has received some of the expected data.
       |  531|
       |  532|            - parameter session:  The session containing the data task that provided data.
       |  533|            - parameter dataTask: The data task that provided data.
       |  534|            - parameter data:     A data object containing the transferred data.
       |  535|        */
      1|  536|        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  537|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  538|                dataTaskDidReceiveData(session, dataTask, data)
      1|  539|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      1|  540|                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
      1|  541|            }
      1|  542|        }
       |  543|
       |  544|        /**
       |  545|            Asks the delegate whether the data (or upload) task should store the response in the cache.
       |  546|
       |  547|            - parameter session:           The session containing the data (or upload) task.
       |  548|            - parameter dataTask:          The data (or upload) task.
       |  549|            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
       |  550|                                           caching policy and the values of certain received headers, such as the Pragma 
       |  551|                                           and Cache-Control headers.
       |  552|            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
       |  553|                                           response, a modified version of that response, or NULL to prevent caching the 
       |  554|                                           response. If your delegate implements this method, it must call this completion 
       |  555|                                           handler; otherwise, your app leaks memory.
       |  556|        */
       |  557|        public func URLSession(
       |  558|            session: NSURLSession,
       |  559|            dataTask: NSURLSessionDataTask,
       |  560|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  561|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  562|        {
      0|  563|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  564|                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
      0|  565|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      0|  566|                delegate.URLSession(
      0|  567|                    session,
      0|  568|                    dataTask: dataTask,
      0|  569|                    willCacheResponse: proposedResponse,
      0|  570|                    completionHandler: completionHandler
      0|  571|                )
      0|  572|            } else {
      0|  573|                completionHandler(proposedResponse)
      0|  574|            }
      0|  575|        }
       |  576|
       |  577|        // MARK: - NSURLSessionDownloadDelegate
       |  578|
       |  579|        // MARK: Override Closures
       |  580|
       |  581|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
       |  582|        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
       |  583|
       |  584|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
       |  585|        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  586|
       |  587|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
       |  588|        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  589|
       |  590|        // MARK: Delegate Methods
       |  591|
       |  592|        /**
       |  593|            Tells the delegate that a download task has finished downloading.
       |  594|
       |  595|            - parameter session:      The session containing the download task that finished.
       |  596|            - parameter downloadTask: The download task that finished.
       |  597|            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
       |  598|                                      open the file for reading or move it to a permanent location in your app’s sandbox 
       |  599|                                      container directory before returning from this delegate method.
       |  600|        */
       |  601|        public func URLSession(
       |  602|            session: NSURLSession,
       |  603|            downloadTask: NSURLSessionDownloadTask,
       |  604|            didFinishDownloadingToURL location: NSURL)
      0|  605|        {
      0|  606|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  607|                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  608|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  609|                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
      0|  610|            }
      0|  611|        }
       |  612|
       |  613|        /**
       |  614|            Periodically informs the delegate about the download’s progress.
       |  615|
       |  616|            - parameter session:                   The session containing the download task.
       |  617|            - parameter downloadTask:              The download task.
       |  618|            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
       |  619|                                                   method was called.
       |  620|            - parameter totalBytesWritten:         The total number of bytes transferred so far.
       |  621|            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
       |  622|                                                   header. If this header was not provided, the value is 
       |  623|                                                   `NSURLSessionTransferSizeUnknown`.
       |  624|        */
       |  625|        public func URLSession(
       |  626|            session: NSURLSession,
       |  627|            downloadTask: NSURLSessionDownloadTask,
       |  628|            didWriteData bytesWritten: Int64,
       |  629|            totalBytesWritten: Int64,
       |  630|            totalBytesExpectedToWrite: Int64)
      0|  631|        {
      0|  632|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  633|                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  634|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  635|                delegate.URLSession(
      0|  636|                    session,
      0|  637|                    downloadTask: downloadTask,
      0|  638|                    didWriteData: bytesWritten,
      0|  639|                    totalBytesWritten: totalBytesWritten,
      0|  640|                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
      0|  641|                )
      0|  642|            }
      0|  643|        }
       |  644|
       |  645|        /**
       |  646|            Tells the delegate that the download task has resumed downloading.
       |  647|
       |  648|            - parameter session:            The session containing the download task that finished.
       |  649|            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
       |  650|            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
       |  651|                                            existing content, then this value is zero. Otherwise, this value is an 
       |  652|                                            integer representing the number of bytes on disk that do not need to be 
       |  653|                                            retrieved again.
       |  654|            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
       |  655|                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
       |  656|        */
       |  657|        public func URLSession(
       |  658|            session: NSURLSession,
       |  659|            downloadTask: NSURLSessionDownloadTask,
       |  660|            didResumeAtOffset fileOffset: Int64,
       |  661|            expectedTotalBytes: Int64)
      0|  662|        {
      0|  663|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  664|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  665|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  666|                delegate.URLSession(
      0|  667|                    session,
      0|  668|                    downloadTask: downloadTask,
      0|  669|                    didResumeAtOffset: fileOffset,
      0|  670|                    expectedTotalBytes: expectedTotalBytes
      0|  671|                )
      0|  672|            }
      0|  673|        }
       |  674|
       |  675|        // MARK: - NSURLSessionStreamDelegate
       |  676|
       |  677|        var _streamTaskReadClosed: Any?
       |  678|        var _streamTaskWriteClosed: Any?
       |  679|        var _streamTaskBetterRouteDiscovered: Any?
       |  680|        var _streamTaskDidBecomeInputStream: Any?
       |  681|
       |  682|        // MARK: - NSObject
       |  683|
     11|  684|        public override func respondsToSelector(selector: Selector) -> Bool {
     11|  685|            switch selector {
      0|  686|            case "URLSession:didBecomeInvalidWithError:":
      0|  687|                return sessionDidBecomeInvalidWithError != nil
      1|  688|            case "URLSession:didReceiveChallenge:completionHandler:":
      1|  689|                return sessionDidReceiveChallenge != nil
      0|  690|            case "URLSessionDidFinishEventsForBackgroundURLSession:":
      0|  691|                return sessionDidFinishEventsForBackgroundURLSession != nil
      0|  692|            case "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:":
      0|  693|                return taskWillPerformHTTPRedirection != nil
      1|  694|            case "URLSession:dataTask:didReceiveResponse:completionHandler:":
      1|  695|                return dataTaskDidReceiveResponse != nil
      9|  696|            default:
      9|  697|                return self.dynamicType.instancesRespondToSelector(selector)
     11|  698|            }
     11|  699|        }
       |  700|    }
       |  701|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/MultipartFormData.swift:
       |    1|// MultipartFormData.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if os(iOS) || os(watchOS) || os(tvOS)
       |   26|import MobileCoreServices
       |   27|#elseif os(OSX)
       |   28|import CoreServices
       |   29|#endif
       |   30|
       |   31|/**
       |   32|    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
       |   33|    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
       |   34|    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
       |   35|    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
       |   36|    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
       |   37|
       |   38|    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
       |   39|    and the w3 form documentation.
       |   40|
       |   41|    - https://www.ietf.org/rfc/rfc2388.txt
       |   42|    - https://www.ietf.org/rfc/rfc2045.txt
       |   43|    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
       |   44|*/
       |   45|public class MultipartFormData {
       |   46|
       |   47|    // MARK: - Helper Types
       |   48|
       |   49|    struct EncodingCharacters {
       |   50|        static let CRLF = "\r\n"
       |   51|    }
       |   52|
       |   53|    struct BoundaryGenerator {
       |   54|        enum BoundaryType {
       |   55|            case Initial, Encapsulated, Final
       |   56|        }
       |   57|
      0|   58|        static func randomBoundary() -> String {
      0|   59|            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
      0|   60|        }
       |   61|
      0|   62|        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
      0|   63|            let boundaryText: String
      0|   64|
      0|   65|            switch boundaryType {
      0|   66|            case .Initial:
      0|   67|                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
      0|   68|            case .Encapsulated:
      0|   69|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
      0|   70|            case .Final:
      0|   71|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
      0|   72|            }
      0|   73|
      0|   74|            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|   75|        }
       |   76|    }
       |   77|
       |   78|    class BodyPart {
       |   79|        let headers: [String: String]
       |   80|        let bodyStream: NSInputStream
       |   81|        let bodyContentLength: UInt64
       |   82|        var hasInitialBoundary = false
       |   83|        var hasFinalBoundary = false
       |   84|
      0|   85|        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
      0|   86|            self.headers = headers
      0|   87|            self.bodyStream = bodyStream
      0|   88|            self.bodyContentLength = bodyContentLength
      0|   89|        }
       |   90|    }
       |   91|
       |   92|    // MARK: - Properties
       |   93|
       |   94|    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
      0|   95|    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
       |   96|
       |   97|    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
      0|   98|    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
       |   99|
       |  100|    /// The boundary used to separate the body parts in the encoded form data.
       |  101|    public let boundary: String
       |  102|
       |  103|    private var bodyParts: [BodyPart]
       |  104|    private var bodyPartError: NSError?
       |  105|    private let streamBufferSize: Int
       |  106|
       |  107|    // MARK: - Lifecycle
       |  108|
       |  109|    /**
       |  110|        Creates a multipart form data object.
       |  111|
       |  112|        - returns: The multipart form data object.
       |  113|    */
      0|  114|    public init() {
      0|  115|        self.boundary = BoundaryGenerator.randomBoundary()
      0|  116|        self.bodyParts = []
      0|  117|
      0|  118|        /**
      0|  119|         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
      0|  120|         *  information, please refer to the following article:
      0|  121|         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
      0|  122|         */
      0|  123|
      0|  124|        self.streamBufferSize = 1024
      0|  125|    }
       |  126|
       |  127|    // MARK: - Body Parts
       |  128|
       |  129|    /**
       |  130|        Creates a body part from the data and appends it to the multipart form data object.
       |  131|
       |  132|        The body part data will be encoded using the following format:
       |  133|
       |  134|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  135|        - Encoded data
       |  136|        - Multipart form boundary
       |  137|
       |  138|        - parameter data: The data to encode into the multipart form data.
       |  139|        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
       |  140|    */
      0|  141|    public func appendBodyPart(data data: NSData, name: String) {
      0|  142|        let headers = contentHeaders(name: name)
      0|  143|        let stream = NSInputStream(data: data)
      0|  144|        let length = UInt64(data.length)
      0|  145|
      0|  146|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  147|    }
       |  148|
       |  149|    /**
       |  150|        Creates a body part from the data and appends it to the multipart form data object.
       |  151|
       |  152|        The body part data will be encoded using the following format:
       |  153|
       |  154|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  155|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  156|        - Encoded data
       |  157|        - Multipart form boundary
       |  158|
       |  159|        - parameter data:     The data to encode into the multipart form data.
       |  160|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  161|        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
       |  162|    */
      0|  163|    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
      0|  164|        let headers = contentHeaders(name: name, mimeType: mimeType)
      0|  165|        let stream = NSInputStream(data: data)
      0|  166|        let length = UInt64(data.length)
      0|  167|
      0|  168|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  169|    }
       |  170|
       |  171|    /**
       |  172|        Creates a body part from the data and appends it to the multipart form data object.
       |  173|
       |  174|        The body part data will be encoded using the following format:
       |  175|
       |  176|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  177|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  178|        - Encoded file data
       |  179|        - Multipart form boundary
       |  180|
       |  181|        - parameter data:     The data to encode into the multipart form data.
       |  182|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  183|        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
       |  184|        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
       |  185|    */
      0|  186|    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
      0|  187|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  188|        let stream = NSInputStream(data: data)
      0|  189|        let length = UInt64(data.length)
      0|  190|
      0|  191|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Creates a body part from the file and appends it to the multipart form data object.
       |  196|
       |  197|        The body part data will be encoded using the following format:
       |  198|
       |  199|        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
       |  200|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  201|        - Encoded file data
       |  202|        - Multipart form boundary
       |  203|
       |  204|        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
       |  205|        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
       |  206|        system associated MIME type.
       |  207|
       |  208|        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
       |  209|        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  210|    */
      0|  211|    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
      0|  212|        if let
      0|  213|            fileName = fileURL.lastPathComponent,
      0|  214|            pathExtension = fileURL.pathExtension
      0|  215|        {
      0|  216|            let mimeType = mimeTypeForPathExtension(pathExtension)
      0|  217|            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
      0|  218|        } else {
      0|  219|            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
      0|  220|            setBodyPartError(Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason))
      0|  221|        }
      0|  222|    }
       |  223|
       |  224|    /**
       |  225|        Creates a body part from the file and appends it to the multipart form data object.
       |  226|
       |  227|        The body part data will be encoded using the following format:
       |  228|
       |  229|        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
       |  230|        - Content-Type: #{mimeType} (HTTP Header)
       |  231|        - Encoded file data
       |  232|        - Multipart form boundary
       |  233|
       |  234|        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
       |  235|        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  236|        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
       |  237|        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
       |  238|    */
      0|  239|    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
      0|  240|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  241|
      0|  242|        //============================================================
      0|  243|        //                 Check 1 - is file URL?
      0|  244|        //============================================================
      0|  245|
      0|  246|        guard fileURL.fileURL else {
      0|  247|            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
      0|  248|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  249|            setBodyPartError(error)
      0|  250|            return
      0|  251|        }
      0|  252|
      0|  253|        //============================================================
      0|  254|        //              Check 2 - is file URL reachable?
      0|  255|        //============================================================
      0|  256|
      0|  257|        var isReachable = true
      0|  258|
      0|  259|        if #available(OSX 10.10, *) {
      0|  260|            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
      0|  261|        }
      0|  262|
      0|  263|        guard isReachable else {
      0|  264|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
      0|  265|            setBodyPartError(error)
      0|  266|            return
      0|  267|        }
      0|  268|
      0|  269|        //============================================================
      0|  270|        //            Check 3 - is file URL a directory?
      0|  271|        //============================================================
      0|  272|
      0|  273|        var isDirectory: ObjCBool = false
      0|  274|
      0|  275|        guard let
      0|  276|            path = fileURL.path
      0|  277|            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
      0|  278|        {
      0|  279|            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
      0|  280|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  281|            setBodyPartError(error)
      0|  282|            return
      0|  283|        }
      0|  284|
      0|  285|        //============================================================
      0|  286|        //          Check 4 - can the file size be extracted?
      0|  287|        //============================================================
      0|  288|
      0|  289|        var bodyContentLength: UInt64?
      0|  290|
      0|  291|        do {
      0|  292|            if let
      0|  293|                path = fileURL.path,
      0|  294|                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
      0|  295|            {
      0|  296|                bodyContentLength = fileSize.unsignedLongLongValue
      0|  297|            }
      0|  298|        } catch {
      0|  299|            // No-op
      0|  300|        }
      0|  301|
      0|  302|        guard let length = bodyContentLength else {
      0|  303|            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
      0|  304|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  305|            setBodyPartError(error)
      0|  306|            return
      0|  307|        }
      0|  308|
      0|  309|        //============================================================
      0|  310|        //       Check 5 - can a stream be created from file URL?
      0|  311|        //============================================================
      0|  312|
      0|  313|        guard let stream = NSInputStream(URL: fileURL) else {
      0|  314|            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
      0|  315|            let error = Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  316|            setBodyPartError(error)
      0|  317|            return
      0|  318|        }
      0|  319|
      0|  320|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  321|    }
       |  322|
       |  323|    /**
       |  324|        Creates a body part from the stream and appends it to the multipart form data object.
       |  325|
       |  326|        The body part data will be encoded using the following format:
       |  327|
       |  328|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  329|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  330|        - Encoded stream data
       |  331|        - Multipart form boundary
       |  332|
       |  333|        - parameter stream:   The input stream to encode in the multipart form data.
       |  334|        - parameter length:   The content length of the stream.
       |  335|        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
       |  336|        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
       |  337|        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
       |  338|    */
       |  339|    public func appendBodyPart(
       |  340|        stream stream: NSInputStream,
       |  341|        length: UInt64,
       |  342|        name: String,
       |  343|        fileName: String,
       |  344|        mimeType: String)
      0|  345|    {
      0|  346|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  347|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  348|    }
       |  349|
       |  350|    /**
       |  351|        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
       |  352|
       |  353|        The body part data will be encoded using the following format:
       |  354|
       |  355|        - HTTP headers
       |  356|        - Encoded stream data
       |  357|        - Multipart form boundary
       |  358|
       |  359|        - parameter stream:  The input stream to encode in the multipart form data.
       |  360|        - parameter length:  The content length of the stream.
       |  361|        - parameter headers: The HTTP headers for the body part.
       |  362|    */
      0|  363|    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
      0|  364|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
      0|  365|        bodyParts.append(bodyPart)
      0|  366|    }
       |  367|
       |  368|    // MARK: - Data Encoding
       |  369|
       |  370|    /**
       |  371|        Encodes all the appended body parts into a single `NSData` object.
       |  372|
       |  373|        It is important to note that this method will load all the appended body parts into memory all at the same 
       |  374|        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
       |  375|        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
       |  376|
       |  377|        - throws: An `NSError` if encoding encounters an error.
       |  378|
       |  379|        - returns: The encoded `NSData` if encoding is successful.
       |  380|    */
      0|  381|    public func encode() throws -> NSData {
      0|  382|        if let bodyPartError = bodyPartError {
      0|  383|            throw bodyPartError
      0|  384|        }
      0|  385|
      0|  386|        let encoded = NSMutableData()
      0|  387|
      0|  388|        bodyParts.first?.hasInitialBoundary = true
      0|  389|        bodyParts.last?.hasFinalBoundary = true
      0|  390|
      0|  391|        for bodyPart in bodyParts {
      0|  392|            let encodedData = try encodeBodyPart(bodyPart)
      0|  393|            encoded.appendData(encodedData)
      0|  394|        }
      0|  395|
      0|  396|        return encoded
      0|  397|    }
       |  398|
       |  399|    /**
       |  400|        Writes the appended body parts into the given file URL.
       |  401|
       |  402|        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
       |  403|        this approach is very memory efficient and should be used for large body part data.
       |  404|
       |  405|        - parameter fileURL: The file URL to write the multipart form data into.
       |  406|
       |  407|        - throws: An `NSError` if encoding encounters an error.
       |  408|    */
      0|  409|    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
      0|  410|        if let bodyPartError = bodyPartError {
      0|  411|            throw bodyPartError
      0|  412|        }
      0|  413|
      0|  414|        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
      0|  415|            let failureReason = "A file already exists at the given file URL: \(fileURL)"
      0|  416|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  417|        } else if !fileURL.fileURL {
      0|  418|            let failureReason = "The URL does not point to a valid file: \(fileURL)"
      0|  419|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  420|        }
      0|  421|
      0|  422|        let outputStream: NSOutputStream
      0|  423|
      0|  424|        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
      0|  425|            outputStream = possibleOutputStream
      0|  426|        } else {
      0|  427|            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
      0|  428|            throw Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  429|        }
      0|  430|
      0|  431|        outputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  432|        outputStream.open()
      0|  433|
      0|  434|        self.bodyParts.first?.hasInitialBoundary = true
      0|  435|        self.bodyParts.last?.hasFinalBoundary = true
      0|  436|
      0|  437|        for bodyPart in self.bodyParts {
      0|  438|            try writeBodyPart(bodyPart, toOutputStream: outputStream)
      0|  439|        }
      0|  440|
      0|  441|        outputStream.close()
      0|  442|        outputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  443|    }
       |  444|
       |  445|    // MARK: - Private - Body Part Encoding
       |  446|
      0|  447|    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  448|        let encoded = NSMutableData()
      0|  449|
      0|  450|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  451|        encoded.appendData(initialData)
      0|  452|
      0|  453|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  454|        encoded.appendData(headerData)
      0|  455|
      0|  456|        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
      0|  457|        encoded.appendData(bodyStreamData)
      0|  458|
      0|  459|        if bodyPart.hasFinalBoundary {
      0|  460|            encoded.appendData(finalBoundaryData())
      0|  461|        }
      0|  462|
      0|  463|        return encoded
      0|  464|    }
       |  465|
      0|  466|    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
      0|  467|        var headerText = ""
      0|  468|
      0|  469|        for (key, value) in bodyPart.headers {
      0|  470|            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
      0|  471|        }
      0|  472|        headerText += EncodingCharacters.CRLF
      0|  473|
      0|  474|        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|  475|    }
       |  476|
      0|  477|    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  478|        let inputStream = bodyPart.bodyStream
      0|  479|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  480|        inputStream.open()
      0|  481|
      0|  482|        var error: NSError?
      0|  483|        let encoded = NSMutableData()
      0|  484|
      0|  485|        while inputStream.hasBytesAvailable {
      0|  486|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  487|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  488|
      0|  489|            if inputStream.streamError != nil {
      0|  490|                error = inputStream.streamError
      0|  491|                break
      0|  492|            }
      0|  493|
      0|  494|            if bytesRead > 0 {
      0|  495|                encoded.appendBytes(buffer, length: bytesRead)
      0|  496|            } else if bytesRead < 0 {
      0|  497|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  498|                error = Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  499|                break
      0|  500|            } else {
      0|  501|                break
      0|  502|            }
      0|  503|        }
      0|  504|
      0|  505|        inputStream.close()
      0|  506|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  507|
      0|  508|        if let error = error {
      0|  509|            throw error
      0|  510|        }
      0|  511|
      0|  512|        return encoded
      0|  513|    }
       |  514|
       |  515|    // MARK: - Private - Writing Body Part to Output Stream
       |  516|
      0|  517|    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  518|        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  519|        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  520|        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  521|        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  522|    }
       |  523|
       |  524|    private func writeInitialBoundaryDataForBodyPart(
       |  525|        bodyPart: BodyPart,
       |  526|        toOutputStream outputStream: NSOutputStream)
       |  527|        throws
      0|  528|    {
      0|  529|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  530|        return try writeData(initialData, toOutputStream: outputStream)
      0|  531|    }
       |  532|
      0|  533|    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  534|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  535|        return try writeData(headerData, toOutputStream: outputStream)
      0|  536|    }
       |  537|
      0|  538|    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  539|        let inputStream = bodyPart.bodyStream
      0|  540|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  541|        inputStream.open()
      0|  542|
      0|  543|        while inputStream.hasBytesAvailable {
      0|  544|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  545|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  546|
      0|  547|            if let streamError = inputStream.streamError {
      0|  548|                throw streamError
      0|  549|            }
      0|  550|
      0|  551|            if bytesRead > 0 {
      0|  552|                if buffer.count != bytesRead {
      0|  553|                    buffer = Array(buffer[0..<bytesRead])
      0|  554|                }
      0|  555|
      0|  556|                try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  557|            } else if bytesRead < 0 {
      0|  558|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  559|                throw Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  560|            } else {
      0|  561|                break
      0|  562|            }
      0|  563|        }
      0|  564|
      0|  565|        inputStream.close()
      0|  566|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  567|    }
       |  568|
       |  569|    private func writeFinalBoundaryDataForBodyPart(
       |  570|        bodyPart: BodyPart,
       |  571|        toOutputStream outputStream: NSOutputStream)
       |  572|        throws
      0|  573|    {
      0|  574|        if bodyPart.hasFinalBoundary {
      0|  575|            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
      0|  576|        }
      0|  577|    }
       |  578|
       |  579|    // MARK: - Private - Writing Buffered Data to Output Stream
       |  580|
      0|  581|    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
      0|  582|        var buffer = [UInt8](count: data.length, repeatedValue: 0)
      0|  583|        data.getBytes(&buffer, length: data.length)
      0|  584|
      0|  585|        return try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  586|    }
       |  587|
      0|  588|    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
      0|  589|        var bytesToWrite = buffer.count
      0|  590|
      0|  591|        while bytesToWrite > 0 {
      0|  592|            if outputStream.hasSpaceAvailable {
      0|  593|                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
      0|  594|
      0|  595|                if let streamError = outputStream.streamError {
      0|  596|                    throw streamError
      0|  597|                }
      0|  598|
      0|  599|                if bytesWritten < 0 {
      0|  600|                    let failureReason = "Failed to write to output stream: \(outputStream)"
      0|  601|                    throw Error.errorWithCode(.OutputStreamWriteFailed, failureReason: failureReason)
      0|  602|                }
      0|  603|
      0|  604|                bytesToWrite -= bytesWritten
      0|  605|
      0|  606|                if bytesToWrite > 0 {
      0|  607|                    buffer = Array(buffer[bytesWritten..<buffer.count])
      0|  608|                }
      0|  609|            } else if let streamError = outputStream.streamError {
      0|  610|                throw streamError
      0|  611|            }
      0|  612|        }
      0|  613|    }
       |  614|
       |  615|    // MARK: - Private - Mime Type
       |  616|
      0|  617|    private func mimeTypeForPathExtension(pathExtension: String) -> String {
      0|  618|        if let
      0|  619|            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
      0|  620|            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
      0|  621|        {
      0|  622|            return contentType as String
      0|  623|        }
      0|  624|
      0|  625|        return "application/octet-stream"
      0|  626|    }
       |  627|
       |  628|    // MARK: - Private - Content Headers
       |  629|
      0|  630|    private func contentHeaders(name name: String) -> [String: String] {
      0|  631|        return ["Content-Disposition": "form-data; name=\"\(name)\""]
      0|  632|    }
       |  633|
      0|  634|    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
      0|  635|        return [
      0|  636|            "Content-Disposition": "form-data; name=\"\(name)\"",
      0|  637|            "Content-Type": "\(mimeType)"
      0|  638|        ]
      0|  639|    }
       |  640|
      0|  641|    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
      0|  642|        return [
      0|  643|            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
      0|  644|            "Content-Type": "\(mimeType)"
      0|  645|        ]
      0|  646|    }
       |  647|
       |  648|    // MARK: - Private - Boundary Encoding
       |  649|
      0|  650|    private func initialBoundaryData() -> NSData {
      0|  651|        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
      0|  652|    }
       |  653|
      0|  654|    private func encapsulatedBoundaryData() -> NSData {
      0|  655|        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
      0|  656|    }
       |  657|
      0|  658|    private func finalBoundaryData() -> NSData {
      0|  659|        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
      0|  660|    }
       |  661|
       |  662|    // MARK: - Private - Errors
       |  663|
      0|  664|    private func setBodyPartError(error: NSError) {
      0|  665|        if bodyPartError == nil {
      0|  666|            bodyPartError = error
      0|  667|        }
      0|  668|    }
       |  669|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ParameterEncoding.swift:
       |    1|// ParameterEncoding.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    HTTP method definitions.
       |   27|
       |   28|    See https://tools.ietf.org/html/rfc7231#section-4.3
       |   29|*/
       |   30|public enum Method: String {
       |   31|    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
       |   32|}
       |   33|
       |   34|// MARK: ParameterEncoding
       |   35|
       |   36|/**
       |   37|    Used to specify the way in which a set of parameters are applied to a URL request.
       |   38|
       |   39|    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
       |   40|                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
       |   41|                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
       |   42|                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
       |   43|                         for how to encode collection types, the convention of appending `[]` to the key for array
       |   44|                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
       |   45|                         dictionary values (`foo[bar]=baz`).
       |   46|
       |   47|    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
       |   48|                         implementation as the `.URL` case, but always applies the encoded result to the URL.
       |   49|
       |   50|    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
       |   51|                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
       |   52|                         set to `application/json`.
       |   53|
       |   54|    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
       |   55|                         according to the associated format and write options values, which is set as the body of the
       |   56|                         request. The `Content-Type` HTTP header field of an encoded request is set to
       |   57|                         `application/x-plist`.
       |   58|
       |   59|    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
       |   60|                         parameters.
       |   61|*/
       |   62|public enum ParameterEncoding {
       |   63|    case URL
       |   64|    case URLEncodedInURL
       |   65|    case JSON
       |   66|    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
       |   67|    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
       |   68|
       |   69|    /**
       |   70|        Creates a URL request by encoding parameters and applying them onto an existing request.
       |   71|
       |   72|        - parameter URLRequest: The request to have parameters applied
       |   73|        - parameter parameters: The parameters to apply
       |   74|
       |   75|        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
       |   76|                   if any.
       |   77|    */
       |   78|    public func encode(
       |   79|        URLRequest: URLRequestConvertible,
       |   80|        parameters: [String: AnyObject]?)
       |   81|        -> (NSMutableURLRequest, NSError?)
      1|   82|    {
      1|   83|        var mutableURLRequest = URLRequest.URLRequest
      1|   84|
      0|   85|        guard let parameters = parameters where !parameters.isEmpty else {
      0|   86|            return (mutableURLRequest, nil)
      0|   87|        }
      1|   88|
      1|   89|        var encodingError: NSError? = nil
      1|   90|
      1|   91|        switch self {
      0|   92|        case .URL, .URLEncodedInURL:
      0|   93|            func query(parameters: [String: AnyObject]) -> String {
      0|   94|                var components: [(String, String)] = []
      0|   95|
      0|   96|                for key in parameters.keys.sort(<) {
      0|   97|                    let value = parameters[key]!
      0|   98|                    components += queryComponents(key, value)
      0|   99|                }
      0|  100|
      0|  101|                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
      0|  102|            }
      0|  103|
      0|  104|            func encodesParametersInURL(method: Method) -> Bool {
      0|  105|                switch self {
      0|  106|                case .URLEncodedInURL:
      0|  107|                    return true
      0|  108|                default:
      0|  109|                    break
      0|  110|                }
      0|  111|
      0|  112|                switch method {
      0|  113|                case .GET, .HEAD, .DELETE:
      0|  114|                    return true
      0|  115|                default:
      0|  116|                    return false
      0|  117|                }
      0|  118|            }
      0|  119|
      0|  120|            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
      0|  121|                if let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false) {
      0|  122|                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
      0|  123|                    URLComponents.percentEncodedQuery = percentEncodedQuery
      0|  124|                    mutableURLRequest.URL = URLComponents.URL
      0|  125|                }
      0|  126|            } else {
      0|  127|                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
      0|  128|                    mutableURLRequest.setValue(
      0|  129|                        "application/x-www-form-urlencoded; charset=utf-8",
      0|  130|                        forHTTPHeaderField: "Content-Type"
      0|  131|                    )
      0|  132|                }
      0|  133|
      0|  134|                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
      0|  135|                    NSUTF8StringEncoding,
      0|  136|                    allowLossyConversion: false
      0|  137|                )
      0|  138|            }
      1|  139|        case .JSON:
      1|  140|            do {
      1|  141|                let options = NSJSONWritingOptions()
      1|  142|                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
      1|  143|
      1|  144|                mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
      1|  145|                mutableURLRequest.HTTPBody = data
      0|  146|            } catch {
      0|  147|                encodingError = error as NSError
      0|  148|            }
      0|  149|        case .PropertyList(let format, let options):
      0|  150|            do {
      0|  151|                let data = try NSPropertyListSerialization.dataWithPropertyList(
      0|  152|                    parameters,
      0|  153|                    format: format,
      0|  154|                    options: options
      0|  155|                )
      0|  156|                mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
      0|  157|                mutableURLRequest.HTTPBody = data
      0|  158|            } catch {
      0|  159|                encodingError = error as NSError
      0|  160|            }
      0|  161|        case .Custom(let closure):
      0|  162|            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
      1|  163|        }
      1|  164|
      1|  165|        return (mutableURLRequest, encodingError)
      1|  166|    }
       |  167|
       |  168|    /**
       |  169|        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
       |  170|
       |  171|        - parameter key:   The key of the query component.
       |  172|        - parameter value: The value of the query component.
       |  173|
       |  174|        - returns: The percent-escaped, URL encoded query string components.
       |  175|    */
      0|  176|    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
      0|  177|        var components: [(String, String)] = []
      0|  178|
      0|  179|        if let dictionary = value as? [String: AnyObject] {
      0|  180|            for (nestedKey, value) in dictionary {
      0|  181|                components += queryComponents("\(key)[\(nestedKey)]", value)
      0|  182|            }
      0|  183|        } else if let array = value as? [AnyObject] {
      0|  184|            for value in array {
      0|  185|                components += queryComponents("\(key)[]", value)
      0|  186|            }
      0|  187|        } else {
      0|  188|            components.append((escape(key), escape("\(value)")))
      0|  189|        }
      0|  190|
      0|  191|        return components
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Returns a percent-escaped string following RFC 3986 for a query string key or value.
       |  196|
       |  197|        RFC 3986 states that the following characters are "reserved" characters.
       |  198|
       |  199|        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
       |  200|        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
       |  201|
       |  202|        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
       |  203|        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
       |  204|        should be percent-escaped in the query string.
       |  205|
       |  206|        - parameter string: The string to be percent-escaped.
       |  207|
       |  208|        - returns: The percent-escaped string.
       |  209|    */
      0|  210|    public func escape(string: String) -> String {
      0|  211|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
      0|  212|        let subDelimitersToEncode = "!$&'()*+,;="
      0|  213|
      0|  214|        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
      0|  215|        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
      0|  216|
      0|  217|        var escaped = ""
      0|  218|
      0|  219|        //==========================================================================================================
      0|  220|        //
      0|  221|        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
      0|  222|        //  hundred Chinense characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
      0|  223|        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
      0|  224|        //  info, please refer to:
      0|  225|        //
      0|  226|        //      - https://github.com/Alamofire/Alamofire/issues/206
      0|  227|        //
      0|  228|        //==========================================================================================================
      0|  229|
      0|  230|        if #available(iOS 8.3, OSX 10.10, *) {
      0|  231|            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
      0|  232|        } else {
      0|  233|            let batchSize = 50
      0|  234|            var index = string.startIndex
      0|  235|
      0|  236|            while index != string.endIndex {
      0|  237|                let startIndex = index
      0|  238|                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
      0|  239|                let range = Range(start: startIndex, end: endIndex)
      0|  240|
      0|  241|                let substring = string.substringWithRange(range)
      0|  242|
      0|  243|                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
      0|  244|
      0|  245|                index = endIndex
      0|  246|            }
      0|  247|        }
      0|  248|
      0|  249|        return escaped
      0|  250|    }
       |  251|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Request.swift:
       |    1|// Request.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for sending a request and receiving the response and associated data from the server, as well as 
       |   27|    managing its underlying `NSURLSessionTask`.
       |   28|*/
       |   29|public class Request {
       |   30|
       |   31|    // MARK: - Properties
       |   32|
       |   33|    /// The delegate for the underlying task.
       |   34|    public let delegate: TaskDelegate
       |   35|
       |   36|    /// The underlying task.
      5|   37|    public var task: NSURLSessionTask { return delegate.task }
       |   38|
       |   39|    /// The session belonging to the underlying task.
       |   40|    public let session: NSURLSession
       |   41|
       |   42|    /// The request sent or to be sent to the server.
      2|   43|    public var request: NSURLRequest? { return task.originalRequest }
       |   44|
       |   45|    /// The response received from the server, if any.
      2|   46|    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
       |   47|
       |   48|    /// The progress of the request lifecycle.
      0|   49|    public var progress: NSProgress { return delegate.progress }
       |   50|
       |   51|    // MARK: - Lifecycle
       |   52|
      1|   53|    init(session: NSURLSession, task: NSURLSessionTask) {
      1|   54|        self.session = session
      1|   55|
      1|   56|        switch task {
      0|   57|        case is NSURLSessionUploadTask:
      0|   58|            self.delegate = UploadTaskDelegate(task: task)
      1|   59|        case is NSURLSessionDataTask:
      1|   60|            self.delegate = DataTaskDelegate(task: task)
      0|   61|        case is NSURLSessionDownloadTask:
      0|   62|            self.delegate = DownloadTaskDelegate(task: task)
      0|   63|        default:
      0|   64|            self.delegate = TaskDelegate(task: task)
      1|   65|        }
      1|   66|    }
       |   67|
       |   68|    // MARK: - Authentication
       |   69|
       |   70|    /**
       |   71|        Associates an HTTP Basic credential with the request.
       |   72|
       |   73|        - parameter user:        The user.
       |   74|        - parameter password:    The password.
       |   75|        - parameter persistence: The URL credential persistence. `.ForSession` by default.
       |   76|
       |   77|        - returns: The request.
       |   78|    */
       |   79|    public func authenticate(
       |   80|        user user: String,
       |   81|        password: String,
       |   82|        persistence: NSURLCredentialPersistence = .ForSession)
       |   83|        -> Self
      0|   84|    {
      0|   85|        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
      0|   86|
      0|   87|        return authenticate(usingCredential: credential)
      0|   88|    }
       |   89|
       |   90|    /**
       |   91|        Associates a specified credential with the request.
       |   92|
       |   93|        - parameter credential: The credential.
       |   94|
       |   95|        - returns: The request.
       |   96|    */
      0|   97|    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
      0|   98|        delegate.credential = credential
      0|   99|
      0|  100|        return self
      0|  101|    }
       |  102|
       |  103|    // MARK: - Progress
       |  104|
       |  105|    /**
       |  106|        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
       |  107|        from the server.
       |  108|
       |  109|        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
       |  110|          to write.
       |  111|        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
       |  112|          expected to read.
       |  113|
       |  114|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  115|
       |  116|        - returns: The request.
       |  117|    */
      0|  118|    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
      0|  119|        if let uploadDelegate = delegate as? UploadTaskDelegate {
      0|  120|            uploadDelegate.uploadProgress = closure
      0|  121|        } else if let dataDelegate = delegate as? DataTaskDelegate {
      0|  122|            dataDelegate.dataProgress = closure
      0|  123|        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
      0|  124|            downloadDelegate.downloadProgress = closure
      0|  125|        }
      0|  126|
      0|  127|        return self
      0|  128|    }
       |  129|
       |  130|    /**
       |  131|        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
       |  132|
       |  133|        This closure returns the bytes most recently received from the server, not including data from previous calls. 
       |  134|        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
       |  135|        also important to note that the `response` closure will be called with nil `responseData`.
       |  136|
       |  137|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  138|
       |  139|        - returns: The request.
       |  140|    */
      0|  141|    public func stream(closure: (NSData -> Void)? = nil) -> Self {
      0|  142|        if let dataDelegate = delegate as? DataTaskDelegate {
      0|  143|            dataDelegate.dataStream = closure
      0|  144|        }
      0|  145|
      0|  146|        return self
      0|  147|    }
       |  148|
       |  149|    // MARK: - State
       |  150|
       |  151|    /**
       |  152|        Suspends the request.
       |  153|    */
      0|  154|    public func suspend() {
      0|  155|        task.suspend()
      0|  156|    }
       |  157|
       |  158|    /**
       |  159|        Resumes the request.
       |  160|    */
      1|  161|    public func resume() {
      1|  162|        task.resume()
      1|  163|    }
       |  164|
       |  165|    /**
       |  166|        Cancels the request.
       |  167|    */
      0|  168|    public func cancel() {
      0|  169|        if let
      0|  170|            downloadDelegate = delegate as? DownloadTaskDelegate,
      0|  171|            downloadTask = downloadDelegate.downloadTask
      0|  172|        {
      0|  173|            downloadTask.cancelByProducingResumeData { data in
      0|  174|                downloadDelegate.resumeData = data
      0|  175|            }
      0|  176|        } else {
      0|  177|            task.cancel()
      0|  178|        }
      0|  179|    }
       |  180|
       |  181|    // MARK: - TaskDelegate
       |  182|
       |  183|    /**
       |  184|        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
       |  185|        executing all operations attached to the serial operation queue upon task completion.
       |  186|    */
       |  187|    public class TaskDelegate: NSObject {
       |  188|
       |  189|        /// The serial operation queue used to execute all operations after the task completes.
       |  190|        public let queue: NSOperationQueue
       |  191|
       |  192|        let task: NSURLSessionTask
       |  193|        let progress: NSProgress
       |  194|
      0|  195|        var data: NSData? { return nil }
       |  196|        var error: NSError?
       |  197|
       |  198|        var credential: NSURLCredential?
       |  199|
      1|  200|        init(task: NSURLSessionTask) {
      1|  201|            self.task = task
      1|  202|            self.progress = NSProgress(totalUnitCount: 0)
      1|  203|            self.queue = {
      1|  204|                let operationQueue = NSOperationQueue()
      1|  205|                operationQueue.maxConcurrentOperationCount = 1
      1|  206|                operationQueue.suspended = true
      1|  207|
      1|  208|                if #available(OSX 10.10, *) {
      1|  209|                    operationQueue.qualityOfService = NSQualityOfService.Utility
      1|  210|                }
      1|  211|
      1|  212|                return operationQueue
      1|  213|            }()
      1|  214|        }
       |  215|
      0|  216|        deinit {
      0|  217|            queue.cancelAllOperations()
      0|  218|            queue.suspended = false
      0|  219|        }
       |  220|
       |  221|        // MARK: - NSURLSessionTaskDelegate
       |  222|
       |  223|        // MARK: Override Closures
       |  224|
       |  225|        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  226|        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  227|        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
       |  228|        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  229|
       |  230|        // MARK: Delegate Methods
       |  231|
       |  232|        func URLSession(
       |  233|            session: NSURLSession,
       |  234|            task: NSURLSessionTask,
       |  235|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  236|            newRequest request: NSURLRequest,
       |  237|            completionHandler: ((NSURLRequest?) -> Void))
      0|  238|        {
      0|  239|            var redirectRequest: NSURLRequest? = request
      0|  240|
      0|  241|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  242|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  243|            }
      0|  244|
      0|  245|            completionHandler(redirectRequest)
      0|  246|        }
       |  247|
       |  248|        func URLSession(
       |  249|            session: NSURLSession,
       |  250|            task: NSURLSessionTask,
       |  251|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  252|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  253|        {
      1|  254|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      1|  255|            var credential: NSURLCredential?
      1|  256|
      0|  257|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  258|                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
      1|  259|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      1|  260|                let host = challenge.protectionSpace.host
      1|  261|
      1|  262|                if let
      1|  263|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      1|  264|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  265|                {
      0|  266|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  267|                        disposition = .UseCredential
      0|  268|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  269|                    } else {
      0|  270|                        disposition = .CancelAuthenticationChallenge
      0|  271|                    }
      0|  272|                }
      0|  273|            } else {
      0|  274|                if challenge.previousFailureCount > 0 {
      0|  275|                    disposition = .CancelAuthenticationChallenge
      0|  276|                } else {
      0|  277|                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
      0|  278|
      0|  279|                    if credential != nil {
      0|  280|                        disposition = .UseCredential
      0|  281|                    }
      0|  282|                }
      0|  283|            }
      1|  284|
      1|  285|            completionHandler(disposition, credential)
      1|  286|        }
       |  287|
       |  288|        func URLSession(
       |  289|            session: NSURLSession,
       |  290|            task: NSURLSessionTask,
       |  291|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  292|        {
      0|  293|            var bodyStream: NSInputStream?
      0|  294|
      0|  295|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  296|                bodyStream = taskNeedNewBodyStream(session, task)
      0|  297|            }
      0|  298|
      0|  299|            completionHandler(bodyStream)
      0|  300|        }
       |  301|
      1|  302|        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  303|            if let taskDidCompleteWithError = taskDidCompleteWithError {
      0|  304|                taskDidCompleteWithError(session, task, error)
      1|  305|            } else {
      0|  306|                if let error = error {
      0|  307|                    self.error = error
      0|  308|
      0|  309|                    if let
      0|  310|                        downloadDelegate = self as? DownloadTaskDelegate,
      0|  311|                        userInfo = error.userInfo as? [String: AnyObject],
      0|  312|                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
      0|  313|                    {
      0|  314|                        downloadDelegate.resumeData = resumeData
      0|  315|                    }
      0|  316|                }
      1|  317|
      1|  318|                queue.suspended = false
      1|  319|            }
      1|  320|        }
       |  321|    }
       |  322|
       |  323|    // MARK: - DataTaskDelegate
       |  324|
       |  325|    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
      0|  326|        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
       |  327|
       |  328|        private var totalBytesReceived: Int64 = 0
       |  329|        private var mutableData: NSMutableData
      2|  330|        override var data: NSData? {
      0|  331|            if dataStream != nil {
      0|  332|                return nil
      2|  333|            } else {
      2|  334|                return mutableData
      2|  335|            }
      0|  336|        }
       |  337|
       |  338|        private var expectedContentLength: Int64?
       |  339|        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
       |  340|        private var dataStream: ((data: NSData) -> Void)?
       |  341|
      1|  342|        override init(task: NSURLSessionTask) {
      1|  343|            mutableData = NSMutableData()
      1|  344|            super.init(task: task)
      1|  345|        }
       |  346|
       |  347|        // MARK: - NSURLSessionDataDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  352|        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  353|        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  354|        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
       |  355|
       |  356|        // MARK: Delegate Methods
       |  357|
       |  358|        func URLSession(
       |  359|            session: NSURLSession,
       |  360|            dataTask: NSURLSessionDataTask,
       |  361|            didReceiveResponse response: NSURLResponse,
       |  362|            completionHandler: (NSURLSessionResponseDisposition -> Void))
      0|  363|        {
      0|  364|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  365|
      0|  366|            expectedContentLength = response.expectedContentLength
      0|  367|
      0|  368|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  369|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  370|            }
      0|  371|
      0|  372|            completionHandler(disposition)
      0|  373|        }
       |  374|
       |  375|        func URLSession(
       |  376|            session: NSURLSession,
       |  377|            dataTask: NSURLSessionDataTask,
       |  378|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  379|        {
      0|  380|            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
      0|  381|        }
       |  382|
      1|  383|        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  384|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  385|                dataTaskDidReceiveData(session, dataTask, data)
      1|  386|            } else {
      0|  387|                if let dataStream = dataStream {
      0|  388|                    dataStream(data: data)
      1|  389|                } else {
      1|  390|                    mutableData.appendData(data)
      1|  391|                }
      1|  392|
      1|  393|                totalBytesReceived += data.length
      0|  394|                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
      1|  395|
      1|  396|                progress.totalUnitCount = totalBytesExpected
      1|  397|                progress.completedUnitCount = totalBytesReceived
      1|  398|
      1|  399|                dataProgress?(
      1|  400|                    bytesReceived: Int64(data.length),
      1|  401|                    totalBytesReceived: totalBytesReceived,
      1|  402|                    totalBytesExpectedToReceive: totalBytesExpected
      1|  403|                )
      1|  404|            }
      1|  405|        }
       |  406|
       |  407|        func URLSession(
       |  408|            session: NSURLSession,
       |  409|            dataTask: NSURLSessionDataTask,
       |  410|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  411|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  412|        {
      0|  413|            var cachedResponse: NSCachedURLResponse? = proposedResponse
      0|  414|
      0|  415|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  416|                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
      0|  417|            }
      0|  418|
      0|  419|            completionHandler(cachedResponse)
      0|  420|        }
       |  421|    }
       |  422|}
       |  423|
       |  424|// MARK: - CustomStringConvertible
       |  425|
       |  426|extension Request: CustomStringConvertible {
       |  427|
       |  428|    /**
       |  429|        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
       |  430|        well as the response status code if a response has been received.
       |  431|    */
      0|  432|    public var description: String {
      0|  433|        var components: [String] = []
      0|  434|
      0|  435|        if let HTTPMethod = request?.HTTPMethod {
      0|  436|            components.append(HTTPMethod)
      0|  437|        }
      0|  438|
      0|  439|        if let URLString = request?.URL?.absoluteString {
      0|  440|            components.append(URLString)
      0|  441|        }
      0|  442|
      0|  443|        if let response = response {
      0|  444|            components.append("(\(response.statusCode))")
      0|  445|        }
      0|  446|
      0|  447|        return components.joinWithSeparator(" ")
      0|  448|    }
       |  449|}
       |  450|
       |  451|// MARK: - CustomDebugStringConvertible
       |  452|
       |  453|extension Request: CustomDebugStringConvertible {
      0|  454|    func cURLRepresentation() -> String {
      0|  455|        var components = ["$ curl -i"]
      0|  456|
      0|  457|        guard let request = self.request else {
      0|  458|            return "$ curl command could not be created"
      0|  459|        }
      0|  460|
      0|  461|        let URL = request.URL
      0|  462|
      0|  463|        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
      0|  464|            components.append("-X \(HTTPMethod)")
      0|  465|        }
      0|  466|
      0|  467|        if let credentialStorage = self.session.configuration.URLCredentialStorage {
      0|  468|            let protectionSpace = NSURLProtectionSpace(
      0|  469|                host: URL!.host!,
      0|  470|                port: URL!.port?.integerValue ?? 0,
      0|  471|                `protocol`: URL!.scheme,
      0|  472|                realm: URL!.host!,
      0|  473|                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
      0|  474|            )
      0|  475|
      0|  476|            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
      0|  477|                for credential in credentials {
      0|  478|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  479|                }
      0|  480|            } else {
      0|  481|                if let credential = delegate.credential {
      0|  482|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  483|                }
      0|  484|            }
      0|  485|        }
      0|  486|
      0|  487|        if session.configuration.HTTPShouldSetCookies {
      0|  488|            if let
      0|  489|                cookieStorage = session.configuration.HTTPCookieStorage,
      0|  490|                cookies = cookieStorage.cookiesForURL(URL!) where !cookies.isEmpty
      0|  491|            {
      0|  492|                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
      0|  493|                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
      0|  494|            }
      0|  495|        }
      0|  496|
      0|  497|        if let headerFields = request.allHTTPHeaderFields {
      0|  498|            for (field, value) in headerFields {
      0|  499|                switch field {
      0|  500|                case "Cookie":
      0|  501|                    continue
      0|  502|                default:
      0|  503|                    components.append("-H \"\(field): \(value)\"")
      0|  504|                }
      0|  505|            }
      0|  506|        }
      0|  507|
      0|  508|        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
      0|  509|            for (field, value) in additionalHeaders {
      0|  510|                switch field {
      0|  511|                case "Cookie":
      0|  512|                    continue
      0|  513|                default:
      0|  514|                    components.append("-H \"\(field): \(value)\"")
      0|  515|                }
      0|  516|            }
      0|  517|        }
      0|  518|
      0|  519|        if let
      0|  520|            HTTPBodyData = request.HTTPBody,
      0|  521|            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
      0|  522|        {
      0|  523|            let escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
      0|  524|            components.append("-d \"\(escapedBody)\"")
      0|  525|        }
      0|  526|
      0|  527|        components.append("\"\(URL!.absoluteString)\"")
      0|  528|
      0|  529|        return components.joinWithSeparator(" \\\n\t")
      0|  530|    }
       |  531|
       |  532|    /// The textual representation used when written to an output stream, in the form of a cURL command.
      0|  533|    public var debugDescription: String {
      0|  534|        return cURLRepresentation()
      0|  535|    }
       |  536|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Response.swift:
       |    1|// Response.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Used to store all response data returned from a completed `Request`.
       |   26|public struct Response<Value, Error: ErrorType> {
       |   27|    /// The URL request sent to the server.
       |   28|    public let request: NSURLRequest?
       |   29|
       |   30|    /// The server's response to the URL request.
       |   31|    public let response: NSHTTPURLResponse?
       |   32|
       |   33|    /// The data returned by the server.
       |   34|    public let data: NSData?
       |   35|
       |   36|    /// The result of response serialization.
       |   37|    public let result: Result<Value, Error>
       |   38|
       |   39|    /**
       |   40|        Initializes the `Response` instance with the specified URL request, URL response, server data and response
       |   41|        serialization result.
       |   42|    
       |   43|        - parameter request:  The URL request sent to the server.
       |   44|        - parameter response: The server's response to the URL request.
       |   45|        - parameter data:     The data returned by the server.
       |   46|        - parameter result:   The result of response serialization.
       |   47|    
       |   48|        - returns: the new `Response` instance.
       |   49|    */
      1|   50|    public init(request: NSURLRequest?, response: NSHTTPURLResponse?, data: NSData?, result: Result<Value, Error>) {
      1|   51|        self.request = request
      1|   52|        self.response = response
      1|   53|        self.data = data
      1|   54|        self.result = result
      1|   55|    }
       |   56|}
       |   57|
       |   58|// MARK: - CustomStringConvertible
       |   59|
       |   60|extension Response: CustomStringConvertible {
       |   61|    /// The textual representation used when written to an output stream, which includes whether the result was a
       |   62|    /// success or failure.
      0|   63|    public var description: String {
      0|   64|        return result.debugDescription
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - CustomDebugStringConvertible
       |   69|
       |   70|extension Response: CustomDebugStringConvertible {
       |   71|    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
       |   72|    /// response, the server data and the response serialization result.
      0|   73|    public var debugDescription: String {
      0|   74|        var output: [String] = []
      0|   75|
      0|   76|        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
      0|   77|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
      0|   78|        output.append("[Data]: \(data?.length ?? 0) bytes")
      0|   79|        output.append("[Result]: \(result.debugDescription)")
      0|   80|
      0|   81|        return output.joinWithSeparator("\n")
      0|   82|    }
       |   83|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ResponseSerialization.swift:
       |    1|// ResponseSerialization.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: ResponseSerializer
       |   26|
       |   27|/**
       |   28|    The type in which all response serializers must conform to in order to serialize a response.
       |   29|*/
       |   30|public protocol ResponseSerializerType {
       |   31|    /// The type of serialized object to be created by this `ResponseSerializerType`.
       |   32|    typealias SerializedObject
       |   33|
       |   34|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   35|    typealias ErrorObject: ErrorType
       |   36|
       |   37|    /**
       |   38|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   39|    */
       |   40|    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
       |   41|}
       |   42|
       |   43|// MARK: -
       |   44|
       |   45|/**
       |   46|    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
       |   47|*/
       |   48|public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
       |   49|    /// The type of serialized object to be created by this `ResponseSerializer`.
       |   50|    public typealias SerializedObject = Value
       |   51|
       |   52|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   53|    public typealias ErrorObject = Error
       |   54|
       |   55|    /**
       |   56|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   57|    */
       |   58|    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
       |   59|
       |   60|    /**
       |   61|        Initializes the `ResponseSerializer` instance with the given serialize response closure.
       |   62|
       |   63|        - parameter serializeResponse: The closure used to serialize the response.
       |   64|
       |   65|        - returns: The new generic response serializer instance.
       |   66|    */
      1|   67|    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
      1|   68|        self.serializeResponse = serializeResponse
      1|   69|    }
       |   70|}
       |   71|
       |   72|// MARK: - Default
       |   73|
       |   74|extension Request {
       |   75|
       |   76|    /**
       |   77|        Adds a handler to be called once the request has finished.
       |   78|
       |   79|        - parameter queue:             The queue on which the completion handler is dispatched.
       |   80|        - parameter completionHandler: The code to be executed once the request has finished.
       |   81|
       |   82|        - returns: The request.
       |   83|    */
       |   84|    public func response(
       |   85|        queue queue: dispatch_queue_t? = nil,
       |   86|        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
       |   87|        -> Self
      0|   88|    {
      0|   89|        delegate.queue.addOperationWithBlock {
      0|   90|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      0|   91|                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
      0|   92|            }
      0|   93|        }
      0|   94|
      0|   95|        return self
      0|   96|    }
       |   97|
       |   98|    /**
       |   99|        Adds a handler to be called once the request has finished.
       |  100|
       |  101|        - parameter queue:              The queue on which the completion handler is dispatched.
       |  102|        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
       |  103|                                        and data.
       |  104|        - parameter completionHandler:  The code to be executed once the request has finished.
       |  105|
       |  106|        - returns: The request.
       |  107|    */
       |  108|    public func response<T: ResponseSerializerType>(
       |  109|        queue queue: dispatch_queue_t? = nil,
       |  110|        responseSerializer: T,
       |  111|        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
       |  112|        -> Self
      1|  113|    {
      1|  114|        delegate.queue.addOperationWithBlock {
      1|  115|            let result = responseSerializer.serializeResponse(
      1|  116|                self.request,
      1|  117|                self.response,
      1|  118|                self.delegate.data,
      1|  119|                self.delegate.error
      1|  120|            )
      1|  121|
      1|  122|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      1|  123|                let response = Response<T.SerializedObject, T.ErrorObject>(
      1|  124|                    request: self.request,
      1|  125|                    response: self.response,
      1|  126|                    data: self.delegate.data,
      1|  127|                    result: result
      1|  128|                )
      1|  129|
      1|  130|                completionHandler(response)
      1|  131|            }
      1|  132|        }
      1|  133|
      1|  134|        return self
      1|  135|    }
       |  136|}
       |  137|
       |  138|// MARK: - Data
       |  139|
       |  140|extension Request {
       |  141|
       |  142|    /**
       |  143|        Creates a response serializer that returns the associated data as-is.
       |  144|
       |  145|        - returns: A data response serializer.
       |  146|    */
      0|  147|    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
      0|  148|        return ResponseSerializer { _, response, data, error in
      0|  149|            guard error == nil else { return .Failure(error!) }
      0|  150|
      0|  151|            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
      0|  152|
      0|  153|            guard let validData = data else {
      0|  154|                let failureReason = "Data could not be serialized. Input data was nil."
      0|  155|                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
      0|  156|                return .Failure(error)
      0|  157|            }
      0|  158|
      0|  159|            return .Success(validData)
      0|  160|        }
      0|  161|    }
       |  162|
       |  163|    /**
       |  164|        Adds a handler to be called once the request has finished.
       |  165|
       |  166|        - parameter completionHandler: The code to be executed once the request has finished.
       |  167|
       |  168|        - returns: The request.
       |  169|    */
      0|  170|    public func responseData(completionHandler: Response<NSData, NSError> -> Void) -> Self {
      0|  171|        return response(responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
      0|  172|    }
       |  173|}
       |  174|
       |  175|// MARK: - String
       |  176|
       |  177|extension Request {
       |  178|
       |  179|    /**
       |  180|        Creates a response serializer that returns a string initialized from the response data with the specified 
       |  181|        string encoding.
       |  182|
       |  183|        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
       |  184|                              response, falling back to the default HTTP default character set, ISO-8859-1.
       |  185|
       |  186|        - returns: A string response serializer.
       |  187|    */
       |  188|    public static func stringResponseSerializer(
       |  189|        var encoding encoding: NSStringEncoding? = nil)
       |  190|        -> ResponseSerializer<String, NSError>
      0|  191|    {
      0|  192|        return ResponseSerializer { _, response, data, error in
      0|  193|            guard error == nil else { return .Failure(error!) }
      0|  194|
      0|  195|            if let response = response where response.statusCode == 204 { return .Success("") }
      0|  196|
      0|  197|            guard let validData = data else {
      0|  198|                let failureReason = "String could not be serialized. Input data was nil."
      0|  199|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  200|                return .Failure(error)
      0|  201|            }
      0|  202|
      0|  203|            if let encodingName = response?.textEncodingName where encoding == nil {
      0|  204|                encoding = CFStringConvertEncodingToNSStringEncoding(
      0|  205|                    CFStringConvertIANACharSetNameToEncoding(encodingName)
      0|  206|                )
      0|  207|            }
      0|  208|
      0|  209|            let actualEncoding = encoding ?? NSISOLatin1StringEncoding
      0|  210|
      0|  211|            if let string = String(data: validData, encoding: actualEncoding) {
      0|  212|                return .Success(string)
      0|  213|            } else {
      0|  214|                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
      0|  215|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  216|                return .Failure(error)
      0|  217|            }
      0|  218|        }
      0|  219|    }
       |  220|
       |  221|    /**
       |  222|        Adds a handler to be called once the request has finished.
       |  223|
       |  224|        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
       |  225|                                       server response, falling back to the default HTTP default character set, 
       |  226|                                       ISO-8859-1.
       |  227|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  228|
       |  229|        - returns: The request.
       |  230|    */
       |  231|    public func responseString(
       |  232|        encoding encoding: NSStringEncoding? = nil,
       |  233|        completionHandler: Response<String, NSError> -> Void)
       |  234|        -> Self
      0|  235|    {
      0|  236|        return response(
      0|  237|            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
      0|  238|            completionHandler: completionHandler
      0|  239|        )
      0|  240|    }
       |  241|}
       |  242|
       |  243|// MARK: - JSON
       |  244|
       |  245|extension Request {
       |  246|
       |  247|    /**
       |  248|        Creates a response serializer that returns a JSON object constructed from the response data using 
       |  249|        `NSJSONSerialization` with the specified reading options.
       |  250|
       |  251|        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
       |  252|
       |  253|        - returns: A JSON object response serializer.
       |  254|    */
       |  255|    public static func JSONResponseSerializer(
       |  256|        options options: NSJSONReadingOptions = .AllowFragments)
       |  257|        -> ResponseSerializer<AnyObject, NSError>
      1|  258|    {
      1|  259|        return ResponseSerializer { _, response, data, error in
      0|  260|            guard error == nil else { return .Failure(error!) }
      1|  261|
      0|  262|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      1|  263|
      0|  264|            guard let validData = data where validData.length > 0 else {
      0|  265|                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
      0|  266|                let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
      0|  267|                return .Failure(error)
      0|  268|            }
      1|  269|
      1|  270|            do {
      1|  271|                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
      1|  272|                return .Success(JSON)
      1|  273|            } catch {
      1|  274|                return .Failure(error as NSError)
      1|  275|            }
      0|  276|        }
      1|  277|    }
       |  278|
       |  279|    /**
       |  280|        Adds a handler to be called once the request has finished.
       |  281|
       |  282|        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
       |  283|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  284|
       |  285|        - returns: The request.
       |  286|    */
       |  287|    public func responseJSON(
       |  288|        options options: NSJSONReadingOptions = .AllowFragments,
       |  289|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  290|        -> Self
      1|  291|    {
      1|  292|        return response(
      1|  293|            responseSerializer: Request.JSONResponseSerializer(options: options),
      1|  294|            completionHandler: completionHandler
      1|  295|        )
      1|  296|    }
       |  297|}
       |  298|
       |  299|// MARK: - Property List
       |  300|
       |  301|extension Request {
       |  302|
       |  303|    /**
       |  304|        Creates a response serializer that returns an object constructed from the response data using 
       |  305|        `NSPropertyListSerialization` with the specified reading options.
       |  306|
       |  307|        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
       |  308|
       |  309|        - returns: A property list object response serializer.
       |  310|    */
       |  311|    public static func propertyListResponseSerializer(
       |  312|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
       |  313|        -> ResponseSerializer<AnyObject, NSError>
      0|  314|    {
      0|  315|        return ResponseSerializer { _, response, data, error in
      0|  316|            guard error == nil else { return .Failure(error!) }
      0|  317|
      0|  318|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      0|  319|
      0|  320|            guard let validData = data where validData.length > 0 else {
      0|  321|                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
      0|  322|                let error = Error.errorWithCode(.PropertyListSerializationFailed, failureReason: failureReason)
      0|  323|                return .Failure(error)
      0|  324|            }
      0|  325|
      0|  326|            do {
      0|  327|                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
      0|  328|                return .Success(plist)
      0|  329|            } catch {
      0|  330|                return .Failure(error as NSError)
      0|  331|            }
      0|  332|        }
      0|  333|    }
       |  334|
       |  335|    /**
       |  336|        Adds a handler to be called once the request has finished.
       |  337|
       |  338|        - parameter options:           The property list reading options. `0` by default.
       |  339|        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
       |  340|                                       arguments: the URL request, the URL response, the server data and the result 
       |  341|                                       produced while creating the property list.
       |  342|
       |  343|        - returns: The request.
       |  344|    */
       |  345|    public func responsePropertyList(
       |  346|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
       |  347|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  348|        -> Self
      0|  349|    {
      0|  350|        return response(
      0|  351|            responseSerializer: Request.propertyListResponseSerializer(options: options),
      0|  352|            completionHandler: completionHandler
      0|  353|        )
      0|  354|    }
       |  355|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Result.swift:
       |    1|// Result.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Used to represent whether a request was successful or encountered an error.
       |   27|
       |   28|    - Success: The request and all post processing operations were successful resulting in the serialization of the 
       |   29|               provided associated value.
       |   30|    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
       |   31|               provided by the server as well as the error that caused the failure.
       |   32|*/
       |   33|public enum Result<Value, Error: ErrorType> {
       |   34|    case Success(Value)
       |   35|    case Failure(Error)
       |   36|
       |   37|    /// Returns `true` if the result is a success, `false` otherwise.
      0|   38|    public var isSuccess: Bool {
      0|   39|        switch self {
      0|   40|        case .Success:
      0|   41|            return true
      0|   42|        case .Failure:
      0|   43|            return false
      0|   44|        }
      0|   45|    }
       |   46|
       |   47|    /// Returns `true` if the result is a failure, `false` otherwise.
      0|   48|    public var isFailure: Bool {
      0|   49|        return !isSuccess
      0|   50|    }
       |   51|
       |   52|    /// Returns the associated value if the result is a success, `nil` otherwise.
      0|   53|    public var value: Value? {
      0|   54|        switch self {
      0|   55|        case .Success(let value):
      0|   56|            return value
      0|   57|        case .Failure:
      0|   58|            return nil
      0|   59|        }
      0|   60|    }
       |   61|
       |   62|    /// Returns the associated error value if the result is a failure, `nil` otherwise.
      0|   63|    public var error: Error? {
      0|   64|        switch self {
      0|   65|        case .Success:
      0|   66|            return nil
      0|   67|        case .Failure(let error):
      0|   68|            return error
      0|   69|        }
      0|   70|    }
       |   71|}
       |   72|
       |   73|// MARK: - CustomStringConvertible
       |   74|
       |   75|extension Result: CustomStringConvertible {
       |   76|    /// The textual representation used when written to an output stream, which includes whether the result was a 
       |   77|    /// success or failure.
      0|   78|    public var description: String {
      0|   79|        switch self {
      0|   80|        case .Success:
      0|   81|            return "SUCCESS"
      0|   82|        case .Failure:
      0|   83|            return "FAILURE"
      0|   84|        }
      0|   85|    }
       |   86|}
       |   87|
       |   88|// MARK: - CustomDebugStringConvertible
       |   89|
       |   90|extension Result: CustomDebugStringConvertible {
       |   91|    /// The debug textual representation used when written to an output stream, which includes whether the result was a
       |   92|    /// success or failure in addition to the value or error.
      1|   93|    public var debugDescription: String {
      1|   94|        switch self {
      0|   95|        case .Success(let value):
      0|   96|            return "SUCCESS: \(value)"
      1|   97|        case .Failure(let error):
      1|   98|            return "FAILURE: \(error)"
      1|   99|        }
      1|  100|    }
       |  101|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ServerTrustPolicy.swift:
       |    1|// ServerTrustPolicy.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
       |   26|public class ServerTrustPolicyManager {
       |   27|    /// The dictionary of policies mapped to a particular host.
       |   28|    public let policies: [String: ServerTrustPolicy]
       |   29|
       |   30|    /**
       |   31|        Initializes the `ServerTrustPolicyManager` instance with the given policies.
       |   32|
       |   33|        Since different servers and web services can have different leaf certificates, intermediate and even root 
       |   34|        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
       |   35|        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
       |   36|        pinning for host3 and disabling evaluation for host4.
       |   37|
       |   38|        - parameter policies: A dictionary of all policies mapped to a particular host.
       |   39|
       |   40|        - returns: The new `ServerTrustPolicyManager` instance.
       |   41|    */
      0|   42|    public init(policies: [String: ServerTrustPolicy]) {
      0|   43|        self.policies = policies
      0|   44|    }
       |   45|
       |   46|    /**
       |   47|        Returns the `ServerTrustPolicy` for the given host if applicable.
       |   48|
       |   49|        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
       |   50|        this method and implement more complex mapping implementations such as wildcards.
       |   51|
       |   52|        - parameter host: The host to use when searching for a matching policy.
       |   53|
       |   54|        - returns: The server trust policy for the given host if found.
       |   55|    */
      0|   56|    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
      0|   57|        return policies[host]
      0|   58|    }
       |   59|}
       |   60|
       |   61|// MARK: -
       |   62|
       |   63|extension NSURLSession {
       |   64|    private struct AssociatedKeys {
       |   65|        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
       |   66|    }
       |   67|
       |   68|    var serverTrustPolicyManager: ServerTrustPolicyManager? {
      1|   69|        get {
      1|   70|            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
      1|   71|        }
      1|   72|        set (manager) {
      1|   73|            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
      1|   74|        }
       |   75|    }
       |   76|}
       |   77|
       |   78|// MARK: - ServerTrustPolicy
       |   79|
       |   80|/**
       |   81|    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
       |   82|    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
       |   83|    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
       |   84|
       |   85|    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
       |   86|    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
       |   87|    to route all communication over an HTTPS connection with pinning enabled.
       |   88|
       |   89|    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
       |   90|                                validate the host provided by the challenge. Applications are encouraged to always 
       |   91|                                validate the host in production environments to guarantee the validity of the server's 
       |   92|                                certificate chain.
       |   93|
       |   94|    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
       |   95|                                considered valid if one of the pinned certificates match one of the server certificates. 
       |   96|                                By validating both the certificate chain and host, certificate pinning provides a very 
       |   97|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |   98|                                Applications are encouraged to always validate the host and require a valid certificate 
       |   99|                                chain in production environments.
       |  100|
       |  101|    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
       |  102|                                valid if one of the pinned public keys match one of the server certificate public keys. 
       |  103|                                By validating both the certificate chain and host, public key pinning provides a very 
       |  104|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |  105|                                Applications are encouraged to always validate the host and require a valid certificate 
       |  106|                                chain in production environments.
       |  107|
       |  108|    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
       |  109|
       |  110|    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
       |  111|*/
       |  112|public enum ServerTrustPolicy {
       |  113|    case PerformDefaultEvaluation(validateHost: Bool)
       |  114|    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
       |  115|    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
       |  116|    case DisableEvaluation
       |  117|    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
       |  118|
       |  119|    // MARK: - Bundle Location
       |  120|
       |  121|    /**
       |  122|        Returns all certificates within the given bundle with a `.cer` file extension.
       |  123|
       |  124|        - parameter bundle: The bundle to search for all `.cer` files.
       |  125|
       |  126|        - returns: All certificates within the given bundle.
       |  127|    */
      0|  128|    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
      0|  129|        var certificates: [SecCertificate] = []
      0|  130|
      0|  131|        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
      0|  132|            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
      0|  133|        }.flatten())
      0|  134|
      0|  135|        for path in paths {
      0|  136|            if let
      0|  137|                certificateData = NSData(contentsOfFile: path),
      0|  138|                certificate = SecCertificateCreateWithData(nil, certificateData)
      0|  139|            {
      0|  140|                certificates.append(certificate)
      0|  141|            }
      0|  142|        }
      0|  143|
      0|  144|        return certificates
      0|  145|    }
       |  146|
       |  147|    /**
       |  148|        Returns all public keys within the given bundle with a `.cer` file extension.
       |  149|
       |  150|        - parameter bundle: The bundle to search for all `*.cer` files.
       |  151|
       |  152|        - returns: All public keys within the given bundle.
       |  153|    */
      0|  154|    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
      0|  155|        var publicKeys: [SecKey] = []
      0|  156|
      0|  157|        for certificate in certificatesInBundle(bundle) {
      0|  158|            if let publicKey = publicKeyForCertificate(certificate) {
      0|  159|                publicKeys.append(publicKey)
      0|  160|            }
      0|  161|        }
      0|  162|
      0|  163|        return publicKeys
      0|  164|    }
       |  165|
       |  166|    // MARK: - Evaluation
       |  167|
       |  168|    /**
       |  169|        Evaluates whether the server trust is valid for the given host.
       |  170|
       |  171|        - parameter serverTrust: The server trust to evaluate.
       |  172|        - parameter host:        The host of the challenge protection space.
       |  173|
       |  174|        - returns: Whether the server trust is valid.
       |  175|    */
      0|  176|    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
      0|  177|        var serverTrustIsValid = false
      0|  178|
      0|  179|        switch self {
      0|  180|        case let .PerformDefaultEvaluation(validateHost):
      0|  181|            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  182|            SecTrustSetPolicies(serverTrust, [policy])
      0|  183|
      0|  184|            serverTrustIsValid = trustIsValid(serverTrust)
      0|  185|        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
      0|  186|            if validateCertificateChain {
      0|  187|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  188|                SecTrustSetPolicies(serverTrust, [policy])
      0|  189|
      0|  190|                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
      0|  191|                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
      0|  192|
      0|  193|                serverTrustIsValid = trustIsValid(serverTrust)
      0|  194|            } else {
      0|  195|                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
      0|  196|                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
      0|  197|
      0|  198|                outerLoop: for serverCertificateData in serverCertificatesDataArray {
      0|  199|                    for pinnedCertificateData in pinnedCertificatesDataArray {
      0|  200|                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
      0|  201|                            serverTrustIsValid = true
      0|  202|                            break outerLoop
      0|  203|                        }
      0|  204|                    }
      0|  205|                }
      0|  206|            }
      0|  207|        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
      0|  208|            var certificateChainEvaluationPassed = true
      0|  209|
      0|  210|            if validateCertificateChain {
      0|  211|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  212|                SecTrustSetPolicies(serverTrust, [policy])
      0|  213|
      0|  214|                certificateChainEvaluationPassed = trustIsValid(serverTrust)
      0|  215|            }
      0|  216|
      0|  217|            if certificateChainEvaluationPassed {
      0|  218|                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
      0|  219|                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
      0|  220|                        if serverPublicKey.isEqual(pinnedPublicKey) {
      0|  221|                            serverTrustIsValid = true
      0|  222|                            break outerLoop
      0|  223|                        }
      0|  224|                    }
      0|  225|                }
      0|  226|            }
      0|  227|        case .DisableEvaluation:
      0|  228|            serverTrustIsValid = true
      0|  229|        case let .CustomEvaluation(closure):
      0|  230|            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
      0|  231|        }
      0|  232|
      0|  233|        return serverTrustIsValid
      0|  234|    }
       |  235|
       |  236|    // MARK: - Private - Trust Validation
       |  237|
      0|  238|    private func trustIsValid(trust: SecTrust) -> Bool {
      0|  239|        var isValid = false
      0|  240|
      0|  241|        var result = SecTrustResultType(kSecTrustResultInvalid)
      0|  242|        let status = SecTrustEvaluate(trust, &result)
      0|  243|
      0|  244|        if status == errSecSuccess {
      0|  245|            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
      0|  246|            let proceed = SecTrustResultType(kSecTrustResultProceed)
      0|  247|
      0|  248|            isValid = result == unspecified || result == proceed
      0|  249|        }
      0|  250|
      0|  251|        return isValid
      0|  252|    }
       |  253|
       |  254|    // MARK: - Private - Certificate Data
       |  255|
      0|  256|    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
      0|  257|        var certificates: [SecCertificate] = []
      0|  258|
      0|  259|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  260|            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
      0|  261|                certificates.append(certificate)
      0|  262|            }
      0|  263|        }
      0|  264|
      0|  265|        return certificateDataForCertificates(certificates)
      0|  266|    }
       |  267|
      0|  268|    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
      0|  269|        return certificates.map { SecCertificateCopyData($0) as NSData }
      0|  270|    }
       |  271|
       |  272|    // MARK: - Private - Public Key Extraction
       |  273|
      0|  274|    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
      0|  275|        var publicKeys: [SecKey] = []
      0|  276|
      0|  277|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  278|            if let
      0|  279|                certificate = SecTrustGetCertificateAtIndex(trust, index),
      0|  280|                publicKey = publicKeyForCertificate(certificate)
      0|  281|            {
      0|  282|                publicKeys.append(publicKey)
      0|  283|            }
      0|  284|        }
      0|  285|
      0|  286|        return publicKeys
      0|  287|    }
       |  288|
      0|  289|    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
      0|  290|        var publicKey: SecKey?
      0|  291|
      0|  292|        let policy = SecPolicyCreateBasicX509()
      0|  293|        var trust: SecTrust?
      0|  294|        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
      0|  295|
      0|  296|        if let trust = trust where trustCreationStatus == errSecSuccess {
      0|  297|            publicKey = SecTrustCopyPublicKey(trust)
      0|  298|        }
      0|  299|
      0|  300|        return publicKey
      0|  301|    }
       |  302|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Stream.swift:
       |    1|// Stream.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if !os(watchOS)
       |   26|
       |   27|@available(iOS 9.0, OSX 10.11, *)
       |   28|extension Manager {
       |   29|    private enum Streamable {
       |   30|        case Stream(String, Int)
       |   31|        case NetService(NSNetService)
       |   32|    }
       |   33|
      0|   34|    private func stream(streamable: Streamable) -> Request {
      0|   35|        var streamTask: NSURLSessionStreamTask!
      0|   36|
      0|   37|        switch streamable {
      0|   38|        case .Stream(let hostName, let port):
      0|   39|            dispatch_sync(queue) {
      0|   40|                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
      0|   41|            }
      0|   42|        case .NetService(let netService):
      0|   43|            dispatch_sync(queue) {
      0|   44|                streamTask = self.session.streamTaskWithNetService(netService)
      0|   45|            }
      0|   46|        }
      0|   47|
      0|   48|        let request = Request(session: session, task: streamTask)
      0|   49|
      0|   50|        delegate[request.delegate.task] = request.delegate
      0|   51|
      0|   52|        if startRequestsImmediately {
      0|   53|            request.resume()
      0|   54|        }
      0|   55|
      0|   56|        return request
      0|   57|    }
       |   58|
       |   59|    /**
       |   60|        Creates a request for bidirectional streaming with the given hostname and port.
       |   61|
       |   62|        - parameter hostName: The hostname of the server to connect to.
       |   63|        - parameter port:     The port of the server to connect to.
       |   64|
       |   65|        :returns: The created stream request.
       |   66|    */
      0|   67|    public func stream(hostName hostName: String, port: Int) -> Request {
      0|   68|        return stream(.Stream(hostName, port))
      0|   69|    }
       |   70|
       |   71|    /**
       |   72|        Creates a request for bidirectional streaming with the given `NSNetService`.
       |   73|
       |   74|        - parameter netService: The net service used to identify the endpoint.
       |   75|
       |   76|        - returns: The created stream request.
       |   77|    */
      0|   78|    public func stream(netService netService: NSNetService) -> Request {
      0|   79|        return stream(.NetService(netService))
      0|   80|    }
       |   81|}
       |   82|
       |   83|// MARK: -
       |   84|
       |   85|@available(iOS 9.0, OSX 10.11, *)
       |   86|extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
       |   87|
       |   88|    // MARK: Override Closures
       |   89|
       |   90|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
       |   91|    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|   92|        get {
      0|   93|            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|   94|        }
      0|   95|        set {
      0|   96|            _streamTaskReadClosed = newValue
      0|   97|        }
       |   98|    }
       |   99|
       |  100|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
       |  101|    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  102|        get {
      0|  103|            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  104|        }
      0|  105|        set {
      0|  106|            _streamTaskWriteClosed = newValue
      0|  107|        }
       |  108|    }
       |  109|
       |  110|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
       |  111|    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  112|        get {
      0|  113|            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  114|        }
      0|  115|        set {
      0|  116|            _streamTaskBetterRouteDiscovered = newValue
      0|  117|        }
       |  118|    }
       |  119|
       |  120|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
       |  121|    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
      0|  122|        get {
      0|  123|            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
      0|  124|        }
      0|  125|        set {
      0|  126|            _streamTaskDidBecomeInputStream = newValue
      0|  127|        }
       |  128|    }
       |  129|
       |  130|    // MARK: Delegate Methods
       |  131|
       |  132|    /**
       |  133|        Tells the delegate that the read side of the connection has been closed.
       |  134|
       |  135|        - parameter session:    The session.
       |  136|        - parameter streamTask: The stream task.
       |  137|    */
      0|  138|    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  139|        streamTaskReadClosed?(session, streamTask)
      0|  140|    }
       |  141|
       |  142|    /**
       |  143|        Tells the delegate that the write side of the connection has been closed.
       |  144|
       |  145|        - parameter session:    The session.
       |  146|        - parameter streamTask: The stream task.
       |  147|    */
      0|  148|    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  149|        streamTaskWriteClosed?(session, streamTask)
      0|  150|    }
       |  151|
       |  152|    /**
       |  153|        Tells the delegate that the system has determined that a better route to the host is available.
       |  154|
       |  155|        - parameter session:    The session.
       |  156|        - parameter streamTask: The stream task.
       |  157|    */
      0|  158|    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  159|        streamTaskBetterRouteDiscovered?(session, streamTask)
      0|  160|    }
       |  161|
       |  162|    /**
       |  163|        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
       |  164|
       |  165|        - parameter session:      The session.
       |  166|        - parameter streamTask:   The stream task.
       |  167|        - parameter inputStream:  The new input stream.
       |  168|        - parameter outputStream: The new output stream.
       |  169|    */
       |  170|    public func URLSession(
       |  171|        session: NSURLSession,
       |  172|        streamTask: NSURLSessionStreamTask,
       |  173|        didBecomeInputStream inputStream: NSInputStream,
       |  174|        outputStream: NSOutputStream)
      0|  175|    {
      0|  176|        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
      0|  177|    }
       |  178|}
       |  179|
       |  180|#endif

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Upload.swift:
       |    1|// Upload.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Uploadable {
       |   27|        case Data(NSURLRequest, NSData)
       |   28|        case File(NSURLRequest, NSURL)
       |   29|        case Stream(NSURLRequest, NSInputStream)
       |   30|    }
       |   31|
      0|   32|    private func upload(uploadable: Uploadable) -> Request {
      0|   33|        var uploadTask: NSURLSessionUploadTask!
      0|   34|        var HTTPBodyStream: NSInputStream?
      0|   35|
      0|   36|        switch uploadable {
      0|   37|        case .Data(let request, let data):
      0|   38|            dispatch_sync(queue) {
      0|   39|                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
      0|   40|            }
      0|   41|        case .File(let request, let fileURL):
      0|   42|            dispatch_sync(queue) {
      0|   43|                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
      0|   44|            }
      0|   45|        case .Stream(let request, let stream):
      0|   46|            dispatch_sync(queue) {
      0|   47|                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
      0|   48|            }
      0|   49|
      0|   50|            HTTPBodyStream = stream
      0|   51|        }
      0|   52|
      0|   53|        let request = Request(session: session, task: uploadTask)
      0|   54|
      0|   55|        if HTTPBodyStream != nil {
      0|   56|            request.delegate.taskNeedNewBodyStream = { _, _ in
      0|   57|                return HTTPBodyStream
      0|   58|            }
      0|   59|        }
      0|   60|
      0|   61|        delegate[request.delegate.task] = request.delegate
      0|   62|
      0|   63|        if startRequestsImmediately {
      0|   64|            request.resume()
      0|   65|        }
      0|   66|
      0|   67|        return request
      0|   68|    }
       |   69|
       |   70|    // MARK: File
       |   71|
       |   72|    /**
       |   73|        Creates a request for uploading a file to the specified URL request.
       |   74|
       |   75|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   76|
       |   77|        - parameter URLRequest: The URL request
       |   78|        - parameter file:       The file to upload
       |   79|
       |   80|        - returns: The created upload request.
       |   81|    */
      0|   82|    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|   83|        return upload(.File(URLRequest.URLRequest, file))
      0|   84|    }
       |   85|
       |   86|    /**
       |   87|        Creates a request for uploading a file to the specified URL request.
       |   88|
       |   89|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   90|
       |   91|        - parameter method:    The HTTP method.
       |   92|        - parameter URLString: The URL string.
       |   93|        - parameter headers:   The HTTP headers. `nil` by default.
       |   94|        - parameter file:      The file to upload
       |   95|
       |   96|        - returns: The created upload request.
       |   97|    */
       |   98|    public func upload(
       |   99|        method: Method,
       |  100|        _ URLString: URLStringConvertible,
       |  101|        headers: [String: String]? = nil,
       |  102|        file: NSURL)
       |  103|        -> Request
      0|  104|    {
      0|  105|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  106|        return upload(mutableURLRequest, file: file)
      0|  107|    }
       |  108|
       |  109|    // MARK: Data
       |  110|
       |  111|    /**
       |  112|        Creates a request for uploading data to the specified URL request.
       |  113|
       |  114|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  115|
       |  116|        - parameter URLRequest: The URL request.
       |  117|        - parameter data:       The data to upload.
       |  118|
       |  119|        - returns: The created upload request.
       |  120|    */
      0|  121|    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  122|        return upload(.Data(URLRequest.URLRequest, data))
      0|  123|    }
       |  124|
       |  125|    /**
       |  126|        Creates a request for uploading data to the specified URL request.
       |  127|
       |  128|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  129|
       |  130|        - parameter method:    The HTTP method.
       |  131|        - parameter URLString: The URL string.
       |  132|        - parameter headers:   The HTTP headers. `nil` by default.
       |  133|        - parameter data:      The data to upload
       |  134|
       |  135|        - returns: The created upload request.
       |  136|    */
       |  137|    public func upload(
       |  138|        method: Method,
       |  139|        _ URLString: URLStringConvertible,
       |  140|        headers: [String: String]? = nil,
       |  141|        data: NSData)
       |  142|        -> Request
      0|  143|    {
      0|  144|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  145|
      0|  146|        return upload(mutableURLRequest, data: data)
      0|  147|    }
       |  148|
       |  149|    // MARK: Stream
       |  150|
       |  151|    /**
       |  152|        Creates a request for uploading a stream to the specified URL request.
       |  153|
       |  154|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  155|
       |  156|        - parameter URLRequest: The URL request.
       |  157|        - parameter stream:     The stream to upload.
       |  158|
       |  159|        - returns: The created upload request.
       |  160|    */
      0|  161|    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  162|        return upload(.Stream(URLRequest.URLRequest, stream))
      0|  163|    }
       |  164|
       |  165|    /**
       |  166|        Creates a request for uploading a stream to the specified URL request.
       |  167|
       |  168|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  169|
       |  170|        - parameter method:    The HTTP method.
       |  171|        - parameter URLString: The URL string.
       |  172|        - parameter headers:   The HTTP headers. `nil` by default.
       |  173|        - parameter stream:    The stream to upload.
       |  174|
       |  175|        - returns: The created upload request.
       |  176|    */
       |  177|    public func upload(
       |  178|        method: Method,
       |  179|        _ URLString: URLStringConvertible,
       |  180|        headers: [String: String]? = nil,
       |  181|        stream: NSInputStream)
       |  182|        -> Request
      0|  183|    {
      0|  184|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  185|
      0|  186|        return upload(mutableURLRequest, stream: stream)
      0|  187|    }
       |  188|
       |  189|    // MARK: MultipartFormData
       |  190|
       |  191|    /// Default memory threshold used when encoding `MultipartFormData`.
       |  192|    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
       |  193|
       |  194|    /**
       |  195|        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
       |  196|        associated values.
       |  197|
       |  198|        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
       |  199|                   streaming information.
       |  200|        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
       |  201|                   error.
       |  202|    */
       |  203|    public enum MultipartFormDataEncodingResult {
       |  204|        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
       |  205|        case Failure(ErrorType)
       |  206|    }
       |  207|
       |  208|    /**
       |  209|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  210|
       |  211|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
       |  212|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
       |  213|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
       |  214|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
       |  215|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
       |  216|        used for larger payloads such as video content.
       |  217|
       |  218|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
       |  219|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  220|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
       |  221|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
       |  222|        technique was used.
       |  223|
       |  224|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  225|
       |  226|        - parameter method:                  The HTTP method.
       |  227|        - parameter URLString:               The URL string.
       |  228|        - parameter headers:                 The HTTP headers. `nil` by default.
       |  229|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  230|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  231|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  232|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  233|    */
       |  234|    public func upload(
       |  235|        method: Method,
       |  236|        _ URLString: URLStringConvertible,
       |  237|        headers: [String: String]? = nil,
       |  238|        multipartFormData: MultipartFormData -> Void,
       |  239|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  240|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  241|    {
      0|  242|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  243|
      0|  244|        return upload(
      0|  245|            mutableURLRequest,
      0|  246|            multipartFormData: multipartFormData,
      0|  247|            encodingMemoryThreshold: encodingMemoryThreshold,
      0|  248|            encodingCompletion: encodingCompletion
      0|  249|        )
      0|  250|    }
       |  251|
       |  252|    /**
       |  253|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  254|
       |  255|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
       |  256|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
       |  257|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
       |  258|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
       |  259|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
       |  260|        used for larger payloads such as video content.
       |  261|
       |  262|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
       |  263|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  264|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
       |  265|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
       |  266|        technique was used.
       |  267|
       |  268|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  269|
       |  270|        - parameter URLRequest:              The URL request.
       |  271|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  272|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  273|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  274|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  275|    */
       |  276|    public func upload(
       |  277|        URLRequest: URLRequestConvertible,
       |  278|        multipartFormData: MultipartFormData -> Void,
       |  279|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  280|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  281|    {
      0|  282|        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
      0|  283|            let formData = MultipartFormData()
      0|  284|            multipartFormData(formData)
      0|  285|
      0|  286|            let URLRequestWithContentType = URLRequest.URLRequest
      0|  287|            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
      0|  288|
      0|  289|            let isBackgroundSession = self.session.configuration.identifier != nil
      0|  290|
      0|  291|            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
      0|  292|                do {
      0|  293|                    let data = try formData.encode()
      0|  294|                    let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  295|                        request: self.upload(URLRequestWithContentType, data: data),
      0|  296|                        streamingFromDisk: false,
      0|  297|                        streamFileURL: nil
      0|  298|                    )
      0|  299|
      0|  300|                    dispatch_async(dispatch_get_main_queue()) {
      0|  301|                        encodingCompletion?(encodingResult)
      0|  302|                    }
      0|  303|                } catch {
      0|  304|                    dispatch_async(dispatch_get_main_queue()) {
      0|  305|                        encodingCompletion?(.Failure(error as NSError))
      0|  306|                    }
      0|  307|                }
      0|  308|            } else {
      0|  309|                let fileManager = NSFileManager.defaultManager()
      0|  310|                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
      0|  311|                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
      0|  312|                let fileName = NSUUID().UUIDString
      0|  313|                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
      0|  314|
      0|  315|                do {
      0|  316|                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
      0|  317|                    try formData.writeEncodedDataToDisk(fileURL)
      0|  318|
      0|  319|                    dispatch_async(dispatch_get_main_queue()) {
      0|  320|                        let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  321|                            request: self.upload(URLRequestWithContentType, file: fileURL),
      0|  322|                            streamingFromDisk: true,
      0|  323|                            streamFileURL: fileURL
      0|  324|                        )
      0|  325|                        encodingCompletion?(encodingResult)
      0|  326|                    }
      0|  327|                } catch {
      0|  328|                    dispatch_async(dispatch_get_main_queue()) {
      0|  329|                        encodingCompletion?(.Failure(error as NSError))
      0|  330|                    }
      0|  331|                }
      0|  332|            }
      0|  333|        }
      0|  334|    }
       |  335|}
       |  336|
       |  337|// MARK: -
       |  338|
       |  339|extension Request {
       |  340|
       |  341|    // MARK: - UploadTaskDelegate
       |  342|
       |  343|    class UploadTaskDelegate: DataTaskDelegate {
      0|  344|        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
       |  345|        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
       |  346|
       |  347|        // MARK: - NSURLSessionTaskDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  352|
       |  353|        // MARK: Delegate Methods
       |  354|
       |  355|        func URLSession(
       |  356|            session: NSURLSession,
       |  357|            task: NSURLSessionTask,
       |  358|            didSendBodyData bytesSent: Int64,
       |  359|            totalBytesSent: Int64,
       |  360|            totalBytesExpectedToSend: Int64)
      0|  361|        {
      0|  362|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  363|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  364|            } else {
      0|  365|                progress.totalUnitCount = totalBytesExpectedToSend
      0|  366|                progress.completedUnitCount = totalBytesSent
      0|  367|
      0|  368|                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  369|            }
      0|  370|        }
       |  371|    }
       |  372|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Validation.swift:
       |    1|// Validation.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Request {
       |   26|
       |   27|    /**
       |   28|        Used to represent whether validation was successful or encountered an error resulting in a failure.
       |   29|
       |   30|        - Success: The validation was successful.
       |   31|        - Failure: The validation failed encountering the provided error.
       |   32|    */
       |   33|    public enum ValidationResult {
       |   34|        case Success
       |   35|        case Failure(NSError)
       |   36|    }
       |   37|
       |   38|    /**
       |   39|        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
       |   40|        request was valid.
       |   41|    */
       |   42|    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
       |   43|
       |   44|    /**
       |   45|        Validates the request, using the specified closure.
       |   46|
       |   47|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   48|
       |   49|        - parameter validation: A closure to validate the request.
       |   50|
       |   51|        - returns: The request.
       |   52|    */
      0|   53|    public func validate(validation: Validation) -> Self {
      0|   54|        delegate.queue.addOperationWithBlock {
      0|   55|            if let
      0|   56|                response = self.response where self.delegate.error == nil,
      0|   57|                case let .Failure(error) = validation(self.request, response)
      0|   58|            {
      0|   59|                self.delegate.error = error
      0|   60|            }
      0|   61|        }
      0|   62|
      0|   63|        return self
      0|   64|    }
       |   65|
       |   66|    // MARK: - Status Code
       |   67|
       |   68|    /**
       |   69|        Validates that the response has a status code in the specified range.
       |   70|
       |   71|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   72|
       |   73|        - parameter range: The range of acceptable status codes.
       |   74|
       |   75|        - returns: The request.
       |   76|    */
      0|   77|    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
      0|   78|        return validate { _, response in
      0|   79|            if acceptableStatusCode.contains(response.statusCode) {
      0|   80|                return .Success
      0|   81|            } else {
      0|   82|                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
      0|   83|                return .Failure(Error.errorWithCode(.StatusCodeValidationFailed, failureReason: failureReason))
      0|   84|            }
      0|   85|        }
      0|   86|    }
       |   87|
       |   88|    // MARK: - Content-Type
       |   89|
       |   90|    private struct MIMEType {
       |   91|        let type: String
       |   92|        let subtype: String
       |   93|
      0|   94|        init?(_ string: String) {
      0|   95|            let components: [String] = {
      0|   96|                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
      0|   97|                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
      0|   98|                return split.componentsSeparatedByString("/")
      0|   99|            }()
      0|  100|
      0|  101|            if let
      0|  102|                type = components.first,
      0|  103|                subtype = components.last
      0|  104|            {
      0|  105|                self.type = type
      0|  106|                self.subtype = subtype
      0|  107|            } else {
      0|  108|                return nil
      0|  109|            }
      0|  110|        }
       |  111|
      0|  112|        func matches(MIME: MIMEType) -> Bool {
      0|  113|            switch (type, subtype) {
      0|  114|            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
      0|  115|                return true
      0|  116|            default:
      0|  117|                return false
      0|  118|            }
      0|  119|        }
       |  120|    }
       |  121|
       |  122|    /**
       |  123|        Validates that the response has a content type in the specified array.
       |  124|
       |  125|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  126|
       |  127|        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
       |  128|
       |  129|        - returns: The request.
       |  130|    */
      0|  131|    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
      0|  132|        return validate { _, response in
      0|  133|            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
      0|  134|
      0|  135|            if let
      0|  136|                responseContentType = response.MIMEType,
      0|  137|                responseMIMEType = MIMEType(responseContentType)
      0|  138|            {
      0|  139|                for contentType in acceptableContentTypes {
      0|  140|                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
      0|  141|                        return .Success
      0|  142|                    }
      0|  143|                }
      0|  144|            } else {
      0|  145|                for contentType in acceptableContentTypes {
      0|  146|                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
      0|  147|                        return .Success
      0|  148|                    }
      0|  149|                }
      0|  150|            }
      0|  151|
      0|  152|            let failureReason: String
      0|  153|
      0|  154|            if let responseContentType = response.MIMEType {
      0|  155|                failureReason = (
      0|  156|                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
      0|  157|                    "content types: \(acceptableContentTypes)"
      0|  158|                )
      0|  159|            } else {
      0|  160|                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
      0|  161|            }
      0|  162|
      0|  163|            return .Failure(Error.errorWithCode(.ContentTypeValidationFailed, failureReason: failureReason))
      0|  164|        }
      0|  165|    }
       |  166|
       |  167|    // MARK: - Automatic
       |  168|
       |  169|    /**
       |  170|        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
       |  171|        type matches any specified in the Accept HTTP header field.
       |  172|
       |  173|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  174|
       |  175|        - returns: The request.
       |  176|    */
      0|  177|    public func validate() -> Self {
      0|  178|        let acceptableStatusCodes: Range<Int> = 200..<300
      0|  179|        let acceptableContentTypes: [String] = {
      0|  180|            if let accept = request?.valueForHTTPHeaderField("Accept") {
      0|  181|                return accept.componentsSeparatedByString(",")
      0|  182|            }
      0|  183|
      0|  184|            return ["*/*"]
      0|  185|        }()
      0|  186|
      0|  187|        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
      0|  188|    }
       |  189|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Alamofire.swift:
       |    1|// Alamofire.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: - URLStringConvertible
       |   26|
       |   27|/**
       |   28|    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
       |   29|    construct URL requests.
       |   30|*/
       |   31|public protocol URLStringConvertible {
       |   32|    /**
       |   33|        A URL that conforms to RFC 2396.
       |   34|
       |   35|        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
       |   36|
       |   37|        See https://tools.ietf.org/html/rfc2396
       |   38|        See https://tools.ietf.org/html/rfc1738
       |   39|        See https://tools.ietf.org/html/rfc1808
       |   40|    */
       |   41|    var URLString: String { get }
       |   42|}
       |   43|
       |   44|extension String: URLStringConvertible {
      1|   45|    public var URLString: String {
      1|   46|        return self
      1|   47|    }
       |   48|}
       |   49|
       |   50|extension NSURL: URLStringConvertible {
      0|   51|    public var URLString: String {
      0|   52|        return absoluteString
      0|   53|    }
       |   54|}
       |   55|
       |   56|extension NSURLComponents: URLStringConvertible {
      0|   57|    public var URLString: String {
      0|   58|        return URL!.URLString
      0|   59|    }
       |   60|}
       |   61|
       |   62|extension NSURLRequest: URLStringConvertible {
      0|   63|    public var URLString: String {
      0|   64|        return URL!.URLString
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - URLRequestConvertible
       |   69|
       |   70|/**
       |   71|    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
       |   72|*/
       |   73|public protocol URLRequestConvertible {
       |   74|    /// The URL request.
       |   75|    var URLRequest: NSMutableURLRequest { get }
       |   76|}
       |   77|
       |   78|extension NSURLRequest: URLRequestConvertible {
      2|   79|    public var URLRequest: NSMutableURLRequest {
      2|   80|        return self.mutableCopy() as! NSMutableURLRequest
      2|   81|    }
       |   82|}
       |   83|
       |   84|// MARK: - Convenience
       |   85|
       |   86|func URLRequest(
       |   87|    method: Method,
       |   88|    _ URLString: URLStringConvertible,
       |   89|    headers: [String: String]? = nil)
       |   90|    -> NSMutableURLRequest
      1|   91|{
      1|   92|    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
      1|   93|    mutableURLRequest.HTTPMethod = method.rawValue
      1|   94|
      1|   95|    if let headers = headers {
      2|   96|        for (headerField, headerValue) in headers {
      2|   97|            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
      2|   98|        }
      1|   99|    }
      1|  100|
      1|  101|    return mutableURLRequest
      1|  102|}
       |  103|
       |  104|// MARK: - Request Methods
       |  105|
       |  106|/**
       |  107|    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
       |  108|    parameter encoding.
       |  109|
       |  110|    - parameter method:     The HTTP method.
       |  111|    - parameter URLString:  The URL string.
       |  112|    - parameter parameters: The parameters. `nil` by default.
       |  113|    - parameter encoding:   The parameter encoding. `.URL` by default.
       |  114|    - parameter headers:    The HTTP headers. `nil` by default.
       |  115|
       |  116|    - returns: The created request.
       |  117|*/
       |  118|public func request(
       |  119|    method: Method,
       |  120|    _ URLString: URLStringConvertible,
       |  121|    parameters: [String: AnyObject]? = nil,
       |  122|    encoding: ParameterEncoding = .URL,
       |  123|    headers: [String: String]? = nil)
       |  124|    -> Request
      1|  125|{
      1|  126|    return Manager.sharedInstance.request(
      1|  127|        method,
      1|  128|        URLString,
      1|  129|        parameters: parameters,
      1|  130|        encoding: encoding,
      1|  131|        headers: headers
      1|  132|    )
      1|  133|}
       |  134|
       |  135|/**
       |  136|    Creates a request using the shared manager instance for the specified URL request.
       |  137|
       |  138|    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  139|
       |  140|    - parameter URLRequest: The URL request
       |  141|
       |  142|    - returns: The created request.
       |  143|*/
      0|  144|public func request(URLRequest: URLRequestConvertible) -> Request {
      0|  145|    return Manager.sharedInstance.request(URLRequest.URLRequest)
      0|  146|}
       |  147|
       |  148|// MARK: - Upload Methods
       |  149|
       |  150|// MARK: File
       |  151|
       |  152|/**
       |  153|    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
       |  154|
       |  155|    - parameter method:    The HTTP method.
       |  156|    - parameter URLString: The URL string.
       |  157|    - parameter headers:   The HTTP headers. `nil` by default.
       |  158|    - parameter file:      The file to upload.
       |  159|
       |  160|    - returns: The created upload request.
       |  161|*/
       |  162|public func upload(
       |  163|    method: Method,
       |  164|    _ URLString: URLStringConvertible,
       |  165|    headers: [String: String]? = nil,
       |  166|    file: NSURL)
       |  167|    -> Request
      0|  168|{
      0|  169|    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
      0|  170|}
       |  171|
       |  172|/**
       |  173|    Creates an upload request using the shared manager instance for the specified URL request and file.
       |  174|
       |  175|    - parameter URLRequest: The URL request.
       |  176|    - parameter file:       The file to upload.
       |  177|
       |  178|    - returns: The created upload request.
       |  179|*/
      0|  180|public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|  181|    return Manager.sharedInstance.upload(URLRequest, file: file)
      0|  182|}
       |  183|
       |  184|// MARK: Data
       |  185|
       |  186|/**
       |  187|    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
       |  188|
       |  189|    - parameter method:    The HTTP method.
       |  190|    - parameter URLString: The URL string.
       |  191|    - parameter headers:   The HTTP headers. `nil` by default.
       |  192|    - parameter data:      The data to upload.
       |  193|
       |  194|    - returns: The created upload request.
       |  195|*/
       |  196|public func upload(
       |  197|    method: Method,
       |  198|    _ URLString: URLStringConvertible,
       |  199|    headers: [String: String]? = nil,
       |  200|    data: NSData)
       |  201|    -> Request
      0|  202|{
      0|  203|    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
      0|  204|}
       |  205|
       |  206|/**
       |  207|    Creates an upload request using the shared manager instance for the specified URL request and data.
       |  208|
       |  209|    - parameter URLRequest: The URL request.
       |  210|    - parameter data:       The data to upload.
       |  211|
       |  212|    - returns: The created upload request.
       |  213|*/
      0|  214|public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  215|    return Manager.sharedInstance.upload(URLRequest, data: data)
      0|  216|}
       |  217|
       |  218|// MARK: Stream
       |  219|
       |  220|/**
       |  221|    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
       |  222|
       |  223|    - parameter method:    The HTTP method.
       |  224|    - parameter URLString: The URL string.
       |  225|    - parameter headers:   The HTTP headers. `nil` by default.
       |  226|    - parameter stream:    The stream to upload.
       |  227|
       |  228|    - returns: The created upload request.
       |  229|*/
       |  230|public func upload(
       |  231|    method: Method,
       |  232|    _ URLString: URLStringConvertible,
       |  233|    headers: [String: String]? = nil,
       |  234|    stream: NSInputStream)
       |  235|    -> Request
      0|  236|{
      0|  237|    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
      0|  238|}
       |  239|
       |  240|/**
       |  241|    Creates an upload request using the shared manager instance for the specified URL request and stream.
       |  242|
       |  243|    - parameter URLRequest: The URL request.
       |  244|    - parameter stream:     The stream to upload.
       |  245|
       |  246|    - returns: The created upload request.
       |  247|*/
      0|  248|public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  249|    return Manager.sharedInstance.upload(URLRequest, stream: stream)
      0|  250|}
       |  251|
       |  252|// MARK: MultipartFormData
       |  253|
       |  254|/**
       |  255|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  256|
       |  257|    - parameter method:                  The HTTP method.
       |  258|    - parameter URLString:               The URL string.
       |  259|    - parameter headers:                 The HTTP headers. `nil` by default.
       |  260|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  261|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  262|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  263|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  264|*/
       |  265|public func upload(
       |  266|    method: Method,
       |  267|    _ URLString: URLStringConvertible,
       |  268|    headers: [String: String]? = nil,
       |  269|    multipartFormData: MultipartFormData -> Void,
       |  270|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  271|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  272|{
      0|  273|    return Manager.sharedInstance.upload(
      0|  274|        method,
      0|  275|        URLString,
      0|  276|        headers: headers,
      0|  277|        multipartFormData: multipartFormData,
      0|  278|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  279|        encodingCompletion: encodingCompletion
      0|  280|    )
      0|  281|}
       |  282|
       |  283|/**
       |  284|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  285|
       |  286|    - parameter URLRequest:              The URL request.
       |  287|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  288|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  289|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  290|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  291|*/
       |  292|public func upload(
       |  293|    URLRequest: URLRequestConvertible,
       |  294|    multipartFormData: MultipartFormData -> Void,
       |  295|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  296|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  297|{
      0|  298|    return Manager.sharedInstance.upload(
      0|  299|        URLRequest,
      0|  300|        multipartFormData: multipartFormData,
      0|  301|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  302|        encodingCompletion: encodingCompletion
      0|  303|    )
      0|  304|}
       |  305|
       |  306|// MARK: - Download Methods
       |  307|
       |  308|// MARK: URL Request
       |  309|
       |  310|/**
       |  311|    Creates a download request using the shared manager instance for the specified method and URL string.
       |  312|
       |  313|    - parameter method:      The HTTP method.
       |  314|    - parameter URLString:   The URL string.
       |  315|    - parameter parameters:  The parameters. `nil` by default.
       |  316|    - parameter encoding:    The parameter encoding. `.URL` by default.
       |  317|    - parameter headers:     The HTTP headers. `nil` by default.
       |  318|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  319|
       |  320|    - returns: The created download request.
       |  321|*/
       |  322|public func download(
       |  323|    method: Method,
       |  324|    _ URLString: URLStringConvertible,
       |  325|    parameters: [String: AnyObject]? = nil,
       |  326|    encoding: ParameterEncoding = .URL,
       |  327|    headers: [String: String]? = nil,
       |  328|    destination: Request.DownloadFileDestination)
       |  329|    -> Request
      0|  330|{
      0|  331|    return Manager.sharedInstance.download(
      0|  332|        method,
      0|  333|        URLString,
      0|  334|        parameters: parameters,
      0|  335|        encoding: encoding,
      0|  336|        headers: headers,
      0|  337|        destination: destination
      0|  338|    )
      0|  339|}
       |  340|
       |  341|/**
       |  342|    Creates a download request using the shared manager instance for the specified URL request.
       |  343|
       |  344|    - parameter URLRequest:  The URL request.
       |  345|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  346|
       |  347|    - returns: The created download request.
       |  348|*/
      0|  349|public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  350|    return Manager.sharedInstance.download(URLRequest, destination: destination)
      0|  351|}
       |  352|
       |  353|// MARK: Resume Data
       |  354|
       |  355|/**
       |  356|    Creates a request using the shared manager instance for downloading from the resume data produced from a 
       |  357|    previous request cancellation.
       |  358|
       |  359|    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
       |  360|                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
       |  361|                             information.
       |  362|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  363|
       |  364|    - returns: The created download request.
       |  365|*/
      0|  366|public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  367|    return Manager.sharedInstance.download(data, destination: destination)
      0|  368|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Download.swift:
       |    1|// Download.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Downloadable {
       |   27|        case Request(NSURLRequest)
       |   28|        case ResumeData(NSData)
       |   29|    }
       |   30|
      0|   31|    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
      0|   32|        var downloadTask: NSURLSessionDownloadTask!
      0|   33|
      0|   34|        switch downloadable {
      0|   35|        case .Request(let request):
      0|   36|            dispatch_sync(queue) {
      0|   37|                downloadTask = self.session.downloadTaskWithRequest(request)
      0|   38|            }
      0|   39|        case .ResumeData(let resumeData):
      0|   40|            dispatch_sync(queue) {
      0|   41|                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
      0|   42|            }
      0|   43|        }
      0|   44|
      0|   45|        let request = Request(session: session, task: downloadTask)
      0|   46|
      0|   47|        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
      0|   48|            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
      0|   49|                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
      0|   50|            }
      0|   51|        }
      0|   52|
      0|   53|        delegate[request.delegate.task] = request.delegate
      0|   54|
      0|   55|        if startRequestsImmediately {
      0|   56|            request.resume()
      0|   57|        }
      0|   58|
      0|   59|        return request
      0|   60|    }
       |   61|
       |   62|    // MARK: Request
       |   63|
       |   64|    /**
       |   65|        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
       |   66|        and destination.
       |   67|
       |   68|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   69|
       |   70|        - parameter method:      The HTTP method.
       |   71|        - parameter URLString:   The URL string.
       |   72|        - parameter parameters:  The parameters. `nil` by default.
       |   73|        - parameter encoding:    The parameter encoding. `.URL` by default.
       |   74|        - parameter headers:     The HTTP headers. `nil` by default.
       |   75|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |   76|
       |   77|        - returns: The created download request.
       |   78|    */
       |   79|    public func download(
       |   80|        method: Method,
       |   81|        _ URLString: URLStringConvertible,
       |   82|        parameters: [String: AnyObject]? = nil,
       |   83|        encoding: ParameterEncoding = .URL,
       |   84|        headers: [String: String]? = nil,
       |   85|        destination: Request.DownloadFileDestination)
       |   86|        -> Request
      0|   87|    {
      0|   88|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|   89|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      0|   90|
      0|   91|        return download(encodedURLRequest, destination: destination)
      0|   92|    }
       |   93|
       |   94|    /**
       |   95|        Creates a request for downloading from the specified URL request.
       |   96|
       |   97|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   98|
       |   99|        - parameter URLRequest:  The URL request
       |  100|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  101|
       |  102|        - returns: The created download request.
       |  103|    */
      0|  104|    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  105|        return download(.Request(URLRequest.URLRequest), destination: destination)
      0|  106|    }
       |  107|
       |  108|    // MARK: Resume Data
       |  109|
       |  110|    /**
       |  111|        Creates a request for downloading from the resume data produced from a previous request cancellation.
       |  112|
       |  113|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  114|
       |  115|        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
       |  116|                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
       |  117|                                 additional information.
       |  118|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  119|
       |  120|        - returns: The created download request.
       |  121|    */
      0|  122|    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  123|        return download(.ResumeData(resumeData), destination: destination)
      0|  124|    }
       |  125|}
       |  126|
       |  127|// MARK: -
       |  128|
       |  129|extension Request {
       |  130|    /**
       |  131|        A closure executed once a request has successfully completed in order to determine where to move the temporary 
       |  132|        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
       |  133|        response, and returns a single argument: the file URL where the temporary file should be moved.
       |  134|    */
       |  135|    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
       |  136|
       |  137|    /**
       |  138|        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
       |  139|        file URL in the first available directory with the specified search path directory and search path domain mask.
       |  140|
       |  141|        - parameter directory: The search path directory. `.DocumentDirectory` by default.
       |  142|        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
       |  143|
       |  144|        - returns: A download file destination closure.
       |  145|    */
       |  146|    public class func suggestedDownloadDestination(
       |  147|        directory directory: NSSearchPathDirectory = .DocumentDirectory,
       |  148|        domain: NSSearchPathDomainMask = .UserDomainMask)
       |  149|        -> DownloadFileDestination
      0|  150|    {
      0|  151|        return { temporaryURL, response -> NSURL in
      0|  152|            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
      0|  153|
      0|  154|            if !directoryURLs.isEmpty {
      0|  155|                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
      0|  156|            }
      0|  157|
      0|  158|            return temporaryURL
      0|  159|        }
      0|  160|    }
       |  161|
       |  162|    /// The resume data of the underlying download task if available after a failure.
      0|  163|    public var resumeData: NSData? {
      0|  164|        var data: NSData?
      0|  165|
      0|  166|        if let delegate = delegate as? DownloadTaskDelegate {
      0|  167|            data = delegate.resumeData
      0|  168|        }
      0|  169|
      0|  170|        return data
      0|  171|    }
       |  172|
       |  173|    // MARK: - DownloadTaskDelegate
       |  174|
       |  175|    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
      0|  176|        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
       |  177|        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
       |  178|
       |  179|        var resumeData: NSData?
      0|  180|        override var data: NSData? { return resumeData }
       |  181|
       |  182|        // MARK: - NSURLSessionDownloadDelegate
       |  183|
       |  184|        // MARK: Override Closures
       |  185|
       |  186|        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
       |  187|        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  188|        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  189|
       |  190|        // MARK: Delegate Methods
       |  191|
       |  192|        func URLSession(
       |  193|            session: NSURLSession,
       |  194|            downloadTask: NSURLSessionDownloadTask,
       |  195|            didFinishDownloadingToURL location: NSURL)
      0|  196|        {
      0|  197|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  198|                do {
      0|  199|                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  200|                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
      0|  201|                } catch {
      0|  202|                    self.error = error as NSError
      0|  203|                }
      0|  204|            }
      0|  205|        }
       |  206|
       |  207|        func URLSession(
       |  208|            session: NSURLSession,
       |  209|            downloadTask: NSURLSessionDownloadTask,
       |  210|            didWriteData bytesWritten: Int64,
       |  211|            totalBytesWritten: Int64,
       |  212|            totalBytesExpectedToWrite: Int64)
      0|  213|        {
      0|  214|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  215|                downloadTaskDidWriteData(
      0|  216|                    session,
      0|  217|                    downloadTask,
      0|  218|                    bytesWritten,
      0|  219|                    totalBytesWritten, 
      0|  220|                    totalBytesExpectedToWrite
      0|  221|                )
      0|  222|            } else {
      0|  223|                progress.totalUnitCount = totalBytesExpectedToWrite
      0|  224|                progress.completedUnitCount = totalBytesWritten
      0|  225|
      0|  226|                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  227|            }
      0|  228|        }
       |  229|
       |  230|        func URLSession(
       |  231|            session: NSURLSession,
       |  232|            downloadTask: NSURLSessionDownloadTask,
       |  233|            didResumeAtOffset fileOffset: Int64,
       |  234|            expectedTotalBytes: Int64)
      0|  235|        {
      0|  236|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  237|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  238|            } else {
      0|  239|                progress.totalUnitCount = expectedTotalBytes
      0|  240|                progress.completedUnitCount = fileOffset
      0|  241|            }
      0|  242|        }
       |  243|    }
       |  244|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Error.swift:
       |    1|// Error.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
       |   26|public struct Error {
       |   27|    /// The domain used for creating all Alamofire errors.
       |   28|    public static let Domain = "com.alamofire.error"
       |   29|
       |   30|    /// The custom error codes generated by Alamofire.
       |   31|    public enum Code: Int {
       |   32|        case InputStreamReadFailed           = -6000
       |   33|        case OutputStreamWriteFailed         = -6001
       |   34|        case ContentTypeValidationFailed     = -6002
       |   35|        case StatusCodeValidationFailed      = -6003
       |   36|        case DataSerializationFailed         = -6004
       |   37|        case StringSerializationFailed       = -6005
       |   38|        case JSONSerializationFailed         = -6006
       |   39|        case PropertyListSerializationFailed = -6007
       |   40|    }
       |   41|
       |   42|    /**
       |   43|        Creates an `NSError` with the given error code and failure reason.
       |   44|
       |   45|        - parameter code:          The error code.
       |   46|        - parameter failureReason: The failure reason.
       |   47|
       |   48|        - returns: An `NSError` with the given error code and failure reason.
       |   49|    */
      0|   50|    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
      0|   51|        return errorWithCode(code.rawValue, failureReason: failureReason)
      0|   52|    }
       |   53|
       |   54|    /**
       |   55|        Creates an `NSError` with the given error code and failure reason.
       |   56|
       |   57|        - parameter code:          The error code.
       |   58|        - parameter failureReason: The failure reason.
       |   59|
       |   60|        - returns: An `NSError` with the given error code and failure reason.
       |   61|    */
      0|   62|    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
      0|   63|        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
      0|   64|        return NSError(domain: Domain, code: code, userInfo: userInfo)
      0|   65|    }
       |   66|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Manager.swift:
       |    1|// Manager.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
       |   27|*/
       |   28|public class Manager {
       |   29|
       |   30|    // MARK: - Properties
       |   31|
       |   32|    /**
       |   33|        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
       |   34|        for any ad hoc requests.
       |   35|    */
       |   36|    public static let sharedInstance: Manager = {
       |   37|        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
       |   38|        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
       |   39|
       |   40|        return Manager(configuration: configuration)
       |   41|    }()
       |   42|
       |   43|    /**
       |   44|        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
       |   45|    */
       |   46|    public static let defaultHTTPHeaders: [String: String] = {
       |   47|        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
       |   48|        let acceptEncoding: String = "gzip;q=1.0,compress;q=0.5"
       |   49|
       |   50|        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
       |   51|        let acceptLanguage: String = {
       |   52|            var components: [String] = []
       |   53|            for (index, languageCode) in (NSLocale.preferredLanguages() as [String]).enumerate() {
       |   54|                let q = 1.0 - (Double(index) * 0.1)
       |   55|                components.append("\(languageCode);q=\(q)")
       |   56|                if q <= 0.5 {
       |   57|                    break
       |   58|                }
       |   59|            }
       |   60|
       |   61|            return components.joinWithSeparator(",")
       |   62|        }()
       |   63|
       |   64|        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
       |   65|        let userAgent: String = {
       |   66|            if let info = NSBundle.mainBundle().infoDictionary {
       |   67|                let executable: AnyObject = info[kCFBundleExecutableKey as String] ?? "Unknown"
       |   68|                let bundle: AnyObject = info[kCFBundleIdentifierKey as String] ?? "Unknown"
       |   69|                let version: AnyObject = info[kCFBundleVersionKey as String] ?? "Unknown"
       |   70|                let os: AnyObject = NSProcessInfo.processInfo().operatingSystemVersionString ?? "Unknown"
       |   71|
       |   72|                var mutableUserAgent = NSMutableString(string: "\(executable)/\(bundle) (\(version); OS \(os))") as CFMutableString
       |   73|                let transform = NSString(string: "Any-Latin; Latin-ASCII; [:^ASCII:] Remove") as CFString
       |   74|
       |   75|                if CFStringTransform(mutableUserAgent, UnsafeMutablePointer<CFRange>(nil), transform, false) {
       |   76|                    return mutableUserAgent as String
       |   77|                }
       |   78|            }
       |   79|
       |   80|            return "Alamofire"
       |   81|        }()
       |   82|
       |   83|        return [
       |   84|            "Accept-Encoding": acceptEncoding,
       |   85|            "Accept-Language": acceptLanguage,
       |   86|            "User-Agent": userAgent
       |   87|        ]
       |   88|    }()
       |   89|
       |   90|    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
       |   91|
       |   92|    /// The underlying session.
       |   93|    public let session: NSURLSession
       |   94|
       |   95|    /// The session delegate handling all the task and session delegate callbacks.
       |   96|    public let delegate: SessionDelegate
       |   97|
       |   98|    /// Whether to start requests immediately after being constructed. `true` by default.
       |   99|    public var startRequestsImmediately: Bool = true
       |  100|
       |  101|    /**
       |  102|        The background completion handler closure provided by the UIApplicationDelegate 
       |  103|        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
       |  104|        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
       |  105|        will automatically call the handler.
       |  106|    
       |  107|        If you need to handle your own events before the handler is called, then you need to override the 
       |  108|        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
       |  109|    
       |  110|        `nil` by default.
       |  111|    */
       |  112|    public var backgroundCompletionHandler: (() -> Void)?
       |  113|
       |  114|    // MARK: - Lifecycle
       |  115|
       |  116|    /**
       |  117|        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
       |  118|
       |  119|        - parameter configuration:            The configuration used to construct the managed session. 
       |  120|                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
       |  121|        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
       |  122|                                              default.
       |  123|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
       |  124|                                              challenges. `nil` by default.
       |  125|
       |  126|        - returns: The new `Manager` instance.
       |  127|    */
       |  128|    public init(
       |  129|        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
       |  130|        delegate: SessionDelegate = SessionDelegate(),
       |  131|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      1|  132|    {
      1|  133|        self.delegate = delegate
      1|  134|        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
      1|  135|
      1|  136|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      1|  137|    }
       |  138|
       |  139|    /**
       |  140|        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
       |  141|
       |  142|        - parameter session:                  The URL session.
       |  143|        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
       |  144|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
       |  145|                                              challenges. `nil` by default.
       |  146|
       |  147|        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
       |  148|    */
       |  149|    public init?(
       |  150|        session: NSURLSession,
       |  151|        delegate: SessionDelegate,
       |  152|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      0|  153|    {
      0|  154|        self.delegate = delegate
      0|  155|        self.session = session
      0|  156|
      0|  157|        guard delegate === session.delegate else { return nil }
      0|  158|
      0|  159|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      0|  160|    }
       |  161|
      1|  162|    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
      1|  163|        session.serverTrustPolicyManager = serverTrustPolicyManager
      1|  164|
      0|  165|        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
      0|  166|            guard let strongSelf = self else { return }
      0|  167|            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
      0|  168|        }
      1|  169|    }
       |  170|
      0|  171|    deinit {
      0|  172|        session.invalidateAndCancel()
      0|  173|    }
       |  174|
       |  175|    // MARK: - Request
       |  176|
       |  177|    /**
       |  178|        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
       |  179|
       |  180|        - parameter method:     The HTTP method.
       |  181|        - parameter URLString:  The URL string.
       |  182|        - parameter parameters: The parameters. `nil` by default.
       |  183|        - parameter encoding:   The parameter encoding. `.URL` by default.
       |  184|        - parameter headers:    The HTTP headers. `nil` by default.
       |  185|
       |  186|        - returns: The created request.
       |  187|    */
       |  188|    public func request(
       |  189|        method: Method,
       |  190|        _ URLString: URLStringConvertible,
       |  191|        parameters: [String: AnyObject]? = nil,
       |  192|        encoding: ParameterEncoding = .URL,
       |  193|        headers: [String: String]? = nil)
       |  194|        -> Request
      1|  195|    {
      1|  196|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      1|  197|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      1|  198|        return request(encodedURLRequest)
      1|  199|    }
       |  200|
       |  201|    /**
       |  202|        Creates a request for the specified URL request.
       |  203|
       |  204|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  205|
       |  206|        - parameter URLRequest: The URL request
       |  207|
       |  208|        - returns: The created request.
       |  209|    */
      1|  210|    public func request(URLRequest: URLRequestConvertible) -> Request {
      1|  211|        var dataTask: NSURLSessionDataTask!
      1|  212|        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
      1|  213|
      1|  214|        let request = Request(session: session, task: dataTask)
      1|  215|        delegate[request.delegate.task] = request.delegate
      1|  216|
      1|  217|        if startRequestsImmediately {
      1|  218|            request.resume()
      1|  219|        }
      1|  220|
      1|  221|        return request
      1|  222|    }
       |  223|
       |  224|    // MARK: - SessionDelegate
       |  225|
       |  226|    /**
       |  227|        Responsible for handling all delegate callbacks for the underlying session.
       |  228|    */
       |  229|    public final class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
       |  230|        private var subdelegates: [Int: Request.TaskDelegate] = [:]
       |  231|        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
       |  232|
       |  233|        subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
      4|  234|            get {
      4|  235|                var subdelegate: Request.TaskDelegate?
      4|  236|                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
      4|  237|
      4|  238|                return subdelegate
      4|  239|            }
       |  240|
      2|  241|            set {
      2|  242|                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
      2|  243|            }
       |  244|        }
       |  245|
       |  246|        /**
       |  247|            Initializes the `SessionDelegate` instance.
       |  248|
       |  249|            - returns: The new `SessionDelegate` instance.
       |  250|        */
      1|  251|        public override init() {
      1|  252|            super.init()
      1|  253|        }
       |  254|
       |  255|        // MARK: - NSURLSessionDelegate
       |  256|
       |  257|        // MARK: Override Closures
       |  258|
       |  259|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
       |  260|        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
       |  261|
       |  262|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
       |  263|        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  264|
       |  265|        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
       |  266|        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
       |  267|
       |  268|        // MARK: Delegate Methods
       |  269|
       |  270|        /**
       |  271|            Tells the delegate that the session has been invalidated.
       |  272|
       |  273|            - parameter session: The session object that was invalidated.
       |  274|            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
       |  275|        */
      0|  276|        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
      0|  277|            sessionDidBecomeInvalidWithError?(session, error)
      0|  278|        }
       |  279|
       |  280|        /**
       |  281|            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
       |  282|
       |  283|            - parameter session:           The session containing the task that requested authentication.
       |  284|            - parameter challenge:         An object that contains the request for authentication.
       |  285|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  286|        */
       |  287|        public func URLSession(
       |  288|            session: NSURLSession,
       |  289|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  290|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      0|  291|        {
      0|  292|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      0|  293|            var credential: NSURLCredential?
      0|  294|
      0|  295|            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
      0|  296|                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
      0|  297|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      0|  298|                let host = challenge.protectionSpace.host
      0|  299|
      0|  300|                if let
      0|  301|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      0|  302|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  303|                {
      0|  304|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  305|                        disposition = .UseCredential
      0|  306|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  307|                    } else {
      0|  308|                        disposition = .CancelAuthenticationChallenge
      0|  309|                    }
      0|  310|                }
      0|  311|            }
      0|  312|
      0|  313|            completionHandler(disposition, credential)
      0|  314|        }
       |  315|
       |  316|        /**
       |  317|            Tells the delegate that all messages enqueued for a session have been delivered.
       |  318|
       |  319|            - parameter session: The session that no longer has any outstanding requests.
       |  320|        */
      0|  321|        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
      0|  322|            sessionDidFinishEventsForBackgroundURLSession?(session)
      0|  323|        }
       |  324|
       |  325|        // MARK: - NSURLSessionTaskDelegate
       |  326|
       |  327|        // MARK: Override Closures
       |  328|
       |  329|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
       |  330|        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  331|
       |  332|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
       |  333|        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  334|
       |  335|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
       |  336|        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream!)?
       |  337|
       |  338|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
       |  339|        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  340|
       |  341|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
       |  342|        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  343|
       |  344|        // MARK: Delegate Methods
       |  345|
       |  346|        /**
       |  347|            Tells the delegate that the remote server requested an HTTP redirect.
       |  348|
       |  349|            - parameter session:           The session containing the task whose request resulted in a redirect.
       |  350|            - parameter task:              The task whose request resulted in a redirect.
       |  351|            - parameter response:          An object containing the server’s response to the original request.
       |  352|            - parameter request:           A URL request object filled out with the new location.
       |  353|            - parameter completionHandler: A closure that your handler should call with either the value of the request 
       |  354|                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
       |  355|                                           return the body of the redirect response.
       |  356|        */
       |  357|        public func URLSession(
       |  358|            session: NSURLSession,
       |  359|            task: NSURLSessionTask,
       |  360|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  361|            newRequest request: NSURLRequest,
       |  362|            completionHandler: ((NSURLRequest?) -> Void))
      0|  363|        {
      0|  364|            var redirectRequest: NSURLRequest? = request
      0|  365|
      0|  366|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  367|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  368|            }
      0|  369|
      0|  370|            completionHandler(redirectRequest)
      0|  371|        }
       |  372|
       |  373|        /**
       |  374|            Requests credentials from the delegate in response to an authentication request from the remote server.
       |  375|
       |  376|            - parameter session:           The session containing the task whose request requires authentication.
       |  377|            - parameter task:              The task whose request requires authentication.
       |  378|            - parameter challenge:         An object that contains the request for authentication.
       |  379|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  380|        */
       |  381|        public func URLSession(
       |  382|            session: NSURLSession,
       |  383|            task: NSURLSessionTask,
       |  384|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  385|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  386|        {
      0|  387|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  388|                completionHandler(taskDidReceiveChallenge(session, task, challenge))
      1|  389|            } else if let delegate = self[task] {
      1|  390|                delegate.URLSession(
      1|  391|                    session,
      1|  392|                    task: task,
      1|  393|                    didReceiveChallenge: challenge,
      1|  394|                    completionHandler: completionHandler
      1|  395|                )
      0|  396|            } else {
      0|  397|                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
      0|  398|            }
      1|  399|        }
       |  400|
       |  401|        /**
       |  402|            Tells the delegate when a task requires a new request body stream to send to the remote server.
       |  403|
       |  404|            - parameter session:           The session containing the task that needs a new body stream.
       |  405|            - parameter task:              The task that needs a new body stream.
       |  406|            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
       |  407|        */
       |  408|        public func URLSession(
       |  409|            session: NSURLSession,
       |  410|            task: NSURLSessionTask,
       |  411|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  412|        {
      0|  413|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  414|                completionHandler(taskNeedNewBodyStream(session, task))
      0|  415|            } else if let delegate = self[task] {
      0|  416|                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
      0|  417|            }
      0|  418|        }
       |  419|
       |  420|        /**
       |  421|            Periodically informs the delegate of the progress of sending body content to the server.
       |  422|
       |  423|            - parameter session:                  The session containing the data task.
       |  424|            - parameter task:                     The data task.
       |  425|            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
       |  426|            - parameter totalBytesSent:           The total number of bytes sent so far.
       |  427|            - parameter totalBytesExpectedToSend: The expected length of the body data.
       |  428|        */
       |  429|        public func URLSession(
       |  430|            session: NSURLSession,
       |  431|            task: NSURLSessionTask,
       |  432|            didSendBodyData bytesSent: Int64,
       |  433|            totalBytesSent: Int64,
       |  434|            totalBytesExpectedToSend: Int64)
      1|  435|        {
      0|  436|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  437|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  438|            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
      0|  439|                delegate.URLSession(
      0|  440|                    session,
      0|  441|                    task: task,
      0|  442|                    didSendBodyData: bytesSent,
      0|  443|                    totalBytesSent: totalBytesSent,
      0|  444|                    totalBytesExpectedToSend: totalBytesExpectedToSend
      0|  445|                )
      0|  446|            }
      1|  447|        }
       |  448|
       |  449|        /**
       |  450|            Tells the delegate that the task finished transferring data.
       |  451|
       |  452|            - parameter session: The session containing the task whose request finished transferring data.
       |  453|            - parameter task:    The task whose request finished transferring data.
       |  454|            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
       |  455|        */
      1|  456|        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  457|            if let taskDidComplete = taskDidComplete {
      0|  458|                taskDidComplete(session, task, error)
      1|  459|            } else if let delegate = self[task] {
      1|  460|                delegate.URLSession(session, task: task, didCompleteWithError: error)
      1|  461|            }
      1|  462|
      1|  463|            self[task] = nil
      1|  464|        }
       |  465|
       |  466|        // MARK: - NSURLSessionDataDelegate
       |  467|
       |  468|        // MARK: Override Closures
       |  469|
       |  470|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
       |  471|        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  472|
       |  473|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
       |  474|        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  475|
       |  476|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
       |  477|        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  478|
       |  479|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
       |  480|        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse!)?
       |  481|
       |  482|        // MARK: Delegate Methods
       |  483|
       |  484|        /**
       |  485|            Tells the delegate that the data task received the initial reply (headers) from the server.
       |  486|
       |  487|            - parameter session:           The session containing the data task that received an initial reply.
       |  488|            - parameter dataTask:          The data task that received an initial reply.
       |  489|            - parameter response:          A URL response object populated with headers.
       |  490|            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
       |  491|                                           constant to indicate whether the transfer should continue as a data task or 
       |  492|                                           should become a download task.
       |  493|        */
       |  494|        public func URLSession(
       |  495|            session: NSURLSession,
       |  496|            dataTask: NSURLSessionDataTask,
       |  497|            didReceiveResponse response: NSURLResponse,
       |  498|            completionHandler: ((NSURLSessionResponseDisposition) -> Void))
      0|  499|        {
      0|  500|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  501|
      0|  502|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  503|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  504|            }
      0|  505|
      0|  506|            completionHandler(disposition)
      0|  507|        }
       |  508|
       |  509|        /**
       |  510|            Tells the delegate that the data task was changed to a download task.
       |  511|
       |  512|            - parameter session:      The session containing the task that was replaced by a download task.
       |  513|            - parameter dataTask:     The data task that was replaced by a download task.
       |  514|            - parameter downloadTask: The new download task that replaced the data task.
       |  515|        */
       |  516|        public func URLSession(
       |  517|            session: NSURLSession,
       |  518|            dataTask: NSURLSessionDataTask,
       |  519|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  520|        {
      0|  521|            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
      0|  522|                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
      0|  523|            } else {
      0|  524|                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
      0|  525|                self[downloadTask] = downloadDelegate
      0|  526|            }
      0|  527|        }
       |  528|
       |  529|        /**
       |  530|            Tells the delegate that the data task has received some of the expected data.
       |  531|
       |  532|            - parameter session:  The session containing the data task that provided data.
       |  533|            - parameter dataTask: The data task that provided data.
       |  534|            - parameter data:     A data object containing the transferred data.
       |  535|        */
      1|  536|        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  537|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  538|                dataTaskDidReceiveData(session, dataTask, data)
      1|  539|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      1|  540|                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
      1|  541|            }
      1|  542|        }
       |  543|
       |  544|        /**
       |  545|            Asks the delegate whether the data (or upload) task should store the response in the cache.
       |  546|
       |  547|            - parameter session:           The session containing the data (or upload) task.
       |  548|            - parameter dataTask:          The data (or upload) task.
       |  549|            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
       |  550|                                           caching policy and the values of certain received headers, such as the Pragma 
       |  551|                                           and Cache-Control headers.
       |  552|            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
       |  553|                                           response, a modified version of that response, or NULL to prevent caching the 
       |  554|                                           response. If your delegate implements this method, it must call this completion 
       |  555|                                           handler; otherwise, your app leaks memory.
       |  556|        */
       |  557|        public func URLSession(
       |  558|            session: NSURLSession,
       |  559|            dataTask: NSURLSessionDataTask,
       |  560|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  561|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  562|        {
      0|  563|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  564|                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
      0|  565|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      0|  566|                delegate.URLSession(
      0|  567|                    session,
      0|  568|                    dataTask: dataTask,
      0|  569|                    willCacheResponse: proposedResponse,
      0|  570|                    completionHandler: completionHandler
      0|  571|                )
      0|  572|            } else {
      0|  573|                completionHandler(proposedResponse)
      0|  574|            }
      0|  575|        }
       |  576|
       |  577|        // MARK: - NSURLSessionDownloadDelegate
       |  578|
       |  579|        // MARK: Override Closures
       |  580|
       |  581|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
       |  582|        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
       |  583|
       |  584|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
       |  585|        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  586|
       |  587|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
       |  588|        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  589|
       |  590|        // MARK: Delegate Methods
       |  591|
       |  592|        /**
       |  593|            Tells the delegate that a download task has finished downloading.
       |  594|
       |  595|            - parameter session:      The session containing the download task that finished.
       |  596|            - parameter downloadTask: The download task that finished.
       |  597|            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
       |  598|                                      open the file for reading or move it to a permanent location in your app’s sandbox 
       |  599|                                      container directory before returning from this delegate method.
       |  600|        */
       |  601|        public func URLSession(
       |  602|            session: NSURLSession,
       |  603|            downloadTask: NSURLSessionDownloadTask,
       |  604|            didFinishDownloadingToURL location: NSURL)
      0|  605|        {
      0|  606|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  607|                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  608|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  609|                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
      0|  610|            }
      0|  611|        }
       |  612|
       |  613|        /**
       |  614|            Periodically informs the delegate about the download’s progress.
       |  615|
       |  616|            - parameter session:                   The session containing the download task.
       |  617|            - parameter downloadTask:              The download task.
       |  618|            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
       |  619|                                                   method was called.
       |  620|            - parameter totalBytesWritten:         The total number of bytes transferred so far.
       |  621|            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
       |  622|                                                   header. If this header was not provided, the value is 
       |  623|                                                   `NSURLSessionTransferSizeUnknown`.
       |  624|        */
       |  625|        public func URLSession(
       |  626|            session: NSURLSession,
       |  627|            downloadTask: NSURLSessionDownloadTask,
       |  628|            didWriteData bytesWritten: Int64,
       |  629|            totalBytesWritten: Int64,
       |  630|            totalBytesExpectedToWrite: Int64)
      0|  631|        {
      0|  632|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  633|                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  634|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  635|                delegate.URLSession(
      0|  636|                    session,
      0|  637|                    downloadTask: downloadTask,
      0|  638|                    didWriteData: bytesWritten,
      0|  639|                    totalBytesWritten: totalBytesWritten,
      0|  640|                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
      0|  641|                )
      0|  642|            }
      0|  643|        }
       |  644|
       |  645|        /**
       |  646|            Tells the delegate that the download task has resumed downloading.
       |  647|
       |  648|            - parameter session:            The session containing the download task that finished.
       |  649|            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
       |  650|            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
       |  651|                                            existing content, then this value is zero. Otherwise, this value is an 
       |  652|                                            integer representing the number of bytes on disk that do not need to be 
       |  653|                                            retrieved again.
       |  654|            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
       |  655|                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
       |  656|        */
       |  657|        public func URLSession(
       |  658|            session: NSURLSession,
       |  659|            downloadTask: NSURLSessionDownloadTask,
       |  660|            didResumeAtOffset fileOffset: Int64,
       |  661|            expectedTotalBytes: Int64)
      0|  662|        {
      0|  663|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  664|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  665|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  666|                delegate.URLSession(
      0|  667|                    session,
      0|  668|                    downloadTask: downloadTask,
      0|  669|                    didResumeAtOffset: fileOffset,
      0|  670|                    expectedTotalBytes: expectedTotalBytes
      0|  671|                )
      0|  672|            }
      0|  673|        }
       |  674|
       |  675|        // MARK: - NSURLSessionStreamDelegate
       |  676|
       |  677|        var _streamTaskReadClosed: Any?
       |  678|        var _streamTaskWriteClosed: Any?
       |  679|        var _streamTaskBetterRouteDiscovered: Any?
       |  680|        var _streamTaskDidBecomeInputStream: Any?
       |  681|
       |  682|        // MARK: - NSObject
       |  683|
     11|  684|        public override func respondsToSelector(selector: Selector) -> Bool {
     11|  685|            switch selector {
      0|  686|            case "URLSession:didBecomeInvalidWithError:":
      0|  687|                return sessionDidBecomeInvalidWithError != nil
      1|  688|            case "URLSession:didReceiveChallenge:completionHandler:":
      1|  689|                return sessionDidReceiveChallenge != nil
      0|  690|            case "URLSessionDidFinishEventsForBackgroundURLSession:":
      0|  691|                return sessionDidFinishEventsForBackgroundURLSession != nil
      0|  692|            case "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:":
      0|  693|                return taskWillPerformHTTPRedirection != nil
      1|  694|            case "URLSession:dataTask:didReceiveResponse:completionHandler:":
      1|  695|                return dataTaskDidReceiveResponse != nil
      9|  696|            default:
      9|  697|                return self.dynamicType.instancesRespondToSelector(selector)
     11|  698|            }
     11|  699|        }
       |  700|    }
       |  701|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/MultipartFormData.swift:
       |    1|// MultipartFormData.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if os(iOS) || os(watchOS) || os(tvOS)
       |   26|import MobileCoreServices
       |   27|#elseif os(OSX)
       |   28|import CoreServices
       |   29|#endif
       |   30|
       |   31|/**
       |   32|    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
       |   33|    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
       |   34|    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
       |   35|    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
       |   36|    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
       |   37|
       |   38|    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
       |   39|    and the w3 form documentation.
       |   40|
       |   41|    - https://www.ietf.org/rfc/rfc2388.txt
       |   42|    - https://www.ietf.org/rfc/rfc2045.txt
       |   43|    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
       |   44|*/
       |   45|public class MultipartFormData {
       |   46|
       |   47|    // MARK: - Helper Types
       |   48|
       |   49|    struct EncodingCharacters {
       |   50|        static let CRLF = "\r\n"
       |   51|    }
       |   52|
       |   53|    struct BoundaryGenerator {
       |   54|        enum BoundaryType {
       |   55|            case Initial, Encapsulated, Final
       |   56|        }
       |   57|
      0|   58|        static func randomBoundary() -> String {
      0|   59|            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
      0|   60|        }
       |   61|
      0|   62|        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
      0|   63|            let boundaryText: String
      0|   64|
      0|   65|            switch boundaryType {
      0|   66|            case .Initial:
      0|   67|                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
      0|   68|            case .Encapsulated:
      0|   69|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
      0|   70|            case .Final:
      0|   71|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
      0|   72|            }
      0|   73|
      0|   74|            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|   75|        }
       |   76|    }
       |   77|
       |   78|    class BodyPart {
       |   79|        let headers: [String: String]
       |   80|        let bodyStream: NSInputStream
       |   81|        let bodyContentLength: UInt64
       |   82|        var hasInitialBoundary = false
       |   83|        var hasFinalBoundary = false
       |   84|
      0|   85|        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
      0|   86|            self.headers = headers
      0|   87|            self.bodyStream = bodyStream
      0|   88|            self.bodyContentLength = bodyContentLength
      0|   89|        }
       |   90|    }
       |   91|
       |   92|    // MARK: - Properties
       |   93|
       |   94|    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
      0|   95|    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
       |   96|
       |   97|    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
      0|   98|    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
       |   99|
       |  100|    /// The boundary used to separate the body parts in the encoded form data.
       |  101|    public let boundary: String
       |  102|
       |  103|    private var bodyParts: [BodyPart]
       |  104|    private var bodyPartError: NSError?
       |  105|    private let streamBufferSize: Int
       |  106|
       |  107|    // MARK: - Lifecycle
       |  108|
       |  109|    /**
       |  110|        Creates a multipart form data object.
       |  111|
       |  112|        - returns: The multipart form data object.
       |  113|    */
      0|  114|    public init() {
      0|  115|        self.boundary = BoundaryGenerator.randomBoundary()
      0|  116|        self.bodyParts = []
      0|  117|
      0|  118|        /**
      0|  119|         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
      0|  120|         *  information, please refer to the following article:
      0|  121|         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
      0|  122|         */
      0|  123|
      0|  124|        self.streamBufferSize = 1024
      0|  125|    }
       |  126|
       |  127|    // MARK: - Body Parts
       |  128|
       |  129|    /**
       |  130|        Creates a body part from the data and appends it to the multipart form data object.
       |  131|
       |  132|        The body part data will be encoded using the following format:
       |  133|
       |  134|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  135|        - Encoded data
       |  136|        - Multipart form boundary
       |  137|
       |  138|        - parameter data: The data to encode into the multipart form data.
       |  139|        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
       |  140|    */
      0|  141|    public func appendBodyPart(data data: NSData, name: String) {
      0|  142|        let headers = contentHeaders(name: name)
      0|  143|        let stream = NSInputStream(data: data)
      0|  144|        let length = UInt64(data.length)
      0|  145|
      0|  146|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  147|    }
       |  148|
       |  149|    /**
       |  150|        Creates a body part from the data and appends it to the multipart form data object.
       |  151|
       |  152|        The body part data will be encoded using the following format:
       |  153|
       |  154|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  155|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  156|        - Encoded data
       |  157|        - Multipart form boundary
       |  158|
       |  159|        - parameter data:     The data to encode into the multipart form data.
       |  160|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  161|        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
       |  162|    */
      0|  163|    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
      0|  164|        let headers = contentHeaders(name: name, mimeType: mimeType)
      0|  165|        let stream = NSInputStream(data: data)
      0|  166|        let length = UInt64(data.length)
      0|  167|
      0|  168|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  169|    }
       |  170|
       |  171|    /**
       |  172|        Creates a body part from the data and appends it to the multipart form data object.
       |  173|
       |  174|        The body part data will be encoded using the following format:
       |  175|
       |  176|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  177|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  178|        - Encoded file data
       |  179|        - Multipart form boundary
       |  180|
       |  181|        - parameter data:     The data to encode into the multipart form data.
       |  182|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  183|        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
       |  184|        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
       |  185|    */
      0|  186|    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
      0|  187|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  188|        let stream = NSInputStream(data: data)
      0|  189|        let length = UInt64(data.length)
      0|  190|
      0|  191|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Creates a body part from the file and appends it to the multipart form data object.
       |  196|
       |  197|        The body part data will be encoded using the following format:
       |  198|
       |  199|        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
       |  200|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  201|        - Encoded file data
       |  202|        - Multipart form boundary
       |  203|
       |  204|        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
       |  205|        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
       |  206|        system associated MIME type.
       |  207|
       |  208|        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
       |  209|        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  210|    */
      0|  211|    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
      0|  212|        if let
      0|  213|            fileName = fileURL.lastPathComponent,
      0|  214|            pathExtension = fileURL.pathExtension
      0|  215|        {
      0|  216|            let mimeType = mimeTypeForPathExtension(pathExtension)
      0|  217|            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
      0|  218|        } else {
      0|  219|            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
      0|  220|            setBodyPartError(Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason))
      0|  221|        }
      0|  222|    }
       |  223|
       |  224|    /**
       |  225|        Creates a body part from the file and appends it to the multipart form data object.
       |  226|
       |  227|        The body part data will be encoded using the following format:
       |  228|
       |  229|        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
       |  230|        - Content-Type: #{mimeType} (HTTP Header)
       |  231|        - Encoded file data
       |  232|        - Multipart form boundary
       |  233|
       |  234|        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
       |  235|        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  236|        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
       |  237|        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
       |  238|    */
      0|  239|    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
      0|  240|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  241|
      0|  242|        //============================================================
      0|  243|        //                 Check 1 - is file URL?
      0|  244|        //============================================================
      0|  245|
      0|  246|        guard fileURL.fileURL else {
      0|  247|            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
      0|  248|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  249|            setBodyPartError(error)
      0|  250|            return
      0|  251|        }
      0|  252|
      0|  253|        //============================================================
      0|  254|        //              Check 2 - is file URL reachable?
      0|  255|        //============================================================
      0|  256|
      0|  257|        var isReachable = true
      0|  258|
      0|  259|        if #available(OSX 10.10, *) {
      0|  260|            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
      0|  261|        }
      0|  262|
      0|  263|        guard isReachable else {
      0|  264|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
      0|  265|            setBodyPartError(error)
      0|  266|            return
      0|  267|        }
      0|  268|
      0|  269|        //============================================================
      0|  270|        //            Check 3 - is file URL a directory?
      0|  271|        //============================================================
      0|  272|
      0|  273|        var isDirectory: ObjCBool = false
      0|  274|
      0|  275|        guard let
      0|  276|            path = fileURL.path
      0|  277|            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
      0|  278|        {
      0|  279|            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
      0|  280|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  281|            setBodyPartError(error)
      0|  282|            return
      0|  283|        }
      0|  284|
      0|  285|        //============================================================
      0|  286|        //          Check 4 - can the file size be extracted?
      0|  287|        //============================================================
      0|  288|
      0|  289|        var bodyContentLength: UInt64?
      0|  290|
      0|  291|        do {
      0|  292|            if let
      0|  293|                path = fileURL.path,
      0|  294|                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
      0|  295|            {
      0|  296|                bodyContentLength = fileSize.unsignedLongLongValue
      0|  297|            }
      0|  298|        } catch {
      0|  299|            // No-op
      0|  300|        }
      0|  301|
      0|  302|        guard let length = bodyContentLength else {
      0|  303|            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
      0|  304|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  305|            setBodyPartError(error)
      0|  306|            return
      0|  307|        }
      0|  308|
      0|  309|        //============================================================
      0|  310|        //       Check 5 - can a stream be created from file URL?
      0|  311|        //============================================================
      0|  312|
      0|  313|        guard let stream = NSInputStream(URL: fileURL) else {
      0|  314|            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
      0|  315|            let error = Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  316|            setBodyPartError(error)
      0|  317|            return
      0|  318|        }
      0|  319|
      0|  320|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  321|    }
       |  322|
       |  323|    /**
       |  324|        Creates a body part from the stream and appends it to the multipart form data object.
       |  325|
       |  326|        The body part data will be encoded using the following format:
       |  327|
       |  328|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  329|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  330|        - Encoded stream data
       |  331|        - Multipart form boundary
       |  332|
       |  333|        - parameter stream:   The input stream to encode in the multipart form data.
       |  334|        - parameter length:   The content length of the stream.
       |  335|        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
       |  336|        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
       |  337|        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
       |  338|    */
       |  339|    public func appendBodyPart(
       |  340|        stream stream: NSInputStream,
       |  341|        length: UInt64,
       |  342|        name: String,
       |  343|        fileName: String,
       |  344|        mimeType: String)
      0|  345|    {
      0|  346|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  347|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  348|    }
       |  349|
       |  350|    /**
       |  351|        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
       |  352|
       |  353|        The body part data will be encoded using the following format:
       |  354|
       |  355|        - HTTP headers
       |  356|        - Encoded stream data
       |  357|        - Multipart form boundary
       |  358|
       |  359|        - parameter stream:  The input stream to encode in the multipart form data.
       |  360|        - parameter length:  The content length of the stream.
       |  361|        - parameter headers: The HTTP headers for the body part.
       |  362|    */
      0|  363|    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
      0|  364|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
      0|  365|        bodyParts.append(bodyPart)
      0|  366|    }
       |  367|
       |  368|    // MARK: - Data Encoding
       |  369|
       |  370|    /**
       |  371|        Encodes all the appended body parts into a single `NSData` object.
       |  372|
       |  373|        It is important to note that this method will load all the appended body parts into memory all at the same 
       |  374|        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
       |  375|        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
       |  376|
       |  377|        - throws: An `NSError` if encoding encounters an error.
       |  378|
       |  379|        - returns: The encoded `NSData` if encoding is successful.
       |  380|    */
      0|  381|    public func encode() throws -> NSData {
      0|  382|        if let bodyPartError = bodyPartError {
      0|  383|            throw bodyPartError
      0|  384|        }
      0|  385|
      0|  386|        let encoded = NSMutableData()
      0|  387|
      0|  388|        bodyParts.first?.hasInitialBoundary = true
      0|  389|        bodyParts.last?.hasFinalBoundary = true
      0|  390|
      0|  391|        for bodyPart in bodyParts {
      0|  392|            let encodedData = try encodeBodyPart(bodyPart)
      0|  393|            encoded.appendData(encodedData)
      0|  394|        }
      0|  395|
      0|  396|        return encoded
      0|  397|    }
       |  398|
       |  399|    /**
       |  400|        Writes the appended body parts into the given file URL.
       |  401|
       |  402|        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
       |  403|        this approach is very memory efficient and should be used for large body part data.
       |  404|
       |  405|        - parameter fileURL: The file URL to write the multipart form data into.
       |  406|
       |  407|        - throws: An `NSError` if encoding encounters an error.
       |  408|    */
      0|  409|    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
      0|  410|        if let bodyPartError = bodyPartError {
      0|  411|            throw bodyPartError
      0|  412|        }
      0|  413|
      0|  414|        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
      0|  415|            let failureReason = "A file already exists at the given file URL: \(fileURL)"
      0|  416|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  417|        } else if !fileURL.fileURL {
      0|  418|            let failureReason = "The URL does not point to a valid file: \(fileURL)"
      0|  419|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  420|        }
      0|  421|
      0|  422|        let outputStream: NSOutputStream
      0|  423|
      0|  424|        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
      0|  425|            outputStream = possibleOutputStream
      0|  426|        } else {
      0|  427|            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
      0|  428|            throw Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  429|        }
      0|  430|
      0|  431|        outputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  432|        outputStream.open()
      0|  433|
      0|  434|        self.bodyParts.first?.hasInitialBoundary = true
      0|  435|        self.bodyParts.last?.hasFinalBoundary = true
      0|  436|
      0|  437|        for bodyPart in self.bodyParts {
      0|  438|            try writeBodyPart(bodyPart, toOutputStream: outputStream)
      0|  439|        }
      0|  440|
      0|  441|        outputStream.close()
      0|  442|        outputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  443|    }
       |  444|
       |  445|    // MARK: - Private - Body Part Encoding
       |  446|
      0|  447|    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  448|        let encoded = NSMutableData()
      0|  449|
      0|  450|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  451|        encoded.appendData(initialData)
      0|  452|
      0|  453|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  454|        encoded.appendData(headerData)
      0|  455|
      0|  456|        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
      0|  457|        encoded.appendData(bodyStreamData)
      0|  458|
      0|  459|        if bodyPart.hasFinalBoundary {
      0|  460|            encoded.appendData(finalBoundaryData())
      0|  461|        }
      0|  462|
      0|  463|        return encoded
      0|  464|    }
       |  465|
      0|  466|    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
      0|  467|        var headerText = ""
      0|  468|
      0|  469|        for (key, value) in bodyPart.headers {
      0|  470|            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
      0|  471|        }
      0|  472|        headerText += EncodingCharacters.CRLF
      0|  473|
      0|  474|        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|  475|    }
       |  476|
      0|  477|    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  478|        let inputStream = bodyPart.bodyStream
      0|  479|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  480|        inputStream.open()
      0|  481|
      0|  482|        var error: NSError?
      0|  483|        let encoded = NSMutableData()
      0|  484|
      0|  485|        while inputStream.hasBytesAvailable {
      0|  486|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  487|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  488|
      0|  489|            if inputStream.streamError != nil {
      0|  490|                error = inputStream.streamError
      0|  491|                break
      0|  492|            }
      0|  493|
      0|  494|            if bytesRead > 0 {
      0|  495|                encoded.appendBytes(buffer, length: bytesRead)
      0|  496|            } else if bytesRead < 0 {
      0|  497|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  498|                error = Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  499|                break
      0|  500|            } else {
      0|  501|                break
      0|  502|            }
      0|  503|        }
      0|  504|
      0|  505|        inputStream.close()
      0|  506|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  507|
      0|  508|        if let error = error {
      0|  509|            throw error
      0|  510|        }
      0|  511|
      0|  512|        return encoded
      0|  513|    }
       |  514|
       |  515|    // MARK: - Private - Writing Body Part to Output Stream
       |  516|
      0|  517|    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  518|        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  519|        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  520|        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  521|        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  522|    }
       |  523|
       |  524|    private func writeInitialBoundaryDataForBodyPart(
       |  525|        bodyPart: BodyPart,
       |  526|        toOutputStream outputStream: NSOutputStream)
       |  527|        throws
      0|  528|    {
      0|  529|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  530|        return try writeData(initialData, toOutputStream: outputStream)
      0|  531|    }
       |  532|
      0|  533|    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  534|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  535|        return try writeData(headerData, toOutputStream: outputStream)
      0|  536|    }
       |  537|
      0|  538|    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  539|        let inputStream = bodyPart.bodyStream
      0|  540|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  541|        inputStream.open()
      0|  542|
      0|  543|        while inputStream.hasBytesAvailable {
      0|  544|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  545|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  546|
      0|  547|            if let streamError = inputStream.streamError {
      0|  548|                throw streamError
      0|  549|            }
      0|  550|
      0|  551|            if bytesRead > 0 {
      0|  552|                if buffer.count != bytesRead {
      0|  553|                    buffer = Array(buffer[0..<bytesRead])
      0|  554|                }
      0|  555|
      0|  556|                try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  557|            } else if bytesRead < 0 {
      0|  558|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  559|                throw Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  560|            } else {
      0|  561|                break
      0|  562|            }
      0|  563|        }
      0|  564|
      0|  565|        inputStream.close()
      0|  566|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  567|    }
       |  568|
       |  569|    private func writeFinalBoundaryDataForBodyPart(
       |  570|        bodyPart: BodyPart,
       |  571|        toOutputStream outputStream: NSOutputStream)
       |  572|        throws
      0|  573|    {
      0|  574|        if bodyPart.hasFinalBoundary {
      0|  575|            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
      0|  576|        }
      0|  577|    }
       |  578|
       |  579|    // MARK: - Private - Writing Buffered Data to Output Stream
       |  580|
      0|  581|    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
      0|  582|        var buffer = [UInt8](count: data.length, repeatedValue: 0)
      0|  583|        data.getBytes(&buffer, length: data.length)
      0|  584|
      0|  585|        return try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  586|    }
       |  587|
      0|  588|    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
      0|  589|        var bytesToWrite = buffer.count
      0|  590|
      0|  591|        while bytesToWrite > 0 {
      0|  592|            if outputStream.hasSpaceAvailable {
      0|  593|                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
      0|  594|
      0|  595|                if let streamError = outputStream.streamError {
      0|  596|                    throw streamError
      0|  597|                }
      0|  598|
      0|  599|                if bytesWritten < 0 {
      0|  600|                    let failureReason = "Failed to write to output stream: \(outputStream)"
      0|  601|                    throw Error.errorWithCode(.OutputStreamWriteFailed, failureReason: failureReason)
      0|  602|                }
      0|  603|
      0|  604|                bytesToWrite -= bytesWritten
      0|  605|
      0|  606|                if bytesToWrite > 0 {
      0|  607|                    buffer = Array(buffer[bytesWritten..<buffer.count])
      0|  608|                }
      0|  609|            } else if let streamError = outputStream.streamError {
      0|  610|                throw streamError
      0|  611|            }
      0|  612|        }
      0|  613|    }
       |  614|
       |  615|    // MARK: - Private - Mime Type
       |  616|
      0|  617|    private func mimeTypeForPathExtension(pathExtension: String) -> String {
      0|  618|        if let
      0|  619|            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
      0|  620|            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
      0|  621|        {
      0|  622|            return contentType as String
      0|  623|        }
      0|  624|
      0|  625|        return "application/octet-stream"
      0|  626|    }
       |  627|
       |  628|    // MARK: - Private - Content Headers
       |  629|
      0|  630|    private func contentHeaders(name name: String) -> [String: String] {
      0|  631|        return ["Content-Disposition": "form-data; name=\"\(name)\""]
      0|  632|    }
       |  633|
      0|  634|    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
      0|  635|        return [
      0|  636|            "Content-Disposition": "form-data; name=\"\(name)\"",
      0|  637|            "Content-Type": "\(mimeType)"
      0|  638|        ]
      0|  639|    }
       |  640|
      0|  641|    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
      0|  642|        return [
      0|  643|            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
      0|  644|            "Content-Type": "\(mimeType)"
      0|  645|        ]
      0|  646|    }
       |  647|
       |  648|    // MARK: - Private - Boundary Encoding
       |  649|
      0|  650|    private func initialBoundaryData() -> NSData {
      0|  651|        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
      0|  652|    }
       |  653|
      0|  654|    private func encapsulatedBoundaryData() -> NSData {
      0|  655|        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
      0|  656|    }
       |  657|
      0|  658|    private func finalBoundaryData() -> NSData {
      0|  659|        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
      0|  660|    }
       |  661|
       |  662|    // MARK: - Private - Errors
       |  663|
      0|  664|    private func setBodyPartError(error: NSError) {
      0|  665|        if bodyPartError == nil {
      0|  666|            bodyPartError = error
      0|  667|        }
      0|  668|    }
       |  669|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ParameterEncoding.swift:
       |    1|// ParameterEncoding.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    HTTP method definitions.
       |   27|
       |   28|    See https://tools.ietf.org/html/rfc7231#section-4.3
       |   29|*/
       |   30|public enum Method: String {
       |   31|    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
       |   32|}
       |   33|
       |   34|// MARK: ParameterEncoding
       |   35|
       |   36|/**
       |   37|    Used to specify the way in which a set of parameters are applied to a URL request.
       |   38|
       |   39|    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
       |   40|                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
       |   41|                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
       |   42|                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
       |   43|                         for how to encode collection types, the convention of appending `[]` to the key for array
       |   44|                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
       |   45|                         dictionary values (`foo[bar]=baz`).
       |   46|
       |   47|    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
       |   48|                         implementation as the `.URL` case, but always applies the encoded result to the URL.
       |   49|
       |   50|    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
       |   51|                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
       |   52|                         set to `application/json`.
       |   53|
       |   54|    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
       |   55|                         according to the associated format and write options values, which is set as the body of the
       |   56|                         request. The `Content-Type` HTTP header field of an encoded request is set to
       |   57|                         `application/x-plist`.
       |   58|
       |   59|    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
       |   60|                         parameters.
       |   61|*/
       |   62|public enum ParameterEncoding {
       |   63|    case URL
       |   64|    case URLEncodedInURL
       |   65|    case JSON
       |   66|    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
       |   67|    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
       |   68|
       |   69|    /**
       |   70|        Creates a URL request by encoding parameters and applying them onto an existing request.
       |   71|
       |   72|        - parameter URLRequest: The request to have parameters applied
       |   73|        - parameter parameters: The parameters to apply
       |   74|
       |   75|        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
       |   76|                   if any.
       |   77|    */
       |   78|    public func encode(
       |   79|        URLRequest: URLRequestConvertible,
       |   80|        parameters: [String: AnyObject]?)
       |   81|        -> (NSMutableURLRequest, NSError?)
      1|   82|    {
      1|   83|        var mutableURLRequest = URLRequest.URLRequest
      1|   84|
      0|   85|        guard let parameters = parameters where !parameters.isEmpty else {
      0|   86|            return (mutableURLRequest, nil)
      0|   87|        }
      1|   88|
      1|   89|        var encodingError: NSError? = nil
      1|   90|
      1|   91|        switch self {
      0|   92|        case .URL, .URLEncodedInURL:
      0|   93|            func query(parameters: [String: AnyObject]) -> String {
      0|   94|                var components: [(String, String)] = []
      0|   95|
      0|   96|                for key in parameters.keys.sort(<) {
      0|   97|                    let value = parameters[key]!
      0|   98|                    components += queryComponents(key, value)
      0|   99|                }
      0|  100|
      0|  101|                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
      0|  102|            }
      0|  103|
      0|  104|            func encodesParametersInURL(method: Method) -> Bool {
      0|  105|                switch self {
      0|  106|                case .URLEncodedInURL:
      0|  107|                    return true
      0|  108|                default:
      0|  109|                    break
      0|  110|                }
      0|  111|
      0|  112|                switch method {
      0|  113|                case .GET, .HEAD, .DELETE:
      0|  114|                    return true
      0|  115|                default:
      0|  116|                    return false
      0|  117|                }
      0|  118|            }
      0|  119|
      0|  120|            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
      0|  121|                if let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false) {
      0|  122|                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
      0|  123|                    URLComponents.percentEncodedQuery = percentEncodedQuery
      0|  124|                    mutableURLRequest.URL = URLComponents.URL
      0|  125|                }
      0|  126|            } else {
      0|  127|                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
      0|  128|                    mutableURLRequest.setValue(
      0|  129|                        "application/x-www-form-urlencoded; charset=utf-8",
      0|  130|                        forHTTPHeaderField: "Content-Type"
      0|  131|                    )
      0|  132|                }
      0|  133|
      0|  134|                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
      0|  135|                    NSUTF8StringEncoding,
      0|  136|                    allowLossyConversion: false
      0|  137|                )
      0|  138|            }
      1|  139|        case .JSON:
      1|  140|            do {
      1|  141|                let options = NSJSONWritingOptions()
      1|  142|                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
      1|  143|
      1|  144|                mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
      1|  145|                mutableURLRequest.HTTPBody = data
      0|  146|            } catch {
      0|  147|                encodingError = error as NSError
      0|  148|            }
      0|  149|        case .PropertyList(let format, let options):
      0|  150|            do {
      0|  151|                let data = try NSPropertyListSerialization.dataWithPropertyList(
      0|  152|                    parameters,
      0|  153|                    format: format,
      0|  154|                    options: options
      0|  155|                )
      0|  156|                mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
      0|  157|                mutableURLRequest.HTTPBody = data
      0|  158|            } catch {
      0|  159|                encodingError = error as NSError
      0|  160|            }
      0|  161|        case .Custom(let closure):
      0|  162|            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
      1|  163|        }
      1|  164|
      1|  165|        return (mutableURLRequest, encodingError)
      1|  166|    }
       |  167|
       |  168|    /**
       |  169|        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
       |  170|
       |  171|        - parameter key:   The key of the query component.
       |  172|        - parameter value: The value of the query component.
       |  173|
       |  174|        - returns: The percent-escaped, URL encoded query string components.
       |  175|    */
      0|  176|    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
      0|  177|        var components: [(String, String)] = []
      0|  178|
      0|  179|        if let dictionary = value as? [String: AnyObject] {
      0|  180|            for (nestedKey, value) in dictionary {
      0|  181|                components += queryComponents("\(key)[\(nestedKey)]", value)
      0|  182|            }
      0|  183|        } else if let array = value as? [AnyObject] {
      0|  184|            for value in array {
      0|  185|                components += queryComponents("\(key)[]", value)
      0|  186|            }
      0|  187|        } else {
      0|  188|            components.append((escape(key), escape("\(value)")))
      0|  189|        }
      0|  190|
      0|  191|        return components
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Returns a percent-escaped string following RFC 3986 for a query string key or value.
       |  196|
       |  197|        RFC 3986 states that the following characters are "reserved" characters.
       |  198|
       |  199|        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
       |  200|        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
       |  201|
       |  202|        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
       |  203|        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
       |  204|        should be percent-escaped in the query string.
       |  205|
       |  206|        - parameter string: The string to be percent-escaped.
       |  207|
       |  208|        - returns: The percent-escaped string.
       |  209|    */
      0|  210|    public func escape(string: String) -> String {
      0|  211|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
      0|  212|        let subDelimitersToEncode = "!$&'()*+,;="
      0|  213|
      0|  214|        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
      0|  215|        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
      0|  216|
      0|  217|        var escaped = ""
      0|  218|
      0|  219|        //==========================================================================================================
      0|  220|        //
      0|  221|        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
      0|  222|        //  hundred Chinense characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
      0|  223|        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
      0|  224|        //  info, please refer to:
      0|  225|        //
      0|  226|        //      - https://github.com/Alamofire/Alamofire/issues/206
      0|  227|        //
      0|  228|        //==========================================================================================================
      0|  229|
      0|  230|        if #available(iOS 8.3, OSX 10.10, *) {
      0|  231|            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
      0|  232|        } else {
      0|  233|            let batchSize = 50
      0|  234|            var index = string.startIndex
      0|  235|
      0|  236|            while index != string.endIndex {
      0|  237|                let startIndex = index
      0|  238|                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
      0|  239|                let range = Range(start: startIndex, end: endIndex)
      0|  240|
      0|  241|                let substring = string.substringWithRange(range)
      0|  242|
      0|  243|                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
      0|  244|
      0|  245|                index = endIndex
      0|  246|            }
      0|  247|        }
      0|  248|
      0|  249|        return escaped
      0|  250|    }
       |  251|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Request.swift:
       |    1|// Request.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for sending a request and receiving the response and associated data from the server, as well as 
       |   27|    managing its underlying `NSURLSessionTask`.
       |   28|*/
       |   29|public class Request {
       |   30|
       |   31|    // MARK: - Properties
       |   32|
       |   33|    /// The delegate for the underlying task.
       |   34|    public let delegate: TaskDelegate
       |   35|
       |   36|    /// The underlying task.
      5|   37|    public var task: NSURLSessionTask { return delegate.task }
       |   38|
       |   39|    /// The session belonging to the underlying task.
       |   40|    public let session: NSURLSession
       |   41|
       |   42|    /// The request sent or to be sent to the server.
      2|   43|    public var request: NSURLRequest? { return task.originalRequest }
       |   44|
       |   45|    /// The response received from the server, if any.
      2|   46|    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
       |   47|
       |   48|    /// The progress of the request lifecycle.
      0|   49|    public var progress: NSProgress { return delegate.progress }
       |   50|
       |   51|    // MARK: - Lifecycle
       |   52|
      1|   53|    init(session: NSURLSession, task: NSURLSessionTask) {
      1|   54|        self.session = session
      1|   55|
      1|   56|        switch task {
      0|   57|        case is NSURLSessionUploadTask:
      0|   58|            self.delegate = UploadTaskDelegate(task: task)
      1|   59|        case is NSURLSessionDataTask:
      1|   60|            self.delegate = DataTaskDelegate(task: task)
      0|   61|        case is NSURLSessionDownloadTask:
      0|   62|            self.delegate = DownloadTaskDelegate(task: task)
      0|   63|        default:
      0|   64|            self.delegate = TaskDelegate(task: task)
      1|   65|        }
      1|   66|    }
       |   67|
       |   68|    // MARK: - Authentication
       |   69|
       |   70|    /**
       |   71|        Associates an HTTP Basic credential with the request.
       |   72|
       |   73|        - parameter user:        The user.
       |   74|        - parameter password:    The password.
       |   75|        - parameter persistence: The URL credential persistence. `.ForSession` by default.
       |   76|
       |   77|        - returns: The request.
       |   78|    */
       |   79|    public func authenticate(
       |   80|        user user: String,
       |   81|        password: String,
       |   82|        persistence: NSURLCredentialPersistence = .ForSession)
       |   83|        -> Self
      0|   84|    {
      0|   85|        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
      0|   86|
      0|   87|        return authenticate(usingCredential: credential)
      0|   88|    }
       |   89|
       |   90|    /**
       |   91|        Associates a specified credential with the request.
       |   92|
       |   93|        - parameter credential: The credential.
       |   94|
       |   95|        - returns: The request.
       |   96|    */
      0|   97|    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
      0|   98|        delegate.credential = credential
      0|   99|
      0|  100|        return self
      0|  101|    }
       |  102|
       |  103|    // MARK: - Progress
       |  104|
       |  105|    /**
       |  106|        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
       |  107|        from the server.
       |  108|
       |  109|        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
       |  110|          to write.
       |  111|        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
       |  112|          expected to read.
       |  113|
       |  114|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  115|
       |  116|        - returns: The request.
       |  117|    */
      0|  118|    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
      0|  119|        if let uploadDelegate = delegate as? UploadTaskDelegate {
      0|  120|            uploadDelegate.uploadProgress = closure
      0|  121|        } else if let dataDelegate = delegate as? DataTaskDelegate {
      0|  122|            dataDelegate.dataProgress = closure
      0|  123|        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
      0|  124|            downloadDelegate.downloadProgress = closure
      0|  125|        }
      0|  126|
      0|  127|        return self
      0|  128|    }
       |  129|
       |  130|    /**
       |  131|        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
       |  132|
       |  133|        This closure returns the bytes most recently received from the server, not including data from previous calls. 
       |  134|        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
       |  135|        also important to note that the `response` closure will be called with nil `responseData`.
       |  136|
       |  137|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  138|
       |  139|        - returns: The request.
       |  140|    */
      0|  141|    public func stream(closure: (NSData -> Void)? = nil) -> Self {
      0|  142|        if let dataDelegate = delegate as? DataTaskDelegate {
      0|  143|            dataDelegate.dataStream = closure
      0|  144|        }
      0|  145|
      0|  146|        return self
      0|  147|    }
       |  148|
       |  149|    // MARK: - State
       |  150|
       |  151|    /**
       |  152|        Suspends the request.
       |  153|    */
      0|  154|    public func suspend() {
      0|  155|        task.suspend()
      0|  156|    }
       |  157|
       |  158|    /**
       |  159|        Resumes the request.
       |  160|    */
      1|  161|    public func resume() {
      1|  162|        task.resume()
      1|  163|    }
       |  164|
       |  165|    /**
       |  166|        Cancels the request.
       |  167|    */
      0|  168|    public func cancel() {
      0|  169|        if let
      0|  170|            downloadDelegate = delegate as? DownloadTaskDelegate,
      0|  171|            downloadTask = downloadDelegate.downloadTask
      0|  172|        {
      0|  173|            downloadTask.cancelByProducingResumeData { data in
      0|  174|                downloadDelegate.resumeData = data
      0|  175|            }
      0|  176|        } else {
      0|  177|            task.cancel()
      0|  178|        }
      0|  179|    }
       |  180|
       |  181|    // MARK: - TaskDelegate
       |  182|
       |  183|    /**
       |  184|        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
       |  185|        executing all operations attached to the serial operation queue upon task completion.
       |  186|    */
       |  187|    public class TaskDelegate: NSObject {
       |  188|
       |  189|        /// The serial operation queue used to execute all operations after the task completes.
       |  190|        public let queue: NSOperationQueue
       |  191|
       |  192|        let task: NSURLSessionTask
       |  193|        let progress: NSProgress
       |  194|
      0|  195|        var data: NSData? { return nil }
       |  196|        var error: NSError?
       |  197|
       |  198|        var credential: NSURLCredential?
       |  199|
      1|  200|        init(task: NSURLSessionTask) {
      1|  201|            self.task = task
      1|  202|            self.progress = NSProgress(totalUnitCount: 0)
      1|  203|            self.queue = {
      1|  204|                let operationQueue = NSOperationQueue()
      1|  205|                operationQueue.maxConcurrentOperationCount = 1
      1|  206|                operationQueue.suspended = true
      1|  207|
      1|  208|                if #available(OSX 10.10, *) {
      1|  209|                    operationQueue.qualityOfService = NSQualityOfService.Utility
      1|  210|                }
      1|  211|
      1|  212|                return operationQueue
      1|  213|            }()
      1|  214|        }
       |  215|
      0|  216|        deinit {
      0|  217|            queue.cancelAllOperations()
      0|  218|            queue.suspended = false
      0|  219|        }
       |  220|
       |  221|        // MARK: - NSURLSessionTaskDelegate
       |  222|
       |  223|        // MARK: Override Closures
       |  224|
       |  225|        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  226|        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  227|        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
       |  228|        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  229|
       |  230|        // MARK: Delegate Methods
       |  231|
       |  232|        func URLSession(
       |  233|            session: NSURLSession,
       |  234|            task: NSURLSessionTask,
       |  235|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  236|            newRequest request: NSURLRequest,
       |  237|            completionHandler: ((NSURLRequest?) -> Void))
      0|  238|        {
      0|  239|            var redirectRequest: NSURLRequest? = request
      0|  240|
      0|  241|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  242|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  243|            }
      0|  244|
      0|  245|            completionHandler(redirectRequest)
      0|  246|        }
       |  247|
       |  248|        func URLSession(
       |  249|            session: NSURLSession,
       |  250|            task: NSURLSessionTask,
       |  251|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  252|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  253|        {
      1|  254|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      1|  255|            var credential: NSURLCredential?
      1|  256|
      0|  257|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  258|                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
      1|  259|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      1|  260|                let host = challenge.protectionSpace.host
      1|  261|
      1|  262|                if let
      1|  263|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      1|  264|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  265|                {
      0|  266|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  267|                        disposition = .UseCredential
      0|  268|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  269|                    } else {
      0|  270|                        disposition = .CancelAuthenticationChallenge
      0|  271|                    }
      0|  272|                }
      0|  273|            } else {
      0|  274|                if challenge.previousFailureCount > 0 {
      0|  275|                    disposition = .CancelAuthenticationChallenge
      0|  276|                } else {
      0|  277|                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
      0|  278|
      0|  279|                    if credential != nil {
      0|  280|                        disposition = .UseCredential
      0|  281|                    }
      0|  282|                }
      0|  283|            }
      1|  284|
      1|  285|            completionHandler(disposition, credential)
      1|  286|        }
       |  287|
       |  288|        func URLSession(
       |  289|            session: NSURLSession,
       |  290|            task: NSURLSessionTask,
       |  291|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  292|        {
      0|  293|            var bodyStream: NSInputStream?
      0|  294|
      0|  295|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  296|                bodyStream = taskNeedNewBodyStream(session, task)
      0|  297|            }
      0|  298|
      0|  299|            completionHandler(bodyStream)
      0|  300|        }
       |  301|
      1|  302|        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  303|            if let taskDidCompleteWithError = taskDidCompleteWithError {
      0|  304|                taskDidCompleteWithError(session, task, error)
      1|  305|            } else {
      0|  306|                if let error = error {
      0|  307|                    self.error = error
      0|  308|
      0|  309|                    if let
      0|  310|                        downloadDelegate = self as? DownloadTaskDelegate,
      0|  311|                        userInfo = error.userInfo as? [String: AnyObject],
      0|  312|                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
      0|  313|                    {
      0|  314|                        downloadDelegate.resumeData = resumeData
      0|  315|                    }
      0|  316|                }
      1|  317|
      1|  318|                queue.suspended = false
      1|  319|            }
      1|  320|        }
       |  321|    }
       |  322|
       |  323|    // MARK: - DataTaskDelegate
       |  324|
       |  325|    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
      0|  326|        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
       |  327|
       |  328|        private var totalBytesReceived: Int64 = 0
       |  329|        private var mutableData: NSMutableData
      2|  330|        override var data: NSData? {
      0|  331|            if dataStream != nil {
      0|  332|                return nil
      2|  333|            } else {
      2|  334|                return mutableData
      2|  335|            }
      0|  336|        }
       |  337|
       |  338|        private var expectedContentLength: Int64?
       |  339|        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
       |  340|        private var dataStream: ((data: NSData) -> Void)?
       |  341|
      1|  342|        override init(task: NSURLSessionTask) {
      1|  343|            mutableData = NSMutableData()
      1|  344|            super.init(task: task)
      1|  345|        }
       |  346|
       |  347|        // MARK: - NSURLSessionDataDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  352|        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  353|        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  354|        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
       |  355|
       |  356|        // MARK: Delegate Methods
       |  357|
       |  358|        func URLSession(
       |  359|            session: NSURLSession,
       |  360|            dataTask: NSURLSessionDataTask,
       |  361|            didReceiveResponse response: NSURLResponse,
       |  362|            completionHandler: (NSURLSessionResponseDisposition -> Void))
      0|  363|        {
      0|  364|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  365|
      0|  366|            expectedContentLength = response.expectedContentLength
      0|  367|
      0|  368|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  369|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  370|            }
      0|  371|
      0|  372|            completionHandler(disposition)
      0|  373|        }
       |  374|
       |  375|        func URLSession(
       |  376|            session: NSURLSession,
       |  377|            dataTask: NSURLSessionDataTask,
       |  378|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  379|        {
      0|  380|            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
      0|  381|        }
       |  382|
      1|  383|        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  384|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  385|                dataTaskDidReceiveData(session, dataTask, data)
      1|  386|            } else {
      0|  387|                if let dataStream = dataStream {
      0|  388|                    dataStream(data: data)
      1|  389|                } else {
      1|  390|                    mutableData.appendData(data)
      1|  391|                }
      1|  392|
      1|  393|                totalBytesReceived += data.length
      0|  394|                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
      1|  395|
      1|  396|                progress.totalUnitCount = totalBytesExpected
      1|  397|                progress.completedUnitCount = totalBytesReceived
      1|  398|
      1|  399|                dataProgress?(
      1|  400|                    bytesReceived: Int64(data.length),
      1|  401|                    totalBytesReceived: totalBytesReceived,
      1|  402|                    totalBytesExpectedToReceive: totalBytesExpected
      1|  403|                )
      1|  404|            }
      1|  405|        }
       |  406|
       |  407|        func URLSession(
       |  408|            session: NSURLSession,
       |  409|            dataTask: NSURLSessionDataTask,
       |  410|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  411|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  412|        {
      0|  413|            var cachedResponse: NSCachedURLResponse? = proposedResponse
      0|  414|
      0|  415|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  416|                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
      0|  417|            }
      0|  418|
      0|  419|            completionHandler(cachedResponse)
      0|  420|        }
       |  421|    }
       |  422|}
       |  423|
       |  424|// MARK: - CustomStringConvertible
       |  425|
       |  426|extension Request: CustomStringConvertible {
       |  427|
       |  428|    /**
       |  429|        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
       |  430|        well as the response status code if a response has been received.
       |  431|    */
      0|  432|    public var description: String {
      0|  433|        var components: [String] = []
      0|  434|
      0|  435|        if let HTTPMethod = request?.HTTPMethod {
      0|  436|            components.append(HTTPMethod)
      0|  437|        }
      0|  438|
      0|  439|        if let URLString = request?.URL?.absoluteString {
      0|  440|            components.append(URLString)
      0|  441|        }
      0|  442|
      0|  443|        if let response = response {
      0|  444|            components.append("(\(response.statusCode))")
      0|  445|        }
      0|  446|
      0|  447|        return components.joinWithSeparator(" ")
      0|  448|    }
       |  449|}
       |  450|
       |  451|// MARK: - CustomDebugStringConvertible
       |  452|
       |  453|extension Request: CustomDebugStringConvertible {
      0|  454|    func cURLRepresentation() -> String {
      0|  455|        var components = ["$ curl -i"]
      0|  456|
      0|  457|        guard let request = self.request else {
      0|  458|            return "$ curl command could not be created"
      0|  459|        }
      0|  460|
      0|  461|        let URL = request.URL
      0|  462|
      0|  463|        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
      0|  464|            components.append("-X \(HTTPMethod)")
      0|  465|        }
      0|  466|
      0|  467|        if let credentialStorage = self.session.configuration.URLCredentialStorage {
      0|  468|            let protectionSpace = NSURLProtectionSpace(
      0|  469|                host: URL!.host!,
      0|  470|                port: URL!.port?.integerValue ?? 0,
      0|  471|                `protocol`: URL!.scheme,
      0|  472|                realm: URL!.host!,
      0|  473|                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
      0|  474|            )
      0|  475|
      0|  476|            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
      0|  477|                for credential in credentials {
      0|  478|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  479|                }
      0|  480|            } else {
      0|  481|                if let credential = delegate.credential {
      0|  482|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  483|                }
      0|  484|            }
      0|  485|        }
      0|  486|
      0|  487|        if session.configuration.HTTPShouldSetCookies {
      0|  488|            if let
      0|  489|                cookieStorage = session.configuration.HTTPCookieStorage,
      0|  490|                cookies = cookieStorage.cookiesForURL(URL!) where !cookies.isEmpty
      0|  491|            {
      0|  492|                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
      0|  493|                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
      0|  494|            }
      0|  495|        }
      0|  496|
      0|  497|        if let headerFields = request.allHTTPHeaderFields {
      0|  498|            for (field, value) in headerFields {
      0|  499|                switch field {
      0|  500|                case "Cookie":
      0|  501|                    continue
      0|  502|                default:
      0|  503|                    components.append("-H \"\(field): \(value)\"")
      0|  504|                }
      0|  505|            }
      0|  506|        }
      0|  507|
      0|  508|        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
      0|  509|            for (field, value) in additionalHeaders {
      0|  510|                switch field {
      0|  511|                case "Cookie":
      0|  512|                    continue
      0|  513|                default:
      0|  514|                    components.append("-H \"\(field): \(value)\"")
      0|  515|                }
      0|  516|            }
      0|  517|        }
      0|  518|
      0|  519|        if let
      0|  520|            HTTPBodyData = request.HTTPBody,
      0|  521|            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
      0|  522|        {
      0|  523|            let escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
      0|  524|            components.append("-d \"\(escapedBody)\"")
      0|  525|        }
      0|  526|
      0|  527|        components.append("\"\(URL!.absoluteString)\"")
      0|  528|
      0|  529|        return components.joinWithSeparator(" \\\n\t")
      0|  530|    }
       |  531|
       |  532|    /// The textual representation used when written to an output stream, in the form of a cURL command.
      0|  533|    public var debugDescription: String {
      0|  534|        return cURLRepresentation()
      0|  535|    }
       |  536|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Response.swift:
       |    1|// Response.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Used to store all response data returned from a completed `Request`.
       |   26|public struct Response<Value, Error: ErrorType> {
       |   27|    /// The URL request sent to the server.
       |   28|    public let request: NSURLRequest?
       |   29|
       |   30|    /// The server's response to the URL request.
       |   31|    public let response: NSHTTPURLResponse?
       |   32|
       |   33|    /// The data returned by the server.
       |   34|    public let data: NSData?
       |   35|
       |   36|    /// The result of response serialization.
       |   37|    public let result: Result<Value, Error>
       |   38|
       |   39|    /**
       |   40|        Initializes the `Response` instance with the specified URL request, URL response, server data and response
       |   41|        serialization result.
       |   42|    
       |   43|        - parameter request:  The URL request sent to the server.
       |   44|        - parameter response: The server's response to the URL request.
       |   45|        - parameter data:     The data returned by the server.
       |   46|        - parameter result:   The result of response serialization.
       |   47|    
       |   48|        - returns: the new `Response` instance.
       |   49|    */
      1|   50|    public init(request: NSURLRequest?, response: NSHTTPURLResponse?, data: NSData?, result: Result<Value, Error>) {
      1|   51|        self.request = request
      1|   52|        self.response = response
      1|   53|        self.data = data
      1|   54|        self.result = result
      1|   55|    }
       |   56|}
       |   57|
       |   58|// MARK: - CustomStringConvertible
       |   59|
       |   60|extension Response: CustomStringConvertible {
       |   61|    /// The textual representation used when written to an output stream, which includes whether the result was a
       |   62|    /// success or failure.
      0|   63|    public var description: String {
      0|   64|        return result.debugDescription
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - CustomDebugStringConvertible
       |   69|
       |   70|extension Response: CustomDebugStringConvertible {
       |   71|    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
       |   72|    /// response, the server data and the response serialization result.
      0|   73|    public var debugDescription: String {
      0|   74|        var output: [String] = []
      0|   75|
      0|   76|        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
      0|   77|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
      0|   78|        output.append("[Data]: \(data?.length ?? 0) bytes")
      0|   79|        output.append("[Result]: \(result.debugDescription)")
      0|   80|
      0|   81|        return output.joinWithSeparator("\n")
      0|   82|    }
       |   83|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ResponseSerialization.swift:
       |    1|// ResponseSerialization.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: ResponseSerializer
       |   26|
       |   27|/**
       |   28|    The type in which all response serializers must conform to in order to serialize a response.
       |   29|*/
       |   30|public protocol ResponseSerializerType {
       |   31|    /// The type of serialized object to be created by this `ResponseSerializerType`.
       |   32|    typealias SerializedObject
       |   33|
       |   34|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   35|    typealias ErrorObject: ErrorType
       |   36|
       |   37|    /**
       |   38|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   39|    */
       |   40|    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
       |   41|}
       |   42|
       |   43|// MARK: -
       |   44|
       |   45|/**
       |   46|    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
       |   47|*/
       |   48|public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
       |   49|    /// The type of serialized object to be created by this `ResponseSerializer`.
       |   50|    public typealias SerializedObject = Value
       |   51|
       |   52|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   53|    public typealias ErrorObject = Error
       |   54|
       |   55|    /**
       |   56|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   57|    */
       |   58|    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
       |   59|
       |   60|    /**
       |   61|        Initializes the `ResponseSerializer` instance with the given serialize response closure.
       |   62|
       |   63|        - parameter serializeResponse: The closure used to serialize the response.
       |   64|
       |   65|        - returns: The new generic response serializer instance.
       |   66|    */
      1|   67|    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
      1|   68|        self.serializeResponse = serializeResponse
      1|   69|    }
       |   70|}
       |   71|
       |   72|// MARK: - Default
       |   73|
       |   74|extension Request {
       |   75|
       |   76|    /**
       |   77|        Adds a handler to be called once the request has finished.
       |   78|
       |   79|        - parameter queue:             The queue on which the completion handler is dispatched.
       |   80|        - parameter completionHandler: The code to be executed once the request has finished.
       |   81|
       |   82|        - returns: The request.
       |   83|    */
       |   84|    public func response(
       |   85|        queue queue: dispatch_queue_t? = nil,
       |   86|        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
       |   87|        -> Self
      0|   88|    {
      0|   89|        delegate.queue.addOperationWithBlock {
      0|   90|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      0|   91|                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
      0|   92|            }
      0|   93|        }
      0|   94|
      0|   95|        return self
      0|   96|    }
       |   97|
       |   98|    /**
       |   99|        Adds a handler to be called once the request has finished.
       |  100|
       |  101|        - parameter queue:              The queue on which the completion handler is dispatched.
       |  102|        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
       |  103|                                        and data.
       |  104|        - parameter completionHandler:  The code to be executed once the request has finished.
       |  105|
       |  106|        - returns: The request.
       |  107|    */
       |  108|    public func response<T: ResponseSerializerType>(
       |  109|        queue queue: dispatch_queue_t? = nil,
       |  110|        responseSerializer: T,
       |  111|        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
       |  112|        -> Self
      1|  113|    {
      1|  114|        delegate.queue.addOperationWithBlock {
      1|  115|            let result = responseSerializer.serializeResponse(
      1|  116|                self.request,
      1|  117|                self.response,
      1|  118|                self.delegate.data,
      1|  119|                self.delegate.error
      1|  120|            )
      1|  121|
      1|  122|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      1|  123|                let response = Response<T.SerializedObject, T.ErrorObject>(
      1|  124|                    request: self.request,
      1|  125|                    response: self.response,
      1|  126|                    data: self.delegate.data,
      1|  127|                    result: result
      1|  128|                )
      1|  129|
      1|  130|                completionHandler(response)
      1|  131|            }
      1|  132|        }
      1|  133|
      1|  134|        return self
      1|  135|    }
       |  136|}
       |  137|
       |  138|// MARK: - Data
       |  139|
       |  140|extension Request {
       |  141|
       |  142|    /**
       |  143|        Creates a response serializer that returns the associated data as-is.
       |  144|
       |  145|        - returns: A data response serializer.
       |  146|    */
      0|  147|    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
      0|  148|        return ResponseSerializer { _, response, data, error in
      0|  149|            guard error == nil else { return .Failure(error!) }
      0|  150|
      0|  151|            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
      0|  152|
      0|  153|            guard let validData = data else {
      0|  154|                let failureReason = "Data could not be serialized. Input data was nil."
      0|  155|                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
      0|  156|                return .Failure(error)
      0|  157|            }
      0|  158|
      0|  159|            return .Success(validData)
      0|  160|        }
      0|  161|    }
       |  162|
       |  163|    /**
       |  164|        Adds a handler to be called once the request has finished.
       |  165|
       |  166|        - parameter completionHandler: The code to be executed once the request has finished.
       |  167|
       |  168|        - returns: The request.
       |  169|    */
      0|  170|    public func responseData(completionHandler: Response<NSData, NSError> -> Void) -> Self {
      0|  171|        return response(responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
      0|  172|    }
       |  173|}
       |  174|
       |  175|// MARK: - String
       |  176|
       |  177|extension Request {
       |  178|
       |  179|    /**
       |  180|        Creates a response serializer that returns a string initialized from the response data with the specified 
       |  181|        string encoding.
       |  182|
       |  183|        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
       |  184|                              response, falling back to the default HTTP default character set, ISO-8859-1.
       |  185|
       |  186|        - returns: A string response serializer.
       |  187|    */
       |  188|    public static func stringResponseSerializer(
       |  189|        var encoding encoding: NSStringEncoding? = nil)
       |  190|        -> ResponseSerializer<String, NSError>
      0|  191|    {
      0|  192|        return ResponseSerializer { _, response, data, error in
      0|  193|            guard error == nil else { return .Failure(error!) }
      0|  194|
      0|  195|            if let response = response where response.statusCode == 204 { return .Success("") }
      0|  196|
      0|  197|            guard let validData = data else {
      0|  198|                let failureReason = "String could not be serialized. Input data was nil."
      0|  199|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  200|                return .Failure(error)
      0|  201|            }
      0|  202|
      0|  203|            if let encodingName = response?.textEncodingName where encoding == nil {
      0|  204|                encoding = CFStringConvertEncodingToNSStringEncoding(
      0|  205|                    CFStringConvertIANACharSetNameToEncoding(encodingName)
      0|  206|                )
      0|  207|            }
      0|  208|
      0|  209|            let actualEncoding = encoding ?? NSISOLatin1StringEncoding
      0|  210|
      0|  211|            if let string = String(data: validData, encoding: actualEncoding) {
      0|  212|                return .Success(string)
      0|  213|            } else {
      0|  214|                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
      0|  215|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  216|                return .Failure(error)
      0|  217|            }
      0|  218|        }
      0|  219|    }
       |  220|
       |  221|    /**
       |  222|        Adds a handler to be called once the request has finished.
       |  223|
       |  224|        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
       |  225|                                       server response, falling back to the default HTTP default character set, 
       |  226|                                       ISO-8859-1.
       |  227|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  228|
       |  229|        - returns: The request.
       |  230|    */
       |  231|    public func responseString(
       |  232|        encoding encoding: NSStringEncoding? = nil,
       |  233|        completionHandler: Response<String, NSError> -> Void)
       |  234|        -> Self
      0|  235|    {
      0|  236|        return response(
      0|  237|            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
      0|  238|            completionHandler: completionHandler
      0|  239|        )
      0|  240|    }
       |  241|}
       |  242|
       |  243|// MARK: - JSON
       |  244|
       |  245|extension Request {
       |  246|
       |  247|    /**
       |  248|        Creates a response serializer that returns a JSON object constructed from the response data using 
       |  249|        `NSJSONSerialization` with the specified reading options.
       |  250|
       |  251|        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
       |  252|
       |  253|        - returns: A JSON object response serializer.
       |  254|    */
       |  255|    public static func JSONResponseSerializer(
       |  256|        options options: NSJSONReadingOptions = .AllowFragments)
       |  257|        -> ResponseSerializer<AnyObject, NSError>
      1|  258|    {
      1|  259|        return ResponseSerializer { _, response, data, error in
      0|  260|            guard error == nil else { return .Failure(error!) }
      1|  261|
      0|  262|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      1|  263|
      0|  264|            guard let validData = data where validData.length > 0 else {
      0|  265|                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
      0|  266|                let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
      0|  267|                return .Failure(error)
      0|  268|            }
      1|  269|
      1|  270|            do {
      1|  271|                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
      1|  272|                return .Success(JSON)
      1|  273|            } catch {
      1|  274|                return .Failure(error as NSError)
      1|  275|            }
      0|  276|        }
      1|  277|    }
       |  278|
       |  279|    /**
       |  280|        Adds a handler to be called once the request has finished.
       |  281|
       |  282|        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
       |  283|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  284|
       |  285|        - returns: The request.
       |  286|    */
       |  287|    public func responseJSON(
       |  288|        options options: NSJSONReadingOptions = .AllowFragments,
       |  289|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  290|        -> Self
      1|  291|    {
      1|  292|        return response(
      1|  293|            responseSerializer: Request.JSONResponseSerializer(options: options),
      1|  294|            completionHandler: completionHandler
      1|  295|        )
      1|  296|    }
       |  297|}
       |  298|
       |  299|// MARK: - Property List
       |  300|
       |  301|extension Request {
       |  302|
       |  303|    /**
       |  304|        Creates a response serializer that returns an object constructed from the response data using 
       |  305|        `NSPropertyListSerialization` with the specified reading options.
       |  306|
       |  307|        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
       |  308|
       |  309|        - returns: A property list object response serializer.
       |  310|    */
       |  311|    public static func propertyListResponseSerializer(
       |  312|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
       |  313|        -> ResponseSerializer<AnyObject, NSError>
      0|  314|    {
      0|  315|        return ResponseSerializer { _, response, data, error in
      0|  316|            guard error == nil else { return .Failure(error!) }
      0|  317|
      0|  318|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      0|  319|
      0|  320|            guard let validData = data where validData.length > 0 else {
      0|  321|                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
      0|  322|                let error = Error.errorWithCode(.PropertyListSerializationFailed, failureReason: failureReason)
      0|  323|                return .Failure(error)
      0|  324|            }
      0|  325|
      0|  326|            do {
      0|  327|                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
      0|  328|                return .Success(plist)
      0|  329|            } catch {
      0|  330|                return .Failure(error as NSError)
      0|  331|            }
      0|  332|        }
      0|  333|    }
       |  334|
       |  335|    /**
       |  336|        Adds a handler to be called once the request has finished.
       |  337|
       |  338|        - parameter options:           The property list reading options. `0` by default.
       |  339|        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
       |  340|                                       arguments: the URL request, the URL response, the server data and the result 
       |  341|                                       produced while creating the property list.
       |  342|
       |  343|        - returns: The request.
       |  344|    */
       |  345|    public func responsePropertyList(
       |  346|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
       |  347|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  348|        -> Self
      0|  349|    {
      0|  350|        return response(
      0|  351|            responseSerializer: Request.propertyListResponseSerializer(options: options),
      0|  352|            completionHandler: completionHandler
      0|  353|        )
      0|  354|    }
       |  355|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Result.swift:
       |    1|// Result.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Used to represent whether a request was successful or encountered an error.
       |   27|
       |   28|    - Success: The request and all post processing operations were successful resulting in the serialization of the 
       |   29|               provided associated value.
       |   30|    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
       |   31|               provided by the server as well as the error that caused the failure.
       |   32|*/
       |   33|public enum Result<Value, Error: ErrorType> {
       |   34|    case Success(Value)
       |   35|    case Failure(Error)
       |   36|
       |   37|    /// Returns `true` if the result is a success, `false` otherwise.
      0|   38|    public var isSuccess: Bool {
      0|   39|        switch self {
      0|   40|        case .Success:
      0|   41|            return true
      0|   42|        case .Failure:
      0|   43|            return false
      0|   44|        }
      0|   45|    }
       |   46|
       |   47|    /// Returns `true` if the result is a failure, `false` otherwise.
      0|   48|    public var isFailure: Bool {
      0|   49|        return !isSuccess
      0|   50|    }
       |   51|
       |   52|    /// Returns the associated value if the result is a success, `nil` otherwise.
      0|   53|    public var value: Value? {
      0|   54|        switch self {
      0|   55|        case .Success(let value):
      0|   56|            return value
      0|   57|        case .Failure:
      0|   58|            return nil
      0|   59|        }
      0|   60|    }
       |   61|
       |   62|    /// Returns the associated error value if the result is a failure, `nil` otherwise.
      0|   63|    public var error: Error? {
      0|   64|        switch self {
      0|   65|        case .Success:
      0|   66|            return nil
      0|   67|        case .Failure(let error):
      0|   68|            return error
      0|   69|        }
      0|   70|    }
       |   71|}
       |   72|
       |   73|// MARK: - CustomStringConvertible
       |   74|
       |   75|extension Result: CustomStringConvertible {
       |   76|    /// The textual representation used when written to an output stream, which includes whether the result was a 
       |   77|    /// success or failure.
      0|   78|    public var description: String {
      0|   79|        switch self {
      0|   80|        case .Success:
      0|   81|            return "SUCCESS"
      0|   82|        case .Failure:
      0|   83|            return "FAILURE"
      0|   84|        }
      0|   85|    }
       |   86|}
       |   87|
       |   88|// MARK: - CustomDebugStringConvertible
       |   89|
       |   90|extension Result: CustomDebugStringConvertible {
       |   91|    /// The debug textual representation used when written to an output stream, which includes whether the result was a
       |   92|    /// success or failure in addition to the value or error.
      1|   93|    public var debugDescription: String {
      1|   94|        switch self {
      0|   95|        case .Success(let value):
      0|   96|            return "SUCCESS: \(value)"
      1|   97|        case .Failure(let error):
      1|   98|            return "FAILURE: \(error)"
      1|   99|        }
      1|  100|    }
       |  101|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ServerTrustPolicy.swift:
       |    1|// ServerTrustPolicy.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
       |   26|public class ServerTrustPolicyManager {
       |   27|    /// The dictionary of policies mapped to a particular host.
       |   28|    public let policies: [String: ServerTrustPolicy]
       |   29|
       |   30|    /**
       |   31|        Initializes the `ServerTrustPolicyManager` instance with the given policies.
       |   32|
       |   33|        Since different servers and web services can have different leaf certificates, intermediate and even root 
       |   34|        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
       |   35|        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
       |   36|        pinning for host3 and disabling evaluation for host4.
       |   37|
       |   38|        - parameter policies: A dictionary of all policies mapped to a particular host.
       |   39|
       |   40|        - returns: The new `ServerTrustPolicyManager` instance.
       |   41|    */
      0|   42|    public init(policies: [String: ServerTrustPolicy]) {
      0|   43|        self.policies = policies
      0|   44|    }
       |   45|
       |   46|    /**
       |   47|        Returns the `ServerTrustPolicy` for the given host if applicable.
       |   48|
       |   49|        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
       |   50|        this method and implement more complex mapping implementations such as wildcards.
       |   51|
       |   52|        - parameter host: The host to use when searching for a matching policy.
       |   53|
       |   54|        - returns: The server trust policy for the given host if found.
       |   55|    */
      0|   56|    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
      0|   57|        return policies[host]
      0|   58|    }
       |   59|}
       |   60|
       |   61|// MARK: -
       |   62|
       |   63|extension NSURLSession {
       |   64|    private struct AssociatedKeys {
       |   65|        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
       |   66|    }
       |   67|
       |   68|    var serverTrustPolicyManager: ServerTrustPolicyManager? {
      1|   69|        get {
      1|   70|            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
      1|   71|        }
      1|   72|        set (manager) {
      1|   73|            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
      1|   74|        }
       |   75|    }
       |   76|}
       |   77|
       |   78|// MARK: - ServerTrustPolicy
       |   79|
       |   80|/**
       |   81|    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
       |   82|    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
       |   83|    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
       |   84|
       |   85|    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
       |   86|    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
       |   87|    to route all communication over an HTTPS connection with pinning enabled.
       |   88|
       |   89|    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
       |   90|                                validate the host provided by the challenge. Applications are encouraged to always 
       |   91|                                validate the host in production environments to guarantee the validity of the server's 
       |   92|                                certificate chain.
       |   93|
       |   94|    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
       |   95|                                considered valid if one of the pinned certificates match one of the server certificates. 
       |   96|                                By validating both the certificate chain and host, certificate pinning provides a very 
       |   97|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |   98|                                Applications are encouraged to always validate the host and require a valid certificate 
       |   99|                                chain in production environments.
       |  100|
       |  101|    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
       |  102|                                valid if one of the pinned public keys match one of the server certificate public keys. 
       |  103|                                By validating both the certificate chain and host, public key pinning provides a very 
       |  104|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |  105|                                Applications are encouraged to always validate the host and require a valid certificate 
       |  106|                                chain in production environments.
       |  107|
       |  108|    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
       |  109|
       |  110|    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
       |  111|*/
       |  112|public enum ServerTrustPolicy {
       |  113|    case PerformDefaultEvaluation(validateHost: Bool)
       |  114|    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
       |  115|    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
       |  116|    case DisableEvaluation
       |  117|    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
       |  118|
       |  119|    // MARK: - Bundle Location
       |  120|
       |  121|    /**
       |  122|        Returns all certificates within the given bundle with a `.cer` file extension.
       |  123|
       |  124|        - parameter bundle: The bundle to search for all `.cer` files.
       |  125|
       |  126|        - returns: All certificates within the given bundle.
       |  127|    */
      0|  128|    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
      0|  129|        var certificates: [SecCertificate] = []
      0|  130|
      0|  131|        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
      0|  132|            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
      0|  133|        }.flatten())
      0|  134|
      0|  135|        for path in paths {
      0|  136|            if let
      0|  137|                certificateData = NSData(contentsOfFile: path),
      0|  138|                certificate = SecCertificateCreateWithData(nil, certificateData)
      0|  139|            {
      0|  140|                certificates.append(certificate)
      0|  141|            }
      0|  142|        }
      0|  143|
      0|  144|        return certificates
      0|  145|    }
       |  146|
       |  147|    /**
       |  148|        Returns all public keys within the given bundle with a `.cer` file extension.
       |  149|
       |  150|        - parameter bundle: The bundle to search for all `*.cer` files.
       |  151|
       |  152|        - returns: All public keys within the given bundle.
       |  153|    */
      0|  154|    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
      0|  155|        var publicKeys: [SecKey] = []
      0|  156|
      0|  157|        for certificate in certificatesInBundle(bundle) {
      0|  158|            if let publicKey = publicKeyForCertificate(certificate) {
      0|  159|                publicKeys.append(publicKey)
      0|  160|            }
      0|  161|        }
      0|  162|
      0|  163|        return publicKeys
      0|  164|    }
       |  165|
       |  166|    // MARK: - Evaluation
       |  167|
       |  168|    /**
       |  169|        Evaluates whether the server trust is valid for the given host.
       |  170|
       |  171|        - parameter serverTrust: The server trust to evaluate.
       |  172|        - parameter host:        The host of the challenge protection space.
       |  173|
       |  174|        - returns: Whether the server trust is valid.
       |  175|    */
      0|  176|    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
      0|  177|        var serverTrustIsValid = false
      0|  178|
      0|  179|        switch self {
      0|  180|        case let .PerformDefaultEvaluation(validateHost):
      0|  181|            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  182|            SecTrustSetPolicies(serverTrust, [policy])
      0|  183|
      0|  184|            serverTrustIsValid = trustIsValid(serverTrust)
      0|  185|        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
      0|  186|            if validateCertificateChain {
      0|  187|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  188|                SecTrustSetPolicies(serverTrust, [policy])
      0|  189|
      0|  190|                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
      0|  191|                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
      0|  192|
      0|  193|                serverTrustIsValid = trustIsValid(serverTrust)
      0|  194|            } else {
      0|  195|                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
      0|  196|                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
      0|  197|
      0|  198|                outerLoop: for serverCertificateData in serverCertificatesDataArray {
      0|  199|                    for pinnedCertificateData in pinnedCertificatesDataArray {
      0|  200|                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
      0|  201|                            serverTrustIsValid = true
      0|  202|                            break outerLoop
      0|  203|                        }
      0|  204|                    }
      0|  205|                }
      0|  206|            }
      0|  207|        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
      0|  208|            var certificateChainEvaluationPassed = true
      0|  209|
      0|  210|            if validateCertificateChain {
      0|  211|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  212|                SecTrustSetPolicies(serverTrust, [policy])
      0|  213|
      0|  214|                certificateChainEvaluationPassed = trustIsValid(serverTrust)
      0|  215|            }
      0|  216|
      0|  217|            if certificateChainEvaluationPassed {
      0|  218|                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
      0|  219|                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
      0|  220|                        if serverPublicKey.isEqual(pinnedPublicKey) {
      0|  221|                            serverTrustIsValid = true
      0|  222|                            break outerLoop
      0|  223|                        }
      0|  224|                    }
      0|  225|                }
      0|  226|            }
      0|  227|        case .DisableEvaluation:
      0|  228|            serverTrustIsValid = true
      0|  229|        case let .CustomEvaluation(closure):
      0|  230|            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
      0|  231|        }
      0|  232|
      0|  233|        return serverTrustIsValid
      0|  234|    }
       |  235|
       |  236|    // MARK: - Private - Trust Validation
       |  237|
      0|  238|    private func trustIsValid(trust: SecTrust) -> Bool {
      0|  239|        var isValid = false
      0|  240|
      0|  241|        var result = SecTrustResultType(kSecTrustResultInvalid)
      0|  242|        let status = SecTrustEvaluate(trust, &result)
      0|  243|
      0|  244|        if status == errSecSuccess {
      0|  245|            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
      0|  246|            let proceed = SecTrustResultType(kSecTrustResultProceed)
      0|  247|
      0|  248|            isValid = result == unspecified || result == proceed
      0|  249|        }
      0|  250|
      0|  251|        return isValid
      0|  252|    }
       |  253|
       |  254|    // MARK: - Private - Certificate Data
       |  255|
      0|  256|    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
      0|  257|        var certificates: [SecCertificate] = []
      0|  258|
      0|  259|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  260|            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
      0|  261|                certificates.append(certificate)
      0|  262|            }
      0|  263|        }
      0|  264|
      0|  265|        return certificateDataForCertificates(certificates)
      0|  266|    }
       |  267|
      0|  268|    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
      0|  269|        return certificates.map { SecCertificateCopyData($0) as NSData }
      0|  270|    }
       |  271|
       |  272|    // MARK: - Private - Public Key Extraction
       |  273|
      0|  274|    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
      0|  275|        var publicKeys: [SecKey] = []
      0|  276|
      0|  277|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  278|            if let
      0|  279|                certificate = SecTrustGetCertificateAtIndex(trust, index),
      0|  280|                publicKey = publicKeyForCertificate(certificate)
      0|  281|            {
      0|  282|                publicKeys.append(publicKey)
      0|  283|            }
      0|  284|        }
      0|  285|
      0|  286|        return publicKeys
      0|  287|    }
       |  288|
      0|  289|    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
      0|  290|        var publicKey: SecKey?
      0|  291|
      0|  292|        let policy = SecPolicyCreateBasicX509()
      0|  293|        var trust: SecTrust?
      0|  294|        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
      0|  295|
      0|  296|        if let trust = trust where trustCreationStatus == errSecSuccess {
      0|  297|            publicKey = SecTrustCopyPublicKey(trust)
      0|  298|        }
      0|  299|
      0|  300|        return publicKey
      0|  301|    }
       |  302|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Stream.swift:
       |    1|// Stream.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if !os(watchOS)
       |   26|
       |   27|@available(iOS 9.0, OSX 10.11, *)
       |   28|extension Manager {
       |   29|    private enum Streamable {
       |   30|        case Stream(String, Int)
       |   31|        case NetService(NSNetService)
       |   32|    }
       |   33|
      0|   34|    private func stream(streamable: Streamable) -> Request {
      0|   35|        var streamTask: NSURLSessionStreamTask!
      0|   36|
      0|   37|        switch streamable {
      0|   38|        case .Stream(let hostName, let port):
      0|   39|            dispatch_sync(queue) {
      0|   40|                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
      0|   41|            }
      0|   42|        case .NetService(let netService):
      0|   43|            dispatch_sync(queue) {
      0|   44|                streamTask = self.session.streamTaskWithNetService(netService)
      0|   45|            }
      0|   46|        }
      0|   47|
      0|   48|        let request = Request(session: session, task: streamTask)
      0|   49|
      0|   50|        delegate[request.delegate.task] = request.delegate
      0|   51|
      0|   52|        if startRequestsImmediately {
      0|   53|            request.resume()
      0|   54|        }
      0|   55|
      0|   56|        return request
      0|   57|    }
       |   58|
       |   59|    /**
       |   60|        Creates a request for bidirectional streaming with the given hostname and port.
       |   61|
       |   62|        - parameter hostName: The hostname of the server to connect to.
       |   63|        - parameter port:     The port of the server to connect to.
       |   64|
       |   65|        :returns: The created stream request.
       |   66|    */
      0|   67|    public func stream(hostName hostName: String, port: Int) -> Request {
      0|   68|        return stream(.Stream(hostName, port))
      0|   69|    }
       |   70|
       |   71|    /**
       |   72|        Creates a request for bidirectional streaming with the given `NSNetService`.
       |   73|
       |   74|        - parameter netService: The net service used to identify the endpoint.
       |   75|
       |   76|        - returns: The created stream request.
       |   77|    */
      0|   78|    public func stream(netService netService: NSNetService) -> Request {
      0|   79|        return stream(.NetService(netService))
      0|   80|    }
       |   81|}
       |   82|
       |   83|// MARK: -
       |   84|
       |   85|@available(iOS 9.0, OSX 10.11, *)
       |   86|extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
       |   87|
       |   88|    // MARK: Override Closures
       |   89|
       |   90|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
       |   91|    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|   92|        get {
      0|   93|            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|   94|        }
      0|   95|        set {
      0|   96|            _streamTaskReadClosed = newValue
      0|   97|        }
       |   98|    }
       |   99|
       |  100|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
       |  101|    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  102|        get {
      0|  103|            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  104|        }
      0|  105|        set {
      0|  106|            _streamTaskWriteClosed = newValue
      0|  107|        }
       |  108|    }
       |  109|
       |  110|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
       |  111|    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  112|        get {
      0|  113|            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  114|        }
      0|  115|        set {
      0|  116|            _streamTaskBetterRouteDiscovered = newValue
      0|  117|        }
       |  118|    }
       |  119|
       |  120|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
       |  121|    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
      0|  122|        get {
      0|  123|            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
      0|  124|        }
      0|  125|        set {
      0|  126|            _streamTaskDidBecomeInputStream = newValue
      0|  127|        }
       |  128|    }
       |  129|
       |  130|    // MARK: Delegate Methods
       |  131|
       |  132|    /**
       |  133|        Tells the delegate that the read side of the connection has been closed.
       |  134|
       |  135|        - parameter session:    The session.
       |  136|        - parameter streamTask: The stream task.
       |  137|    */
      0|  138|    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  139|        streamTaskReadClosed?(session, streamTask)
      0|  140|    }
       |  141|
       |  142|    /**
       |  143|        Tells the delegate that the write side of the connection has been closed.
       |  144|
       |  145|        - parameter session:    The session.
       |  146|        - parameter streamTask: The stream task.
       |  147|    */
      0|  148|    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  149|        streamTaskWriteClosed?(session, streamTask)
      0|  150|    }
       |  151|
       |  152|    /**
       |  153|        Tells the delegate that the system has determined that a better route to the host is available.
       |  154|
       |  155|        - parameter session:    The session.
       |  156|        - parameter streamTask: The stream task.
       |  157|    */
      0|  158|    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  159|        streamTaskBetterRouteDiscovered?(session, streamTask)
      0|  160|    }
       |  161|
       |  162|    /**
       |  163|        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
       |  164|
       |  165|        - parameter session:      The session.
       |  166|        - parameter streamTask:   The stream task.
       |  167|        - parameter inputStream:  The new input stream.
       |  168|        - parameter outputStream: The new output stream.
       |  169|    */
       |  170|    public func URLSession(
       |  171|        session: NSURLSession,
       |  172|        streamTask: NSURLSessionStreamTask,
       |  173|        didBecomeInputStream inputStream: NSInputStream,
       |  174|        outputStream: NSOutputStream)
      0|  175|    {
      0|  176|        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
      0|  177|    }
       |  178|}
       |  179|
       |  180|#endif

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Upload.swift:
       |    1|// Upload.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Uploadable {
       |   27|        case Data(NSURLRequest, NSData)
       |   28|        case File(NSURLRequest, NSURL)
       |   29|        case Stream(NSURLRequest, NSInputStream)
       |   30|    }
       |   31|
      0|   32|    private func upload(uploadable: Uploadable) -> Request {
      0|   33|        var uploadTask: NSURLSessionUploadTask!
      0|   34|        var HTTPBodyStream: NSInputStream?
      0|   35|
      0|   36|        switch uploadable {
      0|   37|        case .Data(let request, let data):
      0|   38|            dispatch_sync(queue) {
      0|   39|                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
      0|   40|            }
      0|   41|        case .File(let request, let fileURL):
      0|   42|            dispatch_sync(queue) {
      0|   43|                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
      0|   44|            }
      0|   45|        case .Stream(let request, let stream):
      0|   46|            dispatch_sync(queue) {
      0|   47|                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
      0|   48|            }
      0|   49|
      0|   50|            HTTPBodyStream = stream
      0|   51|        }
      0|   52|
      0|   53|        let request = Request(session: session, task: uploadTask)
      0|   54|
      0|   55|        if HTTPBodyStream != nil {
      0|   56|            request.delegate.taskNeedNewBodyStream = { _, _ in
      0|   57|                return HTTPBodyStream
      0|   58|            }
      0|   59|        }
      0|   60|
      0|   61|        delegate[request.delegate.task] = request.delegate
      0|   62|
      0|   63|        if startRequestsImmediately {
      0|   64|            request.resume()
      0|   65|        }
      0|   66|
      0|   67|        return request
      0|   68|    }
       |   69|
       |   70|    // MARK: File
       |   71|
       |   72|    /**
       |   73|        Creates a request for uploading a file to the specified URL request.
       |   74|
       |   75|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   76|
       |   77|        - parameter URLRequest: The URL request
       |   78|        - parameter file:       The file to upload
       |   79|
       |   80|        - returns: The created upload request.
       |   81|    */
      0|   82|    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|   83|        return upload(.File(URLRequest.URLRequest, file))
      0|   84|    }
       |   85|
       |   86|    /**
       |   87|        Creates a request for uploading a file to the specified URL request.
       |   88|
       |   89|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   90|
       |   91|        - parameter method:    The HTTP method.
       |   92|        - parameter URLString: The URL string.
       |   93|        - parameter headers:   The HTTP headers. `nil` by default.
       |   94|        - parameter file:      The file to upload
       |   95|
       |   96|        - returns: The created upload request.
       |   97|    */
       |   98|    public func upload(
       |   99|        method: Method,
       |  100|        _ URLString: URLStringConvertible,
       |  101|        headers: [String: String]? = nil,
       |  102|        file: NSURL)
       |  103|        -> Request
      0|  104|    {
      0|  105|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  106|        return upload(mutableURLRequest, file: file)
      0|  107|    }
       |  108|
       |  109|    // MARK: Data
       |  110|
       |  111|    /**
       |  112|        Creates a request for uploading data to the specified URL request.
       |  113|
       |  114|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  115|
       |  116|        - parameter URLRequest: The URL request.
       |  117|        - parameter data:       The data to upload.
       |  118|
       |  119|        - returns: The created upload request.
       |  120|    */
      0|  121|    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  122|        return upload(.Data(URLRequest.URLRequest, data))
      0|  123|    }
       |  124|
       |  125|    /**
       |  126|        Creates a request for uploading data to the specified URL request.
       |  127|
       |  128|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  129|
       |  130|        - parameter method:    The HTTP method.
       |  131|        - parameter URLString: The URL string.
       |  132|        - parameter headers:   The HTTP headers. `nil` by default.
       |  133|        - parameter data:      The data to upload
       |  134|
       |  135|        - returns: The created upload request.
       |  136|    */
       |  137|    public func upload(
       |  138|        method: Method,
       |  139|        _ URLString: URLStringConvertible,
       |  140|        headers: [String: String]? = nil,
       |  141|        data: NSData)
       |  142|        -> Request
      0|  143|    {
      0|  144|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  145|
      0|  146|        return upload(mutableURLRequest, data: data)
      0|  147|    }
       |  148|
       |  149|    // MARK: Stream
       |  150|
       |  151|    /**
       |  152|        Creates a request for uploading a stream to the specified URL request.
       |  153|
       |  154|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  155|
       |  156|        - parameter URLRequest: The URL request.
       |  157|        - parameter stream:     The stream to upload.
       |  158|
       |  159|        - returns: The created upload request.
       |  160|    */
      0|  161|    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  162|        return upload(.Stream(URLRequest.URLRequest, stream))
      0|  163|    }
       |  164|
       |  165|    /**
       |  166|        Creates a request for uploading a stream to the specified URL request.
       |  167|
       |  168|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  169|
       |  170|        - parameter method:    The HTTP method.
       |  171|        - parameter URLString: The URL string.
       |  172|        - parameter headers:   The HTTP headers. `nil` by default.
       |  173|        - parameter stream:    The stream to upload.
       |  174|
       |  175|        - returns: The created upload request.
       |  176|    */
       |  177|    public func upload(
       |  178|        method: Method,
       |  179|        _ URLString: URLStringConvertible,
       |  180|        headers: [String: String]? = nil,
       |  181|        stream: NSInputStream)
       |  182|        -> Request
      0|  183|    {
      0|  184|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  185|
      0|  186|        return upload(mutableURLRequest, stream: stream)
      0|  187|    }
       |  188|
       |  189|    // MARK: MultipartFormData
       |  190|
       |  191|    /// Default memory threshold used when encoding `MultipartFormData`.
       |  192|    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
       |  193|
       |  194|    /**
       |  195|        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
       |  196|        associated values.
       |  197|
       |  198|        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
       |  199|                   streaming information.
       |  200|        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
       |  201|                   error.
       |  202|    */
       |  203|    public enum MultipartFormDataEncodingResult {
       |  204|        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
       |  205|        case Failure(ErrorType)
       |  206|    }
       |  207|
       |  208|    /**
       |  209|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  210|
       |  211|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
       |  212|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
       |  213|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
       |  214|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
       |  215|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
       |  216|        used for larger payloads such as video content.
       |  217|
       |  218|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
       |  219|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  220|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
       |  221|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
       |  222|        technique was used.
       |  223|
       |  224|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  225|
       |  226|        - parameter method:                  The HTTP method.
       |  227|        - parameter URLString:               The URL string.
       |  228|        - parameter headers:                 The HTTP headers. `nil` by default.
       |  229|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  230|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  231|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  232|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  233|    */
       |  234|    public func upload(
       |  235|        method: Method,
       |  236|        _ URLString: URLStringConvertible,
       |  237|        headers: [String: String]? = nil,
       |  238|        multipartFormData: MultipartFormData -> Void,
       |  239|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  240|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  241|    {
      0|  242|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  243|
      0|  244|        return upload(
      0|  245|            mutableURLRequest,
      0|  246|            multipartFormData: multipartFormData,
      0|  247|            encodingMemoryThreshold: encodingMemoryThreshold,
      0|  248|            encodingCompletion: encodingCompletion
      0|  249|        )
      0|  250|    }
       |  251|
       |  252|    /**
       |  253|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  254|
       |  255|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
       |  256|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
       |  257|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
       |  258|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
       |  259|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
       |  260|        used for larger payloads such as video content.
       |  261|
       |  262|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
       |  263|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  264|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
       |  265|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
       |  266|        technique was used.
       |  267|
       |  268|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  269|
       |  270|        - parameter URLRequest:              The URL request.
       |  271|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  272|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  273|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  274|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  275|    */
       |  276|    public func upload(
       |  277|        URLRequest: URLRequestConvertible,
       |  278|        multipartFormData: MultipartFormData -> Void,
       |  279|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  280|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  281|    {
      0|  282|        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
      0|  283|            let formData = MultipartFormData()
      0|  284|            multipartFormData(formData)
      0|  285|
      0|  286|            let URLRequestWithContentType = URLRequest.URLRequest
      0|  287|            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
      0|  288|
      0|  289|            let isBackgroundSession = self.session.configuration.identifier != nil
      0|  290|
      0|  291|            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
      0|  292|                do {
      0|  293|                    let data = try formData.encode()
      0|  294|                    let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  295|                        request: self.upload(URLRequestWithContentType, data: data),
      0|  296|                        streamingFromDisk: false,
      0|  297|                        streamFileURL: nil
      0|  298|                    )
      0|  299|
      0|  300|                    dispatch_async(dispatch_get_main_queue()) {
      0|  301|                        encodingCompletion?(encodingResult)
      0|  302|                    }
      0|  303|                } catch {
      0|  304|                    dispatch_async(dispatch_get_main_queue()) {
      0|  305|                        encodingCompletion?(.Failure(error as NSError))
      0|  306|                    }
      0|  307|                }
      0|  308|            } else {
      0|  309|                let fileManager = NSFileManager.defaultManager()
      0|  310|                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
      0|  311|                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
      0|  312|                let fileName = NSUUID().UUIDString
      0|  313|                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
      0|  314|
      0|  315|                do {
      0|  316|                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
      0|  317|                    try formData.writeEncodedDataToDisk(fileURL)
      0|  318|
      0|  319|                    dispatch_async(dispatch_get_main_queue()) {
      0|  320|                        let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  321|                            request: self.upload(URLRequestWithContentType, file: fileURL),
      0|  322|                            streamingFromDisk: true,
      0|  323|                            streamFileURL: fileURL
      0|  324|                        )
      0|  325|                        encodingCompletion?(encodingResult)
      0|  326|                    }
      0|  327|                } catch {
      0|  328|                    dispatch_async(dispatch_get_main_queue()) {
      0|  329|                        encodingCompletion?(.Failure(error as NSError))
      0|  330|                    }
      0|  331|                }
      0|  332|            }
      0|  333|        }
      0|  334|    }
       |  335|}
       |  336|
       |  337|// MARK: -
       |  338|
       |  339|extension Request {
       |  340|
       |  341|    // MARK: - UploadTaskDelegate
       |  342|
       |  343|    class UploadTaskDelegate: DataTaskDelegate {
      0|  344|        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
       |  345|        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
       |  346|
       |  347|        // MARK: - NSURLSessionTaskDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  352|
       |  353|        // MARK: Delegate Methods
       |  354|
       |  355|        func URLSession(
       |  356|            session: NSURLSession,
       |  357|            task: NSURLSessionTask,
       |  358|            didSendBodyData bytesSent: Int64,
       |  359|            totalBytesSent: Int64,
       |  360|            totalBytesExpectedToSend: Int64)
      0|  361|        {
      0|  362|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  363|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  364|            } else {
      0|  365|                progress.totalUnitCount = totalBytesExpectedToSend
      0|  366|                progress.completedUnitCount = totalBytesSent
      0|  367|
      0|  368|                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  369|            }
      0|  370|        }
       |  371|    }
       |  372|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Validation.swift:
       |    1|// Validation.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Request {
       |   26|
       |   27|    /**
       |   28|        Used to represent whether validation was successful or encountered an error resulting in a failure.
       |   29|
       |   30|        - Success: The validation was successful.
       |   31|        - Failure: The validation failed encountering the provided error.
       |   32|    */
       |   33|    public enum ValidationResult {
       |   34|        case Success
       |   35|        case Failure(NSError)
       |   36|    }
       |   37|
       |   38|    /**
       |   39|        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
       |   40|        request was valid.
       |   41|    */
       |   42|    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
       |   43|
       |   44|    /**
       |   45|        Validates the request, using the specified closure.
       |   46|
       |   47|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   48|
       |   49|        - parameter validation: A closure to validate the request.
       |   50|
       |   51|        - returns: The request.
       |   52|    */
      0|   53|    public func validate(validation: Validation) -> Self {
      0|   54|        delegate.queue.addOperationWithBlock {
      0|   55|            if let
      0|   56|                response = self.response where self.delegate.error == nil,
      0|   57|                case let .Failure(error) = validation(self.request, response)
      0|   58|            {
      0|   59|                self.delegate.error = error
      0|   60|            }
      0|   61|        }
      0|   62|
      0|   63|        return self
      0|   64|    }
       |   65|
       |   66|    // MARK: - Status Code
       |   67|
       |   68|    /**
       |   69|        Validates that the response has a status code in the specified range.
       |   70|
       |   71|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   72|
       |   73|        - parameter range: The range of acceptable status codes.
       |   74|
       |   75|        - returns: The request.
       |   76|    */
      0|   77|    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
      0|   78|        return validate { _, response in
      0|   79|            if acceptableStatusCode.contains(response.statusCode) {
      0|   80|                return .Success
      0|   81|            } else {
      0|   82|                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
      0|   83|                return .Failure(Error.errorWithCode(.StatusCodeValidationFailed, failureReason: failureReason))
      0|   84|            }
      0|   85|        }
      0|   86|    }
       |   87|
       |   88|    // MARK: - Content-Type
       |   89|
       |   90|    private struct MIMEType {
       |   91|        let type: String
       |   92|        let subtype: String
       |   93|
      0|   94|        init?(_ string: String) {
      0|   95|            let components: [String] = {
      0|   96|                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
      0|   97|                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
      0|   98|                return split.componentsSeparatedByString("/")
      0|   99|            }()
      0|  100|
      0|  101|            if let
      0|  102|                type = components.first,
      0|  103|                subtype = components.last
      0|  104|            {
      0|  105|                self.type = type
      0|  106|                self.subtype = subtype
      0|  107|            } else {
      0|  108|                return nil
      0|  109|            }
      0|  110|        }
       |  111|
      0|  112|        func matches(MIME: MIMEType) -> Bool {
      0|  113|            switch (type, subtype) {
      0|  114|            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
      0|  115|                return true
      0|  116|            default:
      0|  117|                return false
      0|  118|            }
      0|  119|        }
       |  120|    }
       |  121|
       |  122|    /**
       |  123|        Validates that the response has a content type in the specified array.
       |  124|
       |  125|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  126|
       |  127|        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
       |  128|
       |  129|        - returns: The request.
       |  130|    */
      0|  131|    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
      0|  132|        return validate { _, response in
      0|  133|            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
      0|  134|
      0|  135|            if let
      0|  136|                responseContentType = response.MIMEType,
      0|  137|                responseMIMEType = MIMEType(responseContentType)
      0|  138|            {
      0|  139|                for contentType in acceptableContentTypes {
      0|  140|                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
      0|  141|                        return .Success
      0|  142|                    }
      0|  143|                }
      0|  144|            } else {
      0|  145|                for contentType in acceptableContentTypes {
      0|  146|                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
      0|  147|                        return .Success
      0|  148|                    }
      0|  149|                }
      0|  150|            }
      0|  151|
      0|  152|            let failureReason: String
      0|  153|
      0|  154|            if let responseContentType = response.MIMEType {
      0|  155|                failureReason = (
      0|  156|                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
      0|  157|                    "content types: \(acceptableContentTypes)"
      0|  158|                )
      0|  159|            } else {
      0|  160|                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
      0|  161|            }
      0|  162|
      0|  163|            return .Failure(Error.errorWithCode(.ContentTypeValidationFailed, failureReason: failureReason))
      0|  164|        }
      0|  165|    }
       |  166|
       |  167|    // MARK: - Automatic
       |  168|
       |  169|    /**
       |  170|        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
       |  171|        type matches any specified in the Accept HTTP header field.
       |  172|
       |  173|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  174|
       |  175|        - returns: The request.
       |  176|    */
      0|  177|    public func validate() -> Self {
      0|  178|        let acceptableStatusCodes: Range<Int> = 200..<300
      0|  179|        let acceptableContentTypes: [String] = {
      0|  180|            if let accept = request?.valueForHTTPHeaderField("Accept") {
      0|  181|                return accept.componentsSeparatedByString(",")
      0|  182|            }
      0|  183|
      0|  184|            return ["*/*"]
      0|  185|        }()
      0|  186|
      0|  187|        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
      0|  188|    }
       |  189|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Alamofire.swift:
       |    1|// Alamofire.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: - URLStringConvertible
       |   26|
       |   27|/**
       |   28|    Types adopting the `URLStringConvertible` protocol can be used to construct URL strings, which are then used to 
       |   29|    construct URL requests.
       |   30|*/
       |   31|public protocol URLStringConvertible {
       |   32|    /**
       |   33|        A URL that conforms to RFC 2396.
       |   34|
       |   35|        Methods accepting a `URLStringConvertible` type parameter parse it according to RFCs 1738 and 1808.
       |   36|
       |   37|        See https://tools.ietf.org/html/rfc2396
       |   38|        See https://tools.ietf.org/html/rfc1738
       |   39|        See https://tools.ietf.org/html/rfc1808
       |   40|    */
       |   41|    var URLString: String { get }
       |   42|}
       |   43|
       |   44|extension String: URLStringConvertible {
      1|   45|    public var URLString: String {
      1|   46|        return self
      1|   47|    }
       |   48|}
       |   49|
       |   50|extension NSURL: URLStringConvertible {
      0|   51|    public var URLString: String {
      0|   52|        return absoluteString
      0|   53|    }
       |   54|}
       |   55|
       |   56|extension NSURLComponents: URLStringConvertible {
      0|   57|    public var URLString: String {
      0|   58|        return URL!.URLString
      0|   59|    }
       |   60|}
       |   61|
       |   62|extension NSURLRequest: URLStringConvertible {
      0|   63|    public var URLString: String {
      0|   64|        return URL!.URLString
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - URLRequestConvertible
       |   69|
       |   70|/**
       |   71|    Types adopting the `URLRequestConvertible` protocol can be used to construct URL requests.
       |   72|*/
       |   73|public protocol URLRequestConvertible {
       |   74|    /// The URL request.
       |   75|    var URLRequest: NSMutableURLRequest { get }
       |   76|}
       |   77|
       |   78|extension NSURLRequest: URLRequestConvertible {
      2|   79|    public var URLRequest: NSMutableURLRequest {
      2|   80|        return self.mutableCopy() as! NSMutableURLRequest
      2|   81|    }
       |   82|}
       |   83|
       |   84|// MARK: - Convenience
       |   85|
       |   86|func URLRequest(
       |   87|    method: Method,
       |   88|    _ URLString: URLStringConvertible,
       |   89|    headers: [String: String]? = nil)
       |   90|    -> NSMutableURLRequest
      1|   91|{
      1|   92|    let mutableURLRequest = NSMutableURLRequest(URL: NSURL(string: URLString.URLString)!)
      1|   93|    mutableURLRequest.HTTPMethod = method.rawValue
      1|   94|
      1|   95|    if let headers = headers {
      2|   96|        for (headerField, headerValue) in headers {
      2|   97|            mutableURLRequest.setValue(headerValue, forHTTPHeaderField: headerField)
      2|   98|        }
      1|   99|    }
      1|  100|
      1|  101|    return mutableURLRequest
      1|  102|}
       |  103|
       |  104|// MARK: - Request Methods
       |  105|
       |  106|/**
       |  107|    Creates a request using the shared manager instance for the specified method, URL string, parameters, and
       |  108|    parameter encoding.
       |  109|
       |  110|    - parameter method:     The HTTP method.
       |  111|    - parameter URLString:  The URL string.
       |  112|    - parameter parameters: The parameters. `nil` by default.
       |  113|    - parameter encoding:   The parameter encoding. `.URL` by default.
       |  114|    - parameter headers:    The HTTP headers. `nil` by default.
       |  115|
       |  116|    - returns: The created request.
       |  117|*/
       |  118|public func request(
       |  119|    method: Method,
       |  120|    _ URLString: URLStringConvertible,
       |  121|    parameters: [String: AnyObject]? = nil,
       |  122|    encoding: ParameterEncoding = .URL,
       |  123|    headers: [String: String]? = nil)
       |  124|    -> Request
      1|  125|{
      1|  126|    return Manager.sharedInstance.request(
      1|  127|        method,
      1|  128|        URLString,
      1|  129|        parameters: parameters,
      1|  130|        encoding: encoding,
      1|  131|        headers: headers
      1|  132|    )
      1|  133|}
       |  134|
       |  135|/**
       |  136|    Creates a request using the shared manager instance for the specified URL request.
       |  137|
       |  138|    If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  139|
       |  140|    - parameter URLRequest: The URL request
       |  141|
       |  142|    - returns: The created request.
       |  143|*/
      0|  144|public func request(URLRequest: URLRequestConvertible) -> Request {
      0|  145|    return Manager.sharedInstance.request(URLRequest.URLRequest)
      0|  146|}
       |  147|
       |  148|// MARK: - Upload Methods
       |  149|
       |  150|// MARK: File
       |  151|
       |  152|/**
       |  153|    Creates an upload request using the shared manager instance for the specified method, URL string, and file.
       |  154|
       |  155|    - parameter method:    The HTTP method.
       |  156|    - parameter URLString: The URL string.
       |  157|    - parameter headers:   The HTTP headers. `nil` by default.
       |  158|    - parameter file:      The file to upload.
       |  159|
       |  160|    - returns: The created upload request.
       |  161|*/
       |  162|public func upload(
       |  163|    method: Method,
       |  164|    _ URLString: URLStringConvertible,
       |  165|    headers: [String: String]? = nil,
       |  166|    file: NSURL)
       |  167|    -> Request
      0|  168|{
      0|  169|    return Manager.sharedInstance.upload(method, URLString, headers: headers, file: file)
      0|  170|}
       |  171|
       |  172|/**
       |  173|    Creates an upload request using the shared manager instance for the specified URL request and file.
       |  174|
       |  175|    - parameter URLRequest: The URL request.
       |  176|    - parameter file:       The file to upload.
       |  177|
       |  178|    - returns: The created upload request.
       |  179|*/
      0|  180|public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|  181|    return Manager.sharedInstance.upload(URLRequest, file: file)
      0|  182|}
       |  183|
       |  184|// MARK: Data
       |  185|
       |  186|/**
       |  187|    Creates an upload request using the shared manager instance for the specified method, URL string, and data.
       |  188|
       |  189|    - parameter method:    The HTTP method.
       |  190|    - parameter URLString: The URL string.
       |  191|    - parameter headers:   The HTTP headers. `nil` by default.
       |  192|    - parameter data:      The data to upload.
       |  193|
       |  194|    - returns: The created upload request.
       |  195|*/
       |  196|public func upload(
       |  197|    method: Method,
       |  198|    _ URLString: URLStringConvertible,
       |  199|    headers: [String: String]? = nil,
       |  200|    data: NSData)
       |  201|    -> Request
      0|  202|{
      0|  203|    return Manager.sharedInstance.upload(method, URLString, headers: headers, data: data)
      0|  204|}
       |  205|
       |  206|/**
       |  207|    Creates an upload request using the shared manager instance for the specified URL request and data.
       |  208|
       |  209|    - parameter URLRequest: The URL request.
       |  210|    - parameter data:       The data to upload.
       |  211|
       |  212|    - returns: The created upload request.
       |  213|*/
      0|  214|public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  215|    return Manager.sharedInstance.upload(URLRequest, data: data)
      0|  216|}
       |  217|
       |  218|// MARK: Stream
       |  219|
       |  220|/**
       |  221|    Creates an upload request using the shared manager instance for the specified method, URL string, and stream.
       |  222|
       |  223|    - parameter method:    The HTTP method.
       |  224|    - parameter URLString: The URL string.
       |  225|    - parameter headers:   The HTTP headers. `nil` by default.
       |  226|    - parameter stream:    The stream to upload.
       |  227|
       |  228|    - returns: The created upload request.
       |  229|*/
       |  230|public func upload(
       |  231|    method: Method,
       |  232|    _ URLString: URLStringConvertible,
       |  233|    headers: [String: String]? = nil,
       |  234|    stream: NSInputStream)
       |  235|    -> Request
      0|  236|{
      0|  237|    return Manager.sharedInstance.upload(method, URLString, headers: headers, stream: stream)
      0|  238|}
       |  239|
       |  240|/**
       |  241|    Creates an upload request using the shared manager instance for the specified URL request and stream.
       |  242|
       |  243|    - parameter URLRequest: The URL request.
       |  244|    - parameter stream:     The stream to upload.
       |  245|
       |  246|    - returns: The created upload request.
       |  247|*/
      0|  248|public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  249|    return Manager.sharedInstance.upload(URLRequest, stream: stream)
      0|  250|}
       |  251|
       |  252|// MARK: MultipartFormData
       |  253|
       |  254|/**
       |  255|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  256|
       |  257|    - parameter method:                  The HTTP method.
       |  258|    - parameter URLString:               The URL string.
       |  259|    - parameter headers:                 The HTTP headers. `nil` by default.
       |  260|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  261|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  262|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  263|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  264|*/
       |  265|public func upload(
       |  266|    method: Method,
       |  267|    _ URLString: URLStringConvertible,
       |  268|    headers: [String: String]? = nil,
       |  269|    multipartFormData: MultipartFormData -> Void,
       |  270|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  271|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  272|{
      0|  273|    return Manager.sharedInstance.upload(
      0|  274|        method,
      0|  275|        URLString,
      0|  276|        headers: headers,
      0|  277|        multipartFormData: multipartFormData,
      0|  278|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  279|        encodingCompletion: encodingCompletion
      0|  280|    )
      0|  281|}
       |  282|
       |  283|/**
       |  284|    Creates an upload request using the shared manager instance for the specified method and URL string.
       |  285|
       |  286|    - parameter URLRequest:              The URL request.
       |  287|    - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  288|    - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  289|                                         `MultipartFormDataEncodingMemoryThreshold` by default.
       |  290|    - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  291|*/
       |  292|public func upload(
       |  293|    URLRequest: URLRequestConvertible,
       |  294|    multipartFormData: MultipartFormData -> Void,
       |  295|    encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  296|    encodingCompletion: (Manager.MultipartFormDataEncodingResult -> Void)?)
      0|  297|{
      0|  298|    return Manager.sharedInstance.upload(
      0|  299|        URLRequest,
      0|  300|        multipartFormData: multipartFormData,
      0|  301|        encodingMemoryThreshold: encodingMemoryThreshold,
      0|  302|        encodingCompletion: encodingCompletion
      0|  303|    )
      0|  304|}
       |  305|
       |  306|// MARK: - Download Methods
       |  307|
       |  308|// MARK: URL Request
       |  309|
       |  310|/**
       |  311|    Creates a download request using the shared manager instance for the specified method and URL string.
       |  312|
       |  313|    - parameter method:      The HTTP method.
       |  314|    - parameter URLString:   The URL string.
       |  315|    - parameter parameters:  The parameters. `nil` by default.
       |  316|    - parameter encoding:    The parameter encoding. `.URL` by default.
       |  317|    - parameter headers:     The HTTP headers. `nil` by default.
       |  318|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  319|
       |  320|    - returns: The created download request.
       |  321|*/
       |  322|public func download(
       |  323|    method: Method,
       |  324|    _ URLString: URLStringConvertible,
       |  325|    parameters: [String: AnyObject]? = nil,
       |  326|    encoding: ParameterEncoding = .URL,
       |  327|    headers: [String: String]? = nil,
       |  328|    destination: Request.DownloadFileDestination)
       |  329|    -> Request
      0|  330|{
      0|  331|    return Manager.sharedInstance.download(
      0|  332|        method,
      0|  333|        URLString,
      0|  334|        parameters: parameters,
      0|  335|        encoding: encoding,
      0|  336|        headers: headers,
      0|  337|        destination: destination
      0|  338|    )
      0|  339|}
       |  340|
       |  341|/**
       |  342|    Creates a download request using the shared manager instance for the specified URL request.
       |  343|
       |  344|    - parameter URLRequest:  The URL request.
       |  345|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  346|
       |  347|    - returns: The created download request.
       |  348|*/
      0|  349|public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  350|    return Manager.sharedInstance.download(URLRequest, destination: destination)
      0|  351|}
       |  352|
       |  353|// MARK: Resume Data
       |  354|
       |  355|/**
       |  356|    Creates a request using the shared manager instance for downloading from the resume data produced from a 
       |  357|    previous request cancellation.
       |  358|
       |  359|    - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask`
       |  360|                             when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for additional 
       |  361|                             information.
       |  362|    - parameter destination: The closure used to determine the destination of the downloaded file.
       |  363|
       |  364|    - returns: The created download request.
       |  365|*/
      0|  366|public func download(resumeData data: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  367|    return Manager.sharedInstance.download(data, destination: destination)
      0|  368|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Download.swift:
       |    1|// Download.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Downloadable {
       |   27|        case Request(NSURLRequest)
       |   28|        case ResumeData(NSData)
       |   29|    }
       |   30|
      0|   31|    private func download(downloadable: Downloadable, destination: Request.DownloadFileDestination) -> Request {
      0|   32|        var downloadTask: NSURLSessionDownloadTask!
      0|   33|
      0|   34|        switch downloadable {
      0|   35|        case .Request(let request):
      0|   36|            dispatch_sync(queue) {
      0|   37|                downloadTask = self.session.downloadTaskWithRequest(request)
      0|   38|            }
      0|   39|        case .ResumeData(let resumeData):
      0|   40|            dispatch_sync(queue) {
      0|   41|                downloadTask = self.session.downloadTaskWithResumeData(resumeData)
      0|   42|            }
      0|   43|        }
      0|   44|
      0|   45|        let request = Request(session: session, task: downloadTask)
      0|   46|
      0|   47|        if let downloadDelegate = request.delegate as? Request.DownloadTaskDelegate {
      0|   48|            downloadDelegate.downloadTaskDidFinishDownloadingToURL = { session, downloadTask, URL in
      0|   49|                return destination(URL, downloadTask.response as! NSHTTPURLResponse)
      0|   50|            }
      0|   51|        }
      0|   52|
      0|   53|        delegate[request.delegate.task] = request.delegate
      0|   54|
      0|   55|        if startRequestsImmediately {
      0|   56|            request.resume()
      0|   57|        }
      0|   58|
      0|   59|        return request
      0|   60|    }
       |   61|
       |   62|    // MARK: Request
       |   63|
       |   64|    /**
       |   65|        Creates a download request for the specified method, URL string, parameters, parameter encoding, headers
       |   66|        and destination.
       |   67|
       |   68|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   69|
       |   70|        - parameter method:      The HTTP method.
       |   71|        - parameter URLString:   The URL string.
       |   72|        - parameter parameters:  The parameters. `nil` by default.
       |   73|        - parameter encoding:    The parameter encoding. `.URL` by default.
       |   74|        - parameter headers:     The HTTP headers. `nil` by default.
       |   75|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |   76|
       |   77|        - returns: The created download request.
       |   78|    */
       |   79|    public func download(
       |   80|        method: Method,
       |   81|        _ URLString: URLStringConvertible,
       |   82|        parameters: [String: AnyObject]? = nil,
       |   83|        encoding: ParameterEncoding = .URL,
       |   84|        headers: [String: String]? = nil,
       |   85|        destination: Request.DownloadFileDestination)
       |   86|        -> Request
      0|   87|    {
      0|   88|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|   89|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      0|   90|
      0|   91|        return download(encodedURLRequest, destination: destination)
      0|   92|    }
       |   93|
       |   94|    /**
       |   95|        Creates a request for downloading from the specified URL request.
       |   96|
       |   97|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   98|
       |   99|        - parameter URLRequest:  The URL request
       |  100|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  101|
       |  102|        - returns: The created download request.
       |  103|    */
      0|  104|    public func download(URLRequest: URLRequestConvertible, destination: Request.DownloadFileDestination) -> Request {
      0|  105|        return download(.Request(URLRequest.URLRequest), destination: destination)
      0|  106|    }
       |  107|
       |  108|    // MARK: Resume Data
       |  109|
       |  110|    /**
       |  111|        Creates a request for downloading from the resume data produced from a previous request cancellation.
       |  112|
       |  113|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  114|
       |  115|        - parameter resumeData:  The resume data. This is an opaque data blob produced by `NSURLSessionDownloadTask` 
       |  116|                                 when a task is cancelled. See `NSURLSession -downloadTaskWithResumeData:` for 
       |  117|                                 additional information.
       |  118|        - parameter destination: The closure used to determine the destination of the downloaded file.
       |  119|
       |  120|        - returns: The created download request.
       |  121|    */
      0|  122|    public func download(resumeData: NSData, destination: Request.DownloadFileDestination) -> Request {
      0|  123|        return download(.ResumeData(resumeData), destination: destination)
      0|  124|    }
       |  125|}
       |  126|
       |  127|// MARK: -
       |  128|
       |  129|extension Request {
       |  130|    /**
       |  131|        A closure executed once a request has successfully completed in order to determine where to move the temporary 
       |  132|        file written to during the download process. The closure takes two arguments: the temporary file URL and the URL 
       |  133|        response, and returns a single argument: the file URL where the temporary file should be moved.
       |  134|    */
       |  135|    public typealias DownloadFileDestination = (NSURL, NSHTTPURLResponse) -> NSURL
       |  136|
       |  137|    /**
       |  138|        Creates a download file destination closure which uses the default file manager to move the temporary file to a 
       |  139|        file URL in the first available directory with the specified search path directory and search path domain mask.
       |  140|
       |  141|        - parameter directory: The search path directory. `.DocumentDirectory` by default.
       |  142|        - parameter domain:    The search path domain mask. `.UserDomainMask` by default.
       |  143|
       |  144|        - returns: A download file destination closure.
       |  145|    */
       |  146|    public class func suggestedDownloadDestination(
       |  147|        directory directory: NSSearchPathDirectory = .DocumentDirectory,
       |  148|        domain: NSSearchPathDomainMask = .UserDomainMask)
       |  149|        -> DownloadFileDestination
      0|  150|    {
      0|  151|        return { temporaryURL, response -> NSURL in
      0|  152|            let directoryURLs = NSFileManager.defaultManager().URLsForDirectory(directory, inDomains: domain)
      0|  153|
      0|  154|            if !directoryURLs.isEmpty {
      0|  155|                return directoryURLs[0].URLByAppendingPathComponent(response.suggestedFilename!)
      0|  156|            }
      0|  157|
      0|  158|            return temporaryURL
      0|  159|        }
      0|  160|    }
       |  161|
       |  162|    /// The resume data of the underlying download task if available after a failure.
      0|  163|    public var resumeData: NSData? {
      0|  164|        var data: NSData?
      0|  165|
      0|  166|        if let delegate = delegate as? DownloadTaskDelegate {
      0|  167|            data = delegate.resumeData
      0|  168|        }
      0|  169|
      0|  170|        return data
      0|  171|    }
       |  172|
       |  173|    // MARK: - DownloadTaskDelegate
       |  174|
       |  175|    class DownloadTaskDelegate: TaskDelegate, NSURLSessionDownloadDelegate {
      0|  176|        var downloadTask: NSURLSessionDownloadTask? { return task as? NSURLSessionDownloadTask }
       |  177|        var downloadProgress: ((Int64, Int64, Int64) -> Void)?
       |  178|
       |  179|        var resumeData: NSData?
      0|  180|        override var data: NSData? { return resumeData }
       |  181|
       |  182|        // MARK: - NSURLSessionDownloadDelegate
       |  183|
       |  184|        // MARK: Override Closures
       |  185|
       |  186|        var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> NSURL)?
       |  187|        var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  188|        var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  189|
       |  190|        // MARK: Delegate Methods
       |  191|
       |  192|        func URLSession(
       |  193|            session: NSURLSession,
       |  194|            downloadTask: NSURLSessionDownloadTask,
       |  195|            didFinishDownloadingToURL location: NSURL)
      0|  196|        {
      0|  197|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  198|                do {
      0|  199|                    let destination = downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  200|                    try NSFileManager.defaultManager().moveItemAtURL(location, toURL: destination)
      0|  201|                } catch {
      0|  202|                    self.error = error as NSError
      0|  203|                }
      0|  204|            }
      0|  205|        }
       |  206|
       |  207|        func URLSession(
       |  208|            session: NSURLSession,
       |  209|            downloadTask: NSURLSessionDownloadTask,
       |  210|            didWriteData bytesWritten: Int64,
       |  211|            totalBytesWritten: Int64,
       |  212|            totalBytesExpectedToWrite: Int64)
      0|  213|        {
      0|  214|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  215|                downloadTaskDidWriteData(
      0|  216|                    session,
      0|  217|                    downloadTask,
      0|  218|                    bytesWritten,
      0|  219|                    totalBytesWritten, 
      0|  220|                    totalBytesExpectedToWrite
      0|  221|                )
      0|  222|            } else {
      0|  223|                progress.totalUnitCount = totalBytesExpectedToWrite
      0|  224|                progress.completedUnitCount = totalBytesWritten
      0|  225|
      0|  226|                downloadProgress?(bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  227|            }
      0|  228|        }
       |  229|
       |  230|        func URLSession(
       |  231|            session: NSURLSession,
       |  232|            downloadTask: NSURLSessionDownloadTask,
       |  233|            didResumeAtOffset fileOffset: Int64,
       |  234|            expectedTotalBytes: Int64)
      0|  235|        {
      0|  236|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  237|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  238|            } else {
      0|  239|                progress.totalUnitCount = expectedTotalBytes
      0|  240|                progress.completedUnitCount = fileOffset
      0|  241|            }
      0|  242|        }
       |  243|    }
       |  244|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Error.swift:
       |    1|// Error.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// The `Error` struct provides a convenience for creating custom Alamofire NSErrors.
       |   26|public struct Error {
       |   27|    /// The domain used for creating all Alamofire errors.
       |   28|    public static let Domain = "com.alamofire.error"
       |   29|
       |   30|    /// The custom error codes generated by Alamofire.
       |   31|    public enum Code: Int {
       |   32|        case InputStreamReadFailed           = -6000
       |   33|        case OutputStreamWriteFailed         = -6001
       |   34|        case ContentTypeValidationFailed     = -6002
       |   35|        case StatusCodeValidationFailed      = -6003
       |   36|        case DataSerializationFailed         = -6004
       |   37|        case StringSerializationFailed       = -6005
       |   38|        case JSONSerializationFailed         = -6006
       |   39|        case PropertyListSerializationFailed = -6007
       |   40|    }
       |   41|
       |   42|    /**
       |   43|        Creates an `NSError` with the given error code and failure reason.
       |   44|
       |   45|        - parameter code:          The error code.
       |   46|        - parameter failureReason: The failure reason.
       |   47|
       |   48|        - returns: An `NSError` with the given error code and failure reason.
       |   49|    */
      0|   50|    public static func errorWithCode(code: Code, failureReason: String) -> NSError {
      0|   51|        return errorWithCode(code.rawValue, failureReason: failureReason)
      0|   52|    }
       |   53|
       |   54|    /**
       |   55|        Creates an `NSError` with the given error code and failure reason.
       |   56|
       |   57|        - parameter code:          The error code.
       |   58|        - parameter failureReason: The failure reason.
       |   59|
       |   60|        - returns: An `NSError` with the given error code and failure reason.
       |   61|    */
      0|   62|    public static func errorWithCode(code: Int, failureReason: String) -> NSError {
      0|   63|        let userInfo = [NSLocalizedFailureReasonErrorKey: failureReason]
      0|   64|        return NSError(domain: Domain, code: code, userInfo: userInfo)
      0|   65|    }
       |   66|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Manager.swift:
       |    1|// Manager.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for creating and managing `Request` objects, as well as their underlying `NSURLSession`.
       |   27|*/
       |   28|public class Manager {
       |   29|
       |   30|    // MARK: - Properties
       |   31|
       |   32|    /**
       |   33|        A shared instance of `Manager`, used by top-level Alamofire request methods, and suitable for use directly 
       |   34|        for any ad hoc requests.
       |   35|    */
       |   36|    public static let sharedInstance: Manager = {
       |   37|        let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
       |   38|        configuration.HTTPAdditionalHeaders = Manager.defaultHTTPHeaders
       |   39|
       |   40|        return Manager(configuration: configuration)
       |   41|    }()
       |   42|
       |   43|    /**
       |   44|        Creates default values for the "Accept-Encoding", "Accept-Language" and "User-Agent" headers.
       |   45|    */
       |   46|    public static let defaultHTTPHeaders: [String: String] = {
       |   47|        // Accept-Encoding HTTP Header; see https://tools.ietf.org/html/rfc7230#section-4.2.3
       |   48|        let acceptEncoding: String = "gzip;q=1.0,compress;q=0.5"
       |   49|
       |   50|        // Accept-Language HTTP Header; see https://tools.ietf.org/html/rfc7231#section-5.3.5
       |   51|        let acceptLanguage: String = {
       |   52|            var components: [String] = []
       |   53|            for (index, languageCode) in (NSLocale.preferredLanguages() as [String]).enumerate() {
       |   54|                let q = 1.0 - (Double(index) * 0.1)
       |   55|                components.append("\(languageCode);q=\(q)")
       |   56|                if q <= 0.5 {
       |   57|                    break
       |   58|                }
       |   59|            }
       |   60|
       |   61|            return components.joinWithSeparator(",")
       |   62|        }()
       |   63|
       |   64|        // User-Agent Header; see https://tools.ietf.org/html/rfc7231#section-5.5.3
       |   65|        let userAgent: String = {
       |   66|            if let info = NSBundle.mainBundle().infoDictionary {
       |   67|                let executable: AnyObject = info[kCFBundleExecutableKey as String] ?? "Unknown"
       |   68|                let bundle: AnyObject = info[kCFBundleIdentifierKey as String] ?? "Unknown"
       |   69|                let version: AnyObject = info[kCFBundleVersionKey as String] ?? "Unknown"
       |   70|                let os: AnyObject = NSProcessInfo.processInfo().operatingSystemVersionString ?? "Unknown"
       |   71|
       |   72|                var mutableUserAgent = NSMutableString(string: "\(executable)/\(bundle) (\(version); OS \(os))") as CFMutableString
       |   73|                let transform = NSString(string: "Any-Latin; Latin-ASCII; [:^ASCII:] Remove") as CFString
       |   74|
       |   75|                if CFStringTransform(mutableUserAgent, UnsafeMutablePointer<CFRange>(nil), transform, false) {
       |   76|                    return mutableUserAgent as String
       |   77|                }
       |   78|            }
       |   79|
       |   80|            return "Alamofire"
       |   81|        }()
       |   82|
       |   83|        return [
       |   84|            "Accept-Encoding": acceptEncoding,
       |   85|            "Accept-Language": acceptLanguage,
       |   86|            "User-Agent": userAgent
       |   87|        ]
       |   88|    }()
       |   89|
       |   90|    let queue = dispatch_queue_create(nil, DISPATCH_QUEUE_SERIAL)
       |   91|
       |   92|    /// The underlying session.
       |   93|    public let session: NSURLSession
       |   94|
       |   95|    /// The session delegate handling all the task and session delegate callbacks.
       |   96|    public let delegate: SessionDelegate
       |   97|
       |   98|    /// Whether to start requests immediately after being constructed. `true` by default.
       |   99|    public var startRequestsImmediately: Bool = true
       |  100|
       |  101|    /**
       |  102|        The background completion handler closure provided by the UIApplicationDelegate 
       |  103|        `application:handleEventsForBackgroundURLSession:completionHandler:` method. By setting the background 
       |  104|        completion handler, the SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` closure implementation 
       |  105|        will automatically call the handler.
       |  106|    
       |  107|        If you need to handle your own events before the handler is called, then you need to override the 
       |  108|        SessionDelegate `sessionDidFinishEventsForBackgroundURLSession` and manually call the handler when finished.
       |  109|    
       |  110|        `nil` by default.
       |  111|    */
       |  112|    public var backgroundCompletionHandler: (() -> Void)?
       |  113|
       |  114|    // MARK: - Lifecycle
       |  115|
       |  116|    /**
       |  117|        Initializes the `Manager` instance with the specified configuration, delegate and server trust policy.
       |  118|
       |  119|        - parameter configuration:            The configuration used to construct the managed session. 
       |  120|                                              `NSURLSessionConfiguration.defaultSessionConfiguration()` by default.
       |  121|        - parameter delegate:                 The delegate used when initializing the session. `SessionDelegate()` by
       |  122|                                              default.
       |  123|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust 
       |  124|                                              challenges. `nil` by default.
       |  125|
       |  126|        - returns: The new `Manager` instance.
       |  127|    */
       |  128|    public init(
       |  129|        configuration: NSURLSessionConfiguration = NSURLSessionConfiguration.defaultSessionConfiguration(),
       |  130|        delegate: SessionDelegate = SessionDelegate(),
       |  131|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      1|  132|    {
      1|  133|        self.delegate = delegate
      1|  134|        self.session = NSURLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)
      1|  135|
      1|  136|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      1|  137|    }
       |  138|
       |  139|    /**
       |  140|        Initializes the `Manager` instance with the specified session, delegate and server trust policy.
       |  141|
       |  142|        - parameter session:                  The URL session.
       |  143|        - parameter delegate:                 The delegate of the URL session. Must equal the URL session's delegate.
       |  144|        - parameter serverTrustPolicyManager: The server trust policy manager to use for evaluating all server trust
       |  145|                                              challenges. `nil` by default.
       |  146|
       |  147|        - returns: The new `Manager` instance if the URL session's delegate matches the delegate parameter.
       |  148|    */
       |  149|    public init?(
       |  150|        session: NSURLSession,
       |  151|        delegate: SessionDelegate,
       |  152|        serverTrustPolicyManager: ServerTrustPolicyManager? = nil)
      0|  153|    {
      0|  154|        self.delegate = delegate
      0|  155|        self.session = session
      0|  156|
      0|  157|        guard delegate === session.delegate else { return nil }
      0|  158|
      0|  159|        commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
      0|  160|    }
       |  161|
      1|  162|    private func commonInit(serverTrustPolicyManager serverTrustPolicyManager: ServerTrustPolicyManager?) {
      1|  163|        session.serverTrustPolicyManager = serverTrustPolicyManager
      1|  164|
      0|  165|        delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
      0|  166|            guard let strongSelf = self else { return }
      0|  167|            dispatch_async(dispatch_get_main_queue()) { strongSelf.backgroundCompletionHandler?() }
      0|  168|        }
      1|  169|    }
       |  170|
      0|  171|    deinit {
      0|  172|        session.invalidateAndCancel()
      0|  173|    }
       |  174|
       |  175|    // MARK: - Request
       |  176|
       |  177|    /**
       |  178|        Creates a request for the specified method, URL string, parameters, parameter encoding and headers.
       |  179|
       |  180|        - parameter method:     The HTTP method.
       |  181|        - parameter URLString:  The URL string.
       |  182|        - parameter parameters: The parameters. `nil` by default.
       |  183|        - parameter encoding:   The parameter encoding. `.URL` by default.
       |  184|        - parameter headers:    The HTTP headers. `nil` by default.
       |  185|
       |  186|        - returns: The created request.
       |  187|    */
       |  188|    public func request(
       |  189|        method: Method,
       |  190|        _ URLString: URLStringConvertible,
       |  191|        parameters: [String: AnyObject]? = nil,
       |  192|        encoding: ParameterEncoding = .URL,
       |  193|        headers: [String: String]? = nil)
       |  194|        -> Request
      1|  195|    {
      1|  196|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      1|  197|        let encodedURLRequest = encoding.encode(mutableURLRequest, parameters: parameters).0
      1|  198|        return request(encodedURLRequest)
      1|  199|    }
       |  200|
       |  201|    /**
       |  202|        Creates a request for the specified URL request.
       |  203|
       |  204|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  205|
       |  206|        - parameter URLRequest: The URL request
       |  207|
       |  208|        - returns: The created request.
       |  209|    */
      1|  210|    public func request(URLRequest: URLRequestConvertible) -> Request {
      1|  211|        var dataTask: NSURLSessionDataTask!
      1|  212|        dispatch_sync(queue) { dataTask = self.session.dataTaskWithRequest(URLRequest.URLRequest) }
      1|  213|
      1|  214|        let request = Request(session: session, task: dataTask)
      1|  215|        delegate[request.delegate.task] = request.delegate
      1|  216|
      1|  217|        if startRequestsImmediately {
      1|  218|            request.resume()
      1|  219|        }
      1|  220|
      1|  221|        return request
      1|  222|    }
       |  223|
       |  224|    // MARK: - SessionDelegate
       |  225|
       |  226|    /**
       |  227|        Responsible for handling all delegate callbacks for the underlying session.
       |  228|    */
       |  229|    public final class SessionDelegate: NSObject, NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate {
       |  230|        private var subdelegates: [Int: Request.TaskDelegate] = [:]
       |  231|        private let subdelegateQueue = dispatch_queue_create(nil, DISPATCH_QUEUE_CONCURRENT)
       |  232|
       |  233|        subscript(task: NSURLSessionTask) -> Request.TaskDelegate? {
      4|  234|            get {
      4|  235|                var subdelegate: Request.TaskDelegate?
      4|  236|                dispatch_sync(subdelegateQueue) { subdelegate = self.subdelegates[task.taskIdentifier] }
      4|  237|
      4|  238|                return subdelegate
      4|  239|            }
       |  240|
      2|  241|            set {
      2|  242|                dispatch_barrier_async(subdelegateQueue) { self.subdelegates[task.taskIdentifier] = newValue }
      2|  243|            }
       |  244|        }
       |  245|
       |  246|        /**
       |  247|            Initializes the `SessionDelegate` instance.
       |  248|
       |  249|            - returns: The new `SessionDelegate` instance.
       |  250|        */
      1|  251|        public override init() {
      1|  252|            super.init()
      1|  253|        }
       |  254|
       |  255|        // MARK: - NSURLSessionDelegate
       |  256|
       |  257|        // MARK: Override Closures
       |  258|
       |  259|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didBecomeInvalidWithError:`.
       |  260|        public var sessionDidBecomeInvalidWithError: ((NSURLSession, NSError?) -> Void)?
       |  261|
       |  262|        /// Overrides default behavior for NSURLSessionDelegate method `URLSession:didReceiveChallenge:completionHandler:`.
       |  263|        public var sessionDidReceiveChallenge: ((NSURLSession, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  264|
       |  265|        /// Overrides default behavior for NSURLSessionDelegate method `URLSessionDidFinishEventsForBackgroundURLSession:`.
       |  266|        public var sessionDidFinishEventsForBackgroundURLSession: ((NSURLSession) -> Void)?
       |  267|
       |  268|        // MARK: Delegate Methods
       |  269|
       |  270|        /**
       |  271|            Tells the delegate that the session has been invalidated.
       |  272|
       |  273|            - parameter session: The session object that was invalidated.
       |  274|            - parameter error:   The error that caused invalidation, or nil if the invalidation was explicit.
       |  275|        */
      0|  276|        public func URLSession(session: NSURLSession, didBecomeInvalidWithError error: NSError?) {
      0|  277|            sessionDidBecomeInvalidWithError?(session, error)
      0|  278|        }
       |  279|
       |  280|        /**
       |  281|            Requests credentials from the delegate in response to a session-level authentication request from the remote server.
       |  282|
       |  283|            - parameter session:           The session containing the task that requested authentication.
       |  284|            - parameter challenge:         An object that contains the request for authentication.
       |  285|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  286|        */
       |  287|        public func URLSession(
       |  288|            session: NSURLSession,
       |  289|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  290|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      0|  291|        {
      0|  292|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      0|  293|            var credential: NSURLCredential?
      0|  294|
      0|  295|            if let sessionDidReceiveChallenge = sessionDidReceiveChallenge {
      0|  296|                (disposition, credential) = sessionDidReceiveChallenge(session, challenge)
      0|  297|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      0|  298|                let host = challenge.protectionSpace.host
      0|  299|
      0|  300|                if let
      0|  301|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      0|  302|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  303|                {
      0|  304|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  305|                        disposition = .UseCredential
      0|  306|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  307|                    } else {
      0|  308|                        disposition = .CancelAuthenticationChallenge
      0|  309|                    }
      0|  310|                }
      0|  311|            }
      0|  312|
      0|  313|            completionHandler(disposition, credential)
      0|  314|        }
       |  315|
       |  316|        /**
       |  317|            Tells the delegate that all messages enqueued for a session have been delivered.
       |  318|
       |  319|            - parameter session: The session that no longer has any outstanding requests.
       |  320|        */
      0|  321|        public func URLSessionDidFinishEventsForBackgroundURLSession(session: NSURLSession) {
      0|  322|            sessionDidFinishEventsForBackgroundURLSession?(session)
      0|  323|        }
       |  324|
       |  325|        // MARK: - NSURLSessionTaskDelegate
       |  326|
       |  327|        // MARK: Override Closures
       |  328|
       |  329|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:`.
       |  330|        public var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  331|
       |  332|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didReceiveChallenge:completionHandler:`.
       |  333|        public var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  334|
       |  335|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:session:task:needNewBodyStream:`.
       |  336|        public var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream!)?
       |  337|
       |  338|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`.
       |  339|        public var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  340|
       |  341|        /// Overrides default behavior for NSURLSessionTaskDelegate method `URLSession:task:didCompleteWithError:`.
       |  342|        public var taskDidComplete: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  343|
       |  344|        // MARK: Delegate Methods
       |  345|
       |  346|        /**
       |  347|            Tells the delegate that the remote server requested an HTTP redirect.
       |  348|
       |  349|            - parameter session:           The session containing the task whose request resulted in a redirect.
       |  350|            - parameter task:              The task whose request resulted in a redirect.
       |  351|            - parameter response:          An object containing the server’s response to the original request.
       |  352|            - parameter request:           A URL request object filled out with the new location.
       |  353|            - parameter completionHandler: A closure that your handler should call with either the value of the request 
       |  354|                                           parameter, a modified URL request object, or NULL to refuse the redirect and 
       |  355|                                           return the body of the redirect response.
       |  356|        */
       |  357|        public func URLSession(
       |  358|            session: NSURLSession,
       |  359|            task: NSURLSessionTask,
       |  360|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  361|            newRequest request: NSURLRequest,
       |  362|            completionHandler: ((NSURLRequest?) -> Void))
      0|  363|        {
      0|  364|            var redirectRequest: NSURLRequest? = request
      0|  365|
      0|  366|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  367|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  368|            }
      0|  369|
      0|  370|            completionHandler(redirectRequest)
      0|  371|        }
       |  372|
       |  373|        /**
       |  374|            Requests credentials from the delegate in response to an authentication request from the remote server.
       |  375|
       |  376|            - parameter session:           The session containing the task whose request requires authentication.
       |  377|            - parameter task:              The task whose request requires authentication.
       |  378|            - parameter challenge:         An object that contains the request for authentication.
       |  379|            - parameter completionHandler: A handler that your delegate method must call providing the disposition and credential.
       |  380|        */
       |  381|        public func URLSession(
       |  382|            session: NSURLSession,
       |  383|            task: NSURLSessionTask,
       |  384|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  385|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  386|        {
      0|  387|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  388|                completionHandler(taskDidReceiveChallenge(session, task, challenge))
      1|  389|            } else if let delegate = self[task] {
      1|  390|                delegate.URLSession(
      1|  391|                    session,
      1|  392|                    task: task,
      1|  393|                    didReceiveChallenge: challenge,
      1|  394|                    completionHandler: completionHandler
      1|  395|                )
      0|  396|            } else {
      0|  397|                URLSession(session, didReceiveChallenge: challenge, completionHandler: completionHandler)
      0|  398|            }
      1|  399|        }
       |  400|
       |  401|        /**
       |  402|            Tells the delegate when a task requires a new request body stream to send to the remote server.
       |  403|
       |  404|            - parameter session:           The session containing the task that needs a new body stream.
       |  405|            - parameter task:              The task that needs a new body stream.
       |  406|            - parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
       |  407|        */
       |  408|        public func URLSession(
       |  409|            session: NSURLSession,
       |  410|            task: NSURLSessionTask,
       |  411|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  412|        {
      0|  413|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  414|                completionHandler(taskNeedNewBodyStream(session, task))
      0|  415|            } else if let delegate = self[task] {
      0|  416|                delegate.URLSession(session, task: task, needNewBodyStream: completionHandler)
      0|  417|            }
      0|  418|        }
       |  419|
       |  420|        /**
       |  421|            Periodically informs the delegate of the progress of sending body content to the server.
       |  422|
       |  423|            - parameter session:                  The session containing the data task.
       |  424|            - parameter task:                     The data task.
       |  425|            - parameter bytesSent:                The number of bytes sent since the last time this delegate method was called.
       |  426|            - parameter totalBytesSent:           The total number of bytes sent so far.
       |  427|            - parameter totalBytesExpectedToSend: The expected length of the body data.
       |  428|        */
       |  429|        public func URLSession(
       |  430|            session: NSURLSession,
       |  431|            task: NSURLSessionTask,
       |  432|            didSendBodyData bytesSent: Int64,
       |  433|            totalBytesSent: Int64,
       |  434|            totalBytesExpectedToSend: Int64)
      1|  435|        {
      0|  436|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  437|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  438|            } else if let delegate = self[task] as? Request.UploadTaskDelegate {
      0|  439|                delegate.URLSession(
      0|  440|                    session,
      0|  441|                    task: task,
      0|  442|                    didSendBodyData: bytesSent,
      0|  443|                    totalBytesSent: totalBytesSent,
      0|  444|                    totalBytesExpectedToSend: totalBytesExpectedToSend
      0|  445|                )
      0|  446|            }
      1|  447|        }
       |  448|
       |  449|        /**
       |  450|            Tells the delegate that the task finished transferring data.
       |  451|
       |  452|            - parameter session: The session containing the task whose request finished transferring data.
       |  453|            - parameter task:    The task whose request finished transferring data.
       |  454|            - parameter error:   If an error occurred, an error object indicating how the transfer failed, otherwise nil.
       |  455|        */
      1|  456|        public func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  457|            if let taskDidComplete = taskDidComplete {
      0|  458|                taskDidComplete(session, task, error)
      1|  459|            } else if let delegate = self[task] {
      1|  460|                delegate.URLSession(session, task: task, didCompleteWithError: error)
      1|  461|            }
      1|  462|
      1|  463|            self[task] = nil
      1|  464|        }
       |  465|
       |  466|        // MARK: - NSURLSessionDataDelegate
       |  467|
       |  468|        // MARK: Override Closures
       |  469|
       |  470|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveResponse:completionHandler:`.
       |  471|        public var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  472|
       |  473|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didBecomeDownloadTask:`.
       |  474|        public var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  475|
       |  476|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:didReceiveData:`.
       |  477|        public var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  478|
       |  479|        /// Overrides default behavior for NSURLSessionDataDelegate method `URLSession:dataTask:willCacheResponse:completionHandler:`.
       |  480|        public var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse!)?
       |  481|
       |  482|        // MARK: Delegate Methods
       |  483|
       |  484|        /**
       |  485|            Tells the delegate that the data task received the initial reply (headers) from the server.
       |  486|
       |  487|            - parameter session:           The session containing the data task that received an initial reply.
       |  488|            - parameter dataTask:          The data task that received an initial reply.
       |  489|            - parameter response:          A URL response object populated with headers.
       |  490|            - parameter completionHandler: A completion handler that your code calls to continue the transfer, passing a 
       |  491|                                           constant to indicate whether the transfer should continue as a data task or 
       |  492|                                           should become a download task.
       |  493|        */
       |  494|        public func URLSession(
       |  495|            session: NSURLSession,
       |  496|            dataTask: NSURLSessionDataTask,
       |  497|            didReceiveResponse response: NSURLResponse,
       |  498|            completionHandler: ((NSURLSessionResponseDisposition) -> Void))
      0|  499|        {
      0|  500|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  501|
      0|  502|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  503|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  504|            }
      0|  505|
      0|  506|            completionHandler(disposition)
      0|  507|        }
       |  508|
       |  509|        /**
       |  510|            Tells the delegate that the data task was changed to a download task.
       |  511|
       |  512|            - parameter session:      The session containing the task that was replaced by a download task.
       |  513|            - parameter dataTask:     The data task that was replaced by a download task.
       |  514|            - parameter downloadTask: The new download task that replaced the data task.
       |  515|        */
       |  516|        public func URLSession(
       |  517|            session: NSURLSession,
       |  518|            dataTask: NSURLSessionDataTask,
       |  519|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  520|        {
      0|  521|            if let dataTaskDidBecomeDownloadTask = dataTaskDidBecomeDownloadTask {
      0|  522|                dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask)
      0|  523|            } else {
      0|  524|                let downloadDelegate = Request.DownloadTaskDelegate(task: downloadTask)
      0|  525|                self[downloadTask] = downloadDelegate
      0|  526|            }
      0|  527|        }
       |  528|
       |  529|        /**
       |  530|            Tells the delegate that the data task has received some of the expected data.
       |  531|
       |  532|            - parameter session:  The session containing the data task that provided data.
       |  533|            - parameter dataTask: The data task that provided data.
       |  534|            - parameter data:     A data object containing the transferred data.
       |  535|        */
      1|  536|        public func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  537|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  538|                dataTaskDidReceiveData(session, dataTask, data)
      1|  539|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      1|  540|                delegate.URLSession(session, dataTask: dataTask, didReceiveData: data)
      1|  541|            }
      1|  542|        }
       |  543|
       |  544|        /**
       |  545|            Asks the delegate whether the data (or upload) task should store the response in the cache.
       |  546|
       |  547|            - parameter session:           The session containing the data (or upload) task.
       |  548|            - parameter dataTask:          The data (or upload) task.
       |  549|            - parameter proposedResponse:  The default caching behavior. This behavior is determined based on the current 
       |  550|                                           caching policy and the values of certain received headers, such as the Pragma 
       |  551|                                           and Cache-Control headers.
       |  552|            - parameter completionHandler: A block that your handler must call, providing either the original proposed 
       |  553|                                           response, a modified version of that response, or NULL to prevent caching the 
       |  554|                                           response. If your delegate implements this method, it must call this completion 
       |  555|                                           handler; otherwise, your app leaks memory.
       |  556|        */
       |  557|        public func URLSession(
       |  558|            session: NSURLSession,
       |  559|            dataTask: NSURLSessionDataTask,
       |  560|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  561|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  562|        {
      0|  563|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  564|                completionHandler(dataTaskWillCacheResponse(session, dataTask, proposedResponse))
      0|  565|            } else if let delegate = self[dataTask] as? Request.DataTaskDelegate {
      0|  566|                delegate.URLSession(
      0|  567|                    session,
      0|  568|                    dataTask: dataTask,
      0|  569|                    willCacheResponse: proposedResponse,
      0|  570|                    completionHandler: completionHandler
      0|  571|                )
      0|  572|            } else {
      0|  573|                completionHandler(proposedResponse)
      0|  574|            }
      0|  575|        }
       |  576|
       |  577|        // MARK: - NSURLSessionDownloadDelegate
       |  578|
       |  579|        // MARK: Override Closures
       |  580|
       |  581|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didFinishDownloadingToURL:`.
       |  582|        public var downloadTaskDidFinishDownloadingToURL: ((NSURLSession, NSURLSessionDownloadTask, NSURL) -> Void)?
       |  583|
       |  584|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`.
       |  585|        public var downloadTaskDidWriteData: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64, Int64) -> Void)?
       |  586|
       |  587|        /// Overrides default behavior for NSURLSessionDownloadDelegate method `URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:`.
       |  588|        public var downloadTaskDidResumeAtOffset: ((NSURLSession, NSURLSessionDownloadTask, Int64, Int64) -> Void)?
       |  589|
       |  590|        // MARK: Delegate Methods
       |  591|
       |  592|        /**
       |  593|            Tells the delegate that a download task has finished downloading.
       |  594|
       |  595|            - parameter session:      The session containing the download task that finished.
       |  596|            - parameter downloadTask: The download task that finished.
       |  597|            - parameter location:     A file URL for the temporary file. Because the file is temporary, you must either 
       |  598|                                      open the file for reading or move it to a permanent location in your app’s sandbox 
       |  599|                                      container directory before returning from this delegate method.
       |  600|        */
       |  601|        public func URLSession(
       |  602|            session: NSURLSession,
       |  603|            downloadTask: NSURLSessionDownloadTask,
       |  604|            didFinishDownloadingToURL location: NSURL)
      0|  605|        {
      0|  606|            if let downloadTaskDidFinishDownloadingToURL = downloadTaskDidFinishDownloadingToURL {
      0|  607|                downloadTaskDidFinishDownloadingToURL(session, downloadTask, location)
      0|  608|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  609|                delegate.URLSession(session, downloadTask: downloadTask, didFinishDownloadingToURL: location)
      0|  610|            }
      0|  611|        }
       |  612|
       |  613|        /**
       |  614|            Periodically informs the delegate about the download’s progress.
       |  615|
       |  616|            - parameter session:                   The session containing the download task.
       |  617|            - parameter downloadTask:              The download task.
       |  618|            - parameter bytesWritten:              The number of bytes transferred since the last time this delegate 
       |  619|                                                   method was called.
       |  620|            - parameter totalBytesWritten:         The total number of bytes transferred so far.
       |  621|            - parameter totalBytesExpectedToWrite: The expected length of the file, as provided by the Content-Length 
       |  622|                                                   header. If this header was not provided, the value is 
       |  623|                                                   `NSURLSessionTransferSizeUnknown`.
       |  624|        */
       |  625|        public func URLSession(
       |  626|            session: NSURLSession,
       |  627|            downloadTask: NSURLSessionDownloadTask,
       |  628|            didWriteData bytesWritten: Int64,
       |  629|            totalBytesWritten: Int64,
       |  630|            totalBytesExpectedToWrite: Int64)
      0|  631|        {
      0|  632|            if let downloadTaskDidWriteData = downloadTaskDidWriteData {
      0|  633|                downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite)
      0|  634|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  635|                delegate.URLSession(
      0|  636|                    session,
      0|  637|                    downloadTask: downloadTask,
      0|  638|                    didWriteData: bytesWritten,
      0|  639|                    totalBytesWritten: totalBytesWritten,
      0|  640|                    totalBytesExpectedToWrite: totalBytesExpectedToWrite
      0|  641|                )
      0|  642|            }
      0|  643|        }
       |  644|
       |  645|        /**
       |  646|            Tells the delegate that the download task has resumed downloading.
       |  647|
       |  648|            - parameter session:            The session containing the download task that finished.
       |  649|            - parameter downloadTask:       The download task that resumed. See explanation in the discussion.
       |  650|            - parameter fileOffset:         If the file's cache policy or last modified date prevents reuse of the 
       |  651|                                            existing content, then this value is zero. Otherwise, this value is an 
       |  652|                                            integer representing the number of bytes on disk that do not need to be 
       |  653|                                            retrieved again.
       |  654|            - parameter expectedTotalBytes: The expected length of the file, as provided by the Content-Length header. 
       |  655|                                            If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
       |  656|        */
       |  657|        public func URLSession(
       |  658|            session: NSURLSession,
       |  659|            downloadTask: NSURLSessionDownloadTask,
       |  660|            didResumeAtOffset fileOffset: Int64,
       |  661|            expectedTotalBytes: Int64)
      0|  662|        {
      0|  663|            if let downloadTaskDidResumeAtOffset = downloadTaskDidResumeAtOffset {
      0|  664|                downloadTaskDidResumeAtOffset(session, downloadTask, fileOffset, expectedTotalBytes)
      0|  665|            } else if let delegate = self[downloadTask] as? Request.DownloadTaskDelegate {
      0|  666|                delegate.URLSession(
      0|  667|                    session,
      0|  668|                    downloadTask: downloadTask,
      0|  669|                    didResumeAtOffset: fileOffset,
      0|  670|                    expectedTotalBytes: expectedTotalBytes
      0|  671|                )
      0|  672|            }
      0|  673|        }
       |  674|
       |  675|        // MARK: - NSURLSessionStreamDelegate
       |  676|
       |  677|        var _streamTaskReadClosed: Any?
       |  678|        var _streamTaskWriteClosed: Any?
       |  679|        var _streamTaskBetterRouteDiscovered: Any?
       |  680|        var _streamTaskDidBecomeInputStream: Any?
       |  681|
       |  682|        // MARK: - NSObject
       |  683|
     11|  684|        public override func respondsToSelector(selector: Selector) -> Bool {
     11|  685|            switch selector {
      0|  686|            case "URLSession:didBecomeInvalidWithError:":
      0|  687|                return sessionDidBecomeInvalidWithError != nil
      1|  688|            case "URLSession:didReceiveChallenge:completionHandler:":
      1|  689|                return sessionDidReceiveChallenge != nil
      0|  690|            case "URLSessionDidFinishEventsForBackgroundURLSession:":
      0|  691|                return sessionDidFinishEventsForBackgroundURLSession != nil
      0|  692|            case "URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:":
      0|  693|                return taskWillPerformHTTPRedirection != nil
      1|  694|            case "URLSession:dataTask:didReceiveResponse:completionHandler:":
      1|  695|                return dataTaskDidReceiveResponse != nil
      9|  696|            default:
      9|  697|                return self.dynamicType.instancesRespondToSelector(selector)
     11|  698|            }
     11|  699|        }
       |  700|    }
       |  701|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/MultipartFormData.swift:
       |    1|// MultipartFormData.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if os(iOS) || os(watchOS) || os(tvOS)
       |   26|import MobileCoreServices
       |   27|#elseif os(OSX)
       |   28|import CoreServices
       |   29|#endif
       |   30|
       |   31|/**
       |   32|    Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body. There are currently two ways to encode 
       |   33|    multipart form data. The first way is to encode the data directly in memory. This is very efficient, but can lead 
       |   34|    to memory issues if the dataset is too large. The second way is designed for larger datasets and will write all the 
       |   35|    data to a single file on disk with all the proper boundary segmentation. The second approach MUST be used for 
       |   36|    larger datasets such as video content, otherwise your app may run out of memory when trying to encode the dataset.
       |   37|
       |   38|    For more information on `multipart/form-data` in general, please refer to the RFC-2388 and RFC-2045 specs as well
       |   39|    and the w3 form documentation.
       |   40|
       |   41|    - https://www.ietf.org/rfc/rfc2388.txt
       |   42|    - https://www.ietf.org/rfc/rfc2045.txt
       |   43|    - https://www.w3.org/TR/html401/interact/forms.html#h-17.13
       |   44|*/
       |   45|public class MultipartFormData {
       |   46|
       |   47|    // MARK: - Helper Types
       |   48|
       |   49|    struct EncodingCharacters {
       |   50|        static let CRLF = "\r\n"
       |   51|    }
       |   52|
       |   53|    struct BoundaryGenerator {
       |   54|        enum BoundaryType {
       |   55|            case Initial, Encapsulated, Final
       |   56|        }
       |   57|
      0|   58|        static func randomBoundary() -> String {
      0|   59|            return String(format: "alamofire.boundary.%08x%08x", arc4random(), arc4random())
      0|   60|        }
       |   61|
      0|   62|        static func boundaryData(boundaryType boundaryType: BoundaryType, boundary: String) -> NSData {
      0|   63|            let boundaryText: String
      0|   64|
      0|   65|            switch boundaryType {
      0|   66|            case .Initial:
      0|   67|                boundaryText = "--\(boundary)\(EncodingCharacters.CRLF)"
      0|   68|            case .Encapsulated:
      0|   69|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)\(EncodingCharacters.CRLF)"
      0|   70|            case .Final:
      0|   71|                boundaryText = "\(EncodingCharacters.CRLF)--\(boundary)--\(EncodingCharacters.CRLF)"
      0|   72|            }
      0|   73|
      0|   74|            return boundaryText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|   75|        }
       |   76|    }
       |   77|
       |   78|    class BodyPart {
       |   79|        let headers: [String: String]
       |   80|        let bodyStream: NSInputStream
       |   81|        let bodyContentLength: UInt64
       |   82|        var hasInitialBoundary = false
       |   83|        var hasFinalBoundary = false
       |   84|
      0|   85|        init(headers: [String: String], bodyStream: NSInputStream, bodyContentLength: UInt64) {
      0|   86|            self.headers = headers
      0|   87|            self.bodyStream = bodyStream
      0|   88|            self.bodyContentLength = bodyContentLength
      0|   89|        }
       |   90|    }
       |   91|
       |   92|    // MARK: - Properties
       |   93|
       |   94|    /// The `Content-Type` header value containing the boundary used to generate the `multipart/form-data`.
      0|   95|    public var contentType: String { return "multipart/form-data; boundary=\(boundary)" }
       |   96|
       |   97|    /// The content length of all body parts used to generate the `multipart/form-data` not including the boundaries.
      0|   98|    public var contentLength: UInt64 { return bodyParts.reduce(0) { $0 + $1.bodyContentLength } }
       |   99|
       |  100|    /// The boundary used to separate the body parts in the encoded form data.
       |  101|    public let boundary: String
       |  102|
       |  103|    private var bodyParts: [BodyPart]
       |  104|    private var bodyPartError: NSError?
       |  105|    private let streamBufferSize: Int
       |  106|
       |  107|    // MARK: - Lifecycle
       |  108|
       |  109|    /**
       |  110|        Creates a multipart form data object.
       |  111|
       |  112|        - returns: The multipart form data object.
       |  113|    */
      0|  114|    public init() {
      0|  115|        self.boundary = BoundaryGenerator.randomBoundary()
      0|  116|        self.bodyParts = []
      0|  117|
      0|  118|        /**
      0|  119|         *  The optimal read/write buffer size in bytes for input and output streams is 1024 (1KB). For more 
      0|  120|         *  information, please refer to the following article:
      0|  121|         *    - https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Streams/Articles/ReadingInputStreams.html
      0|  122|         */
      0|  123|
      0|  124|        self.streamBufferSize = 1024
      0|  125|    }
       |  126|
       |  127|    // MARK: - Body Parts
       |  128|
       |  129|    /**
       |  130|        Creates a body part from the data and appends it to the multipart form data object.
       |  131|
       |  132|        The body part data will be encoded using the following format:
       |  133|
       |  134|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  135|        - Encoded data
       |  136|        - Multipart form boundary
       |  137|
       |  138|        - parameter data: The data to encode into the multipart form data.
       |  139|        - parameter name: The name to associate with the data in the `Content-Disposition` HTTP header.
       |  140|    */
      0|  141|    public func appendBodyPart(data data: NSData, name: String) {
      0|  142|        let headers = contentHeaders(name: name)
      0|  143|        let stream = NSInputStream(data: data)
      0|  144|        let length = UInt64(data.length)
      0|  145|
      0|  146|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  147|    }
       |  148|
       |  149|    /**
       |  150|        Creates a body part from the data and appends it to the multipart form data object.
       |  151|
       |  152|        The body part data will be encoded using the following format:
       |  153|
       |  154|        - `Content-Disposition: form-data; name=#{name}` (HTTP Header)
       |  155|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  156|        - Encoded data
       |  157|        - Multipart form boundary
       |  158|
       |  159|        - parameter data:     The data to encode into the multipart form data.
       |  160|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  161|        - parameter mimeType: The MIME type to associate with the data content type in the `Content-Type` HTTP header.
       |  162|    */
      0|  163|    public func appendBodyPart(data data: NSData, name: String, mimeType: String) {
      0|  164|        let headers = contentHeaders(name: name, mimeType: mimeType)
      0|  165|        let stream = NSInputStream(data: data)
      0|  166|        let length = UInt64(data.length)
      0|  167|
      0|  168|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  169|    }
       |  170|
       |  171|    /**
       |  172|        Creates a body part from the data and appends it to the multipart form data object.
       |  173|
       |  174|        The body part data will be encoded using the following format:
       |  175|
       |  176|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  177|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  178|        - Encoded file data
       |  179|        - Multipart form boundary
       |  180|
       |  181|        - parameter data:     The data to encode into the multipart form data.
       |  182|        - parameter name:     The name to associate with the data in the `Content-Disposition` HTTP header.
       |  183|        - parameter fileName: The filename to associate with the data in the `Content-Disposition` HTTP header.
       |  184|        - parameter mimeType: The MIME type to associate with the data in the `Content-Type` HTTP header.
       |  185|    */
      0|  186|    public func appendBodyPart(data data: NSData, name: String, fileName: String, mimeType: String) {
      0|  187|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  188|        let stream = NSInputStream(data: data)
      0|  189|        let length = UInt64(data.length)
      0|  190|
      0|  191|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Creates a body part from the file and appends it to the multipart form data object.
       |  196|
       |  197|        The body part data will be encoded using the following format:
       |  198|
       |  199|        - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTP Header)
       |  200|        - `Content-Type: #{generated mimeType}` (HTTP Header)
       |  201|        - Encoded file data
       |  202|        - Multipart form boundary
       |  203|
       |  204|        The filename in the `Content-Disposition` HTTP header is generated from the last path component of the
       |  205|        `fileURL`. The `Content-Type` HTTP header MIME type is generated by mapping the `fileURL` extension to the
       |  206|        system associated MIME type.
       |  207|
       |  208|        - parameter fileURL: The URL of the file whose content will be encoded into the multipart form data.
       |  209|        - parameter name:    The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  210|    */
      0|  211|    public func appendBodyPart(fileURL fileURL: NSURL, name: String) {
      0|  212|        if let
      0|  213|            fileName = fileURL.lastPathComponent,
      0|  214|            pathExtension = fileURL.pathExtension
      0|  215|        {
      0|  216|            let mimeType = mimeTypeForPathExtension(pathExtension)
      0|  217|            appendBodyPart(fileURL: fileURL, name: name, fileName: fileName, mimeType: mimeType)
      0|  218|        } else {
      0|  219|            let failureReason = "Failed to extract the fileName of the provided URL: \(fileURL)"
      0|  220|            setBodyPartError(Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason))
      0|  221|        }
      0|  222|    }
       |  223|
       |  224|    /**
       |  225|        Creates a body part from the file and appends it to the multipart form data object.
       |  226|
       |  227|        The body part data will be encoded using the following format:
       |  228|
       |  229|        - Content-Disposition: form-data; name=#{name}; filename=#{filename} (HTTP Header)
       |  230|        - Content-Type: #{mimeType} (HTTP Header)
       |  231|        - Encoded file data
       |  232|        - Multipart form boundary
       |  233|
       |  234|        - parameter fileURL:  The URL of the file whose content will be encoded into the multipart form data.
       |  235|        - parameter name:     The name to associate with the file content in the `Content-Disposition` HTTP header.
       |  236|        - parameter fileName: The filename to associate with the file content in the `Content-Disposition` HTTP header.
       |  237|        - parameter mimeType: The MIME type to associate with the file content in the `Content-Type` HTTP header.
       |  238|    */
      0|  239|    public func appendBodyPart(fileURL fileURL: NSURL, name: String, fileName: String, mimeType: String) {
      0|  240|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  241|
      0|  242|        //============================================================
      0|  243|        //                 Check 1 - is file URL?
      0|  244|        //============================================================
      0|  245|
      0|  246|        guard fileURL.fileURL else {
      0|  247|            let failureReason = "The file URL does not point to a file URL: \(fileURL)"
      0|  248|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  249|            setBodyPartError(error)
      0|  250|            return
      0|  251|        }
      0|  252|
      0|  253|        //============================================================
      0|  254|        //              Check 2 - is file URL reachable?
      0|  255|        //============================================================
      0|  256|
      0|  257|        var isReachable = true
      0|  258|
      0|  259|        if #available(OSX 10.10, *) {
      0|  260|            isReachable = fileURL.checkPromisedItemIsReachableAndReturnError(nil)
      0|  261|        }
      0|  262|
      0|  263|        guard isReachable else {
      0|  264|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: "The file URL is not reachable: \(fileURL)")
      0|  265|            setBodyPartError(error)
      0|  266|            return
      0|  267|        }
      0|  268|
      0|  269|        //============================================================
      0|  270|        //            Check 3 - is file URL a directory?
      0|  271|        //============================================================
      0|  272|
      0|  273|        var isDirectory: ObjCBool = false
      0|  274|
      0|  275|        guard let
      0|  276|            path = fileURL.path
      0|  277|            where NSFileManager.defaultManager().fileExistsAtPath(path, isDirectory: &isDirectory) && !isDirectory else
      0|  278|        {
      0|  279|            let failureReason = "The file URL is a directory, not a file: \(fileURL)"
      0|  280|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  281|            setBodyPartError(error)
      0|  282|            return
      0|  283|        }
      0|  284|
      0|  285|        //============================================================
      0|  286|        //          Check 4 - can the file size be extracted?
      0|  287|        //============================================================
      0|  288|
      0|  289|        var bodyContentLength: UInt64?
      0|  290|
      0|  291|        do {
      0|  292|            if let
      0|  293|                path = fileURL.path,
      0|  294|                fileSize = try NSFileManager.defaultManager().attributesOfItemAtPath(path)[NSFileSize] as? NSNumber
      0|  295|            {
      0|  296|                bodyContentLength = fileSize.unsignedLongLongValue
      0|  297|            }
      0|  298|        } catch {
      0|  299|            // No-op
      0|  300|        }
      0|  301|
      0|  302|        guard let length = bodyContentLength else {
      0|  303|            let failureReason = "Could not fetch attributes from the file URL: \(fileURL)"
      0|  304|            let error = Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  305|            setBodyPartError(error)
      0|  306|            return
      0|  307|        }
      0|  308|
      0|  309|        //============================================================
      0|  310|        //       Check 5 - can a stream be created from file URL?
      0|  311|        //============================================================
      0|  312|
      0|  313|        guard let stream = NSInputStream(URL: fileURL) else {
      0|  314|            let failureReason = "Failed to create an input stream from the file URL: \(fileURL)"
      0|  315|            let error = Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  316|            setBodyPartError(error)
      0|  317|            return
      0|  318|        }
      0|  319|
      0|  320|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  321|    }
       |  322|
       |  323|    /**
       |  324|        Creates a body part from the stream and appends it to the multipart form data object.
       |  325|
       |  326|        The body part data will be encoded using the following format:
       |  327|
       |  328|        - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTP Header)
       |  329|        - `Content-Type: #{mimeType}` (HTTP Header)
       |  330|        - Encoded stream data
       |  331|        - Multipart form boundary
       |  332|
       |  333|        - parameter stream:   The input stream to encode in the multipart form data.
       |  334|        - parameter length:   The content length of the stream.
       |  335|        - parameter name:     The name to associate with the stream content in the `Content-Disposition` HTTP header.
       |  336|        - parameter fileName: The filename to associate with the stream content in the `Content-Disposition` HTTP header.
       |  337|        - parameter mimeType: The MIME type to associate with the stream content in the `Content-Type` HTTP header.
       |  338|    */
       |  339|    public func appendBodyPart(
       |  340|        stream stream: NSInputStream,
       |  341|        length: UInt64,
       |  342|        name: String,
       |  343|        fileName: String,
       |  344|        mimeType: String)
      0|  345|    {
      0|  346|        let headers = contentHeaders(name: name, fileName: fileName, mimeType: mimeType)
      0|  347|        appendBodyPart(stream: stream, length: length, headers: headers)
      0|  348|    }
       |  349|
       |  350|    /**
       |  351|        Creates a body part with the headers, stream and length and appends it to the multipart form data object.
       |  352|
       |  353|        The body part data will be encoded using the following format:
       |  354|
       |  355|        - HTTP headers
       |  356|        - Encoded stream data
       |  357|        - Multipart form boundary
       |  358|
       |  359|        - parameter stream:  The input stream to encode in the multipart form data.
       |  360|        - parameter length:  The content length of the stream.
       |  361|        - parameter headers: The HTTP headers for the body part.
       |  362|    */
      0|  363|    public func appendBodyPart(stream stream: NSInputStream, length: UInt64, headers: [String: String]) {
      0|  364|        let bodyPart = BodyPart(headers: headers, bodyStream: stream, bodyContentLength: length)
      0|  365|        bodyParts.append(bodyPart)
      0|  366|    }
       |  367|
       |  368|    // MARK: - Data Encoding
       |  369|
       |  370|    /**
       |  371|        Encodes all the appended body parts into a single `NSData` object.
       |  372|
       |  373|        It is important to note that this method will load all the appended body parts into memory all at the same 
       |  374|        time. This method should only be used when the encoded data will have a small memory footprint. For large data 
       |  375|        cases, please use the `writeEncodedDataToDisk(fileURL:completionHandler:)` method.
       |  376|
       |  377|        - throws: An `NSError` if encoding encounters an error.
       |  378|
       |  379|        - returns: The encoded `NSData` if encoding is successful.
       |  380|    */
      0|  381|    public func encode() throws -> NSData {
      0|  382|        if let bodyPartError = bodyPartError {
      0|  383|            throw bodyPartError
      0|  384|        }
      0|  385|
      0|  386|        let encoded = NSMutableData()
      0|  387|
      0|  388|        bodyParts.first?.hasInitialBoundary = true
      0|  389|        bodyParts.last?.hasFinalBoundary = true
      0|  390|
      0|  391|        for bodyPart in bodyParts {
      0|  392|            let encodedData = try encodeBodyPart(bodyPart)
      0|  393|            encoded.appendData(encodedData)
      0|  394|        }
      0|  395|
      0|  396|        return encoded
      0|  397|    }
       |  398|
       |  399|    /**
       |  400|        Writes the appended body parts into the given file URL.
       |  401|
       |  402|        This process is facilitated by reading and writing with input and output streams, respectively. Thus,
       |  403|        this approach is very memory efficient and should be used for large body part data.
       |  404|
       |  405|        - parameter fileURL: The file URL to write the multipart form data into.
       |  406|
       |  407|        - throws: An `NSError` if encoding encounters an error.
       |  408|    */
      0|  409|    public func writeEncodedDataToDisk(fileURL: NSURL) throws {
      0|  410|        if let bodyPartError = bodyPartError {
      0|  411|            throw bodyPartError
      0|  412|        }
      0|  413|
      0|  414|        if let path = fileURL.path where NSFileManager.defaultManager().fileExistsAtPath(path) {
      0|  415|            let failureReason = "A file already exists at the given file URL: \(fileURL)"
      0|  416|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  417|        } else if !fileURL.fileURL {
      0|  418|            let failureReason = "The URL does not point to a valid file: \(fileURL)"
      0|  419|            throw Error.errorWithCode(NSURLErrorBadURL, failureReason: failureReason)
      0|  420|        }
      0|  421|
      0|  422|        let outputStream: NSOutputStream
      0|  423|
      0|  424|        if let possibleOutputStream = NSOutputStream(URL: fileURL, append: false) {
      0|  425|            outputStream = possibleOutputStream
      0|  426|        } else {
      0|  427|            let failureReason = "Failed to create an output stream with the given URL: \(fileURL)"
      0|  428|            throw Error.errorWithCode(NSURLErrorCannotOpenFile, failureReason: failureReason)
      0|  429|        }
      0|  430|
      0|  431|        outputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  432|        outputStream.open()
      0|  433|
      0|  434|        self.bodyParts.first?.hasInitialBoundary = true
      0|  435|        self.bodyParts.last?.hasFinalBoundary = true
      0|  436|
      0|  437|        for bodyPart in self.bodyParts {
      0|  438|            try writeBodyPart(bodyPart, toOutputStream: outputStream)
      0|  439|        }
      0|  440|
      0|  441|        outputStream.close()
      0|  442|        outputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  443|    }
       |  444|
       |  445|    // MARK: - Private - Body Part Encoding
       |  446|
      0|  447|    private func encodeBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  448|        let encoded = NSMutableData()
      0|  449|
      0|  450|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  451|        encoded.appendData(initialData)
      0|  452|
      0|  453|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  454|        encoded.appendData(headerData)
      0|  455|
      0|  456|        let bodyStreamData = try encodeBodyStreamDataForBodyPart(bodyPart)
      0|  457|        encoded.appendData(bodyStreamData)
      0|  458|
      0|  459|        if bodyPart.hasFinalBoundary {
      0|  460|            encoded.appendData(finalBoundaryData())
      0|  461|        }
      0|  462|
      0|  463|        return encoded
      0|  464|    }
       |  465|
      0|  466|    private func encodeHeaderDataForBodyPart(bodyPart: BodyPart) -> NSData {
      0|  467|        var headerText = ""
      0|  468|
      0|  469|        for (key, value) in bodyPart.headers {
      0|  470|            headerText += "\(key): \(value)\(EncodingCharacters.CRLF)"
      0|  471|        }
      0|  472|        headerText += EncodingCharacters.CRLF
      0|  473|
      0|  474|        return headerText.dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!
      0|  475|    }
       |  476|
      0|  477|    private func encodeBodyStreamDataForBodyPart(bodyPart: BodyPart) throws -> NSData {
      0|  478|        let inputStream = bodyPart.bodyStream
      0|  479|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  480|        inputStream.open()
      0|  481|
      0|  482|        var error: NSError?
      0|  483|        let encoded = NSMutableData()
      0|  484|
      0|  485|        while inputStream.hasBytesAvailable {
      0|  486|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  487|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  488|
      0|  489|            if inputStream.streamError != nil {
      0|  490|                error = inputStream.streamError
      0|  491|                break
      0|  492|            }
      0|  493|
      0|  494|            if bytesRead > 0 {
      0|  495|                encoded.appendBytes(buffer, length: bytesRead)
      0|  496|            } else if bytesRead < 0 {
      0|  497|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  498|                error = Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  499|                break
      0|  500|            } else {
      0|  501|                break
      0|  502|            }
      0|  503|        }
      0|  504|
      0|  505|        inputStream.close()
      0|  506|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  507|
      0|  508|        if let error = error {
      0|  509|            throw error
      0|  510|        }
      0|  511|
      0|  512|        return encoded
      0|  513|    }
       |  514|
       |  515|    // MARK: - Private - Writing Body Part to Output Stream
       |  516|
      0|  517|    private func writeBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  518|        try writeInitialBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  519|        try writeHeaderDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  520|        try writeBodyStreamForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  521|        try writeFinalBoundaryDataForBodyPart(bodyPart, toOutputStream: outputStream)
      0|  522|    }
       |  523|
       |  524|    private func writeInitialBoundaryDataForBodyPart(
       |  525|        bodyPart: BodyPart,
       |  526|        toOutputStream outputStream: NSOutputStream)
       |  527|        throws
      0|  528|    {
      0|  529|        let initialData = bodyPart.hasInitialBoundary ? initialBoundaryData() : encapsulatedBoundaryData()
      0|  530|        return try writeData(initialData, toOutputStream: outputStream)
      0|  531|    }
       |  532|
      0|  533|    private func writeHeaderDataForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  534|        let headerData = encodeHeaderDataForBodyPart(bodyPart)
      0|  535|        return try writeData(headerData, toOutputStream: outputStream)
      0|  536|    }
       |  537|
      0|  538|    private func writeBodyStreamForBodyPart(bodyPart: BodyPart, toOutputStream outputStream: NSOutputStream) throws {
      0|  539|        let inputStream = bodyPart.bodyStream
      0|  540|        inputStream.scheduleInRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  541|        inputStream.open()
      0|  542|
      0|  543|        while inputStream.hasBytesAvailable {
      0|  544|            var buffer = [UInt8](count: streamBufferSize, repeatedValue: 0)
      0|  545|            let bytesRead = inputStream.read(&buffer, maxLength: streamBufferSize)
      0|  546|
      0|  547|            if let streamError = inputStream.streamError {
      0|  548|                throw streamError
      0|  549|            }
      0|  550|
      0|  551|            if bytesRead > 0 {
      0|  552|                if buffer.count != bytesRead {
      0|  553|                    buffer = Array(buffer[0..<bytesRead])
      0|  554|                }
      0|  555|
      0|  556|                try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  557|            } else if bytesRead < 0 {
      0|  558|                let failureReason = "Failed to read from input stream: \(inputStream)"
      0|  559|                throw Error.errorWithCode(.InputStreamReadFailed, failureReason: failureReason)
      0|  560|            } else {
      0|  561|                break
      0|  562|            }
      0|  563|        }
      0|  564|
      0|  565|        inputStream.close()
      0|  566|        inputStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSDefaultRunLoopMode)
      0|  567|    }
       |  568|
       |  569|    private func writeFinalBoundaryDataForBodyPart(
       |  570|        bodyPart: BodyPart,
       |  571|        toOutputStream outputStream: NSOutputStream)
       |  572|        throws
      0|  573|    {
      0|  574|        if bodyPart.hasFinalBoundary {
      0|  575|            return try writeData(finalBoundaryData(), toOutputStream: outputStream)
      0|  576|        }
      0|  577|    }
       |  578|
       |  579|    // MARK: - Private - Writing Buffered Data to Output Stream
       |  580|
      0|  581|    private func writeData(data: NSData, toOutputStream outputStream: NSOutputStream) throws {
      0|  582|        var buffer = [UInt8](count: data.length, repeatedValue: 0)
      0|  583|        data.getBytes(&buffer, length: data.length)
      0|  584|
      0|  585|        return try writeBuffer(&buffer, toOutputStream: outputStream)
      0|  586|    }
       |  587|
      0|  588|    private func writeBuffer(inout buffer: [UInt8], toOutputStream outputStream: NSOutputStream) throws {
      0|  589|        var bytesToWrite = buffer.count
      0|  590|
      0|  591|        while bytesToWrite > 0 {
      0|  592|            if outputStream.hasSpaceAvailable {
      0|  593|                let bytesWritten = outputStream.write(buffer, maxLength: bytesToWrite)
      0|  594|
      0|  595|                if let streamError = outputStream.streamError {
      0|  596|                    throw streamError
      0|  597|                }
      0|  598|
      0|  599|                if bytesWritten < 0 {
      0|  600|                    let failureReason = "Failed to write to output stream: \(outputStream)"
      0|  601|                    throw Error.errorWithCode(.OutputStreamWriteFailed, failureReason: failureReason)
      0|  602|                }
      0|  603|
      0|  604|                bytesToWrite -= bytesWritten
      0|  605|
      0|  606|                if bytesToWrite > 0 {
      0|  607|                    buffer = Array(buffer[bytesWritten..<buffer.count])
      0|  608|                }
      0|  609|            } else if let streamError = outputStream.streamError {
      0|  610|                throw streamError
      0|  611|            }
      0|  612|        }
      0|  613|    }
       |  614|
       |  615|    // MARK: - Private - Mime Type
       |  616|
      0|  617|    private func mimeTypeForPathExtension(pathExtension: String) -> String {
      0|  618|        if let
      0|  619|            id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, pathExtension, nil)?.takeRetainedValue(),
      0|  620|            contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue()
      0|  621|        {
      0|  622|            return contentType as String
      0|  623|        }
      0|  624|
      0|  625|        return "application/octet-stream"
      0|  626|    }
       |  627|
       |  628|    // MARK: - Private - Content Headers
       |  629|
      0|  630|    private func contentHeaders(name name: String) -> [String: String] {
      0|  631|        return ["Content-Disposition": "form-data; name=\"\(name)\""]
      0|  632|    }
       |  633|
      0|  634|    private func contentHeaders(name name: String, mimeType: String) -> [String: String] {
      0|  635|        return [
      0|  636|            "Content-Disposition": "form-data; name=\"\(name)\"",
      0|  637|            "Content-Type": "\(mimeType)"
      0|  638|        ]
      0|  639|    }
       |  640|
      0|  641|    private func contentHeaders(name name: String, fileName: String, mimeType: String) -> [String: String] {
      0|  642|        return [
      0|  643|            "Content-Disposition": "form-data; name=\"\(name)\"; filename=\"\(fileName)\"",
      0|  644|            "Content-Type": "\(mimeType)"
      0|  645|        ]
      0|  646|    }
       |  647|
       |  648|    // MARK: - Private - Boundary Encoding
       |  649|
      0|  650|    private func initialBoundaryData() -> NSData {
      0|  651|        return BoundaryGenerator.boundaryData(boundaryType: .Initial, boundary: boundary)
      0|  652|    }
       |  653|
      0|  654|    private func encapsulatedBoundaryData() -> NSData {
      0|  655|        return BoundaryGenerator.boundaryData(boundaryType: .Encapsulated, boundary: boundary)
      0|  656|    }
       |  657|
      0|  658|    private func finalBoundaryData() -> NSData {
      0|  659|        return BoundaryGenerator.boundaryData(boundaryType: .Final, boundary: boundary)
      0|  660|    }
       |  661|
       |  662|    // MARK: - Private - Errors
       |  663|
      0|  664|    private func setBodyPartError(error: NSError) {
      0|  665|        if bodyPartError == nil {
      0|  666|            bodyPartError = error
      0|  667|        }
      0|  668|    }
       |  669|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ParameterEncoding.swift:
       |    1|// ParameterEncoding.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    HTTP method definitions.
       |   27|
       |   28|    See https://tools.ietf.org/html/rfc7231#section-4.3
       |   29|*/
       |   30|public enum Method: String {
       |   31|    case OPTIONS, GET, HEAD, POST, PUT, PATCH, DELETE, TRACE, CONNECT
       |   32|}
       |   33|
       |   34|// MARK: ParameterEncoding
       |   35|
       |   36|/**
       |   37|    Used to specify the way in which a set of parameters are applied to a URL request.
       |   38|
       |   39|    - `URL`:             Creates a query string to be set as or appended to any existing URL query for `GET`, `HEAD`, 
       |   40|                         and `DELETE` requests, or set as the body for requests with any other HTTP method. The 
       |   41|                         `Content-Type` HTTP header field of an encoded request with HTTP body is set to
       |   42|                         `application/x-www-form-urlencoded; charset=utf-8`. Since there is no published specification
       |   43|                         for how to encode collection types, the convention of appending `[]` to the key for array
       |   44|                         values (`foo[]=1&foo[]=2`), and appending the key surrounded by square brackets for nested
       |   45|                         dictionary values (`foo[bar]=baz`).
       |   46|
       |   47|    - `URLEncodedInURL`: Creates query string to be set as or appended to any existing URL query. Uses the same
       |   48|                         implementation as the `.URL` case, but always applies the encoded result to the URL.
       |   49|
       |   50|    - `JSON`:            Uses `NSJSONSerialization` to create a JSON representation of the parameters object, which is 
       |   51|                         set as the body of the request. The `Content-Type` HTTP header field of an encoded request is 
       |   52|                         set to `application/json`.
       |   53|
       |   54|    - `PropertyList`:    Uses `NSPropertyListSerialization` to create a plist representation of the parameters object,
       |   55|                         according to the associated format and write options values, which is set as the body of the
       |   56|                         request. The `Content-Type` HTTP header field of an encoded request is set to
       |   57|                         `application/x-plist`.
       |   58|
       |   59|    - `Custom`:          Uses the associated closure value to construct a new request given an existing request and
       |   60|                         parameters.
       |   61|*/
       |   62|public enum ParameterEncoding {
       |   63|    case URL
       |   64|    case URLEncodedInURL
       |   65|    case JSON
       |   66|    case PropertyList(NSPropertyListFormat, NSPropertyListWriteOptions)
       |   67|    case Custom((URLRequestConvertible, [String: AnyObject]?) -> (NSMutableURLRequest, NSError?))
       |   68|
       |   69|    /**
       |   70|        Creates a URL request by encoding parameters and applying them onto an existing request.
       |   71|
       |   72|        - parameter URLRequest: The request to have parameters applied
       |   73|        - parameter parameters: The parameters to apply
       |   74|
       |   75|        - returns: A tuple containing the constructed request and the error that occurred during parameter encoding, 
       |   76|                   if any.
       |   77|    */
       |   78|    public func encode(
       |   79|        URLRequest: URLRequestConvertible,
       |   80|        parameters: [String: AnyObject]?)
       |   81|        -> (NSMutableURLRequest, NSError?)
      1|   82|    {
      1|   83|        var mutableURLRequest = URLRequest.URLRequest
      1|   84|
      0|   85|        guard let parameters = parameters where !parameters.isEmpty else {
      0|   86|            return (mutableURLRequest, nil)
      0|   87|        }
      1|   88|
      1|   89|        var encodingError: NSError? = nil
      1|   90|
      1|   91|        switch self {
      0|   92|        case .URL, .URLEncodedInURL:
      0|   93|            func query(parameters: [String: AnyObject]) -> String {
      0|   94|                var components: [(String, String)] = []
      0|   95|
      0|   96|                for key in parameters.keys.sort(<) {
      0|   97|                    let value = parameters[key]!
      0|   98|                    components += queryComponents(key, value)
      0|   99|                }
      0|  100|
      0|  101|                return (components.map { "\($0)=\($1)" } as [String]).joinWithSeparator("&")
      0|  102|            }
      0|  103|
      0|  104|            func encodesParametersInURL(method: Method) -> Bool {
      0|  105|                switch self {
      0|  106|                case .URLEncodedInURL:
      0|  107|                    return true
      0|  108|                default:
      0|  109|                    break
      0|  110|                }
      0|  111|
      0|  112|                switch method {
      0|  113|                case .GET, .HEAD, .DELETE:
      0|  114|                    return true
      0|  115|                default:
      0|  116|                    return false
      0|  117|                }
      0|  118|            }
      0|  119|
      0|  120|            if let method = Method(rawValue: mutableURLRequest.HTTPMethod) where encodesParametersInURL(method) {
      0|  121|                if let URLComponents = NSURLComponents(URL: mutableURLRequest.URL!, resolvingAgainstBaseURL: false) {
      0|  122|                    let percentEncodedQuery = (URLComponents.percentEncodedQuery.map { $0 + "&" } ?? "") + query(parameters)
      0|  123|                    URLComponents.percentEncodedQuery = percentEncodedQuery
      0|  124|                    mutableURLRequest.URL = URLComponents.URL
      0|  125|                }
      0|  126|            } else {
      0|  127|                if mutableURLRequest.valueForHTTPHeaderField("Content-Type") == nil {
      0|  128|                    mutableURLRequest.setValue(
      0|  129|                        "application/x-www-form-urlencoded; charset=utf-8",
      0|  130|                        forHTTPHeaderField: "Content-Type"
      0|  131|                    )
      0|  132|                }
      0|  133|
      0|  134|                mutableURLRequest.HTTPBody = query(parameters).dataUsingEncoding(
      0|  135|                    NSUTF8StringEncoding,
      0|  136|                    allowLossyConversion: false
      0|  137|                )
      0|  138|            }
      1|  139|        case .JSON:
      1|  140|            do {
      1|  141|                let options = NSJSONWritingOptions()
      1|  142|                let data = try NSJSONSerialization.dataWithJSONObject(parameters, options: options)
      1|  143|
      1|  144|                mutableURLRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
      1|  145|                mutableURLRequest.HTTPBody = data
      0|  146|            } catch {
      0|  147|                encodingError = error as NSError
      0|  148|            }
      0|  149|        case .PropertyList(let format, let options):
      0|  150|            do {
      0|  151|                let data = try NSPropertyListSerialization.dataWithPropertyList(
      0|  152|                    parameters,
      0|  153|                    format: format,
      0|  154|                    options: options
      0|  155|                )
      0|  156|                mutableURLRequest.setValue("application/x-plist", forHTTPHeaderField: "Content-Type")
      0|  157|                mutableURLRequest.HTTPBody = data
      0|  158|            } catch {
      0|  159|                encodingError = error as NSError
      0|  160|            }
      0|  161|        case .Custom(let closure):
      0|  162|            (mutableURLRequest, encodingError) = closure(mutableURLRequest, parameters)
      1|  163|        }
      1|  164|
      1|  165|        return (mutableURLRequest, encodingError)
      1|  166|    }
       |  167|
       |  168|    /**
       |  169|        Creates percent-escaped, URL encoded query string components from the given key-value pair using recursion.
       |  170|
       |  171|        - parameter key:   The key of the query component.
       |  172|        - parameter value: The value of the query component.
       |  173|
       |  174|        - returns: The percent-escaped, URL encoded query string components.
       |  175|    */
      0|  176|    public func queryComponents(key: String, _ value: AnyObject) -> [(String, String)] {
      0|  177|        var components: [(String, String)] = []
      0|  178|
      0|  179|        if let dictionary = value as? [String: AnyObject] {
      0|  180|            for (nestedKey, value) in dictionary {
      0|  181|                components += queryComponents("\(key)[\(nestedKey)]", value)
      0|  182|            }
      0|  183|        } else if let array = value as? [AnyObject] {
      0|  184|            for value in array {
      0|  185|                components += queryComponents("\(key)[]", value)
      0|  186|            }
      0|  187|        } else {
      0|  188|            components.append((escape(key), escape("\(value)")))
      0|  189|        }
      0|  190|
      0|  191|        return components
      0|  192|    }
       |  193|
       |  194|    /**
       |  195|        Returns a percent-escaped string following RFC 3986 for a query string key or value.
       |  196|
       |  197|        RFC 3986 states that the following characters are "reserved" characters.
       |  198|
       |  199|        - General Delimiters: ":", "#", "[", "]", "@", "?", "/"
       |  200|        - Sub-Delimiters: "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "="
       |  201|
       |  202|        In RFC 3986 - Section 3.4, it states that the "?" and "/" characters should not be escaped to allow
       |  203|        query strings to include a URL. Therefore, all "reserved" characters with the exception of "?" and "/"
       |  204|        should be percent-escaped in the query string.
       |  205|
       |  206|        - parameter string: The string to be percent-escaped.
       |  207|
       |  208|        - returns: The percent-escaped string.
       |  209|    */
      0|  210|    public func escape(string: String) -> String {
      0|  211|        let generalDelimitersToEncode = ":#[]@" // does not include "?" or "/" due to RFC 3986 - Section 3.4
      0|  212|        let subDelimitersToEncode = "!$&'()*+,;="
      0|  213|
      0|  214|        let allowedCharacterSet = NSCharacterSet.URLQueryAllowedCharacterSet().mutableCopy() as! NSMutableCharacterSet
      0|  215|        allowedCharacterSet.removeCharactersInString(generalDelimitersToEncode + subDelimitersToEncode)
      0|  216|
      0|  217|        var escaped = ""
      0|  218|
      0|  219|        //==========================================================================================================
      0|  220|        //
      0|  221|        //  Batching is required for escaping due to an internal bug in iOS 8.1 and 8.2. Encoding more than a few
      0|  222|        //  hundred Chinense characters causes various malloc error crashes. To avoid this issue until iOS 8 is no
      0|  223|        //  longer supported, batching MUST be used for encoding. This introduces roughly a 20% overhead. For more
      0|  224|        //  info, please refer to:
      0|  225|        //
      0|  226|        //      - https://github.com/Alamofire/Alamofire/issues/206
      0|  227|        //
      0|  228|        //==========================================================================================================
      0|  229|
      0|  230|        if #available(iOS 8.3, OSX 10.10, *) {
      0|  231|            escaped = string.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? string
      0|  232|        } else {
      0|  233|            let batchSize = 50
      0|  234|            var index = string.startIndex
      0|  235|
      0|  236|            while index != string.endIndex {
      0|  237|                let startIndex = index
      0|  238|                let endIndex = index.advancedBy(batchSize, limit: string.endIndex)
      0|  239|                let range = Range(start: startIndex, end: endIndex)
      0|  240|
      0|  241|                let substring = string.substringWithRange(range)
      0|  242|
      0|  243|                escaped += substring.stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacterSet) ?? substring
      0|  244|
      0|  245|                index = endIndex
      0|  246|            }
      0|  247|        }
      0|  248|
      0|  249|        return escaped
      0|  250|    }
       |  251|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Request.swift:
       |    1|// Request.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Responsible for sending a request and receiving the response and associated data from the server, as well as 
       |   27|    managing its underlying `NSURLSessionTask`.
       |   28|*/
       |   29|public class Request {
       |   30|
       |   31|    // MARK: - Properties
       |   32|
       |   33|    /// The delegate for the underlying task.
       |   34|    public let delegate: TaskDelegate
       |   35|
       |   36|    /// The underlying task.
      5|   37|    public var task: NSURLSessionTask { return delegate.task }
       |   38|
       |   39|    /// The session belonging to the underlying task.
       |   40|    public let session: NSURLSession
       |   41|
       |   42|    /// The request sent or to be sent to the server.
      2|   43|    public var request: NSURLRequest? { return task.originalRequest }
       |   44|
       |   45|    /// The response received from the server, if any.
      2|   46|    public var response: NSHTTPURLResponse? { return task.response as? NSHTTPURLResponse }
       |   47|
       |   48|    /// The progress of the request lifecycle.
      0|   49|    public var progress: NSProgress { return delegate.progress }
       |   50|
       |   51|    // MARK: - Lifecycle
       |   52|
      1|   53|    init(session: NSURLSession, task: NSURLSessionTask) {
      1|   54|        self.session = session
      1|   55|
      1|   56|        switch task {
      0|   57|        case is NSURLSessionUploadTask:
      0|   58|            self.delegate = UploadTaskDelegate(task: task)
      1|   59|        case is NSURLSessionDataTask:
      1|   60|            self.delegate = DataTaskDelegate(task: task)
      0|   61|        case is NSURLSessionDownloadTask:
      0|   62|            self.delegate = DownloadTaskDelegate(task: task)
      0|   63|        default:
      0|   64|            self.delegate = TaskDelegate(task: task)
      1|   65|        }
      1|   66|    }
       |   67|
       |   68|    // MARK: - Authentication
       |   69|
       |   70|    /**
       |   71|        Associates an HTTP Basic credential with the request.
       |   72|
       |   73|        - parameter user:        The user.
       |   74|        - parameter password:    The password.
       |   75|        - parameter persistence: The URL credential persistence. `.ForSession` by default.
       |   76|
       |   77|        - returns: The request.
       |   78|    */
       |   79|    public func authenticate(
       |   80|        user user: String,
       |   81|        password: String,
       |   82|        persistence: NSURLCredentialPersistence = .ForSession)
       |   83|        -> Self
      0|   84|    {
      0|   85|        let credential = NSURLCredential(user: user, password: password, persistence: persistence)
      0|   86|
      0|   87|        return authenticate(usingCredential: credential)
      0|   88|    }
       |   89|
       |   90|    /**
       |   91|        Associates a specified credential with the request.
       |   92|
       |   93|        - parameter credential: The credential.
       |   94|
       |   95|        - returns: The request.
       |   96|    */
      0|   97|    public func authenticate(usingCredential credential: NSURLCredential) -> Self {
      0|   98|        delegate.credential = credential
      0|   99|
      0|  100|        return self
      0|  101|    }
       |  102|
       |  103|    // MARK: - Progress
       |  104|
       |  105|    /**
       |  106|        Sets a closure to be called periodically during the lifecycle of the request as data is written to or read 
       |  107|        from the server.
       |  108|
       |  109|        - For uploads, the progress closure returns the bytes written, total bytes written, and total bytes expected 
       |  110|          to write.
       |  111|        - For downloads and data tasks, the progress closure returns the bytes read, total bytes read, and total bytes 
       |  112|          expected to read.
       |  113|
       |  114|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  115|
       |  116|        - returns: The request.
       |  117|    */
      0|  118|    public func progress(closure: ((Int64, Int64, Int64) -> Void)? = nil) -> Self {
      0|  119|        if let uploadDelegate = delegate as? UploadTaskDelegate {
      0|  120|            uploadDelegate.uploadProgress = closure
      0|  121|        } else if let dataDelegate = delegate as? DataTaskDelegate {
      0|  122|            dataDelegate.dataProgress = closure
      0|  123|        } else if let downloadDelegate = delegate as? DownloadTaskDelegate {
      0|  124|            downloadDelegate.downloadProgress = closure
      0|  125|        }
      0|  126|
      0|  127|        return self
      0|  128|    }
       |  129|
       |  130|    /**
       |  131|        Sets a closure to be called periodically during the lifecycle of the request as data is read from the server.
       |  132|
       |  133|        This closure returns the bytes most recently received from the server, not including data from previous calls. 
       |  134|        If this closure is set, data will only be available within this closure, and will not be saved elsewhere. It is 
       |  135|        also important to note that the `response` closure will be called with nil `responseData`.
       |  136|
       |  137|        - parameter closure: The code to be executed periodically during the lifecycle of the request.
       |  138|
       |  139|        - returns: The request.
       |  140|    */
      0|  141|    public func stream(closure: (NSData -> Void)? = nil) -> Self {
      0|  142|        if let dataDelegate = delegate as? DataTaskDelegate {
      0|  143|            dataDelegate.dataStream = closure
      0|  144|        }
      0|  145|
      0|  146|        return self
      0|  147|    }
       |  148|
       |  149|    // MARK: - State
       |  150|
       |  151|    /**
       |  152|        Suspends the request.
       |  153|    */
      0|  154|    public func suspend() {
      0|  155|        task.suspend()
      0|  156|    }
       |  157|
       |  158|    /**
       |  159|        Resumes the request.
       |  160|    */
      1|  161|    public func resume() {
      1|  162|        task.resume()
      1|  163|    }
       |  164|
       |  165|    /**
       |  166|        Cancels the request.
       |  167|    */
      0|  168|    public func cancel() {
      0|  169|        if let
      0|  170|            downloadDelegate = delegate as? DownloadTaskDelegate,
      0|  171|            downloadTask = downloadDelegate.downloadTask
      0|  172|        {
      0|  173|            downloadTask.cancelByProducingResumeData { data in
      0|  174|                downloadDelegate.resumeData = data
      0|  175|            }
      0|  176|        } else {
      0|  177|            task.cancel()
      0|  178|        }
      0|  179|    }
       |  180|
       |  181|    // MARK: - TaskDelegate
       |  182|
       |  183|    /**
       |  184|        The task delegate is responsible for handling all delegate callbacks for the underlying task as well as 
       |  185|        executing all operations attached to the serial operation queue upon task completion.
       |  186|    */
       |  187|    public class TaskDelegate: NSObject {
       |  188|
       |  189|        /// The serial operation queue used to execute all operations after the task completes.
       |  190|        public let queue: NSOperationQueue
       |  191|
       |  192|        let task: NSURLSessionTask
       |  193|        let progress: NSProgress
       |  194|
      0|  195|        var data: NSData? { return nil }
       |  196|        var error: NSError?
       |  197|
       |  198|        var credential: NSURLCredential?
       |  199|
      1|  200|        init(task: NSURLSessionTask) {
      1|  201|            self.task = task
      1|  202|            self.progress = NSProgress(totalUnitCount: 0)
      1|  203|            self.queue = {
      1|  204|                let operationQueue = NSOperationQueue()
      1|  205|                operationQueue.maxConcurrentOperationCount = 1
      1|  206|                operationQueue.suspended = true
      1|  207|
      1|  208|                if #available(OSX 10.10, *) {
      1|  209|                    operationQueue.qualityOfService = NSQualityOfService.Utility
      1|  210|                }
      1|  211|
      1|  212|                return operationQueue
      1|  213|            }()
      1|  214|        }
       |  215|
      0|  216|        deinit {
      0|  217|            queue.cancelAllOperations()
      0|  218|            queue.suspended = false
      0|  219|        }
       |  220|
       |  221|        // MARK: - NSURLSessionTaskDelegate
       |  222|
       |  223|        // MARK: Override Closures
       |  224|
       |  225|        var taskWillPerformHTTPRedirection: ((NSURLSession, NSURLSessionTask, NSHTTPURLResponse, NSURLRequest) -> NSURLRequest?)?
       |  226|        var taskDidReceiveChallenge: ((NSURLSession, NSURLSessionTask, NSURLAuthenticationChallenge) -> (NSURLSessionAuthChallengeDisposition, NSURLCredential?))?
       |  227|        var taskNeedNewBodyStream: ((NSURLSession, NSURLSessionTask) -> NSInputStream?)?
       |  228|        var taskDidCompleteWithError: ((NSURLSession, NSURLSessionTask, NSError?) -> Void)?
       |  229|
       |  230|        // MARK: Delegate Methods
       |  231|
       |  232|        func URLSession(
       |  233|            session: NSURLSession,
       |  234|            task: NSURLSessionTask,
       |  235|            willPerformHTTPRedirection response: NSHTTPURLResponse,
       |  236|            newRequest request: NSURLRequest,
       |  237|            completionHandler: ((NSURLRequest?) -> Void))
      0|  238|        {
      0|  239|            var redirectRequest: NSURLRequest? = request
      0|  240|
      0|  241|            if let taskWillPerformHTTPRedirection = taskWillPerformHTTPRedirection {
      0|  242|                redirectRequest = taskWillPerformHTTPRedirection(session, task, response, request)
      0|  243|            }
      0|  244|
      0|  245|            completionHandler(redirectRequest)
      0|  246|        }
       |  247|
       |  248|        func URLSession(
       |  249|            session: NSURLSession,
       |  250|            task: NSURLSessionTask,
       |  251|            didReceiveChallenge challenge: NSURLAuthenticationChallenge,
       |  252|            completionHandler: ((NSURLSessionAuthChallengeDisposition, NSURLCredential?) -> Void))
      1|  253|        {
      1|  254|            var disposition: NSURLSessionAuthChallengeDisposition = .PerformDefaultHandling
      1|  255|            var credential: NSURLCredential?
      1|  256|
      0|  257|            if let taskDidReceiveChallenge = taskDidReceiveChallenge {
      0|  258|                (disposition, credential) = taskDidReceiveChallenge(session, task, challenge)
      1|  259|            } else if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
      1|  260|                let host = challenge.protectionSpace.host
      1|  261|
      1|  262|                if let
      1|  263|                    serverTrustPolicy = session.serverTrustPolicyManager?.serverTrustPolicyForHost(host),
      1|  264|                    serverTrust = challenge.protectionSpace.serverTrust
      0|  265|                {
      0|  266|                    if serverTrustPolicy.evaluateServerTrust(serverTrust, isValidForHost: host) {
      0|  267|                        disposition = .UseCredential
      0|  268|                        credential = NSURLCredential(forTrust: serverTrust)
      0|  269|                    } else {
      0|  270|                        disposition = .CancelAuthenticationChallenge
      0|  271|                    }
      0|  272|                }
      0|  273|            } else {
      0|  274|                if challenge.previousFailureCount > 0 {
      0|  275|                    disposition = .CancelAuthenticationChallenge
      0|  276|                } else {
      0|  277|                    credential = self.credential ?? session.configuration.URLCredentialStorage?.defaultCredentialForProtectionSpace(challenge.protectionSpace)
      0|  278|
      0|  279|                    if credential != nil {
      0|  280|                        disposition = .UseCredential
      0|  281|                    }
      0|  282|                }
      0|  283|            }
      1|  284|
      1|  285|            completionHandler(disposition, credential)
      1|  286|        }
       |  287|
       |  288|        func URLSession(
       |  289|            session: NSURLSession,
       |  290|            task: NSURLSessionTask,
       |  291|            needNewBodyStream completionHandler: ((NSInputStream?) -> Void))
      0|  292|        {
      0|  293|            var bodyStream: NSInputStream?
      0|  294|
      0|  295|            if let taskNeedNewBodyStream = taskNeedNewBodyStream {
      0|  296|                bodyStream = taskNeedNewBodyStream(session, task)
      0|  297|            }
      0|  298|
      0|  299|            completionHandler(bodyStream)
      0|  300|        }
       |  301|
      1|  302|        func URLSession(session: NSURLSession, task: NSURLSessionTask, didCompleteWithError error: NSError?) {
      0|  303|            if let taskDidCompleteWithError = taskDidCompleteWithError {
      0|  304|                taskDidCompleteWithError(session, task, error)
      1|  305|            } else {
      0|  306|                if let error = error {
      0|  307|                    self.error = error
      0|  308|
      0|  309|                    if let
      0|  310|                        downloadDelegate = self as? DownloadTaskDelegate,
      0|  311|                        userInfo = error.userInfo as? [String: AnyObject],
      0|  312|                        resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? NSData
      0|  313|                    {
      0|  314|                        downloadDelegate.resumeData = resumeData
      0|  315|                    }
      0|  316|                }
      1|  317|
      1|  318|                queue.suspended = false
      1|  319|            }
      1|  320|        }
       |  321|    }
       |  322|
       |  323|    // MARK: - DataTaskDelegate
       |  324|
       |  325|    class DataTaskDelegate: TaskDelegate, NSURLSessionDataDelegate {
      0|  326|        var dataTask: NSURLSessionDataTask? { return task as? NSURLSessionDataTask }
       |  327|
       |  328|        private var totalBytesReceived: Int64 = 0
       |  329|        private var mutableData: NSMutableData
      2|  330|        override var data: NSData? {
      0|  331|            if dataStream != nil {
      0|  332|                return nil
      2|  333|            } else {
      2|  334|                return mutableData
      2|  335|            }
      0|  336|        }
       |  337|
       |  338|        private var expectedContentLength: Int64?
       |  339|        private var dataProgress: ((bytesReceived: Int64, totalBytesReceived: Int64, totalBytesExpectedToReceive: Int64) -> Void)?
       |  340|        private var dataStream: ((data: NSData) -> Void)?
       |  341|
      1|  342|        override init(task: NSURLSessionTask) {
      1|  343|            mutableData = NSMutableData()
      1|  344|            super.init(task: task)
      1|  345|        }
       |  346|
       |  347|        // MARK: - NSURLSessionDataDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var dataTaskDidReceiveResponse: ((NSURLSession, NSURLSessionDataTask, NSURLResponse) -> NSURLSessionResponseDisposition)?
       |  352|        var dataTaskDidBecomeDownloadTask: ((NSURLSession, NSURLSessionDataTask, NSURLSessionDownloadTask) -> Void)?
       |  353|        var dataTaskDidReceiveData: ((NSURLSession, NSURLSessionDataTask, NSData) -> Void)?
       |  354|        var dataTaskWillCacheResponse: ((NSURLSession, NSURLSessionDataTask, NSCachedURLResponse) -> NSCachedURLResponse?)?
       |  355|
       |  356|        // MARK: Delegate Methods
       |  357|
       |  358|        func URLSession(
       |  359|            session: NSURLSession,
       |  360|            dataTask: NSURLSessionDataTask,
       |  361|            didReceiveResponse response: NSURLResponse,
       |  362|            completionHandler: (NSURLSessionResponseDisposition -> Void))
      0|  363|        {
      0|  364|            var disposition: NSURLSessionResponseDisposition = .Allow
      0|  365|
      0|  366|            expectedContentLength = response.expectedContentLength
      0|  367|
      0|  368|            if let dataTaskDidReceiveResponse = dataTaskDidReceiveResponse {
      0|  369|                disposition = dataTaskDidReceiveResponse(session, dataTask, response)
      0|  370|            }
      0|  371|
      0|  372|            completionHandler(disposition)
      0|  373|        }
       |  374|
       |  375|        func URLSession(
       |  376|            session: NSURLSession,
       |  377|            dataTask: NSURLSessionDataTask,
       |  378|            didBecomeDownloadTask downloadTask: NSURLSessionDownloadTask)
      0|  379|        {
      0|  380|            dataTaskDidBecomeDownloadTask?(session, dataTask, downloadTask)
      0|  381|        }
       |  382|
      1|  383|        func URLSession(session: NSURLSession, dataTask: NSURLSessionDataTask, didReceiveData data: NSData) {
      0|  384|            if let dataTaskDidReceiveData = dataTaskDidReceiveData {
      0|  385|                dataTaskDidReceiveData(session, dataTask, data)
      1|  386|            } else {
      0|  387|                if let dataStream = dataStream {
      0|  388|                    dataStream(data: data)
      1|  389|                } else {
      1|  390|                    mutableData.appendData(data)
      1|  391|                }
      1|  392|
      1|  393|                totalBytesReceived += data.length
      0|  394|                let totalBytesExpected = dataTask.response?.expectedContentLength ?? NSURLSessionTransferSizeUnknown
      1|  395|
      1|  396|                progress.totalUnitCount = totalBytesExpected
      1|  397|                progress.completedUnitCount = totalBytesReceived
      1|  398|
      1|  399|                dataProgress?(
      1|  400|                    bytesReceived: Int64(data.length),
      1|  401|                    totalBytesReceived: totalBytesReceived,
      1|  402|                    totalBytesExpectedToReceive: totalBytesExpected
      1|  403|                )
      1|  404|            }
      1|  405|        }
       |  406|
       |  407|        func URLSession(
       |  408|            session: NSURLSession,
       |  409|            dataTask: NSURLSessionDataTask,
       |  410|            willCacheResponse proposedResponse: NSCachedURLResponse,
       |  411|            completionHandler: ((NSCachedURLResponse?) -> Void))
      0|  412|        {
      0|  413|            var cachedResponse: NSCachedURLResponse? = proposedResponse
      0|  414|
      0|  415|            if let dataTaskWillCacheResponse = dataTaskWillCacheResponse {
      0|  416|                cachedResponse = dataTaskWillCacheResponse(session, dataTask, proposedResponse)
      0|  417|            }
      0|  418|
      0|  419|            completionHandler(cachedResponse)
      0|  420|        }
       |  421|    }
       |  422|}
       |  423|
       |  424|// MARK: - CustomStringConvertible
       |  425|
       |  426|extension Request: CustomStringConvertible {
       |  427|
       |  428|    /**
       |  429|        The textual representation used when written to an output stream, which includes the HTTP method and URL, as 
       |  430|        well as the response status code if a response has been received.
       |  431|    */
      0|  432|    public var description: String {
      0|  433|        var components: [String] = []
      0|  434|
      0|  435|        if let HTTPMethod = request?.HTTPMethod {
      0|  436|            components.append(HTTPMethod)
      0|  437|        }
      0|  438|
      0|  439|        if let URLString = request?.URL?.absoluteString {
      0|  440|            components.append(URLString)
      0|  441|        }
      0|  442|
      0|  443|        if let response = response {
      0|  444|            components.append("(\(response.statusCode))")
      0|  445|        }
      0|  446|
      0|  447|        return components.joinWithSeparator(" ")
      0|  448|    }
       |  449|}
       |  450|
       |  451|// MARK: - CustomDebugStringConvertible
       |  452|
       |  453|extension Request: CustomDebugStringConvertible {
      0|  454|    func cURLRepresentation() -> String {
      0|  455|        var components = ["$ curl -i"]
      0|  456|
      0|  457|        guard let request = self.request else {
      0|  458|            return "$ curl command could not be created"
      0|  459|        }
      0|  460|
      0|  461|        let URL = request.URL
      0|  462|
      0|  463|        if let HTTPMethod = request.HTTPMethod where HTTPMethod != "GET" {
      0|  464|            components.append("-X \(HTTPMethod)")
      0|  465|        }
      0|  466|
      0|  467|        if let credentialStorage = self.session.configuration.URLCredentialStorage {
      0|  468|            let protectionSpace = NSURLProtectionSpace(
      0|  469|                host: URL!.host!,
      0|  470|                port: URL!.port?.integerValue ?? 0,
      0|  471|                `protocol`: URL!.scheme,
      0|  472|                realm: URL!.host!,
      0|  473|                authenticationMethod: NSURLAuthenticationMethodHTTPBasic
      0|  474|            )
      0|  475|
      0|  476|            if let credentials = credentialStorage.credentialsForProtectionSpace(protectionSpace)?.values {
      0|  477|                for credential in credentials {
      0|  478|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  479|                }
      0|  480|            } else {
      0|  481|                if let credential = delegate.credential {
      0|  482|                    components.append("-u \(credential.user!):\(credential.password!)")
      0|  483|                }
      0|  484|            }
      0|  485|        }
      0|  486|
      0|  487|        if session.configuration.HTTPShouldSetCookies {
      0|  488|            if let
      0|  489|                cookieStorage = session.configuration.HTTPCookieStorage,
      0|  490|                cookies = cookieStorage.cookiesForURL(URL!) where !cookies.isEmpty
      0|  491|            {
      0|  492|                let string = cookies.reduce("") { $0 + "\($1.name)=\($1.value ?? String());" }
      0|  493|                components.append("-b \"\(string.substringToIndex(string.endIndex.predecessor()))\"")
      0|  494|            }
      0|  495|        }
      0|  496|
      0|  497|        if let headerFields = request.allHTTPHeaderFields {
      0|  498|            for (field, value) in headerFields {
      0|  499|                switch field {
      0|  500|                case "Cookie":
      0|  501|                    continue
      0|  502|                default:
      0|  503|                    components.append("-H \"\(field): \(value)\"")
      0|  504|                }
      0|  505|            }
      0|  506|        }
      0|  507|
      0|  508|        if let additionalHeaders = session.configuration.HTTPAdditionalHeaders {
      0|  509|            for (field, value) in additionalHeaders {
      0|  510|                switch field {
      0|  511|                case "Cookie":
      0|  512|                    continue
      0|  513|                default:
      0|  514|                    components.append("-H \"\(field): \(value)\"")
      0|  515|                }
      0|  516|            }
      0|  517|        }
      0|  518|
      0|  519|        if let
      0|  520|            HTTPBodyData = request.HTTPBody,
      0|  521|            HTTPBody = String(data: HTTPBodyData, encoding: NSUTF8StringEncoding)
      0|  522|        {
      0|  523|            let escapedBody = HTTPBody.stringByReplacingOccurrencesOfString("\"", withString: "\\\"")
      0|  524|            components.append("-d \"\(escapedBody)\"")
      0|  525|        }
      0|  526|
      0|  527|        components.append("\"\(URL!.absoluteString)\"")
      0|  528|
      0|  529|        return components.joinWithSeparator(" \\\n\t")
      0|  530|    }
       |  531|
       |  532|    /// The textual representation used when written to an output stream, in the form of a cURL command.
      0|  533|    public var debugDescription: String {
      0|  534|        return cURLRepresentation()
      0|  535|    }
       |  536|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Response.swift:
       |    1|// Response.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Used to store all response data returned from a completed `Request`.
       |   26|public struct Response<Value, Error: ErrorType> {
       |   27|    /// The URL request sent to the server.
       |   28|    public let request: NSURLRequest?
       |   29|
       |   30|    /// The server's response to the URL request.
       |   31|    public let response: NSHTTPURLResponse?
       |   32|
       |   33|    /// The data returned by the server.
       |   34|    public let data: NSData?
       |   35|
       |   36|    /// The result of response serialization.
       |   37|    public let result: Result<Value, Error>
       |   38|
       |   39|    /**
       |   40|        Initializes the `Response` instance with the specified URL request, URL response, server data and response
       |   41|        serialization result.
       |   42|    
       |   43|        - parameter request:  The URL request sent to the server.
       |   44|        - parameter response: The server's response to the URL request.
       |   45|        - parameter data:     The data returned by the server.
       |   46|        - parameter result:   The result of response serialization.
       |   47|    
       |   48|        - returns: the new `Response` instance.
       |   49|    */
      1|   50|    public init(request: NSURLRequest?, response: NSHTTPURLResponse?, data: NSData?, result: Result<Value, Error>) {
      1|   51|        self.request = request
      1|   52|        self.response = response
      1|   53|        self.data = data
      1|   54|        self.result = result
      1|   55|    }
       |   56|}
       |   57|
       |   58|// MARK: - CustomStringConvertible
       |   59|
       |   60|extension Response: CustomStringConvertible {
       |   61|    /// The textual representation used when written to an output stream, which includes whether the result was a
       |   62|    /// success or failure.
      0|   63|    public var description: String {
      0|   64|        return result.debugDescription
      0|   65|    }
       |   66|}
       |   67|
       |   68|// MARK: - CustomDebugStringConvertible
       |   69|
       |   70|extension Response: CustomDebugStringConvertible {
       |   71|    /// The debug textual representation used when written to an output stream, which includes the URL request, the URL
       |   72|    /// response, the server data and the response serialization result.
      0|   73|    public var debugDescription: String {
      0|   74|        var output: [String] = []
      0|   75|
      0|   76|        output.append(request != nil ? "[Request]: \(request!)" : "[Request]: nil")
      0|   77|        output.append(response != nil ? "[Response]: \(response!)" : "[Response]: nil")
      0|   78|        output.append("[Data]: \(data?.length ?? 0) bytes")
      0|   79|        output.append("[Result]: \(result.debugDescription)")
      0|   80|
      0|   81|        return output.joinWithSeparator("\n")
      0|   82|    }
       |   83|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ResponseSerialization.swift:
       |    1|// ResponseSerialization.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|// MARK: ResponseSerializer
       |   26|
       |   27|/**
       |   28|    The type in which all response serializers must conform to in order to serialize a response.
       |   29|*/
       |   30|public protocol ResponseSerializerType {
       |   31|    /// The type of serialized object to be created by this `ResponseSerializerType`.
       |   32|    typealias SerializedObject
       |   33|
       |   34|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   35|    typealias ErrorObject: ErrorType
       |   36|
       |   37|    /**
       |   38|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   39|    */
       |   40|    var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<SerializedObject, ErrorObject> { get }
       |   41|}
       |   42|
       |   43|// MARK: -
       |   44|
       |   45|/**
       |   46|    A generic `ResponseSerializerType` used to serialize a request, response, and data into a serialized object.
       |   47|*/
       |   48|public struct ResponseSerializer<Value, Error: ErrorType>: ResponseSerializerType {
       |   49|    /// The type of serialized object to be created by this `ResponseSerializer`.
       |   50|    public typealias SerializedObject = Value
       |   51|
       |   52|    /// The type of error to be created by this `ResponseSerializer` if serialization fails.
       |   53|    public typealias ErrorObject = Error
       |   54|
       |   55|    /**
       |   56|        A closure used by response handlers that takes a request, response, data and error and returns a result.
       |   57|    */
       |   58|    public var serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>
       |   59|
       |   60|    /**
       |   61|        Initializes the `ResponseSerializer` instance with the given serialize response closure.
       |   62|
       |   63|        - parameter serializeResponse: The closure used to serialize the response.
       |   64|
       |   65|        - returns: The new generic response serializer instance.
       |   66|    */
      1|   67|    public init(serializeResponse: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Result<Value, Error>) {
      1|   68|        self.serializeResponse = serializeResponse
      1|   69|    }
       |   70|}
       |   71|
       |   72|// MARK: - Default
       |   73|
       |   74|extension Request {
       |   75|
       |   76|    /**
       |   77|        Adds a handler to be called once the request has finished.
       |   78|
       |   79|        - parameter queue:             The queue on which the completion handler is dispatched.
       |   80|        - parameter completionHandler: The code to be executed once the request has finished.
       |   81|
       |   82|        - returns: The request.
       |   83|    */
       |   84|    public func response(
       |   85|        queue queue: dispatch_queue_t? = nil,
       |   86|        completionHandler: (NSURLRequest?, NSHTTPURLResponse?, NSData?, NSError?) -> Void)
       |   87|        -> Self
      0|   88|    {
      0|   89|        delegate.queue.addOperationWithBlock {
      0|   90|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      0|   91|                completionHandler(self.request, self.response, self.delegate.data, self.delegate.error)
      0|   92|            }
      0|   93|        }
      0|   94|
      0|   95|        return self
      0|   96|    }
       |   97|
       |   98|    /**
       |   99|        Adds a handler to be called once the request has finished.
       |  100|
       |  101|        - parameter queue:              The queue on which the completion handler is dispatched.
       |  102|        - parameter responseSerializer: The response serializer responsible for serializing the request, response, 
       |  103|                                        and data.
       |  104|        - parameter completionHandler:  The code to be executed once the request has finished.
       |  105|
       |  106|        - returns: The request.
       |  107|    */
       |  108|    public func response<T: ResponseSerializerType>(
       |  109|        queue queue: dispatch_queue_t? = nil,
       |  110|        responseSerializer: T,
       |  111|        completionHandler: Response<T.SerializedObject, T.ErrorObject> -> Void)
       |  112|        -> Self
      1|  113|    {
      1|  114|        delegate.queue.addOperationWithBlock {
      1|  115|            let result = responseSerializer.serializeResponse(
      1|  116|                self.request,
      1|  117|                self.response,
      1|  118|                self.delegate.data,
      1|  119|                self.delegate.error
      1|  120|            )
      1|  121|
      1|  122|            dispatch_async(queue ?? dispatch_get_main_queue()) {
      1|  123|                let response = Response<T.SerializedObject, T.ErrorObject>(
      1|  124|                    request: self.request,
      1|  125|                    response: self.response,
      1|  126|                    data: self.delegate.data,
      1|  127|                    result: result
      1|  128|                )
      1|  129|
      1|  130|                completionHandler(response)
      1|  131|            }
      1|  132|        }
      1|  133|
      1|  134|        return self
      1|  135|    }
       |  136|}
       |  137|
       |  138|// MARK: - Data
       |  139|
       |  140|extension Request {
       |  141|
       |  142|    /**
       |  143|        Creates a response serializer that returns the associated data as-is.
       |  144|
       |  145|        - returns: A data response serializer.
       |  146|    */
      0|  147|    public static func dataResponseSerializer() -> ResponseSerializer<NSData, NSError> {
      0|  148|        return ResponseSerializer { _, response, data, error in
      0|  149|            guard error == nil else { return .Failure(error!) }
      0|  150|
      0|  151|            if let response = response where response.statusCode == 204 { return .Success(NSData()) }
      0|  152|
      0|  153|            guard let validData = data else {
      0|  154|                let failureReason = "Data could not be serialized. Input data was nil."
      0|  155|                let error = Error.errorWithCode(.DataSerializationFailed, failureReason: failureReason)
      0|  156|                return .Failure(error)
      0|  157|            }
      0|  158|
      0|  159|            return .Success(validData)
      0|  160|        }
      0|  161|    }
       |  162|
       |  163|    /**
       |  164|        Adds a handler to be called once the request has finished.
       |  165|
       |  166|        - parameter completionHandler: The code to be executed once the request has finished.
       |  167|
       |  168|        - returns: The request.
       |  169|    */
      0|  170|    public func responseData(completionHandler: Response<NSData, NSError> -> Void) -> Self {
      0|  171|        return response(responseSerializer: Request.dataResponseSerializer(), completionHandler: completionHandler)
      0|  172|    }
       |  173|}
       |  174|
       |  175|// MARK: - String
       |  176|
       |  177|extension Request {
       |  178|
       |  179|    /**
       |  180|        Creates a response serializer that returns a string initialized from the response data with the specified 
       |  181|        string encoding.
       |  182|
       |  183|        - parameter encoding: The string encoding. If `nil`, the string encoding will be determined from the server 
       |  184|                              response, falling back to the default HTTP default character set, ISO-8859-1.
       |  185|
       |  186|        - returns: A string response serializer.
       |  187|    */
       |  188|    public static func stringResponseSerializer(
       |  189|        var encoding encoding: NSStringEncoding? = nil)
       |  190|        -> ResponseSerializer<String, NSError>
      0|  191|    {
      0|  192|        return ResponseSerializer { _, response, data, error in
      0|  193|            guard error == nil else { return .Failure(error!) }
      0|  194|
      0|  195|            if let response = response where response.statusCode == 204 { return .Success("") }
      0|  196|
      0|  197|            guard let validData = data else {
      0|  198|                let failureReason = "String could not be serialized. Input data was nil."
      0|  199|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  200|                return .Failure(error)
      0|  201|            }
      0|  202|
      0|  203|            if let encodingName = response?.textEncodingName where encoding == nil {
      0|  204|                encoding = CFStringConvertEncodingToNSStringEncoding(
      0|  205|                    CFStringConvertIANACharSetNameToEncoding(encodingName)
      0|  206|                )
      0|  207|            }
      0|  208|
      0|  209|            let actualEncoding = encoding ?? NSISOLatin1StringEncoding
      0|  210|
      0|  211|            if let string = String(data: validData, encoding: actualEncoding) {
      0|  212|                return .Success(string)
      0|  213|            } else {
      0|  214|                let failureReason = "String could not be serialized with encoding: \(actualEncoding)"
      0|  215|                let error = Error.errorWithCode(.StringSerializationFailed, failureReason: failureReason)
      0|  216|                return .Failure(error)
      0|  217|            }
      0|  218|        }
      0|  219|    }
       |  220|
       |  221|    /**
       |  222|        Adds a handler to be called once the request has finished.
       |  223|
       |  224|        - parameter encoding:          The string encoding. If `nil`, the string encoding will be determined from the 
       |  225|                                       server response, falling back to the default HTTP default character set, 
       |  226|                                       ISO-8859-1.
       |  227|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  228|
       |  229|        - returns: The request.
       |  230|    */
       |  231|    public func responseString(
       |  232|        encoding encoding: NSStringEncoding? = nil,
       |  233|        completionHandler: Response<String, NSError> -> Void)
       |  234|        -> Self
      0|  235|    {
      0|  236|        return response(
      0|  237|            responseSerializer: Request.stringResponseSerializer(encoding: encoding),
      0|  238|            completionHandler: completionHandler
      0|  239|        )
      0|  240|    }
       |  241|}
       |  242|
       |  243|// MARK: - JSON
       |  244|
       |  245|extension Request {
       |  246|
       |  247|    /**
       |  248|        Creates a response serializer that returns a JSON object constructed from the response data using 
       |  249|        `NSJSONSerialization` with the specified reading options.
       |  250|
       |  251|        - parameter options: The JSON serialization reading options. `.AllowFragments` by default.
       |  252|
       |  253|        - returns: A JSON object response serializer.
       |  254|    */
       |  255|    public static func JSONResponseSerializer(
       |  256|        options options: NSJSONReadingOptions = .AllowFragments)
       |  257|        -> ResponseSerializer<AnyObject, NSError>
      1|  258|    {
      1|  259|        return ResponseSerializer { _, response, data, error in
      0|  260|            guard error == nil else { return .Failure(error!) }
      1|  261|
      0|  262|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      1|  263|
      0|  264|            guard let validData = data where validData.length > 0 else {
      0|  265|                let failureReason = "JSON could not be serialized. Input data was nil or zero length."
      0|  266|                let error = Error.errorWithCode(.JSONSerializationFailed, failureReason: failureReason)
      0|  267|                return .Failure(error)
      0|  268|            }
      1|  269|
      1|  270|            do {
      1|  271|                let JSON = try NSJSONSerialization.JSONObjectWithData(validData, options: options)
      1|  272|                return .Success(JSON)
      1|  273|            } catch {
      1|  274|                return .Failure(error as NSError)
      1|  275|            }
      0|  276|        }
      1|  277|    }
       |  278|
       |  279|    /**
       |  280|        Adds a handler to be called once the request has finished.
       |  281|
       |  282|        - parameter options:           The JSON serialization reading options. `.AllowFragments` by default.
       |  283|        - parameter completionHandler: A closure to be executed once the request has finished.
       |  284|
       |  285|        - returns: The request.
       |  286|    */
       |  287|    public func responseJSON(
       |  288|        options options: NSJSONReadingOptions = .AllowFragments,
       |  289|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  290|        -> Self
      1|  291|    {
      1|  292|        return response(
      1|  293|            responseSerializer: Request.JSONResponseSerializer(options: options),
      1|  294|            completionHandler: completionHandler
      1|  295|        )
      1|  296|    }
       |  297|}
       |  298|
       |  299|// MARK: - Property List
       |  300|
       |  301|extension Request {
       |  302|
       |  303|    /**
       |  304|        Creates a response serializer that returns an object constructed from the response data using 
       |  305|        `NSPropertyListSerialization` with the specified reading options.
       |  306|
       |  307|        - parameter options: The property list reading options. `NSPropertyListReadOptions()` by default.
       |  308|
       |  309|        - returns: A property list object response serializer.
       |  310|    */
       |  311|    public static func propertyListResponseSerializer(
       |  312|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions())
       |  313|        -> ResponseSerializer<AnyObject, NSError>
      0|  314|    {
      0|  315|        return ResponseSerializer { _, response, data, error in
      0|  316|            guard error == nil else { return .Failure(error!) }
      0|  317|
      0|  318|            if let response = response where response.statusCode == 204 { return .Success(NSNull()) }
      0|  319|
      0|  320|            guard let validData = data where validData.length > 0 else {
      0|  321|                let failureReason = "Property list could not be serialized. Input data was nil or zero length."
      0|  322|                let error = Error.errorWithCode(.PropertyListSerializationFailed, failureReason: failureReason)
      0|  323|                return .Failure(error)
      0|  324|            }
      0|  325|
      0|  326|            do {
      0|  327|                let plist = try NSPropertyListSerialization.propertyListWithData(validData, options: options, format: nil)
      0|  328|                return .Success(plist)
      0|  329|            } catch {
      0|  330|                return .Failure(error as NSError)
      0|  331|            }
      0|  332|        }
      0|  333|    }
       |  334|
       |  335|    /**
       |  336|        Adds a handler to be called once the request has finished.
       |  337|
       |  338|        - parameter options:           The property list reading options. `0` by default.
       |  339|        - parameter completionHandler: A closure to be executed once the request has finished. The closure takes 3
       |  340|                                       arguments: the URL request, the URL response, the server data and the result 
       |  341|                                       produced while creating the property list.
       |  342|
       |  343|        - returns: The request.
       |  344|    */
       |  345|    public func responsePropertyList(
       |  346|        options options: NSPropertyListReadOptions = NSPropertyListReadOptions(),
       |  347|        completionHandler: Response<AnyObject, NSError> -> Void)
       |  348|        -> Self
      0|  349|    {
      0|  350|        return response(
      0|  351|            responseSerializer: Request.propertyListResponseSerializer(options: options),
      0|  352|            completionHandler: completionHandler
      0|  353|        )
      0|  354|    }
       |  355|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Result.swift:
       |    1|// Result.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/**
       |   26|    Used to represent whether a request was successful or encountered an error.
       |   27|
       |   28|    - Success: The request and all post processing operations were successful resulting in the serialization of the 
       |   29|               provided associated value.
       |   30|    - Failure: The request encountered an error resulting in a failure. The associated values are the original data 
       |   31|               provided by the server as well as the error that caused the failure.
       |   32|*/
       |   33|public enum Result<Value, Error: ErrorType> {
       |   34|    case Success(Value)
       |   35|    case Failure(Error)
       |   36|
       |   37|    /// Returns `true` if the result is a success, `false` otherwise.
      0|   38|    public var isSuccess: Bool {
      0|   39|        switch self {
      0|   40|        case .Success:
      0|   41|            return true
      0|   42|        case .Failure:
      0|   43|            return false
      0|   44|        }
      0|   45|    }
       |   46|
       |   47|    /// Returns `true` if the result is a failure, `false` otherwise.
      0|   48|    public var isFailure: Bool {
      0|   49|        return !isSuccess
      0|   50|    }
       |   51|
       |   52|    /// Returns the associated value if the result is a success, `nil` otherwise.
      0|   53|    public var value: Value? {
      0|   54|        switch self {
      0|   55|        case .Success(let value):
      0|   56|            return value
      0|   57|        case .Failure:
      0|   58|            return nil
      0|   59|        }
      0|   60|    }
       |   61|
       |   62|    /// Returns the associated error value if the result is a failure, `nil` otherwise.
      0|   63|    public var error: Error? {
      0|   64|        switch self {
      0|   65|        case .Success:
      0|   66|            return nil
      0|   67|        case .Failure(let error):
      0|   68|            return error
      0|   69|        }
      0|   70|    }
       |   71|}
       |   72|
       |   73|// MARK: - CustomStringConvertible
       |   74|
       |   75|extension Result: CustomStringConvertible {
       |   76|    /// The textual representation used when written to an output stream, which includes whether the result was a 
       |   77|    /// success or failure.
      0|   78|    public var description: String {
      0|   79|        switch self {
      0|   80|        case .Success:
      0|   81|            return "SUCCESS"
      0|   82|        case .Failure:
      0|   83|            return "FAILURE"
      0|   84|        }
      0|   85|    }
       |   86|}
       |   87|
       |   88|// MARK: - CustomDebugStringConvertible
       |   89|
       |   90|extension Result: CustomDebugStringConvertible {
       |   91|    /// The debug textual representation used when written to an output stream, which includes whether the result was a
       |   92|    /// success or failure in addition to the value or error.
      1|   93|    public var debugDescription: String {
      1|   94|        switch self {
      0|   95|        case .Success(let value):
      0|   96|            return "SUCCESS: \(value)"
      1|   97|        case .Failure(let error):
      1|   98|            return "FAILURE: \(error)"
      1|   99|        }
      1|  100|    }
       |  101|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/ServerTrustPolicy.swift:
       |    1|// ServerTrustPolicy.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|/// Responsible for managing the mapping of `ServerTrustPolicy` objects to a given host.
       |   26|public class ServerTrustPolicyManager {
       |   27|    /// The dictionary of policies mapped to a particular host.
       |   28|    public let policies: [String: ServerTrustPolicy]
       |   29|
       |   30|    /**
       |   31|        Initializes the `ServerTrustPolicyManager` instance with the given policies.
       |   32|
       |   33|        Since different servers and web services can have different leaf certificates, intermediate and even root 
       |   34|        certficates, it is important to have the flexibility to specify evaluation policies on a per host basis. This 
       |   35|        allows for scenarios such as using default evaluation for host1, certificate pinning for host2, public key 
       |   36|        pinning for host3 and disabling evaluation for host4.
       |   37|
       |   38|        - parameter policies: A dictionary of all policies mapped to a particular host.
       |   39|
       |   40|        - returns: The new `ServerTrustPolicyManager` instance.
       |   41|    */
      0|   42|    public init(policies: [String: ServerTrustPolicy]) {
      0|   43|        self.policies = policies
      0|   44|    }
       |   45|
       |   46|    /**
       |   47|        Returns the `ServerTrustPolicy` for the given host if applicable.
       |   48|
       |   49|        By default, this method will return the policy that perfectly matches the given host. Subclasses could override
       |   50|        this method and implement more complex mapping implementations such as wildcards.
       |   51|
       |   52|        - parameter host: The host to use when searching for a matching policy.
       |   53|
       |   54|        - returns: The server trust policy for the given host if found.
       |   55|    */
      0|   56|    public func serverTrustPolicyForHost(host: String) -> ServerTrustPolicy? {
      0|   57|        return policies[host]
      0|   58|    }
       |   59|}
       |   60|
       |   61|// MARK: -
       |   62|
       |   63|extension NSURLSession {
       |   64|    private struct AssociatedKeys {
       |   65|        static var ManagerKey = "NSURLSession.ServerTrustPolicyManager"
       |   66|    }
       |   67|
       |   68|    var serverTrustPolicyManager: ServerTrustPolicyManager? {
      1|   69|        get {
      1|   70|            return objc_getAssociatedObject(self, &AssociatedKeys.ManagerKey) as? ServerTrustPolicyManager
      1|   71|        }
      1|   72|        set (manager) {
      1|   73|            objc_setAssociatedObject(self, &AssociatedKeys.ManagerKey, manager, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
      1|   74|        }
       |   75|    }
       |   76|}
       |   77|
       |   78|// MARK: - ServerTrustPolicy
       |   79|
       |   80|/**
       |   81|    The `ServerTrustPolicy` evaluates the server trust generally provided by an `NSURLAuthenticationChallenge` when 
       |   82|    connecting to a server over a secure HTTPS connection. The policy configuration then evaluates the server trust 
       |   83|    with a given set of criteria to determine whether the server trust is valid and the connection should be made.
       |   84|
       |   85|    Using pinned certificates or public keys for evaluation helps prevent man-in-the-middle (MITM) attacks and other 
       |   86|    vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged 
       |   87|    to route all communication over an HTTPS connection with pinning enabled.
       |   88|
       |   89|    - PerformDefaultEvaluation: Uses the default server trust evaluation while allowing you to control whether to 
       |   90|                                validate the host provided by the challenge. Applications are encouraged to always 
       |   91|                                validate the host in production environments to guarantee the validity of the server's 
       |   92|                                certificate chain.
       |   93|
       |   94|    - PinCertificates:          Uses the pinned certificates to validate the server trust. The server trust is
       |   95|                                considered valid if one of the pinned certificates match one of the server certificates. 
       |   96|                                By validating both the certificate chain and host, certificate pinning provides a very 
       |   97|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |   98|                                Applications are encouraged to always validate the host and require a valid certificate 
       |   99|                                chain in production environments.
       |  100|
       |  101|    - PinPublicKeys:            Uses the pinned public keys to validate the server trust. The server trust is considered
       |  102|                                valid if one of the pinned public keys match one of the server certificate public keys. 
       |  103|                                By validating both the certificate chain and host, public key pinning provides a very 
       |  104|                                secure form of server trust validation mitigating most, if not all, MITM attacks. 
       |  105|                                Applications are encouraged to always validate the host and require a valid certificate 
       |  106|                                chain in production environments.
       |  107|
       |  108|    - DisableEvaluation:        Disables all evaluation which in turn will always consider any server trust as valid.
       |  109|
       |  110|    - CustomEvaluation:         Uses the associated closure to evaluate the validity of the server trust.
       |  111|*/
       |  112|public enum ServerTrustPolicy {
       |  113|    case PerformDefaultEvaluation(validateHost: Bool)
       |  114|    case PinCertificates(certificates: [SecCertificate], validateCertificateChain: Bool, validateHost: Bool)
       |  115|    case PinPublicKeys(publicKeys: [SecKey], validateCertificateChain: Bool, validateHost: Bool)
       |  116|    case DisableEvaluation
       |  117|    case CustomEvaluation((serverTrust: SecTrust, host: String) -> Bool)
       |  118|
       |  119|    // MARK: - Bundle Location
       |  120|
       |  121|    /**
       |  122|        Returns all certificates within the given bundle with a `.cer` file extension.
       |  123|
       |  124|        - parameter bundle: The bundle to search for all `.cer` files.
       |  125|
       |  126|        - returns: All certificates within the given bundle.
       |  127|    */
      0|  128|    public static func certificatesInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecCertificate] {
      0|  129|        var certificates: [SecCertificate] = []
      0|  130|
      0|  131|        let paths = Set([".cer", ".CER", ".crt", ".CRT", ".der", ".DER"].map { fileExtension in
      0|  132|            bundle.pathsForResourcesOfType(fileExtension, inDirectory: nil)
      0|  133|        }.flatten())
      0|  134|
      0|  135|        for path in paths {
      0|  136|            if let
      0|  137|                certificateData = NSData(contentsOfFile: path),
      0|  138|                certificate = SecCertificateCreateWithData(nil, certificateData)
      0|  139|            {
      0|  140|                certificates.append(certificate)
      0|  141|            }
      0|  142|        }
      0|  143|
      0|  144|        return certificates
      0|  145|    }
       |  146|
       |  147|    /**
       |  148|        Returns all public keys within the given bundle with a `.cer` file extension.
       |  149|
       |  150|        - parameter bundle: The bundle to search for all `*.cer` files.
       |  151|
       |  152|        - returns: All public keys within the given bundle.
       |  153|    */
      0|  154|    public static func publicKeysInBundle(bundle: NSBundle = NSBundle.mainBundle()) -> [SecKey] {
      0|  155|        var publicKeys: [SecKey] = []
      0|  156|
      0|  157|        for certificate in certificatesInBundle(bundle) {
      0|  158|            if let publicKey = publicKeyForCertificate(certificate) {
      0|  159|                publicKeys.append(publicKey)
      0|  160|            }
      0|  161|        }
      0|  162|
      0|  163|        return publicKeys
      0|  164|    }
       |  165|
       |  166|    // MARK: - Evaluation
       |  167|
       |  168|    /**
       |  169|        Evaluates whether the server trust is valid for the given host.
       |  170|
       |  171|        - parameter serverTrust: The server trust to evaluate.
       |  172|        - parameter host:        The host of the challenge protection space.
       |  173|
       |  174|        - returns: Whether the server trust is valid.
       |  175|    */
      0|  176|    public func evaluateServerTrust(serverTrust: SecTrust, isValidForHost host: String) -> Bool {
      0|  177|        var serverTrustIsValid = false
      0|  178|
      0|  179|        switch self {
      0|  180|        case let .PerformDefaultEvaluation(validateHost):
      0|  181|            let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  182|            SecTrustSetPolicies(serverTrust, [policy])
      0|  183|
      0|  184|            serverTrustIsValid = trustIsValid(serverTrust)
      0|  185|        case let .PinCertificates(pinnedCertificates, validateCertificateChain, validateHost):
      0|  186|            if validateCertificateChain {
      0|  187|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  188|                SecTrustSetPolicies(serverTrust, [policy])
      0|  189|
      0|  190|                SecTrustSetAnchorCertificates(serverTrust, pinnedCertificates)
      0|  191|                SecTrustSetAnchorCertificatesOnly(serverTrust, true)
      0|  192|
      0|  193|                serverTrustIsValid = trustIsValid(serverTrust)
      0|  194|            } else {
      0|  195|                let serverCertificatesDataArray = certificateDataForTrust(serverTrust)
      0|  196|                let pinnedCertificatesDataArray = certificateDataForCertificates(pinnedCertificates)
      0|  197|
      0|  198|                outerLoop: for serverCertificateData in serverCertificatesDataArray {
      0|  199|                    for pinnedCertificateData in pinnedCertificatesDataArray {
      0|  200|                        if serverCertificateData.isEqualToData(pinnedCertificateData) {
      0|  201|                            serverTrustIsValid = true
      0|  202|                            break outerLoop
      0|  203|                        }
      0|  204|                    }
      0|  205|                }
      0|  206|            }
      0|  207|        case let .PinPublicKeys(pinnedPublicKeys, validateCertificateChain, validateHost):
      0|  208|            var certificateChainEvaluationPassed = true
      0|  209|
      0|  210|            if validateCertificateChain {
      0|  211|                let policy = SecPolicyCreateSSL(true, validateHost ? host as CFString : nil)
      0|  212|                SecTrustSetPolicies(serverTrust, [policy])
      0|  213|
      0|  214|                certificateChainEvaluationPassed = trustIsValid(serverTrust)
      0|  215|            }
      0|  216|
      0|  217|            if certificateChainEvaluationPassed {
      0|  218|                outerLoop: for serverPublicKey in ServerTrustPolicy.publicKeysForTrust(serverTrust) as [AnyObject] {
      0|  219|                    for pinnedPublicKey in pinnedPublicKeys as [AnyObject] {
      0|  220|                        if serverPublicKey.isEqual(pinnedPublicKey) {
      0|  221|                            serverTrustIsValid = true
      0|  222|                            break outerLoop
      0|  223|                        }
      0|  224|                    }
      0|  225|                }
      0|  226|            }
      0|  227|        case .DisableEvaluation:
      0|  228|            serverTrustIsValid = true
      0|  229|        case let .CustomEvaluation(closure):
      0|  230|            serverTrustIsValid = closure(serverTrust: serverTrust, host: host)
      0|  231|        }
      0|  232|
      0|  233|        return serverTrustIsValid
      0|  234|    }
       |  235|
       |  236|    // MARK: - Private - Trust Validation
       |  237|
      0|  238|    private func trustIsValid(trust: SecTrust) -> Bool {
      0|  239|        var isValid = false
      0|  240|
      0|  241|        var result = SecTrustResultType(kSecTrustResultInvalid)
      0|  242|        let status = SecTrustEvaluate(trust, &result)
      0|  243|
      0|  244|        if status == errSecSuccess {
      0|  245|            let unspecified = SecTrustResultType(kSecTrustResultUnspecified)
      0|  246|            let proceed = SecTrustResultType(kSecTrustResultProceed)
      0|  247|
      0|  248|            isValid = result == unspecified || result == proceed
      0|  249|        }
      0|  250|
      0|  251|        return isValid
      0|  252|    }
       |  253|
       |  254|    // MARK: - Private - Certificate Data
       |  255|
      0|  256|    private func certificateDataForTrust(trust: SecTrust) -> [NSData] {
      0|  257|        var certificates: [SecCertificate] = []
      0|  258|
      0|  259|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  260|            if let certificate = SecTrustGetCertificateAtIndex(trust, index) {
      0|  261|                certificates.append(certificate)
      0|  262|            }
      0|  263|        }
      0|  264|
      0|  265|        return certificateDataForCertificates(certificates)
      0|  266|    }
       |  267|
      0|  268|    private func certificateDataForCertificates(certificates: [SecCertificate]) -> [NSData] {
      0|  269|        return certificates.map { SecCertificateCopyData($0) as NSData }
      0|  270|    }
       |  271|
       |  272|    // MARK: - Private - Public Key Extraction
       |  273|
      0|  274|    private static func publicKeysForTrust(trust: SecTrust) -> [SecKey] {
      0|  275|        var publicKeys: [SecKey] = []
      0|  276|
      0|  277|        for index in 0..<SecTrustGetCertificateCount(trust) {
      0|  278|            if let
      0|  279|                certificate = SecTrustGetCertificateAtIndex(trust, index),
      0|  280|                publicKey = publicKeyForCertificate(certificate)
      0|  281|            {
      0|  282|                publicKeys.append(publicKey)
      0|  283|            }
      0|  284|        }
      0|  285|
      0|  286|        return publicKeys
      0|  287|    }
       |  288|
      0|  289|    private static func publicKeyForCertificate(certificate: SecCertificate) -> SecKey? {
      0|  290|        var publicKey: SecKey?
      0|  291|
      0|  292|        let policy = SecPolicyCreateBasicX509()
      0|  293|        var trust: SecTrust?
      0|  294|        let trustCreationStatus = SecTrustCreateWithCertificates(certificate, policy, &trust)
      0|  295|
      0|  296|        if let trust = trust where trustCreationStatus == errSecSuccess {
      0|  297|            publicKey = SecTrustCopyPublicKey(trust)
      0|  298|        }
      0|  299|
      0|  300|        return publicKey
      0|  301|    }
       |  302|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Stream.swift:
       |    1|// Stream.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|#if !os(watchOS)
       |   26|
       |   27|@available(iOS 9.0, OSX 10.11, *)
       |   28|extension Manager {
       |   29|    private enum Streamable {
       |   30|        case Stream(String, Int)
       |   31|        case NetService(NSNetService)
       |   32|    }
       |   33|
      0|   34|    private func stream(streamable: Streamable) -> Request {
      0|   35|        var streamTask: NSURLSessionStreamTask!
      0|   36|
      0|   37|        switch streamable {
      0|   38|        case .Stream(let hostName, let port):
      0|   39|            dispatch_sync(queue) {
      0|   40|                streamTask = self.session.streamTaskWithHostName(hostName, port: port)
      0|   41|            }
      0|   42|        case .NetService(let netService):
      0|   43|            dispatch_sync(queue) {
      0|   44|                streamTask = self.session.streamTaskWithNetService(netService)
      0|   45|            }
      0|   46|        }
      0|   47|
      0|   48|        let request = Request(session: session, task: streamTask)
      0|   49|
      0|   50|        delegate[request.delegate.task] = request.delegate
      0|   51|
      0|   52|        if startRequestsImmediately {
      0|   53|            request.resume()
      0|   54|        }
      0|   55|
      0|   56|        return request
      0|   57|    }
       |   58|
       |   59|    /**
       |   60|        Creates a request for bidirectional streaming with the given hostname and port.
       |   61|
       |   62|        - parameter hostName: The hostname of the server to connect to.
       |   63|        - parameter port:     The port of the server to connect to.
       |   64|
       |   65|        :returns: The created stream request.
       |   66|    */
      0|   67|    public func stream(hostName hostName: String, port: Int) -> Request {
      0|   68|        return stream(.Stream(hostName, port))
      0|   69|    }
       |   70|
       |   71|    /**
       |   72|        Creates a request for bidirectional streaming with the given `NSNetService`.
       |   73|
       |   74|        - parameter netService: The net service used to identify the endpoint.
       |   75|
       |   76|        - returns: The created stream request.
       |   77|    */
      0|   78|    public func stream(netService netService: NSNetService) -> Request {
      0|   79|        return stream(.NetService(netService))
      0|   80|    }
       |   81|}
       |   82|
       |   83|// MARK: -
       |   84|
       |   85|@available(iOS 9.0, OSX 10.11, *)
       |   86|extension Manager.SessionDelegate: NSURLSessionStreamDelegate {
       |   87|
       |   88|    // MARK: Override Closures
       |   89|
       |   90|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:readClosedForStreamTask:`.
       |   91|    public var streamTaskReadClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|   92|        get {
      0|   93|            return _streamTaskReadClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|   94|        }
      0|   95|        set {
      0|   96|            _streamTaskReadClosed = newValue
      0|   97|        }
       |   98|    }
       |   99|
       |  100|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:writeClosedForStreamTask:`.
       |  101|    public var streamTaskWriteClosed: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  102|        get {
      0|  103|            return _streamTaskWriteClosed as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  104|        }
      0|  105|        set {
      0|  106|            _streamTaskWriteClosed = newValue
      0|  107|        }
       |  108|    }
       |  109|
       |  110|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:betterRouteDiscoveredForStreamTask:`.
       |  111|    public var streamTaskBetterRouteDiscovered: ((NSURLSession, NSURLSessionStreamTask) -> Void)? {
      0|  112|        get {
      0|  113|            return _streamTaskBetterRouteDiscovered as? (NSURLSession, NSURLSessionStreamTask) -> Void
      0|  114|        }
      0|  115|        set {
      0|  116|            _streamTaskBetterRouteDiscovered = newValue
      0|  117|        }
       |  118|    }
       |  119|
       |  120|    /// Overrides default behavior for NSURLSessionStreamDelegate method `URLSession:streamTask:didBecomeInputStream:outputStream:`.
       |  121|    public var streamTaskDidBecomeInputStream: ((NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void)? {
      0|  122|        get {
      0|  123|            return _streamTaskDidBecomeInputStream as? (NSURLSession, NSURLSessionStreamTask, NSInputStream, NSOutputStream) -> Void
      0|  124|        }
      0|  125|        set {
      0|  126|            _streamTaskDidBecomeInputStream = newValue
      0|  127|        }
       |  128|    }
       |  129|
       |  130|    // MARK: Delegate Methods
       |  131|
       |  132|    /**
       |  133|        Tells the delegate that the read side of the connection has been closed.
       |  134|
       |  135|        - parameter session:    The session.
       |  136|        - parameter streamTask: The stream task.
       |  137|    */
      0|  138|    public func URLSession(session: NSURLSession, readClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  139|        streamTaskReadClosed?(session, streamTask)
      0|  140|    }
       |  141|
       |  142|    /**
       |  143|        Tells the delegate that the write side of the connection has been closed.
       |  144|
       |  145|        - parameter session:    The session.
       |  146|        - parameter streamTask: The stream task.
       |  147|    */
      0|  148|    public func URLSession(session: NSURLSession, writeClosedForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  149|        streamTaskWriteClosed?(session, streamTask)
      0|  150|    }
       |  151|
       |  152|    /**
       |  153|        Tells the delegate that the system has determined that a better route to the host is available.
       |  154|
       |  155|        - parameter session:    The session.
       |  156|        - parameter streamTask: The stream task.
       |  157|    */
      0|  158|    public func URLSession(session: NSURLSession, betterRouteDiscoveredForStreamTask streamTask: NSURLSessionStreamTask) {
      0|  159|        streamTaskBetterRouteDiscovered?(session, streamTask)
      0|  160|    }
       |  161|
       |  162|    /**
       |  163|        Tells the delegate that the stream task has been completed and provides the unopened stream objects.
       |  164|
       |  165|        - parameter session:      The session.
       |  166|        - parameter streamTask:   The stream task.
       |  167|        - parameter inputStream:  The new input stream.
       |  168|        - parameter outputStream: The new output stream.
       |  169|    */
       |  170|    public func URLSession(
       |  171|        session: NSURLSession,
       |  172|        streamTask: NSURLSessionStreamTask,
       |  173|        didBecomeInputStream inputStream: NSInputStream,
       |  174|        outputStream: NSOutputStream)
      0|  175|    {
      0|  176|        streamTaskDidBecomeInputStream?(session, streamTask, inputStream, outputStream)
      0|  177|    }
       |  178|}
       |  179|
       |  180|#endif

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Upload.swift:
       |    1|// Upload.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Manager {
       |   26|    private enum Uploadable {
       |   27|        case Data(NSURLRequest, NSData)
       |   28|        case File(NSURLRequest, NSURL)
       |   29|        case Stream(NSURLRequest, NSInputStream)
       |   30|    }
       |   31|
      0|   32|    private func upload(uploadable: Uploadable) -> Request {
      0|   33|        var uploadTask: NSURLSessionUploadTask!
      0|   34|        var HTTPBodyStream: NSInputStream?
      0|   35|
      0|   36|        switch uploadable {
      0|   37|        case .Data(let request, let data):
      0|   38|            dispatch_sync(queue) {
      0|   39|                uploadTask = self.session.uploadTaskWithRequest(request, fromData: data)
      0|   40|            }
      0|   41|        case .File(let request, let fileURL):
      0|   42|            dispatch_sync(queue) {
      0|   43|                uploadTask = self.session.uploadTaskWithRequest(request, fromFile: fileURL)
      0|   44|            }
      0|   45|        case .Stream(let request, let stream):
      0|   46|            dispatch_sync(queue) {
      0|   47|                uploadTask = self.session.uploadTaskWithStreamedRequest(request)
      0|   48|            }
      0|   49|
      0|   50|            HTTPBodyStream = stream
      0|   51|        }
      0|   52|
      0|   53|        let request = Request(session: session, task: uploadTask)
      0|   54|
      0|   55|        if HTTPBodyStream != nil {
      0|   56|            request.delegate.taskNeedNewBodyStream = { _, _ in
      0|   57|                return HTTPBodyStream
      0|   58|            }
      0|   59|        }
      0|   60|
      0|   61|        delegate[request.delegate.task] = request.delegate
      0|   62|
      0|   63|        if startRequestsImmediately {
      0|   64|            request.resume()
      0|   65|        }
      0|   66|
      0|   67|        return request
      0|   68|    }
       |   69|
       |   70|    // MARK: File
       |   71|
       |   72|    /**
       |   73|        Creates a request for uploading a file to the specified URL request.
       |   74|
       |   75|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   76|
       |   77|        - parameter URLRequest: The URL request
       |   78|        - parameter file:       The file to upload
       |   79|
       |   80|        - returns: The created upload request.
       |   81|    */
      0|   82|    public func upload(URLRequest: URLRequestConvertible, file: NSURL) -> Request {
      0|   83|        return upload(.File(URLRequest.URLRequest, file))
      0|   84|    }
       |   85|
       |   86|    /**
       |   87|        Creates a request for uploading a file to the specified URL request.
       |   88|
       |   89|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |   90|
       |   91|        - parameter method:    The HTTP method.
       |   92|        - parameter URLString: The URL string.
       |   93|        - parameter headers:   The HTTP headers. `nil` by default.
       |   94|        - parameter file:      The file to upload
       |   95|
       |   96|        - returns: The created upload request.
       |   97|    */
       |   98|    public func upload(
       |   99|        method: Method,
       |  100|        _ URLString: URLStringConvertible,
       |  101|        headers: [String: String]? = nil,
       |  102|        file: NSURL)
       |  103|        -> Request
      0|  104|    {
      0|  105|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  106|        return upload(mutableURLRequest, file: file)
      0|  107|    }
       |  108|
       |  109|    // MARK: Data
       |  110|
       |  111|    /**
       |  112|        Creates a request for uploading data to the specified URL request.
       |  113|
       |  114|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  115|
       |  116|        - parameter URLRequest: The URL request.
       |  117|        - parameter data:       The data to upload.
       |  118|
       |  119|        - returns: The created upload request.
       |  120|    */
      0|  121|    public func upload(URLRequest: URLRequestConvertible, data: NSData) -> Request {
      0|  122|        return upload(.Data(URLRequest.URLRequest, data))
      0|  123|    }
       |  124|
       |  125|    /**
       |  126|        Creates a request for uploading data to the specified URL request.
       |  127|
       |  128|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  129|
       |  130|        - parameter method:    The HTTP method.
       |  131|        - parameter URLString: The URL string.
       |  132|        - parameter headers:   The HTTP headers. `nil` by default.
       |  133|        - parameter data:      The data to upload
       |  134|
       |  135|        - returns: The created upload request.
       |  136|    */
       |  137|    public func upload(
       |  138|        method: Method,
       |  139|        _ URLString: URLStringConvertible,
       |  140|        headers: [String: String]? = nil,
       |  141|        data: NSData)
       |  142|        -> Request
      0|  143|    {
      0|  144|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  145|
      0|  146|        return upload(mutableURLRequest, data: data)
      0|  147|    }
       |  148|
       |  149|    // MARK: Stream
       |  150|
       |  151|    /**
       |  152|        Creates a request for uploading a stream to the specified URL request.
       |  153|
       |  154|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  155|
       |  156|        - parameter URLRequest: The URL request.
       |  157|        - parameter stream:     The stream to upload.
       |  158|
       |  159|        - returns: The created upload request.
       |  160|    */
      0|  161|    public func upload(URLRequest: URLRequestConvertible, stream: NSInputStream) -> Request {
      0|  162|        return upload(.Stream(URLRequest.URLRequest, stream))
      0|  163|    }
       |  164|
       |  165|    /**
       |  166|        Creates a request for uploading a stream to the specified URL request.
       |  167|
       |  168|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  169|
       |  170|        - parameter method:    The HTTP method.
       |  171|        - parameter URLString: The URL string.
       |  172|        - parameter headers:   The HTTP headers. `nil` by default.
       |  173|        - parameter stream:    The stream to upload.
       |  174|
       |  175|        - returns: The created upload request.
       |  176|    */
       |  177|    public func upload(
       |  178|        method: Method,
       |  179|        _ URLString: URLStringConvertible,
       |  180|        headers: [String: String]? = nil,
       |  181|        stream: NSInputStream)
       |  182|        -> Request
      0|  183|    {
      0|  184|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  185|
      0|  186|        return upload(mutableURLRequest, stream: stream)
      0|  187|    }
       |  188|
       |  189|    // MARK: MultipartFormData
       |  190|
       |  191|    /// Default memory threshold used when encoding `MultipartFormData`.
       |  192|    public static let MultipartFormDataEncodingMemoryThreshold: UInt64 = 10 * 1024 * 1024
       |  193|
       |  194|    /**
       |  195|        Defines whether the `MultipartFormData` encoding was successful and contains result of the encoding as 
       |  196|        associated values.
       |  197|
       |  198|        - Success: Represents a successful `MultipartFormData` encoding and contains the new `Request` along with 
       |  199|                   streaming information.
       |  200|        - Failure: Used to represent a failure in the `MultipartFormData` encoding and also contains the encoding 
       |  201|                   error.
       |  202|    */
       |  203|    public enum MultipartFormDataEncodingResult {
       |  204|        case Success(request: Request, streamingFromDisk: Bool, streamFileURL: NSURL?)
       |  205|        case Failure(ErrorType)
       |  206|    }
       |  207|
       |  208|    /**
       |  209|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  210|
       |  211|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative 
       |  212|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most 
       |  213|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to 
       |  214|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory 
       |  215|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be 
       |  216|        used for larger payloads such as video content.
       |  217|
       |  218|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory 
       |  219|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  220|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk 
       |  221|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding 
       |  222|        technique was used.
       |  223|
       |  224|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  225|
       |  226|        - parameter method:                  The HTTP method.
       |  227|        - parameter URLString:               The URL string.
       |  228|        - parameter headers:                 The HTTP headers. `nil` by default.
       |  229|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  230|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  231|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  232|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  233|    */
       |  234|    public func upload(
       |  235|        method: Method,
       |  236|        _ URLString: URLStringConvertible,
       |  237|        headers: [String: String]? = nil,
       |  238|        multipartFormData: MultipartFormData -> Void,
       |  239|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  240|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  241|    {
      0|  242|        let mutableURLRequest = URLRequest(method, URLString, headers: headers)
      0|  243|
      0|  244|        return upload(
      0|  245|            mutableURLRequest,
      0|  246|            multipartFormData: multipartFormData,
      0|  247|            encodingMemoryThreshold: encodingMemoryThreshold,
      0|  248|            encodingCompletion: encodingCompletion
      0|  249|        )
      0|  250|    }
       |  251|
       |  252|    /**
       |  253|        Encodes the `MultipartFormData` and creates a request to upload the result to the specified URL request.
       |  254|
       |  255|        It is important to understand the memory implications of uploading `MultipartFormData`. If the cummulative
       |  256|        payload is small, encoding the data in-memory and directly uploading to a server is the by far the most
       |  257|        efficient approach. However, if the payload is too large, encoding the data in-memory could cause your app to
       |  258|        be terminated. Larger payloads must first be written to disk using input and output streams to keep the memory
       |  259|        footprint low, then the data can be uploaded as a stream from the resulting file. Streaming from disk MUST be
       |  260|        used for larger payloads such as video content.
       |  261|
       |  262|        The `encodingMemoryThreshold` parameter allows Alamofire to automatically determine whether to encode in-memory
       |  263|        or stream from disk. If the content length of the `MultipartFormData` is below the `encodingMemoryThreshold`,
       |  264|        encoding takes place in-memory. If the content length exceeds the threshold, the data is streamed to disk
       |  265|        during the encoding process. Then the result is uploaded as data or as a stream depending on which encoding
       |  266|        technique was used.
       |  267|
       |  268|        If `startRequestsImmediately` is `true`, the request will have `resume()` called before being returned.
       |  269|
       |  270|        - parameter URLRequest:              The URL request.
       |  271|        - parameter multipartFormData:       The closure used to append body parts to the `MultipartFormData`.
       |  272|        - parameter encodingMemoryThreshold: The encoding memory threshold in bytes.
       |  273|                                             `MultipartFormDataEncodingMemoryThreshold` by default.
       |  274|        - parameter encodingCompletion:      The closure called when the `MultipartFormData` encoding is complete.
       |  275|    */
       |  276|    public func upload(
       |  277|        URLRequest: URLRequestConvertible,
       |  278|        multipartFormData: MultipartFormData -> Void,
       |  279|        encodingMemoryThreshold: UInt64 = Manager.MultipartFormDataEncodingMemoryThreshold,
       |  280|        encodingCompletion: (MultipartFormDataEncodingResult -> Void)?)
      0|  281|    {
      0|  282|        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)) {
      0|  283|            let formData = MultipartFormData()
      0|  284|            multipartFormData(formData)
      0|  285|
      0|  286|            let URLRequestWithContentType = URLRequest.URLRequest
      0|  287|            URLRequestWithContentType.setValue(formData.contentType, forHTTPHeaderField: "Content-Type")
      0|  288|
      0|  289|            let isBackgroundSession = self.session.configuration.identifier != nil
      0|  290|
      0|  291|            if formData.contentLength < encodingMemoryThreshold && !isBackgroundSession {
      0|  292|                do {
      0|  293|                    let data = try formData.encode()
      0|  294|                    let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  295|                        request: self.upload(URLRequestWithContentType, data: data),
      0|  296|                        streamingFromDisk: false,
      0|  297|                        streamFileURL: nil
      0|  298|                    )
      0|  299|
      0|  300|                    dispatch_async(dispatch_get_main_queue()) {
      0|  301|                        encodingCompletion?(encodingResult)
      0|  302|                    }
      0|  303|                } catch {
      0|  304|                    dispatch_async(dispatch_get_main_queue()) {
      0|  305|                        encodingCompletion?(.Failure(error as NSError))
      0|  306|                    }
      0|  307|                }
      0|  308|            } else {
      0|  309|                let fileManager = NSFileManager.defaultManager()
      0|  310|                let tempDirectoryURL = NSURL(fileURLWithPath: NSTemporaryDirectory())
      0|  311|                let directoryURL = tempDirectoryURL.URLByAppendingPathComponent("com.alamofire.manager/multipart.form.data")
      0|  312|                let fileName = NSUUID().UUIDString
      0|  313|                let fileURL = directoryURL.URLByAppendingPathComponent(fileName)
      0|  314|
      0|  315|                do {
      0|  316|                    try fileManager.createDirectoryAtURL(directoryURL, withIntermediateDirectories: true, attributes: nil)
      0|  317|                    try formData.writeEncodedDataToDisk(fileURL)
      0|  318|
      0|  319|                    dispatch_async(dispatch_get_main_queue()) {
      0|  320|                        let encodingResult = MultipartFormDataEncodingResult.Success(
      0|  321|                            request: self.upload(URLRequestWithContentType, file: fileURL),
      0|  322|                            streamingFromDisk: true,
      0|  323|                            streamFileURL: fileURL
      0|  324|                        )
      0|  325|                        encodingCompletion?(encodingResult)
      0|  326|                    }
      0|  327|                } catch {
      0|  328|                    dispatch_async(dispatch_get_main_queue()) {
      0|  329|                        encodingCompletion?(.Failure(error as NSError))
      0|  330|                    }
      0|  331|                }
      0|  332|            }
      0|  333|        }
      0|  334|    }
       |  335|}
       |  336|
       |  337|// MARK: -
       |  338|
       |  339|extension Request {
       |  340|
       |  341|    // MARK: - UploadTaskDelegate
       |  342|
       |  343|    class UploadTaskDelegate: DataTaskDelegate {
      0|  344|        var uploadTask: NSURLSessionUploadTask? { return task as? NSURLSessionUploadTask }
       |  345|        var uploadProgress: ((Int64, Int64, Int64) -> Void)!
       |  346|
       |  347|        // MARK: - NSURLSessionTaskDelegate
       |  348|
       |  349|        // MARK: Override Closures
       |  350|
       |  351|        var taskDidSendBodyData: ((NSURLSession, NSURLSessionTask, Int64, Int64, Int64) -> Void)?
       |  352|
       |  353|        // MARK: Delegate Methods
       |  354|
       |  355|        func URLSession(
       |  356|            session: NSURLSession,
       |  357|            task: NSURLSessionTask,
       |  358|            didSendBodyData bytesSent: Int64,
       |  359|            totalBytesSent: Int64,
       |  360|            totalBytesExpectedToSend: Int64)
      0|  361|        {
      0|  362|            if let taskDidSendBodyData = taskDidSendBodyData {
      0|  363|                taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  364|            } else {
      0|  365|                progress.totalUnitCount = totalBytesExpectedToSend
      0|  366|                progress.completedUnitCount = totalBytesSent
      0|  367|
      0|  368|                uploadProgress?(bytesSent, totalBytesSent, totalBytesExpectedToSend)
      0|  369|            }
      0|  370|        }
       |  371|    }
       |  372|}

/Users/quver/GitHub/GCMSender/Pods/Alamofire/Source/Validation.swift:
       |    1|// Validation.swift
       |    2|//
       |    3|// Copyright (c) 2014–2015 Alamofire Software Foundation (http://alamofire.org/)
       |    4|//
       |    5|// Permission is hereby granted, free of charge, to any person obtaining a copy
       |    6|// of this software and associated documentation files (the "Software"), to deal
       |    7|// in the Software without restriction, including without limitation the rights
       |    8|// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       |    9|// copies of the Software, and to permit persons to whom the Software is
       |   10|// furnished to do so, subject to the following conditions:
       |   11|//
       |   12|// The above copyright notice and this permission notice shall be included in
       |   13|// all copies or substantial portions of the Software.
       |   14|//
       |   15|// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |   16|// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |   17|// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       |   18|// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       |   19|// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       |   20|// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       |   21|// THE SOFTWARE.
       |   22|
       |   23|import Foundation
       |   24|
       |   25|extension Request {
       |   26|
       |   27|    /**
       |   28|        Used to represent whether validation was successful or encountered an error resulting in a failure.
       |   29|
       |   30|        - Success: The validation was successful.
       |   31|        - Failure: The validation failed encountering the provided error.
       |   32|    */
       |   33|    public enum ValidationResult {
       |   34|        case Success
       |   35|        case Failure(NSError)
       |   36|    }
       |   37|
       |   38|    /**
       |   39|        A closure used to validate a request that takes a URL request and URL response, and returns whether the 
       |   40|        request was valid.
       |   41|    */
       |   42|    public typealias Validation = (NSURLRequest?, NSHTTPURLResponse) -> ValidationResult
       |   43|
       |   44|    /**
       |   45|        Validates the request, using the specified closure.
       |   46|
       |   47|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   48|
       |   49|        - parameter validation: A closure to validate the request.
       |   50|
       |   51|        - returns: The request.
       |   52|    */
      0|   53|    public func validate(validation: Validation) -> Self {
      0|   54|        delegate.queue.addOperationWithBlock {
      0|   55|            if let
      0|   56|                response = self.response where self.delegate.error == nil,
      0|   57|                case let .Failure(error) = validation(self.request, response)
      0|   58|            {
      0|   59|                self.delegate.error = error
      0|   60|            }
      0|   61|        }
      0|   62|
      0|   63|        return self
      0|   64|    }
       |   65|
       |   66|    // MARK: - Status Code
       |   67|
       |   68|    /**
       |   69|        Validates that the response has a status code in the specified range.
       |   70|
       |   71|        If validation fails, subsequent calls to response handlers will have an associated error.
       |   72|
       |   73|        - parameter range: The range of acceptable status codes.
       |   74|
       |   75|        - returns: The request.
       |   76|    */
      0|   77|    public func validate<S: SequenceType where S.Generator.Element == Int>(statusCode acceptableStatusCode: S) -> Self {
      0|   78|        return validate { _, response in
      0|   79|            if acceptableStatusCode.contains(response.statusCode) {
      0|   80|                return .Success
      0|   81|            } else {
      0|   82|                let failureReason = "Response status code was unacceptable: \(response.statusCode)"
      0|   83|                return .Failure(Error.errorWithCode(.StatusCodeValidationFailed, failureReason: failureReason))
      0|   84|            }
      0|   85|        }
      0|   86|    }
       |   87|
       |   88|    // MARK: - Content-Type
       |   89|
       |   90|    private struct MIMEType {
       |   91|        let type: String
       |   92|        let subtype: String
       |   93|
      0|   94|        init?(_ string: String) {
      0|   95|            let components: [String] = {
      0|   96|                let stripped = string.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())
      0|   97|                let split = stripped.substringToIndex(stripped.rangeOfString(";")?.startIndex ?? stripped.endIndex)
      0|   98|                return split.componentsSeparatedByString("/")
      0|   99|            }()
      0|  100|
      0|  101|            if let
      0|  102|                type = components.first,
      0|  103|                subtype = components.last
      0|  104|            {
      0|  105|                self.type = type
      0|  106|                self.subtype = subtype
      0|  107|            } else {
      0|  108|                return nil
      0|  109|            }
      0|  110|        }
       |  111|
      0|  112|        func matches(MIME: MIMEType) -> Bool {
      0|  113|            switch (type, subtype) {
      0|  114|            case (MIME.type, MIME.subtype), (MIME.type, "*"), ("*", MIME.subtype), ("*", "*"):
      0|  115|                return true
      0|  116|            default:
      0|  117|                return false
      0|  118|            }
      0|  119|        }
       |  120|    }
       |  121|
       |  122|    /**
       |  123|        Validates that the response has a content type in the specified array.
       |  124|
       |  125|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  126|
       |  127|        - parameter contentType: The acceptable content types, which may specify wildcard types and/or subtypes.
       |  128|
       |  129|        - returns: The request.
       |  130|    */
      0|  131|    public func validate<S : SequenceType where S.Generator.Element == String>(contentType acceptableContentTypes: S) -> Self {
      0|  132|        return validate { _, response in
      0|  133|            guard let validData = self.delegate.data where validData.length > 0 else { return .Success }
      0|  134|
      0|  135|            if let
      0|  136|                responseContentType = response.MIMEType,
      0|  137|                responseMIMEType = MIMEType(responseContentType)
      0|  138|            {
      0|  139|                for contentType in acceptableContentTypes {
      0|  140|                    if let acceptableMIMEType = MIMEType(contentType) where acceptableMIMEType.matches(responseMIMEType) {
      0|  141|                        return .Success
      0|  142|                    }
      0|  143|                }
      0|  144|            } else {
      0|  145|                for contentType in acceptableContentTypes {
      0|  146|                    if let MIMEType = MIMEType(contentType) where MIMEType.type == "*" && MIMEType.subtype == "*" {
      0|  147|                        return .Success
      0|  148|                    }
      0|  149|                }
      0|  150|            }
      0|  151|
      0|  152|            let failureReason: String
      0|  153|
      0|  154|            if let responseContentType = response.MIMEType {
      0|  155|                failureReason = (
      0|  156|                    "Response content type \"\(responseContentType)\" does not match any acceptable " +
      0|  157|                    "content types: \(acceptableContentTypes)"
      0|  158|                )
      0|  159|            } else {
      0|  160|                failureReason = "Response content type was missing and acceptable content type does not match \"*/*\""
      0|  161|            }
      0|  162|
      0|  163|            return .Failure(Error.errorWithCode(.ContentTypeValidationFailed, failureReason: failureReason))
      0|  164|        }
      0|  165|    }
       |  166|
       |  167|    // MARK: - Automatic
       |  168|
       |  169|    /**
       |  170|        Validates that the response has a status code in the default acceptable range of 200...299, and that the content 
       |  171|        type matches any specified in the Accept HTTP header field.
       |  172|
       |  173|        If validation fails, subsequent calls to response handlers will have an associated error.
       |  174|
       |  175|        - returns: The request.
       |  176|    */
      0|  177|    public func validate() -> Self {
      0|  178|        let acceptableStatusCodes: Range<Int> = 200..<300
      0|  179|        let acceptableContentTypes: [String] = {
      0|  180|            if let accept = request?.valueForHTTPHeaderField("Accept") {
      0|  181|                return accept.componentsSeparatedByString(",")
      0|  182|            }
      0|  183|
      0|  184|            return ["*/*"]
      0|  185|        }()
      0|  186|
      0|  187|        return validate(statusCode: acceptableStatusCodes).validate(contentType: acceptableContentTypes)
      0|  188|    }
       |  189|}

